--------------------------------------------------------
--  DDL for Package Body PAC_DINCARTERA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "AXIS"."PAC_DINCARTERA" IS
/******************************************************************************
   NOMBRE:      PAC_DINCARTERA
   PROP¿SITO:
   REVISIONES:
   Ver        Fecha        Autor             Descripci¿n
   ---------  ----------  ---------------  ------------------------------------
   1.0        03/12/2008                   1. Creaci¿n del package.
   1.1        16/12/2008
   1.2        18/12/2008     xpl           2. Estandaritzaci¿
   2.0        04/03/2009     RSC           3. Unificaci¿n de recibos
   3.0        17/04/2009     APD           4. Se elimina el cursor cur_pregunprogaran ya que no se utilizaba
                                           5. Bug 9699 - primero se ha de buscar para la actividad en concreto
                                              y si no se encuentra nada ir a buscar a GARANPRO para la actividad cero
   4.0        21/04/2009     YIL           6. Bug 9794: APR - Nuevos tipos de revalorizaci¿n (adaptaci¿n fiscal, revalorizaci¿n de prima)
   5.0        30/04/2009     YIL           7. Bug 9524 - Se modifica el order by de los cursores de garant¿as para que tenga en cuenta el par¿metro ORDEN_TARIF_CARTERA
                                              en lugar del ORDEN_TARIF
   6.0        17/04/2009     RSC           8. Bug 9153: Suplementos autom¿ticos
   7.0        24/04/2009     RSC           9. Bug 9905: Suplemento de cambio de forma de pago diferido
   8.0        14/05/2009     APD          10. Bug 10053: Se modifica la funcion f_maxapor_pp por pac_ppa_planes.ff_importe_por_aportar_persona
   9.0        01/06/2009     NMM          11. 0010251: CRE - Incidencia Cartera con Facultativo.#6.
   10.0       04/05/2009     RSC          12. Bug 9153: Suplementos autom¿ticos
   11.0       29/05/2009     JTS          13. BUG 9658 - JTS - APR - Desarrollo PL de comisiones de adquisi¿n.#6.
   12.0       29/05/2009     NMM          14. BUG 10809: CRE - Errors cartera d'agost 2009.#6.
   13.0       28/08/2009     JMF          15. BUG 10908: CRE - ULK - Parametritzaci¿ del suplement autom¿tic d'actualitzaci¿ de patrimoni
   14.0       17/09/2009     RSC          16. Bug 0010828: CRE - Revisi¿n de los productos PPJ din¿mico y Pla Estudiant (ajustes)
   15.0       28/10/2009     AVT          17. Bug 0011623: CRE - Incidencias de cartera (Productes ESTALVI)
   16.0       04/11/2009     AMC          18  Bug 0011685: CRE - Modificar el previo de cartera y la cartera para que se lancen a trav¿s de jobs
   17.0       01/12/2009     NMM          19. 11845.CRE - Ajustar reasseguran¿a d'estalvi.
   18.0       27/05/2009     RSC          20. 0007926 APR - Fecha de vencimiento a nivel de garant¿a
   19.0       02/02/2010     ICV          21. 0012911: CRE201 - Revisi¿n campo a¿o en pantalla de renovaci¿n de cartera
   20.0       26/02/2010     FAL          22. 0011604: CRE097 - ¿ltimo recibo producto CV complement
   21.0       03/11/2010     ASN          23. 0013607: APR - Comisiones de adquisi¿n en previo de cartera
   24.0       26/04/2010     DRA          24. 0014172: CEM800 - SUPLEMENTS: Error en el suplement de preguntes de p¿lissa de la p¿lissa 60115905.
   25.0       05/05/2010     RSC-FAL      25. 0014336: APR03 - Error en la renovaci¿n de polizas de portfolio con sobreprima
   26.0       05/05/2010     RSC          26. 0013727: APR - An¿lisis/Implementaci¿n de nuevas
   27.0       20/05/2010     JTS          27. 14438: CEM - Unificaci¿n de recibos
   28.0       30/07/2010     XPL          28. 14429: AGA005 - Primes manuals pels productes de Llar
   29.0       07/10/2010     ETM          29. 16146:CEM - Fechas de cartera en procesos previo y real
   30.0       05/11/2010     APD          30. 16095: Implementacion y parametrizacion producto GROUPLIFE
   31.0       27/10/2010     DRA          31. 0015823: CRE803 - Activar suplement autom¿tic fi n¿mina domiciliada per al producte CV Previsi¿ (293)
   32.0       09/12/2010     JMP          32. 0016903: CEM - No renovamos si fecha de revisi¿n anterior a la de renovaci¿n
   33.0       03/01/2011     ICV          33. 0016919: APR - error al crear movimiento en polizas sin garanseg
   34.0       31/12/2010     JMP          34. Bug 0017153: CRE - Permitir pasar la cartera a un colectivo entero o a un certificado
   35.0       26/01/2011     JMF          35. 0016856 CEM - Escut Amortitzaci¿ proc¿s anual actualitzaci¿ de capitals
   36.0       26/01/2011     RSC          36. 0017382: CRE800 - Impagamet de rebuts
   37.0       04/03/2011     DRA          37. 0017886: CRE800 - P¿lissa anul¿lada renovada i passa cartera
   38.0       30/09/2011     JMF          38. 0018967 LCOL_T005 - Listas restringidas validaciones y controles
   39.0       28/09/2011     DRA          39. 0019069: LCOL_C001 - Co-corretaje
   40.0       17/11/2011     FAL          40. 0019627: GIP102 - Reunificaci¿n de recibos
   41.0       28/11/2011     SMF          41. 20149: LCOL_T001-Renovacion no anual (decenal)
   42.0       14/12/2011     RSC          42. 0019715: LCOL: Migraci¿n de productos de Vida Individual
   43.0       21/12/2011     JMP          43. 0018423 - LCOL705 - Multimoneda
   44.0       20/01/2012     JMF          44. 0020932 LCOL_T005 - Llista restringida - Cotitzaci
   45.0       01/02/2012     JRH          45  0020666: LCOL_T004-LCOL - UAT - TEC - Indicencias de Tarificaci?n
   46.0       23/02/2012     APD          46  0021121: MDP701 - TEC - DETALLE DE PRIMAS DE GARANTIAS
   47.0       23/04/2011     MDS          47. 0021907: MDP - TEC - Descuentos y recargos (t¿cnico y comercial) a nivel de p¿liza/riesgo/garant¿a
   48.0       24/08/2012     JMF          48. 0022583: CRE800 - Error previ cartera
   49.0       03/09/2012     JMF          49. 0022701: LCOL: Implementaci¿n de Retorno
   50.0       17/10/2012     APD          50. 0023940: LCOL_T010-LCOL - Certificado 0 renovable - Renovacion colectivos
   51.0       04/12/2012     DRA          51. 0024929: LCOL_C003-LCOL: Co-corretaje en renovaci?n de cartera
   52.0       08/01/2013     APD          52. 0023853: LCOL - PRIMAS M¿NIMAS PACTADAS POR P¿LIZA Y POR COBRO
   53.0       08/01/2013     APD          53. 0023940: LCOL_T010-LCOL - Certificado 0 renovable - Renovacion colectivos
   54.0       28/02/2013     DCT          54. 0026070: LCOL_T010-LCOL - Revision incidencias qtracker (V)
   55.0       01/03/2013     JDS          55. 0026070: LCOL_T010-LCOL - Revision incidencias qtracker (V) -NOTA 0139047
   56.0       01/03/2013     FAC          56. 0026209: LCOL_T010-LCOL - Soluci?n definitiva ejecuci?n de cartera desde pantalla
   57.0       04/03/2013     DRA          57. 0024804: (POSRA100)-Ramo:Rentas- Parametrizacion Conmutacion Pensional
   58.0       08/03/2013     MMS          58. 0025584: En caso que CDURACI=7 buscamos el nedamax po la tabla EDADRENOVA_PERMITE
   59.0       15/04/2013     ECP          59. 0023115: LCOL_T010-LCOL - SUPLEMENTO DE PRoRROGA DE VIGENCIA / SUPLEMENTO DE REINICIO. Nota 142079
   60.0       06/05/2013     JMC          60. 0026261: LCOL_T010-LCOL - Revision incidencias qtracker (IV) 7183
   61.0       15/05/2013     FAC          61. 0026638: FAC LCOL - TEC - Cartera para Autos. (id 176-19)
   62.0       04/07/2013     ECP          62. 0027539: LCOL_T010-LCOL - Revision incidencias qtracker (VII). Nota 148366
   63.0       09/10/2013     JSV          63. 0027539: LCOL_T010-LCOL - Revision incidencias qtracker (VII)
   64.0       28/10/2013     JSV          64. 0027539: LCOL_T010-LCOL - Revision incidencias qtracker (VII)
   65.0       13/11/2013     ECP          65. 0028832: LCOL896-Soporte Cliente en Liberty (Noviembre 2013)  Nota 158351
   66.0       26/11/2013     JSV          66. 0028380: LCOL_PROD-Revisi?n qtrackers Fase 2 Producci?n
   67.0       11/12/2013     JDS          67. 0028821: LCOL895-LCOL - Control en la cartera (Vida Grupo)
   68.0       18/12/2013     APD          68. 0027048/155371: LCOL_T010-Revision incidencias qtracker (V)
   69.0       05/03/2014     ECP          69. 0030417: LCOL896-Soporte a cliente en Liberty (Marzo 2014) /QT 11637
   70.0       15/04/2014     RCL          70. 0028821: LCOL895-LCOL - Control en la cartera (Vida Grupo)
   71.0       22/04/2014     JTT          71. 0029943: Se a¿ade la nueva funcion para tratar las PBs, f_tratamiento_pb
   72.0       06/05/2014     JTT          72. 0029943: Modificaciones para el tratamiento de las PBs.
   73.0       26/05/2014     JTT          73. 0029943: Fecha de cartera pra proceso de PB
   74.0       23-06-2014     SSM          74.0  (30145/175326) LCOL999-Nueva Estructura de Tarifas AUTOS  - Modificaci¿n, se a¿ade parametro pcodgrup a function pac_bonfran.f_resuelve_formula
   75.0       06/06/2014     JTT          75. 0029943: Modificaciones para el tratamiento de las PBs.
   76.0       25/06/2014  FBL             76. 0028974: MSV0003-Desarrollo de Comisiones (COM04-Commercial Network Management)
   77.0       23/10/2014     AGG          77. 0033069: POS TEC VI - NO ARROJO VALOR "TOTAL DTO" EN LA CARATULA DE RENOVACION
   78.0       02/12/2014     RDD          78. 0028974: MSV0003-Desarrollo de Comisiones (COM04-Commercial Network Management)
   79.0       03/12/2014     DCT          79. 0033494: POSPT500-POSTEC VI PV LARGO PLAZO NO CALCULA DESCUENTO SOBRE LAS EXTRAPRIMAS Y SOBREPRIMAS (bug hermano interno)
   80.0       25/05/2015     BLA          80. 004469/0205354: POS Se adiciona funci¿n F_MODIF_CMOVSEG_ANIVERSARIO y tratamiento cmotmov 406
   81.0       22/05/2015     OZEA         81. 0035712: tarea: 0202997 Notificacion por renavacion de poliza.
   82.0       29/10/2015     RLLF         82. 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
   83.0       10/12/2015     FAL          83. 0038828: LANZAMIENTO PREVIO CARTERA DICIEMBRE 2015 (bug hermano interno)
   84.0       22/08/2016     HRE          24  CONF-186: Se incluyen procesos para gestion de marcas.
******************************************************************************/

   -- Bug 23940 - APD - 18/10/2012 - se a¿ade el csituac = 17.-Prop. cartera
   -- Se a¿ade que para los administrados y agrupados solo miramos el 0
   CURSOR c_seg_psu(
      wram NUMBER,
      wmod NUMBER,
      wtip NUMBER,
      wcol NUMBER,
      wsseguro NUMBER,
      wnpoliza NUMBER,
      wncertif NUMBER,
      wmes NUMBER,
      wanyo NUMBER,
      wfcartera DATE,
      pskiprenova NUMBER,
      precunif NUMBER   -- Bug 28640/160626 - 25/03/2014 - AMC
                     ) IS
      SELECT s.*
        FROM seguros s, seguroscol sc, agentes_agente_pol ap
       WHERE s.cramo = wram
         AND s.cmodali = wmod
         AND s.ctipseg = wtip
         AND s.ccolect = wcol
         AND s.sseguro = NVL(wsseguro, s.sseguro)   --AMC
         AND s.sseguro = sc.sseguro(+)
         AND s.cagente = ap.cagente   -- Bug 28640/160626 - 25/03/2014 - AMC
         AND s.cempres = ap.cempres   -- Bug 28640/160626 - 25/03/2014 - AMC
         AND((s.csituac = 5)
             OR(s.creteni = 0
                AND s.csituac NOT IN(7, 8, 9, 10)))
         AND s.csituac <> 2   -- qt 15679
         AND(s.fcarpro < DECODE(wfcartera,
                                NULL, DECODE(sc.ctipcob,
                                             1, ADD_MONTHS
                                                          ((LAST_DAY(TO_DATE(LPAD(wmes, 2, '0')
                                                                             || wanyo,
                                                                             'mmyyyy'))
                                                            + 1),
                                                           -1),
                                             (LAST_DAY(TO_DATE(LPAD(wmes, 2, '0') || wanyo,
                                                               'mmyyyy'))
                                              + 1)),
                                DECODE(sc.ctipcob,
                                       1, ADD_MONTHS(wfcartera + 1, -1),
                                       wfcartera + 1))
             OR(NVL(sc.ctipcol, 0) = 1
                -- Administrada - Bug 28640/160626 - 25/03/2014 - AMC
                AND s.csituac = 17   -- propuesta de cartera
                AND s.fcarant <
                      DECODE(wfcartera,
                             NULL, DECODE(sc.ctipcob,
                                          1, ADD_MONTHS((LAST_DAY(TO_DATE(LPAD(wmes, 2, '0')
                                                                          || wanyo,
                                                                          'mmyyyy'))
                                                         + 1),
                                                        -1),
                                          (LAST_DAY(TO_DATE(LPAD(wmes, 2, '0') || wanyo,
                                                            'mmyyyy'))
                                           + 1)),
                             DECODE(sc.ctipcob,
                                    1, ADD_MONTHS(wfcartera + 1, -1),
                                    wfcartera + 1)))
             OR(NVL(sc.ctipcol, 0) IN(1, 2)
-- BUG 0038828 - FAL - 10/12/2015 - Cojer tmb los certif 0 agrupados con certif. atrasados con fecha anterior al fcarpro del 0
                  --AND NVL (f_parproductos_v (s.sproduc, 'CARTERA_FCARPRO'), 0) = 1
                AND s.ncertif = 0
                AND EXISTS(
                      SELECT 1
                        FROM seguros s2
                       WHERE s2.npoliza = s.npoliza
                         AND s2.ncertif <> 0
                         AND s2.csituac <> 2
                         AND s2.fcarpro <
                               DECODE
                                    (wfcartera,
                                     NULL, DECODE
                                             (sc.ctipcob,
                                              1, ADD_MONTHS
                                                          ((LAST_DAY(TO_DATE(LPAD(wmes, 2, '0')
                                                                             || wanyo,
                                                                             'mmyyyy'))
                                                            + 1),
                                                           -1),
                                              (LAST_DAY(TO_DATE(LPAD(wmes, 2, '0') || wanyo,
                                                                'mmyyyy'))
                                               + 1)),
                                     DECODE(sc.ctipcob,
                                            1, ADD_MONTHS(wfcartera, -1),
                                            wfcartera)))
                AND s.fcarpro >=
                      DECODE(wfcartera,
                             NULL, DECODE(sc.ctipcob,
                                          1, ADD_MONTHS((LAST_DAY(TO_DATE(LPAD(wmes, 2, '0')
                                                                          || wanyo,
                                                                          'mmyyyy'))
                                                         + 1),
                                                        -1),
                                          (LAST_DAY(TO_DATE(LPAD(wmes, 2, '0') || wanyo,
                                                            'mmyyyy'))
                                           + 1)),
                             DECODE(sc.ctipcob, 1, ADD_MONTHS(wfcartera, -1), wfcartera))))
         AND(s.fvencim > DECODE(wfcartera,
                                NULL, DECODE(sc.ctipcob,
                                             1, ADD_MONTHS((LAST_DAY(TO_DATE(LPAD(wmes, 2, '0')
                                                                             || wanyo,
                                                                             'mmyyyy'))),
                                                           -1),
                                             (LAST_DAY(TO_DATE(LPAD(wmes, 2, '0') || wanyo,
                                                               'mmyyyy')))),
                                DECODE(sc.ctipcob, 1, ADD_MONTHS(wfcartera, -1), wfcartera))
             OR(s.fvencim <= DECODE(wfcartera,
                                    NULL, DECODE
                                              (sc.ctipcob,
                                               1, ADD_MONTHS
                                                           ((LAST_DAY(TO_DATE(LPAD(wmes, 2,
                                                                                   '0')
                                                                              || wanyo,
                                                                              'mmyyyy'))),
                                                            -1),
                                               (LAST_DAY(TO_DATE(LPAD(wmes, 2, '0') || wanyo,
                                                                 'mmyyyy')))),
                                    DECODE(sc.ctipcob, 1, ADD_MONTHS(wfcartera, -1), wfcartera))
                AND TO_CHAR(s.fvencim, 'mmyyyy') =
                      DECODE(wfcartera,
                             NULL, DECODE(sc.ctipcob,
                                          1, TO_CHAR(ADD_MONTHS(TO_DATE('01'
                                                                        || LPAD(wmes, 2, '0')
                                                                        || wanyo,
                                                                        'ddmmyyyy'),
                                                                -1),
                                                     'mmyyyy'),
                                          LPAD(wmes, 2, '0') || wanyo),
                             DECODE(sc.ctipcob,
                                    1, TO_CHAR(ADD_MONTHS(wfcartera, -1), 'mmyyyy'),
                                    TO_CHAR(wfcartera, 'mmyyyy')))
                AND s.fvencim > s.fcarpro
                AND NVL(f_parproductos_v(s.sproduc, 'RECMESVENCI'), 1) = 1)
             OR s.fvencim IS NULL)
         AND(EXISTS(
                SELECT sseguro
                  FROM movseguro m
                 WHERE nmovimi =
                          (SELECT MAX(nmovimi)
                             FROM movseguro m3
                            WHERE m3.sseguro = m.sseguro
                              AND TRUNC(m3.fefecto) <=
                                    DECODE
                                       (wfcartera,
                                        NULL, DECODE
                                               (sc.ctipcob,
                                                1, ADD_MONTHS
                                                            (LAST_DAY(TO_DATE(LPAD(wmes, 2,
                                                                                   '0')
                                                                              || wanyo,
                                                                              'mmyyyy')),
                                                             -1),
                                                LAST_DAY(TO_DATE(LPAD(wmes, 2, '0') || wanyo,
                                                                 'mmyyyy'))),
                                        DECODE(sc.ctipcob,
                                               1, ADD_MONTHS(wfcartera, -1),
                                               wfcartera))
                              AND m3.cmovseg NOT IN(6, 52))
                   -- Bug 29665/177284 - 12/06/2014 - AMC
                   AND cmovseg <> 3
                   AND femisio IS NOT NULL
                   AND sseguro = s.sseguro)
             OR(s.csituac = 5
                AND s.ccartera = 1))
         -- BUG 17153 - 31/12/2010 - JMP - Permitir pasar la cartera a un colectivo entero o a un certificado
         AND s.npoliza = NVL(wnpoliza, npoliza)
         AND s.ncertif = NVL(wncertif, ncertif)
         -- BUG 0019627: GIP102 - Reunificaci¿n de recibos - FAL - 10/11/2011
         -- NO seleccionar certificados 0 para RECUNIF = 3 (agrupac¿¿n de recibos en funi¿n de la forma pago del certif 0)
         AND((NVL(precunif, 0) = 3
              -- Bug 28640/160626 - 25/03/2014 - AMC
              AND s.ncertif <> 0)
             OR(NVL(precunif, 0) <> 3))   -- Bug 28640/160626 - 25/03/2014 - AMC
                       --si se est¿ realizando la renovacion
         -- de un certificado X que pertenece a un colectivo agrupado, su fcarpro
         -- no puede ser superior a la fcarpro de su certificado 0
         AND(((NVL(sc.ctipcol, 0) = 1
               -- Bug 28640/160626 - 25/03/2014 - AMC
               OR NVL(sc.ctipcol, 0) = 2
                                        -- Bug 28640/160626 - 25/03/2014 - AMC
              )
              AND NVL(wncertif, 0) = 0
              AND s.ncertif = NVL(wncertif, 0))   --para los administrados solo miramos el 0
             OR(NVL(sc.ctipcol, 0) = 2
                -- Bug 28640/160626 - 25/03/2014 - AMC
                AND NVL(wncertif, 0) <> 0
                AND s.ncertif = NVL(wncertif, 0)
                AND s.fcarpro < (SELECT s1.fcarpro
                                   FROM seguros s1
                                  WHERE s1.npoliza = s.npoliza
                                    AND s1.ncertif = 0))
             OR(NOT(NVL(sc.ctipcol, 0) = 1
                    -- Bug 28640/160626 - 25/03/2014 - AMC
                    OR NVL(sc.ctipcol, 0) = 2
                                             -- Bug 28640/160626 - 25/03/2014 - AMC
                   ))
             OR(NVL(pskiprenova, 0) = 1));

   CURSOR c_seg_col_psu(
      wram NUMBER,
      wmod NUMBER,
      wtip NUMBER,
      wcol NUMBER,
      wnpoliza NUMBER,
      wmes NUMBER,
      wanyo NUMBER) IS
      SELECT s.*
        FROM seguros s, seguroscol sc, agentes_agente_pol ap
       WHERE s.cramo = wram
         AND s.cmodali = wmod
         AND s.ctipseg = wtip
         AND s.ccolect = wcol
         AND s.sseguro = sc.sseguro(+)
         AND s.cagente = ap.cagente   -- Bug 28640/160626 - 25/03/2014 - AMC
         AND s.cempres = ap.cempres   -- Bug 28640/160626 - 25/03/2014 - AMC
         AND((s.csituac = 5)
             OR(s.creteni = 0
                AND s.csituac NOT IN(7, 8, 9, 10)))
         AND s.csituac <> 2   -- qt 15679
         AND s.fcarpro < DECODE(sc.ctipcob,
                                1, ADD_MONTHS((LAST_DAY(TO_DATE(LPAD(wmes, 2, '0') || wanyo,
                                                                'mmyyyy'))
                                               + 1),
                                              -1),
                                (LAST_DAY(TO_DATE(LPAD(wmes, 2, '0') || wanyo, 'mmyyyy')) + 1))
         AND(s.fvencim > DECODE(sc.ctipcob,
                                1, ADD_MONTHS((LAST_DAY(TO_DATE(LPAD(wmes, 2, '0') || wanyo,
                                                                'mmyyyy'))),
                                              -1),
                                (LAST_DAY(TO_DATE(LPAD(wmes, 2, '0') || wanyo, 'mmyyyy'))))
             OR(s.fvencim <= DECODE(sc.ctipcob,
                                    1, ADD_MONTHS((LAST_DAY(TO_DATE(LPAD(wmes, 2, '0') || wanyo,
                                                                    'mmyyyy'))),
                                                  -1),
                                    (LAST_DAY(TO_DATE(LPAD(wmes, 2, '0') || wanyo, 'mmyyyy'))))
                AND TO_CHAR(s.fvencim, 'mmyyyy') =
                      DECODE(sc.ctipcob,
                             1, TO_CHAR(ADD_MONTHS(TO_DATE('01' || LPAD(wmes, 2, '0') || wanyo,
                                                           'ddmmyyyy'),
                                                   -1),
                                        'mmyyyy'),
                             LPAD(wmes, 2, '0') || wanyo)
                AND s.fvencim > s.fcarpro
                AND NVL(f_parproductos_v(s.sproduc, 'RECMESVENCI'), 1) = 1)
             OR s.fvencim IS NULL)
         AND(EXISTS(SELECT sseguro
                      FROM movseguro m
                     WHERE nmovimi =
                              (SELECT MAX(nmovimi)
                                 FROM movseguro m3
                                WHERE m3.sseguro = m.sseguro
                                  AND TRUNC(m3.fefecto) <=
                                        DECODE(sc.ctipcob,
                                               1, ADD_MONTHS
                                                            (LAST_DAY(TO_DATE(LPAD(wmes, 2,
                                                                                   '0')
                                                                              || wanyo,
                                                                              'mmyyyy')),
                                                             -1),
                                               LAST_DAY(TO_DATE(LPAD(wmes, 2, '0') || wanyo,
                                                                'mmyyyy')))
                                  AND m3.cmovseg NOT IN(6, 52))
                       -- Bug 29665/177284 - 12/06/2014 - AMC
                       AND cmovseg <> 3
                       AND femisio IS NOT NULL
                       AND sseguro = s.sseguro)
             OR(s.csituac = 5
                AND s.ccartera = 1))
         -- BUG 17153 - 31/12/2010 - JMP - Permitir pasar la cartera a un colectivo entero o a un certificado
         AND s.npoliza = wnpoliza
         AND s.ncertif <> 0
         -- BUG 0019627: GIP102 - Reunificaci¿n de recibos - FAL - 10/11/2011
         -- NO seleccionar certificados 0 para RECUNIF = 3 (agrupac¿¿n de recibos en funi¿n de la forma pago del certif 0)
         AND((NVL(f_parproductos_v(f_sproduc_ret(s.cramo, s.cmodali, s.ctipseg, s.ccolect),
                                   'RECUNIF'),
                  0) = 3
              AND s.ncertif <> 0)
             OR(NVL(f_parproductos_v(f_sproduc_ret(s.cramo, s.cmodali, s.ctipseg, s.ccolect),
                                     'RECUNIF'),
                    0) <> 3))
         -- Bug 23940 - APD - 13/11/2012 - la poliza no puede estar bloqueada para cartera
         AND NVL(s.cbloqueocol, 0) <> 1;

------------------------------------------------------------------------------------

   -- Funci¿n que modifica el c¿digo informado en movseguro (404) por el nuevo c¿digo 406
   FUNCTION f_modif_cmovseg_aniversario(psseguro IN NUMBER, pfcarpro IN DATE)
      RETURN NUMBER IS
      vobjectname    VARCHAR2(500) := 'PAC_DINCARTERA.f_modif_cmovseg_aniversario';
      vparam         VARCHAR2(1000)
                                 := ' - psseguro: ' || psseguro || ' - pfcarpro: ' || pfcarpro;
      vpasexec       NUMBER(5) := 0;
      v_movimi       NUMBER;
      v_sproduc      NUMBER;
   BEGIN
      --o  el par¿metro de productos NVL('MODIF_MOV_ANIVERSARIO',0)  = 1
      vpasexec := 1;

      SELECT sproduc
        INTO v_sproduc
        FROM seguros
       WHERE sseguro = psseguro;

      IF (NVL(f_parproductos_v(v_sproduc, 'MODIF_MOV_ANIVERSARI'), 0) = 1) THEN
         ---o  el ¿ltimo movimiento de movseguro de esa p¿liza es el 404 y la fecha de efecto de dicho movimiento es la del par¿metro pfcarpro
         vpasexec := 2;

         BEGIN
            --o   no hay ning¿n recibo que 'cuelgue' de ese movimiento (recibos.nmovimi)
            SELECT MAX(nmovimi)
              INTO v_movimi
              FROM recibos
             WHERE sseguro = psseguro
               AND nmovimi = (SELECT MAX(nmovimi)
                                FROM movseguro
                               WHERE sseguro = psseguro
                                 AND fefecto = pfcarpro);
         EXCEPTION
            WHEN NO_DATA_FOUND THEN
               v_movimi := NULL;
         END;

         IF (v_movimi IS NULL) THEN
            vpasexec := 3;

            UPDATE movseguro
               SET cmotmov = 406
             WHERE sseguro = psseguro
               AND nmovimi = (SELECT MAX(nmovimi)
                                FROM movseguro
                               WHERE sseguro = psseguro
                                 AND fefecto = pfcarpro)
               AND fefecto = pfcarpro
               AND cmotmov = 404;
         END IF;
      END IF;

      RETURN 0;
   EXCEPTION
      WHEN OTHERS THEN
         p_tab_error(f_sysdate, f_user, vobjectname, vpasexec, vparam,
                     'ERROR: ' || SQLCODE || ' - ' || SQLERRM);
         RETURN 1000455;
   END f_modif_cmovseg_aniversario;

-- 20149:  creamos funci¿n que nos indica si el movimiento es de renovacion de cartera o de revision anual
   FUNCTION f_renovacion_anual(psseguro IN NUMBER, pfcaranu IN DATE, psproduc IN NUMBER)
      RETURN NUMBER IS
      v_cmotmov      NUMBER := 404;
      v_frenova      DATE;
   BEGIN
      BEGIN
         SELECT TO_DATE(crespue, 'yyyymmdd')
           INTO v_frenova
           FROM pregunpolseg
          WHERE sseguro = psseguro
            AND nmovimi = (SELECT MAX(nmovimi)
                             FROM pregunpolseg
                            WHERE sseguro = psseguro)
            AND cpregun = 4778;   -- fecha de la renovaci¿n
      EXCEPTION
         WHEN NO_DATA_FOUND THEN
            v_frenova := pfcaranu;
         -- INI RLLF 0033840: POSDM400-POSDM200-Tareas de Migraci¿n de Colectivos 07/08/2015
         WHEN OTHERS THEN
            SELECT TO_DATE(trespue, 'yyyymmdd')
              INTO v_frenova
              FROM pregunpolseg
             WHERE sseguro = psseguro
               AND nmovimi = (SELECT MAX(nmovimi)
                                FROM pregunpolseg
                               WHERE sseguro = psseguro)
               AND cpregun = 4778;   -- fecha de la renovaci¿n
      -- FIN RLLF 0033840: POSDM400-POSDM200-Tareas de Migraci¿n de Colectivos 07/08/2015
      END;

      IF (NVL(pac_parametros.f_parproducto_n(psproduc, 'PER_REV_NO_ANUAL'), 0) <> 0)
         AND pfcaranu <> v_frenova THEN
         v_cmotmov := 407;   -- revision anual
      ELSE
         v_cmotmov := 404;   -- renovacion cartera
      END IF;

      RETURN v_cmotmov;
   END;

   PROCEDURE garantia_regularitzacio(
      pcramo IN NUMBER,
      pcmodali IN NUMBER,
      pctipseg IN NUMBER,
      pccolect IN NUMBER,
      pcprimin OUT NUMBER,
      piprimin OUT NUMBER,
      pcclapri OUT NUMBER,
      pcgarant_regu OUT NUMBER,
      pnorden OUT NUMBER) IS
------------------------------------------------------------------------------------
-- Atenci¿!!!!! , Mirem sempre les garanties de l'activitat 0, per que considerem que
-- la prima m¿nima ¿s per producte
-- La garant¿a de regularizaci¿n no se identificar¿ por el par¿metro 'TIPO' sino
-- que ser¿ un tipo de garant¿a ctipgar = 9.- Regularizaci¿n.
------------------------------------------------------------------------------------
      CURSOR c_gar IS
         SELECT *
           FROM garanpro
          WHERE cramo = pcramo
            AND cmodali = pcmodali
            AND ctipseg = pctipseg
            AND ccolect = pccolect
            AND cactivi = 0
            AND ctipgar = 9;

      num_err        NUMBER;
      lcvalpar       NUMBER;
   BEGIN
      pcgarant_regu := NULL;
      pnorden := NULL;
      pcprimin := NULL;
      piprimin := NULL;
      pcclapri := NULL;

      BEGIN
         SELECT cprimin, iprimin, cclapri
           INTO pcprimin, piprimin, pcclapri
           FROM productos
          WHERE cramo = pcramo
            AND cmodali = pcmodali
            AND ctipseg = pctipseg
            AND ccolect = pccolect;
      EXCEPTION
         WHEN OTHERS THEN
            NULL;
      END;

      IF pcprimin IS NOT NULL THEN
         FOR v_gar IN c_gar LOOP
            --num_err     := f_pargaranpro(
            --                pcramo, pcmodali, pctipseg, pccolect, 0,
            --              v_gar.cgarant, 'TIPO', lcvalpar);

            --IF NVL(lcvalpar, 0) = 3 THEN
            pcgarant_regu := v_gar.cgarant;
            pnorden := v_gar.norden;
         --END IF;
         END LOOP;
      END IF;
   END garantia_regularitzacio;

------------------------------------------------------------------------------------
   PROCEDURE media_edad(psseguro IN NUMBER, edad_media OUT NUMBER) IS
      /*CURSOR c_media_edad
                                    IS
         SELECT r.sperson, p.fnacimi
           FROM PERSONAS p, riesgos r
          WHERE sseguro = psseguro
            AND r.fanulac IS NULL
            AND r.sperson = p.sperson;*/
      CURSOR c_media_edad IS
         SELECT r.sperson, p.fnacimi
           FROM per_personas p, riesgos r
          WHERE sseguro = psseguro
            AND r.fanulac IS NULL
            AND r.sperson = p.sperson;

      psperson       NUMBER;
      pfnacimi       DATE;
      i              NUMBER;
      edad_total     NUMBER;
      num_err        NUMBER;
      edad           NUMBER;
      d_hoy          DATE;
-- BUG 0005557 - 29-01-09 - jmf - 0005557: CRE - Suplementos autom¿ticos (cambiar f_sysdate)
   BEGIN
      i := 0;
      edad_total := 0;
      d_hoy := f_sysdate;

      OPEN c_media_edad;

      LOOP
         FETCH c_media_edad
          INTO psperson, pfnacimi;

         EXIT WHEN c_media_edad%NOTFOUND;
         i := i + 1;
         -- BUG 0005557 - 29-01-09 - jmf - 0005557: CRE - Suplementos autom¿ticos (cambiar f_sysdate)
         num_err := f_difdata(pfnacimi, d_hoy, 2, 1, edad);
         edad_total := edad_total + edad;
      END LOOP;

      CLOSE c_media_edad;

      edad_media := edad_total / i;
   END media_edad;

   FUNCTION f_permite_renovar(
      pcramo IN NUMBER,
      pcmodali IN NUMBER,
      pctipseg IN NUMBER,
      pccolect IN NUMBER,
      pnpoliza IN NUMBER,
      pmes IN NUMBER,
      panyo IN NUMBER)
      RETURN NUMBER IS
      vtraza         NUMBER;
      vcont          NUMBER := 0;
   BEGIN
      -- Se debe buscar si todos los certificados x del certificado 0 se pueden renovar.
      -- No se puede renovar un certificado x:
      -- anulado
      -- vencido
      -- con siniestro (poliza retenida)
      -- con rescate (poliza retenida)
      -- Exceptuando los certificados que no se pueden renovar por los motivos anteriores,
      -- el resto de certificados deben cumplir las condiciones del cursor c_seg_col.
      -- Si alg¿n certificado que se puede renovar no entra en el cursor c_seg_col
      -- entonces no se podr¿ renovar el certificado 0 hasta que todos sus certificados
      -- que se pueden renovar entren en el cursor c_seg_col.
      vtraza := 1;

      -- Para validar si se permite renovar una p¿liza, se deben cumplir todas las
      -- condiciones del cursor c_seg_col excepto:
      -- . la situacion (csitauc) y retencion (creteni) de la poliza
      -- . que la poliza no est¿ retenida por siniestro o rescate
      SELECT COUNT(*)
        INTO vcont
        FROM seguros s, seguroscol sc
       WHERE s.cramo = pcramo
         AND s.cmodali = pcmodali
         AND s.ctipseg = pctipseg
         AND s.ccolect = pccolect
         AND s.sseguro = sc.sseguro(+)
         AND s.npoliza = pnpoliza
         AND s.ncertif <> 0
         -- si la poliza cumple alguna de estas condiciones no se puede renovar
         AND NOT(s.csituac = 5
                 OR(s.creteni = 0
                    AND s.csituac NOT IN(7, 8, 9, 10)))
         -- a partir de aqu¿ se deben cumplir estas condiciones
         AND s.csituac <> 2   -- qt 15679
         AND pac_motretencion.f_esta_retenica_sin_resc(s.sseguro) = 0
         AND(EXISTS(SELECT sseguro
                      FROM movseguro m
                     WHERE nmovimi =
                              (SELECT MAX(nmovimi)
                                 FROM movseguro m3
                                WHERE m3.sseguro = m.sseguro
                                  AND TRUNC(m3.fefecto) <=
                                        DECODE(sc.ctipcob,
                                               1, ADD_MONTHS
                                                            (LAST_DAY(TO_DATE(LPAD(pmes, 2,
                                                                                   '0')
                                                                              || panyo,
                                                                              'mmyyyy')),
                                                             -1),
                                               LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo,
                                                                'mmyyyy')))
                                  AND m3.cmovseg NOT IN(6, 52))
                       -- Bug 29665/177284 - 12/06/2014 - AMC
                       AND cmovseg <> 3
                       AND femisio IS NOT NULL
                       AND sseguro = s.sseguro)
             OR(s.csituac = 5
                AND s.ccartera = 1))
         AND s.fcarpro < DECODE(sc.ctipcob,
                                1, ADD_MONTHS((LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo,
                                                                'mmyyyy'))
                                               + 1),
                                              -1),
                                (LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo, 'mmyyyy')) + 1))
         AND(s.fvencim > DECODE(sc.ctipcob,
                                1, ADD_MONTHS((LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo,
                                                                'mmyyyy'))),
                                              -1),
                                (LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo, 'mmyyyy'))))
             OR(s.fvencim <= DECODE(sc.ctipcob,
                                    1, ADD_MONTHS((LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo,
                                                                    'mmyyyy'))),
                                                  -1),
                                    (LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo, 'mmyyyy'))))
                AND TO_CHAR(s.fvencim, 'mmyyyy') =
                      DECODE(sc.ctipcob,
                             1, TO_CHAR(ADD_MONTHS(TO_DATE('01' || LPAD(pmes, 2, '0') || panyo,
                                                           'ddmmyyyy'),
                                                   -1),
                                        'mmyyyy'),
                             LPAD(pmes, 2, '0') || panyo)
                AND s.fvencim > s.fcarpro
                AND NVL(f_parproductos_v(s.sproduc, 'RECMESVENCI'), 1) = 1)
             OR s.fvencim IS NULL)
         AND((NVL(f_parproductos_v(f_sproduc_ret(s.cramo, s.cmodali, s.ctipseg, s.ccolect),
                                   'RECUNIF'),
                  0) = 3
              AND s.ncertif <> 0)
             OR(NVL(f_parproductos_v(f_sproduc_ret(s.cramo, s.cmodali, s.ctipseg, s.ccolect),
                                     'RECUNIF'),
                    0) <> 3))
         AND NVL(s.cbloqueocol, 0) = 0;

      IF vcont <> 0 THEN
         --No puede renovar
         vtraza := 5;
         RETURN 9904492;
      -- No se podr¿n renovar todos los certificados del colectivo.
      END IF;

      -- S¿ puede renovar
      RETURN 0;
   EXCEPTION
      WHEN OTHERS THEN
         p_tab_error(f_sysdate, f_user, 'PAC_DINCARTERA.f_permite_renovar', vtraza,
                     f_axis_literales(1000455), SQLERRM);
         RETURN 1000455;
   END f_permite_renovar;

   -- Bug 23940 - APD - 02/11/2012 - se crea la funcion
   -- Funci¿n que guarda en la tabla DETRECMOVSEGUROCOL los recibos generados
   -- en el proceso de cartera que se est¿ generando
   FUNCTION f_set_recibos_col(
      psproces IN NUMBER,
      psseguro IN NUMBER,
      pfefecto IN DATE,
      pnmovimi_0 IN NUMBER DEFAULT NULL)
      RETURN NUMBER IS
      num_err        NUMBER := 0;
      vtraza         NUMBER;
      vnrecibo       recibos.nrecibo%TYPE;
      vnpoliza       seguros.npoliza%TYPE;
      vncertif       seguros.ncertif%TYPE;
      vsseguro_0     seguros.sseguro%TYPE;
      vnmovimi_0     movseguro.nmovimi%TYPE;
      vnmovimi_cert  movseguro.nmovimi%TYPE;
      vcont          NUMBER;
   BEGIN
      vtraza := 1;

      IF (pac_seguros.f_es_col_admin(psseguro, 'POL') = 1
          OR pac_seguros.f_es_col_agrup(psseguro, 'POL') = 1) THEN
         vtraza := 2;

         -- Se busca el recibo de Cartera-Renovacion que se ha generado
         --Bug 28380/0158848 - JSV - 26/11/2013
         FOR reg_recibo IN
            (   /*SELECT nrecibo
                  INTO vnrecibo
                  FROM recibos
                 WHERE sseguro = psseguro
                   AND TRUNC(fefecto) = TRUNC(pfefecto)
                   AND ctiprec = 3
                   AND f_cestrec_mv(nrecibo, 2) <> 2*/
             SELECT nrecibo
               FROM recibos
              WHERE sseguro = psseguro
                AND TRUNC(fefecto) = TRUNC(pfefecto)
                AND ctiprec = 3
                AND f_cestrec_mv(nrecibo, 2) <> 2
             UNION
             SELECT b.nrecretorno
               FROM recibos a, rtn_recretorno b
              WHERE a.sseguro = psseguro
                AND TRUNC(a.fefecto) = TRUNC(pfefecto)
                AND a.ctiprec = 3
                AND f_cestrec_mv(a.nrecibo, 2) <> 2
                AND a.nrecibo = b.nrecibo) LOOP
            vtraza := 3;

            SELECT npoliza, ncertif
              INTO vnpoliza, vncertif
              FROM seguros
             WHERE sseguro = psseguro;

            vtraza := 4;

            IF vncertif <> 0 THEN
               SELECT sseguro
                 INTO vsseguro_0
                 FROM seguros
                WHERE npoliza = vnpoliza
                  AND ncertif = 0;

               vtraza := 5;

               IF pnmovimi_0 IS NULL THEN
                  SELECT MAX(nmovimi)
                    INTO vnmovimi_0
                    FROM movseguro
                   WHERE sseguro = vsseguro_0
                     AND TRUNC(fefecto) = TRUNC(pfefecto)
                     AND cmovseg NOT IN(6, 52);   -- movimiento no anulado

                  IF vnmovimi_0 IS NULL THEN
                     SELECT MAX(nmovimi)
                       INTO vnmovimi_0
                       FROM movseguro
                      WHERE sseguro = vsseguro_0
                        AND cmovseg NOT IN(6, 52);
                  -- movimiento no anulado
                  END IF;
               ELSE
                  vnmovimi_0 := pnmovimi_0;
               END IF;

               vtraza := 6;
               num_err := f_buscanmovimi(psseguro, 1, 1, vnmovimi_cert);
               vtraza := 7;

               SELECT COUNT(1)
                 INTO vcont
                 FROM detmovsegurocol
                WHERE sseguro_0 = vsseguro_0
                  AND nmovimi_0 = vnmovimi_0
                  AND sseguro_cert = psseguro
                  AND nmovimi_cert = vnmovimi_cert;

               vtraza := 8;

               IF vcont = 0 THEN
                  num_err := pac_seguros.f_set_detmovsegurocol(vsseguro_0, vnmovimi_0,
                                                               psseguro, vnmovimi_cert);
               END IF;

               vtraza := 9;

               IF num_err = 0 THEN
                  SELECT COUNT(1)
                    INTO vcont
                    FROM detrecmovsegurocol
                   WHERE sseguro_0 = vsseguro_0
                     AND nmovimi_0 = vnmovimi_0
                     AND sseguro_cert = psseguro
                     AND nmovimi_cert = vnmovimi_cert
                     AND nrecibo = reg_recibo.nrecibo;

                  IF vcont = 0 THEN
                     vtraza := 10;
                     num_err := pac_seguros.f_set_detrecmovsegurocol(vsseguro_0, vnmovimi_0,
                                                                     psseguro, vnmovimi_cert,
                                                                     reg_recibo.nrecibo,
                                                                     psproces);
                  END IF;
               END IF;
            END IF;
         END LOOP;
      END IF;

      RETURN num_err;
   EXCEPTION
      WHEN OTHERS THEN
         p_tab_error(f_sysdate, f_user, 'PAC_DINCARTERA.f_set_recibos_col', vtraza,
                     f_axis_literales(1000455), SQLERRM);
         RETURN 1000455;
   END f_set_recibos_col;

   -- Bug 23853 - APD - 07/01/2013 - se crea la funcion
   FUNCTION f_recibo_prima_minima(
      psproces IN NUMBER,
      psseguro IN NUMBER,
      pctiprec IN NUMBER,
      onrecibo OUT NUMBER)
      RETURN NUMBER IS
      num_err        NUMBER := 0;
      vtraza         NUMBER;
      texto          VARCHAR2(400);
      num_lin        NUMBER;
      salir          EXCEPTION;
      v_valor        NUMBER;   -- Bug 23853 - APD - 04/01/2013
      v_resp_4821    NUMBER;   -- Bug 23853 - APD - 04/01/2013
      v_femisio      DATE;   -- Bug 23853 - APD - 04/01/2013
      v_fefecto      DATE;   -- Bug 23853 - APD - 04/01/2013
      v_fvencim      DATE;   -- Bug 23853 - APD - 04/01/2013
      v_nrec_primin  recibos.nrecibo%TYPE;   -- Bug 23853 - APD - 04/01/2013
      v_mov          detrecmovsegurocol.nmovimi_0%TYPE;
      -- Bug 23853 - APD - 04/01/2013
      vimporte       NUMBER;
      v_cforpag      seguros.cforpag%TYPE;
      v_fvencim_min  recibos.fvencim%TYPE;
      v_sproduc      seguros.sproduc%TYPE;
   BEGIN
      vtraza := 1;
      num_err := pac_preguntas.f_get_pregunpolseg(psseguro, 4821, 'SEG', v_resp_4821);
      vtraza := 2;

      --Bug 26070 - INICIO - 28/02/2013 - DCT.  A¿adir f_round(v_valor, pac_monedas.f_moneda_producto(v_sproduc));
      SELECT cforpag, sproduc
        INTO v_cforpag, v_sproduc
        FROM seguros
       WHERE sseguro = psseguro;

      SELECT NVL(SUM(f_prima_forpag('SEG', 1, 3, g.sseguro, g.nriesgo, g.cgarant, g.iprianu)),
                 0)
        INTO v_valor
        FROM garanseg g, seguros s, seguros s0
       WHERE s0.sseguro = psseguro
         AND s.npoliza = s0.npoliza
         AND s.sseguro <> s0.sseguro
         AND s.csituac = 0
         AND g.sseguro = s.sseguro
         AND g.nmovimi = (SELECT MAX(g1.nmovimi)
                            FROM garanseg g1
                           WHERE g1.sseguro = g.sseguro
                             AND g1.nriesgo = g.nriesgo);

      vtraza := 3;
      v_valor := f_round(v_valor, pac_monedas.f_moneda_producto(v_sproduc));

      --Bug 26070 - FIN- 28/02/2013 - DCT.  A¿adir f_round(v_valor, pac_monedas.f_moneda_producto(v_sproduc));
      IF NVL(v_valor, 0) < NVL(v_resp_4821, 0) THEN
         vtraza := 4;

         SELECT MAX(nmovimi_0)
           INTO v_mov
           FROM detrecmovsegurocol d
          WHERE d.sseguro_0 = psseguro
            AND NOT EXISTS(SELECT a.nrecibo
                             FROM adm_recunif a
                            WHERE a.nrecibo = d.nrecibo);

         vtraza := 5;

         SELECT MIN(r.fefecto), MAX(r.fvencim), MAX(r.femisio)
           INTO v_fefecto, v_fvencim, v_femisio
           FROM recibos r
          WHERE r.nrecibo IN(SELECT d.nrecibo
                               FROM detrecmovsegurocol d
                              WHERE d.sseguro_0 = psseguro
                                AND NOT EXISTS(SELECT a.nrecibo
                                                 FROM adm_recunif a
                                                WHERE a.nrecibo = d.nrecibo));

         SELECT NVL(MAX(fvencim), v_fefecto)
           INTO v_fvencim_min
           FROM recibos r, detrecibos d
          WHERE r.sseguro = psseguro
            AND d.nrecibo = r.nrecibo
            AND r.ctiprec = pctiprec
            AND r.ctiprec = pctiprec
            AND d.cgarant = 400
            AND d.iconcep <> 0
            AND f_cestrec(d.nrecibo, f_sysdate) <> 2;

         --Bug 27048/158564 - 11/11/2013 - AMC
         SELECT GREATEST(v_fefecto, v_fvencim_min)
           INTO v_fefecto
           FROM DUAL;

         vimporte := NVL(v_resp_4821, 0) - NVL(v_valor, 0);
         vimporte := vimporte
                     *(TRUNC(MONTHS_BETWEEN(v_fvencim, v_fefecto)) / vtramo(-1, 291, v_cforpag));
         vtraza := 6;
         num_err := pac_gestion_rec.f_genrec_primin_col(psseguro, v_mov, pctiprec, v_femisio,
                                                        v_fefecto, v_fvencim, vimporte,
                                                        v_nrec_primin, 'R', psproces, 'SEG');

         IF num_err <> 0 THEN
            RAISE salir;
         END IF;

         onrecibo := v_nrec_primin;
      END IF;

      RETURN 0;
   EXCEPTION
      WHEN salir THEN
         p_tab_error(f_sysdate, f_user, 'PAC_DINCARTERA.f_recibo_prima_minima', vtraza,
                     'psproces = ' || psproces, f_axis_literales(num_err));
         RETURN num_err;
      WHEN OTHERS THEN
         p_tab_error(f_sysdate, f_user, 'PAC_DINCARTERA.f_recibo_prima_minima', vtraza,
                     f_axis_literales(1000455), SQLERRM);
         RETURN 1000455;
   END f_recibo_prima_minima;

   -- Bug 25583 - RSC - 11/01/2013 - se crea la funcion
   FUNCTION f_recibo_gastos_expedicion(
      psproces IN NUMBER,
      psseguro IN NUMBER,
      pctiprec IN NUMBER,
      onrecibo OUT NUMBER)
      RETURN NUMBER IS
      num_err        NUMBER := 0;
      vtraza         NUMBER;
      texto          VARCHAR2(400);
      num_lin        NUMBER;
      salir          EXCEPTION;
      v_femisio      DATE;
      v_fefecto      DATE;
      v_fvencim      DATE;
      v_nrec_gast    recibos.nrecibo%TYPE;
      v_mov          detrecmovsegurocol.nmovimi_0%TYPE;
      vcagastexp     seguroscol.cagastexp%TYPE;
      vcperiogast    seguroscol.cperiogast%TYPE;
      viimporgast    seguroscol.iimporgast%TYPE;
      vcforpag       seguros.cforpag%TYPE;
      v_nfracci      recibos.nfracci%TYPE;
      v_fvencim_gast recibos.fvencim%TYPE;
      v_num_err      NUMBER;
      v_ult_frenova  DATE;
      v_nmovimi      NUMBER;
      v_cuotas       NUMBER;
      v_fcaranu      DATE;
      v_fcarpro      DATE;
      v_fcarant      DATE;
      v_frenova      DATE;
   BEGIN
      vtraza := 1;

      BEGIN
         SELECT cagastexp, cperiogast, iimporgast, cforpag, fcaranu, fcarant,
                fcarpro, frenova
           INTO vcagastexp, vcperiogast, viimporgast, vcforpag, v_fcaranu, v_fcarant,
                v_fcarpro, v_frenova
           FROM seguroscol sc, seguros seg
          WHERE seg.sseguro = psseguro
            AND sc.sseguro = seg.sseguro;
      EXCEPTION
         WHEN OTHERS THEN
            vcagastexp := 0;
            vcperiogast := 0;
            viimporgast := 0;
      END;

      v_num_err := f_ultrenova(psseguro, v_fcarpro, v_ult_frenova, v_nmovimi);
      vtraza := 3;

      IF NVL(viimporgast, 0) <> 0 THEN
         IF vcagastexp = 1 THEN   -- S¿, en car¿tula (administrados --> agrupaci¿n de recibos)
            vtraza := 4;

            SELECT MAX(nmovimi_0)
              INTO v_mov
              FROM detrecmovsegurocol d
             WHERE d.sseguro_0 = psseguro
               AND NOT EXISTS(SELECT a.nrecibo
                                FROM adm_recunif a
                               WHERE a.nrecibo = d.nrecibo);

            vtraza := 5;

            -- Ini 23115 -- ECP -- 15/04/2013 se sustituye MAX(nfracci) por MIN(nfracci).
            SELECT MIN(r.fefecto), MAX(r.fvencim), MAX(r.femisio), MIN(nfracci)
              INTO v_fefecto, v_fvencim, v_femisio, v_nfracci
              FROM recibos r
             WHERE r.nrecibo IN(SELECT d.nrecibo
                                  FROM detrecmovsegurocol d
                                 WHERE d.sseguro_0 = psseguro
                                   AND NOT EXISTS(SELECT a.nrecibo
                                                    FROM adm_recunif a
                                                   WHERE a.nrecibo = d.nrecibo));

            -- Fin 23115 -- ECP -- 15/04/2013
            IF (vcperiogast = 2
                AND v_nfracci > 0) THEN
               -- Periodicidad de los gastos anual y la fraccion no es la primera.
               NULL;
            ELSE
               IF vcperiogast = 1 THEN   --  Periodicidad de los gastos segun forma de pago
                  SELECT CEIL(MONTHS_BETWEEN(NVL(v_fcaranu,
                                                 NVL(v_frenova, ADD_MONTHS(v_ult_frenova, 12))),
                                             v_ult_frenova)
                              / vtramo(-1, 291, vcforpag))
                    INTO v_cuotas
                    FROM DUAL;

                  viimporgast := viimporgast / v_cuotas;
               END IF;

               SELECT NVL(MAX(fvencim), v_fefecto)
                 INTO v_fvencim_gast
                 FROM recibos r, detrecibos d, garanseg g
                WHERE r.sseguro = psseguro
                  AND r.nrecibo = d.nrecibo
                  AND r.sseguro = g.sseguro
                  AND d.cgarant = g.cgarant
                  AND d.nriesgo = g.nriesgo
                  AND d.cgarant = g.cgarant
                  AND d.cconcep = 14
                  AND r.ctiprec = pctiprec
                  AND d.iconcep <> 0
                  AND f_cestrec(d.nrecibo, f_sysdate) <> 2;

               --Bug 27048/158564 - 11/11/2013 - AMC
               SELECT GREATEST(v_fefecto, v_fvencim_gast)
                 INTO v_fefecto
                 FROM DUAL;

               viimporgast := viimporgast
                              *(TRUNC(MONTHS_BETWEEN(v_fvencim, v_fefecto))
                                / vtramo(-1, 291, vcforpag));
               vtraza := 6;
               num_err := pac_gestion_rec.f_genrec_gastos_expedicion(psseguro, v_mov, pctiprec,
                                                                     v_femisio, v_fefecto,
                                                                     v_fvencim, viimporgast,
                                                                     v_nrec_gast, 'R',
                                                                     psproces, 'SEG');

               IF num_err <> 0 THEN
                  RAISE salir;
               END IF;

               onrecibo := v_nrec_gast;
            END IF;
         END IF;
      END IF;

      RETURN 0;
   EXCEPTION
      WHEN salir THEN
         p_tab_error(f_sysdate, f_user, 'PAC_DINCARTERA.f_recibo_gastos_expedicion', vtraza,
                     'psproces = ' || psproces, f_axis_literales(num_err));
         RETURN num_err;
      WHEN OTHERS THEN
         p_tab_error(f_sysdate, f_user, 'PAC_DINCARTERA.f_recibo_gastos_expedicion', vtraza,
                     f_axis_literales(1000455), SQLERRM);
         RETURN 1000455;
   END f_recibo_gastos_expedicion;

   -- Bug 23940 - APD - 18/10/2012 - se crea la funcion
   FUNCTION f_agruparecibos(psproces IN NUMBER, psseguro IN NUMBER)
      RETURN NUMBER IS
      num_err        NUMBER := 0;
      vtraza         NUMBER;
      texto          VARCHAR2(400);
      num_lin        NUMBER;
      t_recibo       t_lista_id := t_lista_id();
      v_nrecunif     NUMBER;
      vctiprec       recibos.ctiprec%TYPE := 3;   -- Cartera-Renovacion
      vcempres       seguros.cempres%TYPE;
      vsproduc       seguros.sproduc%TYPE;
      salir          EXCEPTION;
      v_nrec_primin  recibos.nrecibo%TYPE;   -- Bug 23853 - APD - 04/01/2013
      v_nrec_gastos  recibos.nrecibo%TYPE;
      v_nuevorecibo  NUMBER;
   BEGIN
      t_recibo := NULL;
      t_recibo := t_lista_id();
      vtraza := 1;

      -- Agrupar los recibos generados en el proceso pero solo para los
      -- colectivos Administrados
      -- ini bug 0026261 - 06/05/2013 - JMC Se a¿ade recibos para seleccionar los que no sean retorno
      FOR reg IN (SELECT   d.sseguro_0, d.nmovimi_0
                      FROM detrecmovsegurocol d
                     WHERE d.sseguro_0 = NVL(psseguro, d.sseguro_0)
                       AND pac_seguros.f_es_col_admin(d.sseguro_0, 'POL') = 1
                       --AND sproces = psproces
                       AND NOT EXISTS(SELECT a.nrecibo
                                        FROM adm_recunif a
                                       WHERE a.nrecibo = d.nrecibo)
                       AND f_cestrec_mv(d.nrecibo, 2) = 0
                  GROUP BY sseguro_0, d.nmovimi_0) LOOP
         vtraza := 2;

         SELECT cempres, sproduc
           INTO vcempres, vsproduc
           FROM seguros
          WHERE sseguro = reg.sseguro_0;

         FOR tiprec IN (SELECT DISTINCT r.ctiprec
                                   FROM recibos r, detrecmovsegurocol d
                                  WHERE r.sseguro = d.sseguro_cert
                                    AND r.nmovimi = d.nmovimi_cert
                                    AND d.sseguro_0 = reg.sseguro_0
                                    AND d.nmovimi_0 = reg.nmovimi_0
                                    AND r.nrecibo = d.nrecibo
                                    AND NOT EXISTS(SELECT a.nrecibo
                                                     FROM adm_recunif a
                                                    WHERE a.nrecibo = r.nrecibo)
                        UNION
                        SELECT DISTINCT r.ctiprec
                                   FROM recibos r
                                  WHERE r.sseguro = reg.sseguro_0
                                    AND r.nmovimi = reg.nmovimi_0
                                    AND NOT EXISTS(SELECT a.nrecibo
                                                     FROM adm_recunif a
                                                    WHERE a.nrecibo = r.nrecibo)
                               ORDER BY ctiprec) LOOP
            t_recibo := NULL;
            t_recibo := t_lista_id();

            FOR pers IN (SELECT DISTINCT r.sperson
                                    FROM recibos r, detrecmovsegurocol d
                                   WHERE r.sseguro = d.sseguro_cert
                                     AND r.nmovimi = d.nmovimi_cert
                                     AND r.ctiprec = tiprec.ctiprec
                                     AND d.sseguro_0 = reg.sseguro_0
                                     AND d.nmovimi_0 = reg.nmovimi_0
                                     AND r.nrecibo = d.nrecibo
                                     AND NOT EXISTS(SELECT a.nrecibo
                                                      FROM adm_recunif a
                                                     WHERE a.nrecibo = r.nrecibo)
                         UNION
                         SELECT DISTINCT r.sperson
                                    FROM recibos r
                                   WHERE r.sseguro = reg.sseguro_0
                                     AND r.nmovimi = reg.nmovimi_0
                                     AND r.ctiprec = tiprec.ctiprec
                                     AND NOT EXISTS(SELECT a.nrecibo
                                                      FROM adm_recunif a
                                                     WHERE a.nrecibo = r.nrecibo)
                                     AND NOT EXISTS(SELECT a.nrecunif
                                                      FROM adm_recunif a
                                                     WHERE a.nrecunif = r.nrecibo)) LOOP
               FOR rec IN (SELECT r.nrecibo
                             FROM recibos r, detrecmovsegurocol d
                            WHERE r.sseguro = d.sseguro_cert
                              AND r.nmovimi = d.nmovimi_cert
                              AND r.ctiprec = tiprec.ctiprec
                              AND NVL(r.sperson, -1) = NVL(pers.sperson, -1)
                              AND d.sseguro_0 = reg.sseguro_0
                              AND d.nmovimi_0 = reg.nmovimi_0
                              AND r.nrecibo = d.nrecibo
                              AND NOT EXISTS(SELECT a.nrecibo
                                               FROM adm_recunif a
                                              WHERE a.nrecibo = r.nrecibo)
                           UNION
                           SELECT r.nrecibo
                             FROM recibos r
                            WHERE r.sseguro = reg.sseguro_0
                              AND r.nmovimi = reg.nmovimi_0
                              AND r.ctiprec = tiprec.ctiprec
                              AND NVL(r.sperson, -1) = NVL(pers.sperson, -1)
                              AND NOT EXISTS(SELECT a.nrecibo
                                               FROM adm_recunif a
                                              WHERE a.nrecibo = r.nrecibo)
                              AND NOT EXISTS(SELECT a.nrecunif
                                               FROM adm_recunif a
                                              WHERE a.nrecunif = r.nrecibo)) LOOP
                  t_recibo.EXTEND;
                  t_recibo(t_recibo.LAST) := ob_lista_id();
                  t_recibo(t_recibo.LAST).idd := rec.nrecibo;
               END LOOP;

               IF t_recibo IS NOT NULL THEN
                  IF t_recibo.COUNT > 0 THEN
                     vtraza := 5;

                     IF tiprec.ctiprec NOT IN(13, 15) THEN
                        -- Bug 23853 - APD - 04/01/2012 - se a¿ade el recibo de prima minima
                        num_err := pac_dincartera.f_recibo_prima_minima(psproces,
                                                                        reg.sseguro_0,
                                                                        vctiprec,
                                                                        v_nrec_primin);

                        IF num_err <> 0 THEN
                           RAISE salir;
                        END IF;

                        vtraza := 6;

                        IF v_nrec_primin IS NOT NULL THEN
                           t_recibo.EXTEND;
                           t_recibo(t_recibo.LAST) := ob_lista_id();
                           t_recibo(t_recibo.LAST).idd := v_nrec_primin;
                        END IF;

                        -- fin Bug 23853 - APD - 04/01/2012

                        -- Bug 25583 - RSC - 11/01/2013
                        num_err := pac_dincartera.f_recibo_gastos_expedicion(psproces,
                                                                             reg.sseguro_0,
                                                                             vctiprec,
                                                                             v_nrec_gastos);

                        IF num_err <> 0 THEN
                           RAISE salir;
                        END IF;

                        vtraza := 6;

                        IF v_nrec_gastos IS NOT NULL THEN
                           t_recibo.EXTEND;
                           t_recibo(t_recibo.LAST) := ob_lista_id();
                           t_recibo(t_recibo.LAST).idd := v_nrec_gastos;
                        END IF;
                     END IF;

                     -- Fin bug 25583
                     vtraza := 7;
                     num_err := pac_gestion_rec.f_agruparecibo(vsproduc, f_sysdate, f_sysdate,
                                                               vcempres, t_recibo,
                                                               tiprec.ctiprec);

                     IF num_err <> 0 THEN
                        RAISE salir;
                     END IF;

                     -- ini 22/10/2014 - RSC: Se updatea el nmovimi del recibo agrupado con el nmovimi del movimiento que estro tratando
                     -- aqui. No borrar ya que puede pasar que se encadenen mas de un proceso de cartera, es decir, esta funci¿n
                     -- puede generar m¿s de un recibo y por tanto cada recibo se debe generar con el nmovimi que le corresponde.
                     -- Esto es importante si luego el usuario se pone a rechazar movimiento ya que cada recibo debe ir con el movimiento
                     -- que se gener¿. Esto ha surgido tras el an¿lisis del QT: 14860.
                     IF t_recibo.EXISTS(1) THEN
                        BEGIN
                           SELECT nrecunif
                             INTO v_nuevorecibo
                             FROM adm_recunif a
                            WHERE nrecibo = t_recibo(1).idd;

                           UPDATE recibos
                              SET nmovimi = reg.nmovimi_0
                            WHERE nrecibo = v_nuevorecibo;
                        EXCEPTION
                           WHEN OTHERS THEN
                              NULL;
                        END;
                     END IF;

                     -- fin 22/10/2014 - RSC
                     vtraza := 8;
                  END IF;
               END IF;
            END LOOP;
         END LOOP;
--         FOR rec IN (SELECT d.nrecibo
--                       FROM detrecmovsegurocol d, recibos r
--                      WHERE d.sseguro_0 = reg.sseguro_0
--                        AND r.sseguro = d.sseguro_cert
--                        AND r.nmovimi = d.nmovimi_cert
--                        --AND d.sproces = psproces
--                        AND r.ctiprec NOT IN(13, 15)
--                        AND NOT EXISTS(SELECT a.nrecibo
--                                         FROM adm_recunif a
--                                        WHERE a.nrecibo = d.nrecibo)) LOOP
--            t_recibo.EXTEND;
--            t_recibo(t_recibo.LAST) := ob_lista_id();
--            t_recibo(t_recibo.LAST).idd := rec.nrecibo;
--            vtraza := 3;
--         END LOOP;

      --         vtraza := 4;

      --         IF t_recibo IS NOT NULL THEN
--            IF t_recibo.COUNT > 0 THEN
--               vtraza := 5;
--               -- Bug 23853 - APD - 04/01/2012 - se a¿ade el recibo de prima minima
--               num_err := pac_dincartera.f_recibo_prima_minima(psproces, reg.sseguro_0,
--                                                               vctiprec, v_nrec_primin);

      --               IF num_err <> 0 THEN
--                  RAISE salir;
--               END IF;

      --               vtraza := 6;

      --               IF v_nrec_primin IS NOT NULL THEN
--                  t_recibo.EXTEND;
--                  t_recibo(t_recibo.LAST) := ob_lista_id();
--                  t_recibo(t_recibo.LAST).idd := v_nrec_primin;
--               END IF;

      --               -- fin Bug 23853 - APD - 04/01/2012

      --               -- Bug 25583 - RSC - 11/01/2013
--               num_err := pac_dincartera.f_recibo_gastos_expedicion(psproces, reg.sseguro_0,
--                                                                    vctiprec, v_nrec_gastos);

      --               IF num_err <> 0 THEN
--                  RAISE salir;
--               END IF;

      --               vtraza := 6;

      --               IF v_nrec_gastos IS NOT NULL THEN
--                  t_recibo.EXTEND;
--                  t_recibo(t_recibo.LAST) := ob_lista_id();
--                  t_recibo(t_recibo.LAST).idd := v_nrec_gastos;
--               END IF;

      --               -- Fin bug 25583
--               vtraza := 7;
--               num_err := pac_gestion_rec.f_agruparecibo(vsproduc, f_sysdate, f_sysdate,
--                                                         vcempres, t_recibo, vctiprec);

      --               IF num_err <> 0 THEN
--                  RAISE salir;
--               END IF;

      --               vtraza := 8;
--            END IF;
--         END IF;
      END LOOP;

      RETURN 0;
   EXCEPTION
      WHEN salir THEN
         p_tab_error(f_sysdate, f_user, 'PAC_DINCARTERA.f_agruparecibos', vtraza,
                     'psproces = ' || psproces, f_axis_literales(num_err));
         RETURN num_err;
      WHEN OTHERS THEN
         p_tab_error(f_sysdate, f_user, 'PAC_DINCARTERA.f_agruparecibos', vtraza,
                     f_axis_literales(1000455), SQLERRM);
         RETURN 1000455;
   END f_agruparecibos;

   -- Bug 23940 - APD - 18/10/2012 - se crea la funcion
   -- Funci¿n creada para extraer el c¿digo de la generaci¿n de suplementos diferidos/automaticos
   -- del procedure p_cartera
   FUNCTION f_genera_suplementos(
      p_sseguro IN NUMBER,
      p_fcarpro IN DATE,
      ppsproces IN NUMBER,
      indice_error IN OUT NUMBER)
      RETURN NUMBER IS
      num_err        NUMBER := 0;
      vtraza         NUMBER;
      v_admite_certif NUMBER;
      v_es_administrado NUMBER;
      vcuser         VARCHAR2(40);
      -- Bug 28821/0176979 - APD - 10/06/2014
      vcontexto      NUMBER;   -- Bug 28821/0176979 - APD - 10/06/2014
      salir          EXCEPTION;   -- Bug 28821/0176979 - APD - 10/06/2014
   BEGIN
      vtraza := 1;

      -- Bug 28821/0176979 - APD - 10/06/2014
      -- Nos guardamos el usuario
      SELECT f_user
        INTO vcuser
        FROM DUAL;

      -- Se cambia el usuario de conexion
      SELECT pac_contexto.f_inicializarctx
                                (pac_parametros.f_parempresa_t(pac_md_common.f_get_cxtempresa,
                                                               'USER_BBDD'))
        INTO vcontexto
        FROM DUAL;

      -- fin Bug 28821/0176979 - APD - 10/06/2014
      -- BUG 0005557 - 29-01-09 - jmf - INI 0005557: CRE - Suplementos autom¿ticos

      -- BUG15823:DRA:27/10/2010:Inici
      -- Bug 9905 - 24/04/2009 - RSC - Suplemento de cambio de forma de pago diferido
      IF pac_sup_diferidos.f_eval_diferidos(p_sseguro, p_fcarpro) = 1 THEN
         SELECT NVL(f_parproductos_v(sproduc, 'ADMITE_CERTIFICADOS'), 0)
           INTO v_admite_certif
           FROM seguros
          WHERE sseguro = p_sseguro;

         v_es_administrado := pac_seguros.f_es_col_admin(p_sseguro, 'SEG');

         IF v_admite_certif = 1
            AND v_es_administrado = 1 THEN
            NULL;
         ELSE
            num_err := pac_sup_diferidos.f_gen_supl_diferidos(p_sseguro, p_fcarpro, ppsproces);
         END IF;
      END IF;

      vtraza := 2;

      -- Fin Bug 9905
      IF num_err <> 0 THEN
             -- Volvemos porque ha fallado el suplemento
         -- Bug 28821/0176979 - APD - 10/06/2014
         --RETURN num_err;
         RAISE salir;
      -- fin Bug 28821/0176979 - APD - 10/06/2014
      ELSE
         vtraza := 3;

         -- Bug 9153 - 17/04/2009 - RSC - Suplementos autom¿ticos
         IF pac_sup_diferidos.f_eval_automaticos(p_sseguro) = 1 THEN
            num_err := pac_sup_diferidos.f_gen_supl_automaticos(p_sseguro, p_fcarpro,
                                                                ppsproces);
            -- Bug 10908 - 28/08/2009 - JMF
            -- Bug 16095 - 05/11/2010 - APD - Si pac_sup_diferidos.f_gen_supl_automaticos
            -- devuelve el num_err 9901538 no se debe tratar como un error
            vtraza := 4;

            IF num_err <> 0
               AND num_err <> 9901538 THEN
               indice_error := indice_error + 1;
            END IF;
         -- Bug 16095 - 05/11/2010 - APD
         -- Bug 10908 - 28/08/2009 - JMF
         END IF;

         -- Fin Bug 9153
         vtraza := 5;

         IF num_err <> 0 THEN
            -- Volvemos porque ha fallado el suplemento
            IF num_err = 9901538 THEN   -- Bug 16095 - 05/11/2010 - APD
               COMMIT;   -- Bug 16095 - 05/11/2010 - APD
            END IF;

            -- Bug 28821/0176979 - APD - 10/06/2014
            --RETURN num_err;
            RAISE salir;
         -- fin Bug 28821/0176979 - APD - 10/06/2014
         END IF;
      END IF;

      -- Bug 28821/0176979 - APD - 10/06/2014
      -- Se cambia el usuario de conexion por el usuario inicial
      SELECT pac_contexto.f_inicializarctx(vcuser)
        INTO vcontexto
        FROM DUAL;

      -- fin Bug 28821/0176979 - APD - 10/06/2014
      RETURN num_err;
   EXCEPTION
      -- Bug 28821/0176979 - APD - 10/06/2014
      WHEN salir THEN
         SELECT pac_contexto.f_inicializarctx(vcuser)
           INTO vcontexto
           FROM DUAL;

         RETURN num_err;
      -- fin Bug 28821/0176979 - APD - 10/06/2014
      WHEN OTHERS THEN
         indice_error := indice_error + 1;
         p_tab_error(f_sysdate, f_user, 'PAC_DINCARTERA.f_genera_suplementos', vtraza,
                     f_axis_literales(1000455), SQLERRM);
         RETURN 1000455;
   END f_genera_suplementos;

   -- fin Bug 23940 - APD - 18/10/2012

   -- Bug 23940 - APD - 18/10/2012 - se crea la funcion
   -- Funci¿n creada para extraer el c¿digo de la generaci¿n/validaci¿n de psu
   -- del procedure p_cartera
   FUNCTION f_genera_psu(
      p_modo IN VARCHAR,
      p_accion IN NUMBER,
      p_sseguro IN NUMBER,
      p_fcarpro IN DATE,
      ppsproces IN NUMBER,
      pidioma IN NUMBER,
      indice IN OUT NUMBER,
      indice_error IN OUT NUMBER,
      pcreteni OUT NUMBER)
      RETURN NUMBER IS
      vparam         VARCHAR2(1000)
         := 'p_modo = ' || p_modo || '; p_accion =' || p_accion || '; p_sseguro = '
            || p_sseguro || '; p_fcarpro = ' || p_fcarpro || '; ppsproces = ' || ppsproces
            || '; pidioma = ' || pidioma;
      vsproduc       seguros.sproduc%TYPE;
      vcmotmov       codimotmov.cmotmov%TYPE := 403;   -- Prop. Cartera
      num_err        NUMBER := 0;
      vtraza         NUMBER;
      texto          VARCHAR2(400);
      pnnumlin       NUMBER;
      vnpoliza       seguros.npoliza%TYPE;
      vncertif       seguros.ncertif%TYPE;
      vexistemov     NUMBER := 1;
      vcont          NUMBER;
      v_est_sseguro  NUMBER;
      mens           VARCHAR2(1000);
      v_nmovimi      NUMBER;
      v_nsuplem      seguros.nsuplem%TYPE;
      --       v_nsuplem      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      v_est_nmovimi  NUMBER;
      vnmovimi_out   NUMBER;
      salir          EXCEPTION;
      v_conta        NUMBER := 0;

      FUNCTION f_set_controles(ptablas IN VARCHAR2, psseguro_control IN NUMBER)
         RETURN NUMBER IS
         vtraza         NUMBER := 0;
      BEGIN
         vtraza := 1;

         IF ptablas = 'EST' THEN
            FOR reg_psu IN (SELECT d.ccontrol, d.tcontrol
                              FROM estpsucontrolseg c, psu_descontrol d
                             WHERE c.sseguro = psseguro_control
                               AND c.nmovimi = (SELECT MAX(b.nmovimi)
                                                  FROM estpsucontrolseg b
                                                 WHERE b.sseguro = c.sseguro)
                               AND c.nocurre = (SELECT MAX(b.nocurre)
                                                  FROM estpsucontrolseg b
                                                 WHERE b.sseguro = c.sseguro
--                                                   AND b.ccontrol = c.ccontrol
                                                   AND b.nmovimi = c.nmovimi)
                               AND(c.cautrec = 0
                                   OR(c.cautrec = 1
                                      AND autmanual = 'M'))
                               AND d.ccontrol = c.ccontrol
                               AND d.cidioma = pidioma
                               AND c.isvisible = 1
                               AND c.cnivelr <> 0) LOOP
               vtraza := 2;
               texto := f_axis_literales(9901634, pidioma) || ' ' || reg_psu.ccontrol || ': '
                        || reg_psu.tcontrol;
               vtraza := 3;
               pnnumlin := NULL;
               vtraza := 4;
               num_err := f_proceslin(ppsproces, texto, p_sseguro, pnnumlin, 2);
            END LOOP;
         ELSE
            FOR reg_psu IN (SELECT d.ccontrol, d.tcontrol
                              FROM psucontrolseg c, psu_descontrol d
                             WHERE c.sseguro = psseguro_control
                               AND c.nmovimi = (SELECT MAX(b.nmovimi)
                                                  FROM psucontrolseg b
                                                 WHERE b.sseguro = c.sseguro)
                               AND c.nocurre = (SELECT MAX(b.nocurre)
                                                  FROM psucontrolseg b
                                                 WHERE b.sseguro = c.sseguro
--                                                   AND b.ccontrol = c.ccontrol
                                                   AND b.nmovimi = c.nmovimi)
                               AND(c.cautrec = 0
                                   OR(c.cautrec = 1
                                      AND autmanual = 'M'))
                               AND d.ccontrol = c.ccontrol
                               AND d.cidioma = pidioma
                               AND c.isvisible = 1
                               AND c.cnivelr <> 0) LOOP
               vtraza := 2;
               texto := f_axis_literales(9901634, pidioma) || ' ' || reg_psu.ccontrol || ': '
                        || reg_psu.tcontrol;
               vtraza := 3;
               pnnumlin := NULL;
               vtraza := 4;
               num_err := f_proceslin(ppsproces, texto, p_sseguro, pnnumlin, 2);
            END LOOP;
         END IF;

         RETURN 0;
      EXCEPTION
         WHEN OTHERS THEN
            indice_error := indice_error + 1;
            p_tab_error(f_sysdate, f_user, 'PAC_DINCARTERA.f_genera_psu.f_set_controles',
                        vtraza, f_axis_literales(1000455), SQLERRM);
            RETURN 1000455;
      END f_set_controles;
   BEGIN
      SELECT npoliza, ncertif, sproduc
        INTO vnpoliza, vncertif, vsproduc
        FROM seguros
       WHERE sseguro = p_sseguro;

      SELECT COUNT(*)
        INTO v_conta
        FROM psu_controlpro
       WHERE sproduc = vsproduc
         AND renovaci IN(1, 2);

      IF NVL(pac_parametros.f_parproducto_n(vsproduc, 'PSU'), 0) = 1
         AND v_conta >= 1 THEN
         -- p_modo = 'R' --> validaciones de PSU en CARTERA
         IF p_modo = 'R' THEN
            IF p_accion = 3 THEN   -- PSU PRE
               -- Si ya existe el movimiento de Cartera y se vuelve a lanzar la
               -- cartera es porque la poliza hab¿a quedado retenida por
               -- PSU POST, as¿ que no tienen que volver a ejecutarse las PSU PRE
               -- (esto se hace porque sino al volver a pasar cartera, el nmovimi
               -- que se coge en el PAC_PSU es el ¿ltimo generado, que en este caso
               -- ser¿a el del movimiento de Cartera (404) y no el de Propuesta de
               -- Cartera (403), por lo que no detectaria que ya se han aceptado
               -- las PSU PRE y las volver¿a a validar, por lo que volver¿a a quedar
               -- la p¿liza retenida por PSU PRE, cuando realmente ya han sido
               -- validadas por el nmovimi de Propuesta de Cartera)
               SELECT COUNT(1)
                 INTO vcont
                 FROM movseguro
                WHERE sseguro = p_sseguro
                  AND cmotmov IN(404, 407, 821, 406)
                  --Mantis 34469/0205354 - BLA - DD25/MM05/2015 :add 406
                  AND fefecto = p_fcarpro
                  AND cmovseg NOT IN(6, 52);

               -- movimiento no anulado (v.f. 16)

               -- Bug 29665/177284 - 12/06/2014 - AMC
               IF vcont = 0 THEN
                  -- Las PSU de PRE cartera deben colgar de un nuevo movimiento 403.-Propuesta
                  -- cartera
                  -- puede ser que no exista el movimiento 403 o que ya est¿ creado porque hayan
                  -- saltado previamente las PSU

                  -- Si no hay generado el movimiento de Propuesta Cartera, se crea
                  SELECT COUNT(1)
                    INTO vexistemov
                    FROM movseguro
                   WHERE sseguro = p_sseguro
                     AND cmotmov = vcmotmov
                     AND fefecto = p_fcarpro
                     AND cmovseg NOT IN(6, 52);

                  -- movimiento no anulado (v.f. 16)

                  -- Bug 29665/177284 - 12/06/2014 - AMC
                  IF vexistemov = 0 THEN
                     pac_alctr126.traspaso_tablas_seguros(p_sseguro, mens, 'ALSUP003', NULL,
                                                          NVL(p_fcarpro, TRUNC(f_sysdate)));

                     IF mens IS NOT NULL THEN
                        -- se deber¿ grabar en tab_error
                        num_err := 105419;   --ERROR TRASPASO
                        RAISE salir;
                     END IF;

                     -- Averiguamos el sseguro de las tablas EST
                     SELECT MAX(sseguro)
                       INTO v_est_sseguro
                       FROM estseguros
                      WHERE ssegpol = p_sseguro;
                  END IF;

                  IF vexistemov = 0 THEN
                     num_err := pac_psu.f_inicia_psu('EST', v_est_sseguro, p_accion, pidioma,
                                                     pcreteni);
                  -- Bug 30448/0177077 - APD - 27/03/2014
/*
                  ELSE
                     num_err := pac_psu.f_inicia_psu('POL', p_sseguro, p_accion, pidioma,
                                                     pcreteni);
*/
                  -- fin Bug 30448/0177077 - APD - 27/03/2014
                  END IF;

                  IF num_err <> 0 THEN
                     -- ha habido un error en la package pero no quiere decir que
                     -- sea por los controles de PSU
                     RAISE salir;
                  END IF;

                  IF NVL(pcreteni, 0) <> 0 THEN
                     -- hay error de controles de PSU, entonces no debe continuar el proceso
                     -- pero no debe salir como si hubiera habido un error
                     -- desde CARTERA_PRODUCTE se controlar¿ este error
                     texto := f_axis_literales(9002255, pidioma);
                     texto := texto || ' PRE' || '. (' || vnpoliza || '-' || vncertif || ')';
                     pnnumlin := NULL;
                     num_err := f_proceslin(ppsproces, texto, p_sseguro, pnnumlin, 2);
                     num_err := f_set_controles('EST', v_est_sseguro);

                     IF vexistemov = 0 THEN
                        -- generar un movimiento de Propuesta de Cartera
                              -- obtenemos datos del seguro
                        SELECT s.nsuplem
                          INTO v_nsuplem
                          FROM seguros s
                         WHERE s.sseguro = p_sseguro;

                        num_err := f_movseguro(p_sseguro, NULL, vcmotmov, 1, p_fcarpro, NULL,
                                               v_nsuplem + 1, 0, NULL, vnmovimi_out, f_sysdate,
                                               NULL, NULL);

                        -- Se llama a f_act_hisseg para guardar la
                        -- situaci¿n anterior al suplemento.
                        -- El nmovimi es el anterior al del suplemento,
                        -- por eso se le resta uno al reci¿n creado.
                        --Bug 27048/155371 - APD - 17/12/2013 - se vuelve a dejar que
                        -- busque el max(nmovimi) de movseguro
                        SELECT MAX(nmovimi)
                          INTO v_nmovimi
                          FROM movseguro   --garanseg   --movseguro
                         WHERE sseguro = p_sseguro
                           AND nmovimi < vnmovimi_out
                           --AND ffinefe IS NULL;
                           AND cmovseg NOT IN(6, 52);

                        -- no anulado -- Bug 29665/177284 - 12/06/2014 - AMC

                        --fin Bug 27048/155371 - APD - 17/12/2013
                        num_err := f_act_hisseg(p_sseguro, v_nmovimi);

                        IF num_err <> 0 THEN
                           RAISE salir;
                        END IF;

                        pac_alctr126.traspaso_tablas_est(v_est_sseguro, p_fcarpro, NULL, mens,
                                                         'ALSUP003', NULL, vnmovimi_out,
                                                         p_fcarpro);

                        IF mens IS NOT NULL THEN
                           -- se deber¿ grabar en tab_error
                           num_err := 105419;   --ERROR TRASPASO
                           RAISE salir;
                        END IF;

                        -- actualizar seguros.femisio y seguros.nsuplem
                        UPDATE seguros
                           SET femisio = f_sysdate,
                               nsuplem = v_nsuplem + 1
                         WHERE sseguro = p_sseguro;
                     END IF;

                     indice_error := indice_error + 1;
                  ELSE   -- NO hay error de controles de PSU, ha ido todo bien
                     -- si no existia antes el movimiento de Propuesta de cartera se debe eliminar
                     IF vexistemov = 0 THEN
                        -- no hay error de controles de PSU, por lo que se debe eliminar el movimiento de Propuesta de Cartera
                        pac_alctr126.borrar_tablas_est(v_est_sseguro);
                     END IF;
                  END IF;
               END IF;   -- vcont

               RETURN 0;
            ELSIF p_accion = 4 THEN   -- PSU POST
               -- Las PSU de POST cartera deben colgar del movimiento 404.-Renovaci¿n de cartera
               -- se entiende que el movimiento de renovacion (404) ya existe al validar las
               -- PSU POST, por lo que no hay que generar un movimiento "ficticio" del cual
               -- cuelguen las PSU si hay
               num_err := pac_psu.f_inicia_psu('POL', p_sseguro, p_accion,   --psu, pre-cartera
                                               pidioma, pcreteni);

               IF num_err <> 0 THEN
                  -- ha habido un error en la package pero no quiere decir que
                  -- sea por los controles de PSU
                  RAISE salir;
               END IF;

               IF NVL(pcreteni, 0) <> 0 THEN
                  -- hay error de controles de PSU, entonces no debe continuar el proceso
                  -- pero no debe salir como si hubiera habido un error
                  -- desde CARTERA_PRODUCTE se controlar¿ este error
                  texto := f_axis_literales(9002255, pidioma);
                  texto := texto || ' POST' || '. (' || vnpoliza || '-' || vncertif || ')';
                  pnnumlin := NULL;
                  num_err := f_proceslin(ppsproces, texto, p_sseguro, pnnumlin, 2);
                  num_err := f_set_controles('REA', p_sseguro);
                  indice_error := indice_error + 1;
                  RETURN 0;
               END IF;
            END IF;
         -- p_modo = 'P' --> validaciones de PSU en PREVIO CARTERA
         ELSE
            IF p_accion = 3 THEN   -- PSU PRE PREVIO
               pac_alctr126.traspaso_tablas_seguros(p_sseguro, mens, 'ALSUP003', NULL,
                                                    NVL(p_fcarpro, TRUNC(f_sysdate)));

               IF mens IS NOT NULL THEN
                  num_err := 105419;   --ERROR TRASPASO
                  RAISE salir;
               END IF;

               -- Averiguamos el sseguro de las tablas EST
               SELECT MAX(sseguro)
                 INTO v_est_sseguro
                 FROM estseguros
                WHERE ssegpol = p_sseguro;

               --QT 17260 -- pac_csionesrea.f_buscactrrea_est solo coge las de cobliga = 1
               UPDATE estgaranseg
                  SET cobliga = 1
                WHERE sseguro = v_est_sseguro;

               num_err := pac_psu.f_inicia_psu('EST', v_est_sseguro, p_accion, pidioma,
                                               pcreteni);

               IF num_err <> 0 THEN
                  -- ha habido un error en la package pero no quiere decir que
                  -- sea por los controles de PSU
                  RAISE salir;
               END IF;

               IF NVL(pcreteni, 0) <> 0 THEN
                  -- hay error de controles de PSU, entonces no debe continuar el proceso
                  -- pero no debe salir como si hubiera habido un error
                  -- desde CARTERA_PRODUCTE se controlar¿ este error
                  texto := f_axis_literales(9002255, pidioma);
                  texto := texto || ' PRE' || '. (' || vnpoliza || '-' || vncertif || ')';
                  pnnumlin := NULL;
                  num_err := f_proceslin(ppsproces, texto, p_sseguro, pnnumlin, 2);
                  -- En modo previo, si saltan los controles de PSU no se debe
                  -- para el proceso pero si se debe contabilizar como erroneo
                  indice_error := indice_error + 1;
                  num_err := f_set_controles('EST', v_est_sseguro);
                  pac_alctr126.borrar_tablas_est(v_est_sseguro);
                  RETURN 0;
               END IF;
            ELSIF p_accion = 4 THEN   -- PSU POST PREVIO
               pac_alctr126.traspaso_tablas_seguros(p_sseguro, mens, 'ALSUP003', NULL,
                                                    NVL(p_fcarpro, TRUNC(f_sysdate)));

               IF mens IS NOT NULL THEN
                  -- se deber¿ grabar en tab_error
                  num_err := 105419;   --ERROR TRASPASO
                  RAISE salir;
               END IF;

               -- Averiguamos el sseguro de las tablas EST
               SELECT MAX(sseguro)
                 INTO v_est_sseguro
                 FROM estseguros
                WHERE ssegpol = p_sseguro;

               SELECT DISTINCT (nmovimi)
                          INTO v_est_nmovimi
                          FROM estgaranseg
                         WHERE sseguro = v_est_sseguro;

               SELECT MAX(nmovimi)
                 INTO v_nmovimi
                 FROM garanseg
                WHERE sseguro = p_sseguro
                  AND ffinefe IS NULL;

               -- se actualizan las tablas EST con la informacion de las tablas CAR
               -- ya que al pasar la informacion a las tablas CAR (tablas de CARTERA)
               -- la informaci¿n no tiene pq ser igual a la de las tablas REALES
               -- y en la PSU POST PREVIO se necesita la ¿ltima informaci¿n, es decir, lo
               -- que hay en las tablas CAR.
               -- EN la PSU POST de CARTERA REAL esto no pasa, pues despu¿s de tarifar,
               -- la informaci¿n de las tablas CAR pasa a las REALES con lo que la PSU
               -- POST de CARTERA REAL ya se puede lanzar sobre las tablas REALES.
               -- El problema de todo esto es que las PSU no est¿n preparadas para las
               -- tablas CAR (s¿lo para las EST o las REALES)
               num_err := pac_dincartera.f_traspasgar(ppsproces, p_sseguro, NULL, v_nmovimi,
                                                      'EST', v_est_sseguro, v_est_nmovimi);

               IF num_err <> 0 THEN
                  RAISE salir;
               END IF;

               --QT 17260 -- pac_csionesrea.f_buscactrrea_est solo coge las de cobliga = 1
               UPDATE estgaranseg
                  SET cobliga = 1
                WHERE sseguro = v_est_sseguro;

               num_err := pac_psu.f_inicia_psu('EST', v_est_sseguro, p_accion, pidioma,
                                               pcreteni);

               IF num_err <> 0 THEN
                  -- ha habido un error en la package pero no quiere decir que
                  -- sea por los controles de PSU
                  RAISE salir;
               END IF;

               IF NVL(pcreteni, 0) <> 0 THEN
                  -- hay error de controles de PSU, entonces no debe continuar el proceso
                  -- pero no debe salir como si hubiera habido un error
                  -- desde CARTERA_PRODUCTE se controlar¿ este error
                  texto := f_axis_literales(9002255, pidioma);
                  texto := texto || ' POST' || '. (' || vnpoliza || '-' || vncertif || ')';
                  pnnumlin := NULL;
                  num_err := f_proceslin(ppsproces, texto, p_sseguro, pnnumlin, 2);
                  -- En modo previo, si saltan los controles de PSU no se debe
                  -- para el proceso pero s¿ se debe contabilizar como erroneo
                  indice_error := indice_error + 1;
                  num_err := f_set_controles('EST', v_est_sseguro);
                  pac_alctr126.borrar_tablas_est(v_est_sseguro);
                  RETURN 0;
               END IF;
            END IF;
         END IF;
      END IF;

      RETURN num_err;
   EXCEPTION
      WHEN salir THEN
         indice_error := indice_error + 1;
         p_tab_error(f_sysdate, f_user, 'PAC_DINCARTERA.f_genera_psu', vtraza, vparam,
                     f_axis_literales(num_err));
         RETURN num_err;
      WHEN OTHERS THEN
         indice_error := indice_error + 1;
         p_tab_error(f_sysdate, f_user, 'PAC_DINCARTERA.f_genera_psu', vtraza, vparam,
                     SQLERRM);
         RETURN 1000455;
   END f_genera_psu;

   -- Bug 23940 - APD - 18/10/2012 - se crea la funcion
   -- Funci¿n creada para extraer el c¿digo de la generaci¿n de recibos de reaseguro
   -- del procedure p_cartera
   FUNCTION f_genera_recibo_reaseguro(
      p_sseguro IN NUMBER,
      movimiento IN NUMBER,
      p_sproduc IN NUMBER,
      p_fcarpro IN DATE,
      p_fcaranu IN DATE,
      pfemisio IN DATE,
      n_retafrac IN NUMBER,
      ppsproces IN NUMBER,
      pidioma IN NUMBER,
      pmoneda IN NUMBER,
      indice_error IN OUT NUMBER)
      RETURN NUMBER IS
      num_err        NUMBER := 0;
      vtraza         NUMBER;
      texto          VARCHAR2(400);
      pnnumlin       NUMBER;
   BEGIN
      vtraza := 1;

      -- Mantis 11845.12/2009.NMM.CRE - Ajustar reasseguran¿a d'estalvi .i.
      IF pac_cesionesrea.producte_reassegurable(p_sproduc) = 1 THEN
         --      REASEGURO
         -- Bug: 11623 AVT 28-10-2009 control del reaseguro abans de cridar a les funcions
         -- s'haur¿ d'acabar substituint per la crida a PAC_CESIONESREA.PRODUCTE_REASEGURABLE
         /*BEGIN
                                                                                                                                                                                                                                                                                                                                                                                                      SELECT creaseg
              INTO w_creaseg
              FROM productos
             WHERE sproduc = p_sproduc;
         EXCEPTION
            WHEN NO_DATA_FOUND THEN
               error := 104347;
            WHEN OTHERS THEN
               error := 102705;
         END;
         IF w_creaseg = 1 THEN*/
         -- Bug: 11623 AVT 28-10-2009 fi
            -- REASEGURO
            -- Bug 10782 - RSC - 24/07/2009 - CRE - Incid¿ncia Reaseguro Cr¿dit Salut
         IF n_retafrac = 1
            AND(p_fcarpro <> p_fcaranu) THEN   -- Motivo: 821
            num_err := f_buscactrrea(p_sseguro, movimiento, ppsproces, 4, pmoneda);
         ELSE
            -- Fin Bug 10782
            num_err := f_buscactrrea(p_sseguro, movimiento, ppsproces, 5, pmoneda);
         END IF;

         IF num_err <> 0
            AND num_err <> 99 THEN
            indice_error := indice_error + 1;
         ELSIF num_err = 99 THEN   -- Error controlado
            --NULL; Per coher¿ncia amb el P_EMITIR_PROPUESTA.
            num_err := 0;
         ELSE
            -- Bug 10782 - RSC - 24/07/2009 - CRE - Incid¿ncia Reaseguro Cr¿dit Salut
            IF n_retafrac = 1
               AND(p_fcarpro <> p_fcaranu) THEN   -- Motivo: 821
               num_err := f_cessio(ppsproces, 4, pmoneda);
            ELSE
               -- Fin Bug 10782
               num_err := f_cessio(ppsproces, 5, pmoneda);
            END IF;

            IF num_err <> 0
               AND num_err <> 99 THEN
               indice_error := indice_error + 1;
            ELSIF num_err = 99 THEN   -- Falta facultativo
               -- Aturem la cartera si falta facultatiu i gravem l'error que ho indica
               indice_error := indice_error + 1;
               texto := f_axis_literales(105382, pidioma);
               pnnumlin := NULL;
               num_err := f_proceslin(ppsproces, texto, p_sseguro, pnnumlin, 2);

               -- Mantis 10251/10809.#6.01/06/2009.Ini.0010251: CRE - Incidencia Cartera con Facultativo.NMM.
               -- FAL - 10/05/2011 - Bug 0018514: MSGV003 - Modificacions en la retenci¿ per facultatiu
               -- Recupera el riesgo de facpendientes para insertar motivo retencion por riesgo
               FOR reg IN (SELECT DISTINCT (NVL(nriesgo, 1)) nriesgo
                                      FROM facpendientes
                                     WHERE sseguro = p_sseguro
                                       AND nmovimi = movimiento
                                       AND sproces = ppsproces) LOOP
                  num_err := pac_emision_mv.f_retener_poliza(NULL, p_sseguro, reg.nriesgo,

                                                             -- num_risc
                                                             movimiento, 10
                                                                           -- MOTIU RETENCIO ( Pendent quadre facultatiu)
                                                             , 1
                                                                -- CODI RETENCIO
                                                             , pfemisio);
               END LOOP;

               UPDATE seguros
                  SET csituac = 5
                WHERE sseguro = p_sseguro;

               --
               UPDATE movseguro
                  SET femisio = NULL
                WHERE sseguro = p_sseguro
                  AND nmovimi = movimiento;
            -- Mantis 10251/10809.#6.06/2009.Fi.
            END IF;
         END IF;
      END IF;   -- Bug: 11623 AVT Fi del IF...

      RETURN num_err;
   EXCEPTION
      WHEN OTHERS THEN
         indice_error := indice_error + 1;
         p_tab_error(f_sysdate, f_user, 'PAC_DINCARTERA.f_genera_recibo_reaseguro', vtraza,
                     f_axis_literales(1000455), SQLERRM);
         RETURN 1000455;
   END f_genera_recibo_reaseguro;

   -- Bug 23940 - APD - 18/10/2012 - se crea la funcion
   -- Funci¿n creada para extraer el c¿digo de la generaci¿n de recibos
   -- del procedure p_cartera
   FUNCTION f_genera_recibo(
      pmes IN NUMBER,
      panyo IN NUMBER,
      pempresa IN NUMBER,
      p_sseguro IN NUMBER,
      movimiento IN NUMBER,
      p_cagrpro IN NUMBER,
      p_cforpag IN NUMBER,
      fcarpronueva IN DATE,
      fcarantnueva IN DATE,
      fcaranunueva IN DATE,
      nanualinueva IN NUMBER,
      nfraccinueva IN NUMBER,
      p_ccobban IN NUMBER,
      p_ctipreb IN NUMBER,
      p_sproduc IN NUMBER,
      pfemisio IN DATE,
      ppsproces IN NUMBER,
      pidioma IN NUMBER,
      indice_error IN OUT NUMBER)
      RETURN NUMBER IS
      num_err        NUMBER := 0;
      vtraza         NUMBER;
      texto          VARCHAR2(400);
      pnnumlin       NUMBER;
      pcmovimi       NUMBER;
      modcom         NUMBER;
      vfemisio       DATE;
      pnimport2      NUMBER;
   BEGIN
      -- Se utiliza la funci¿n f_recries para calcular el recibo
      -- Se controlan las p¿lizas de ahorro
      IF p_cagrpro = 2 THEN
         pcmovimi := 2;
      -- indica aportaci¿n peri¿dica
      ELSE
         pcmovimi := NULL;
      END IF;

      --BUG 9658 - JTS - 29/05/2009
      num_err := pac_propio.f_graba_com_adq(p_sseguro, movimiento, 'R', NULL);

      IF num_err <> 0 THEN
         indice_error := indice_error + 1;
      ELSE
         -- Bug 19777/95194 - 26/10/2011 -AMC
         IF f_es_renovacion(p_sseguro) = 0 THEN   -- es cartera
            modcom := 2;
         ELSE
            -- si es 1 es nueva produccion
            modcom := 1;
         END IF;

         -- Fi Bug 19777/95194 - 26/10/2011 -AMC
         --Fi BUG 9658 - JTS - 29/05/2009
         -- Si la forma de pago es ¿nica no se genera recibo
         IF p_cforpag <> 0 THEN
            --Llamamos la funci¿n de calcular recibos
            IF NVL(pac_parametros.f_parempresa_n(pempresa, 'FEMISIO_IS_SYSDATE'), 0) = 1 THEN
               vfemisio := f_sysdate;
            ELSE
               vfemisio := TO_DATE('01/' || TO_CHAR(TO_NUMBER(pmes)) || '/' || TO_CHAR(panyo),
                                   'dd/mm/yyyy');
            END IF;

            --BUG9028-XVM-01102009 inici
            IF NVL(pac_parametros.f_parinstalacion_n('CALCULO_RECIBO'), 1) = 0 THEN
               IF (NVL(f_parproductos_v(p_sproduc, 'SEPARA_RIESGO_AHORRO'), 0) = 1
                   AND pac_seguros.f_tiene_garanahorro(NULL, p_sseguro, fcarpronueva) = 1)
                  OR NVL(f_parproductos_v(p_sproduc, 'SEPARA_RIESGO_AHORRO'), 0) = 0 THEN
                  num_err := pac_adm.f_recries(p_ctipreb, p_sseguro, NULL, vfemisio,
                                               fcarantnueva, fcarpronueva, 3, nanualinueva,
                                               nfraccinueva, p_ccobban, NULL, ppsproces, 21,
                                               'R', modcom, fcaranunueva, NULL, pcmovimi,
                                               pempresa, movimiento, 1, pnimport2);
               END IF;
            ELSE
               IF (NVL(f_parproductos_v(p_sproduc, 'SEPARA_RIESGO_AHORRO'), 0) = 1
                   AND pac_seguros.f_tiene_garanahorro(NULL, p_sseguro, fcarpronueva) = 1)
                  OR NVL(f_parproductos_v(p_sproduc, 'SEPARA_RIESGO_AHORRO'), 0) = 0 THEN
                  num_err := f_recries(p_ctipreb, p_sseguro, NULL, vfemisio, fcarantnueva,
                                       fcarpronueva, 3, nanualinueva, nfraccinueva, p_ccobban,
                                       NULL, ppsproces, 21, 'R', modcom, fcaranunueva, NULL,
                                       pcmovimi, pempresa, movimiento, 1, pnimport2);
               END IF;
            END IF;

            --Bug 23940 - APD - 31/10/2012
            IF num_err <> 0 THEN
               indice_error := indice_error + 1;
            ELSE
               num_err := pac_dincartera.f_set_recibos_col(ppsproces, p_sseguro, fcarantnueva);

               -- fin Bug 23940 - APD - 04/11/2012
                  --BUG9028-XVM-01102009 fi
               IF num_err <> 0 THEN
                  indice_error := indice_error + 1;
               ELSE
                  -- Bug 19096 - RSC - 03/08/2011 - LCOL - Parametrizaci¿n b¿sica producto Vida Individual Pagos Permanentes (Afegim 'RRIE')
                  IF NVL(f_parproductos_v(p_sproduc, 'SEPARA_RIESGO_AHORRO'), 0) = 1 THEN
                     IF NVL(pac_parametros.f_parinstalacion_n('CALCULO_RECIBO'), 1) = 0 THEN
                        num_err := pac_adm.f_recries(p_ctipreb, p_sseguro, NULL, vfemisio,
                                                     fcarantnueva, fcarpronueva, 3,
                                                     nanualinueva, nfraccinueva, p_ccobban,
                                                     NULL, ppsproces, 21, 'RRIE', modcom,
                                                     fcaranunueva, NULL, pcmovimi, pempresa,
                                                     movimiento, 1, pnimport2);
                     ELSE
                        num_err := f_recries(p_ctipreb, p_sseguro, NULL, vfemisio,
                                             fcarantnueva, fcarpronueva, 3, nanualinueva,
                                             nfraccinueva, p_ccobban, NULL, ppsproces, 21,
                                             'RRIE', modcom, fcaranunueva, NULL, pcmovimi,
                                             pempresa, movimiento, 1, pnimport2);
                     END IF;
                  END IF;

                  --Bug 23940 - APD - 31/10/2012
                  IF num_err <> 0 THEN
                     indice_error := indice_error + 1;
                  ELSE
                     num_err := pac_dincartera.f_set_recibos_col(ppsproces, p_sseguro,
                                                                 fcarantnueva);

                     --fin Bug 23940 - APD - 31/10/2012
                     IF num_err <> 0 THEN
                        indice_error := indice_error + 1;
                     ELSE
                        -- Fin Bug 19096

                        -- si todo ha ido bien y hay que grabar provision
                        num_err := pac_provmat_formul.f_ins_garansegprovmat(p_sseguro);

                        IF num_err <> 0 THEN
                           indice_error := indice_error + 1;
                        END IF;

                        -- ini Bug 0022701 - 03/09/2012 - JMF
                        IF pac_retorno.f_tiene_retorno(NULL, p_sseguro, NULL) = 1 THEN
                           num_err := pac_retorno.f_generar_retorno(p_sseguro, movimiento,
                                                                    NULL, ppsproces);

                           IF num_err <> 0 THEN
                              indice_error := indice_error + 1;
                              pnnumlin := NULL;
                              texto := 'pac_retorno:' || f_axis_literales(num_err, pidioma);
                              num_err := f_proceslin(ppsproces, texto, p_sseguro, pnnumlin);
                              num_err := 0;
                           -- ini bug 0026261 - 06/05/2013 - JMC
                           ELSE
                              num_err := pac_dincartera.f_set_recibos_col(ppsproces,
                                                                          p_sseguro,
                                                                          fcarantnueva);

                              IF num_err <> 0 THEN
                                 indice_error := indice_error + 1;
                              END IF;
                           -- fin    bug 0026261 - 06/05/2013 - JMC
                           END IF;
                        END IF;

                        -- fin Bug 0022701 - 03/09/2012 - JMF

                        --Bug.: 20923 - 14/01/2012 - ICV
                        --Si todo OK env¿amos Todos recibos del movimiento al ERP.
                        IF NVL(pac_parametros.f_parempresa_n(pempresa, 'GESTIONA_COBPAG'), 0) =
                                                                                              1
                           AND num_err = 0 THEN
                           num_err := pac_ctrl_env_recibos.f_proc_recpag_mov(pempresa,
                                                                             p_sseguro,
                                                                             movimiento, 4,
                                                                             ppsproces);
                        /* IF num_err <> 0 THEN
                            algun_error := 1;
                            indice_error := indice_error + 1;
                         END IF;*/ --No se devuelve el error ya que el movimiento se ha de enviar
                        END IF;
                     --Fin Bug.: 20923
                     END IF;
                  END IF;   --Bug 23940 - APD - 31/10/2012
               END IF;
            END IF;   --Bug 23940 - APD - 31/10/2012
         END IF;
      END IF;

      RETURN num_err;
   EXCEPTION
      WHEN OTHERS THEN
         indice_error := indice_error + 1;
         p_tab_error(f_sysdate, f_user, 'PAC_DINCARTERA.f_genera_recibo', vtraza,
                     f_axis_literales(1000455), SQLERRM);
         RETURN 1000455;
   END f_genera_recibo;

------------------------------------------------------------------------------------
   FUNCTION p_cartera_psu(
      pmoneda IN NUMBER,
      pidioma IN NUMBER,
      pmes IN NUMBER,
      panyo IN NUMBER,
      p_sseguro IN NUMBER,
      p_cramo IN NUMBER,
      p_cmodali IN NUMBER,
      p_ctipseg IN NUMBER,
      p_ccolect IN NUMBER,
      p_ctarman IN NUMBER,
      p_ccobban IN NUMBER,
      p_nrenova IN NUMBER,
      p_ctipreb IN NUMBER,
      p_cforpag IN NUMBER,
      p_nduraci IN NUMBER,
      p_ndurcob IN NUMBER,
      p_cactivi IN OUT NUMBER,
      p_csubpro IN NUMBER,
      p_cobjase IN NUMBER,
      p_cagrpro IN NUMBER,
      p_fefecto IN DATE,
      p_fvencim IN DATE,
      p_fcarpro IN OUT DATE,
      p_fcaranu IN OUT DATE,
      p_nanuali IN OUT NUMBER,
      p_nfracci IN OUT NUMBER,
      p_fcarant IN OUT DATE,
      ppsproces IN NUMBER,
      indice IN OUT NUMBER,
      indice_error IN OUT NUMBER,
      pfemisio IN DATE,
      pcorrecte OUT NUMBER,
      p_sproduc IN NUMBER,
      p_nsuplem IN NUMBER,
      pcgarant_regu IN NUMBER,
      pnorden IN NUMBER,
      pcprimin IN NUMBER,
      piprimin IN NUMBER,
      pcclapri IN NUMBER,
      pnedamar IN NUMBER,
      pciedmar IN NUMBER,
      pempresa IN NUMBER,
      p_csituac IN NUMBER,
      pcreteni OUT NUMBER)   -- Bug 23940 - APD - 17/10/2012
      RETURN NUMBER IS
      -- A¿adimos los parametros pempresa y p_csituac.
      -- La empresa es para cuestiones de recibos.El csituac para los
      -- casos en que es propuesta de suplemento.
      vfemisio       DATE;
      encontrado     NUMBER := 0;
      codi_ramo      NUMBER;
      mes_conta      DATE;
      algun_error    NUMBER := 0;
      num_err        NUMBER := 0;
      prevcap        NUMBER(13, 2);
      texto          VARCHAR2(400);
      piprima        NUMBER(13, 2);
      psperson       NUMBER(6);
      conta_proces   NUMBER;
      error          NUMBER;
      fcarproant   seguros.fcarpro%TYPE := NULL;
      frenovaant   seguros.frenova%TYPE := NULL;
      fcarpronueva   seguros.fcarpro%TYPE := NULL;
--       fcarpronueva   DATE := NULL; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      fcarantnueva   seguros.fcarant%TYPE := NULL;
--       fcarantnueva   DATE := NULL; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      fcaranunueva   seguros.fcaranu%TYPE := NULL;
--       fcaranunueva   DATE := NULL; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      nanualinueva   seguros.nanuali%TYPE := NULL;
--       nanualinueva   NUMBER := NULL; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      nfraccinueva   seguros.nfracci%TYPE;
      --       nfraccinueva   NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      pnrecibo       extrarec.nrecibo%TYPE;
      --       pnrecibo       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      tipo           codiram.cgtarif%TYPE;
      --       tipo           NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      frenovanueva   seguros.frenova%TYPE := NULL;
      fec            VARCHAR2(20);
      texto2         VARCHAR2(60);
      num            NUMBER;
      ttexto         VARCHAR2(30);
      piregula       NUMBER;
      ptempresa      VARCHAR2(70);
      pnnumlin       NUMBER;
      num_risc       NUMBER;
      pnimport2      NUMBER;
      pcmovimi       NUMBER;
      pnmovimi2      NUMBER;
      movimiento     NUMBER;
      anulado        NUMBER := 0;
      -- Bug 23940 - APD - 25/10/2012
      fecha_carpro   empresas.fcarpro%TYPE;
      --       fecha_carpro   DATE; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      fecha_carant   empresas.fcarant%TYPE;
      --       fecha_carant   DATE; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      dia            VARCHAR2(4);
      fechini        DATE;
      primaant       NUMBER;
      pfech          DATE;
      prima          seguros.iprianu%TYPE;
      --       prima          NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      modcom         NUMBER;
      fultrenova     DATE;
      nmovimi        NUMBER;
      parms_transitorios pac_parm_tarifas.parms_transitorios_tabtyb;
      lbonifica      NUMBER;
      laplica_bonifica NUMBER;
      lcumple        NUMBER;
      num_lin        NUMBER;
      lcactivi       NUMBER;
      v_cont         NUMBER;
      v_pinttec      tmp_garancar.nparben%TYPE;
--       v_pinttec      NUMBER(9, 6); --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      -- BUG 0005557 - 29-01-09 - jmf - 0005557: CRE - Suplementos autom¿ticos
      n_retafrac     NUMBER(1);
      v_cursor       NUMBER;
      ss             VARCHAR2(3000);
      funcion        VARCHAR2(40);
      v_filas        NUMBER;
      w_creaseg      NUMBER;   -- bug:11623 AVT 28-10-2009
      vfcaranu       seguros.fcaranu%TYPE;
--       vfcaranu       DATE;   -- bug 0011604 FAL 25-02-2010 --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      v_frevisio     seguros_aho.frevisio%TYPE;
      --       v_frevisio     DATE; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      v_crealiza     cfg_accion.crealiza%TYPE;
      -- Bug 19096 - RSC - 03/08/2011 - LCOL - Parametrizaci¿n b¿sica producto Vida Individual Pagos Permanentes (Afegim 'RRIE')
      v_recibo_ahorro recibos.nrecibo%TYPE;
      v_recibo_riesgo recibos.nrecibo%TYPE;
      v_listarec     t_lista_id;
      v_obrec        ob_lista_id;
      v_cmotmov      NUMBER := 404;
      -- Fin Bug 19096

      -- Bug 23428 - RSC - 07/09/2012 - EMISI¿N ¿ CARTERA - COBRO VENCIDO / ANTICIPADO
      v_ctipcob      seguroscol.ctipcob%TYPE;
      --       v_ctipcob      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      v_fcartera     DATE;
      -- FIn bug 23428
      v_existe_mov_cartera NUMBER := 0;
      -- Bug 23940 - APD - 09/11/2012
      v_cbloqueocol  seguros.cbloqueocol%TYPE;
                                              -- Bug 23940 - APD - 31/12/2012
      -- BUG 0005557 - 29-01-09 - jmf - 0005557: CRE - Suplementos autom¿ticos
      v_mes_actual   NUMBER;
      v_mes_anteri   NUMBER;

      CURSOR c_motextra IS
         SELECT DISTINCT (sseguro) sseguro
                    FROM extrarec
                   WHERE nrecibo IS NULL
                     AND ADD_MONTHS(falta, f_parinstalacion_n('CEXTRNMES')) <= f_sysdate;
   BEGIN
      pcorrecte := 0;
      vfemisio := pfemisio;
      conta_proces := ppsproces;

p_control_error ('JRB', 'sri', 'cartera psu');

/*
      fcarantnueva := NULL;
      fcarpronueva := NULL;
      fcaranunueva := NULL;
      nanualinueva := NULL;
      nfraccinueva := NULL;
*/
      IF p_fcarpro IS NOT NULL THEN
         indice := indice + 1;
         algun_error := 0;
         num_err := 0;

         -- Bug 23428 - RSC - 07/09/2012 - EMISI¿N ¿ CARTERA - COBRO VENCIDO / ANTICIPADO
         BEGIN
            SELECT ctipcob
              INTO v_ctipcob
              FROM seguroscol
             WHERE sseguro = p_sseguro;
         EXCEPTION
            WHEN NO_DATA_FOUND THEN
               v_ctipcob := 2;
            WHEN OTHERS THEN
               v_ctipcob := 2;
         END;

        begin
        select fcarpro, frenova
        into fcarproant, frenovaant
        from seguros where sseguro = p_sseguro;
        exception when others then
        fcarproant := p_fcarpro;
        end;

         SELECT DECODE(v_ctipcob,
                       1, ADD_MONTHS((LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo, 'mmyyyy'))
                                      + 1),
                                     -1),
                       (LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo, 'mmyyyy')) + 1))
           INTO v_fcartera
           FROM DUAL;

         v_mes_actual := TO_NUMBER(TO_CHAR(p_fcarpro, 'MM'));
         v_mes_anteri := -1;

         -- Fin Bug 23428
         WHILE(p_fcarpro < v_fcartera
               AND algun_error = 0
               AND(p_fcarpro < p_fvencim
                   OR p_fvencim IS NULL)) LOOP
            v_mes_actual := TO_NUMBER(TO_CHAR(p_fcarpro, 'MM'));

            IF v_mes_actual = v_mes_anteri THEN
               EXIT;
            END IF;

            -- Bug 29991/168276
            --si se est¿ realizando la renovacion
            -- de un certificado X que pertenece a un colectivo agrupado, su fcarpro
            -- no puede ser superior a la fcarpro de su certificado 0
            IF NVL(f_parproductos_v(p_sproduc, 'ADMITE_CERTIFICADOS'), 0) = 1
               AND pac_seguros.f_es_col_agrup(p_sseguro, 'POL') = 1
               AND pac_seguros.f_get_escertifcero(NULL, p_sseguro) <> 1 THEN
               NULL;

               SELECT COUNT(1)
                 INTO v_cont
                 FROM seguros s
                WHERE s.npoliza = (SELECT s2.npoliza
                                     FROM seguros s2
                                    WHERE s2.sseguro = p_sseguro)
                  AND s.ncertif = 0
                  AND p_fcarpro < s.fcarpro;

               -- si la p_fcarpro no es inferior a la fcarpro del certificado 0, no
               -- se puede pasar cartera del certificado X
               IF v_cont = 0 THEN
                  EXIT;
               END IF;
            END IF;

            -- fin Bug 29991/168276
            fcarantnueva := NULL;
            fcarpronueva := NULL;
            fcaranunueva := NULL;
            nanualinueva := NULL;
            nfraccinueva := NULL;
            n_retafrac := NULL;
            frenovanueva := NULL;

            -- Bug 23940 - APD - 31/12/2012 - si la poliza est¿ bloqueada en renovacion no permitir renovar
            IF (p_fcarpro = p_fcaranu
                AND p_csituac <> 5
                AND n_retafrac IS NULL)
               OR(n_retafrac = 1) THEN
               SELECT cbloqueocol
                 INTO v_cbloqueocol
                 FROM seguros
                WHERE sseguro = p_sseguro;

               IF v_cbloqueocol = 2 THEN
                  indice_error := indice_error + 1;
                  RETURN 152212;   -- Poliza bloqueada.
                  p_control_error ('JRB', 'sri', 'return 1');
               END IF;
            END IF;

            -- fin Bug 23940 - APD - 31/12/2012

            -- Bug 23940 - APD - 18/10/2012 - se crea la funcion f_genera_suplementos
            -- para pasar c¿digo de p_cartera a dicha funcion
            num_err := pac_dincartera.f_genera_suplementos(p_sseguro, p_fcarpro, ppsproces,
                                                           indice_error);

            IF num_err <> 0 THEN
               algun_error := 1;
               -- Volvemos porque ha fallado el suplemento
               RETURN num_err;
               p_control_error ('JRB', 'sri', 'return 2');
            END IF;

            -- fin Bug 23940 - APD - 18/10/2012
            -- Bug 23940 - APD - 18/10/2012 -- se validan las PSU PRE de Cartera
/*
            num_err := pac_dincartera.f_genera_psu('R', 3, p_sseguro, p_fcarpro, ppsproces,
                                                   pidioma, indice, indice_error, pcreteni);

            IF num_err <> 0
               OR(num_err = 0
                  AND NVL(pcreteni, 0) <> 0) THEN
               -- Volvemos porque ha fallado la PSU o porque hay error de controles de PSU
               RETURN num_err;
            END IF;
*/
            -- fin Bug 23940 - APD - 18/10/2012

            -- BUG15823:DRA:27/10/2010:Fi
            IF NVL(f_parproductos_v(p_sproduc, 'FRACCIONARIO'), 0) = 1 THEN
               SELECT MAX(tvalpar)
                 INTO funcion
                 FROM detparpro
                WHERE cparpro = 'F_PRFRACCIONARIAS'
                  AND cidioma = 2
                  AND cvalpar = (SELECT cvalpar
                                   FROM parproductos
                                  WHERE sproduc = p_sproduc
                                    AND cparpro = 'F_PRFRACCIONARIAS');

               IF funcion IS NOT NULL THEN
                  ss := 'begin :n_retafrac := ' || funcion || '; end;';

                  IF DBMS_SQL.is_open(v_cursor) THEN
                     DBMS_SQL.close_cursor(v_cursor);
                  END IF;

                  v_cursor := DBMS_SQL.open_cursor;
                  DBMS_SQL.parse(v_cursor, ss, DBMS_SQL.native);

                  IF INSTR(ss, ':psseguro') > 0 THEN
                     DBMS_SQL.bind_variable(v_cursor, ':psseguro', p_sseguro);
                  END IF;

                  IF INSTR(ss, ':pfecha') > 0 THEN
                     DBMS_SQL.bind_variable(v_cursor, ':pfecha', p_fcarpro);
                  END IF;

                  IF INSTR(ss, ':n_retafrac') > 0 THEN
                     DBMS_SQL.bind_variable(v_cursor, ':n_retafrac', num_err);
                  END IF;

                  v_filas := DBMS_SQL.EXECUTE(v_cursor);
                  DBMS_SQL.variable_value(v_cursor, 'n_retafrac', n_retafrac);

                  IF DBMS_SQL.is_open(v_cursor) THEN
                     DBMS_SQL.close_cursor(v_cursor);
                  END IF;
               END IF;
            END IF;

            -- BUG 0005557 - 29-01-09 - jmf - FIN 0005557: CRE - Suplementos autom¿ticos
            IF algun_error = 0 THEN
               -- A¿adimos a la condici¿n que no este en Prop. de suplemento.
               -- BUG 0005557 - 29-01-09 - jmf - FIN 0005557: CRE - Suplementos autom¿ticos
               IF (p_fcarpro = p_fcaranu
                   AND p_csituac <> 5
                   AND n_retafrac IS NULL)
                  OR(n_retafrac = 1) THEN
                  -- Bug 27048/155371 - APD - 17/12/2013 - se cambia de posicion la validacion
                  -- de la PSU ya que de momento solo se ejecutaran las PSU en Cartera de Renovacion
                  -- Bug 23940 - APD - 18/10/2012 -- se validan las PSU PRE de Cartera
                  num_err := pac_dincartera.f_genera_psu('R', 3, p_sseguro, p_fcarpro,
                                                         ppsproces, pidioma, indice,
                                                         indice_error, pcreteni);

                  IF num_err <> 0
                     OR(num_err = 0
                        AND NVL(pcreteni, 0) <> 0) THEN
                     -- Volvemos porque ha fallado la PSU o porque hay error de controles de PSU
                     algun_error := 1;
                  END IF;

                  -- fin Bug 23940 - APD - 18/10/2012
                  -- fin Bug 27048/155371 - APD - 17/12/2013
                  IF algun_error = 0 THEN   -- Bug 27048/155371 - APD - 17/12/2013
                     -- Bug 23940 - APD - 08/11/2012 - si ya existe el movimiento
                     -- de CARTERA no volver a crearlo. Esto pasar¿ cuando se haya
                     -- detenido la renovacion (el proceso de CARTERA) porque ha
                     -- saltado una PSU POST
                     SELECT COUNT(1)
                       INTO v_existe_mov_cartera
                       FROM movseguro
                      WHERE sseguro = p_sseguro
                        AND cmotmov IN(404, 407, 821, 406)
                        --Mantis 34469/0205354 - BLA - DD25/MM05/2015 :add 406
                        AND fefecto = p_fcarpro
                        AND cmovseg NOT IN(6, 52);

                     -- movimiento no anulado (v.f. 16)

                     -- Bug 29665/177284 - 12/06/2014 - AMC

                     -- Bug 23940 - APD - 09/11/2012 - si no existe el movimiento de
                     -- cartera, realizar todo lo que se debe hacer en la cartera
                     IF v_existe_mov_cartera = 0 THEN
                        --
                        num_err := pac_cambiocartera.cambiocartera('R', p_sproduc, p_cactivi,
                                                                   p_sseguro, p_cramo,
                                                                   p_cmodali, p_ctipseg,
                                                                   p_ccolect, p_fcaranu,
                                                                   p_nsuplem, lcumple,
                                                                   lcactivi);

                        IF lcumple = 1
                           AND num_err = 0 THEN
                           p_cactivi := lcactivi;
                           texto := f_axis_literales(110406, pidioma);
                           texto := texto || '.' || p_sseguro;
                           num_lin := NULL;
                           num_err := f_proceslin(ppsproces, texto, p_sseguro, num_lin);

                           IF num_err = 0 THEN
                              COMMIT;
                           END IF;
                        ------
                        END IF;

                        IF num_err = 0 THEN
                           -- La p¿lissa renova , cal comprovar si te bonificaci¿
                           -- per no sinistralitat
                           num_err := pac_bonifica.f_bonifica_poliza(p_cramo, p_cmodali,
                                                                     p_ctipseg, p_ccolect,
                                                                     p_sseguro, p_fcaranu,
                                                                     p_fefecto, lbonifica,
                                                                     laplica_bonifica);
                        END IF;

                        IF num_err = 0 THEN
                           -- BUG 16903 - 09/12/2010 - JMP - No renovamos si fecha de revisi¿n anterior a la de renovaci¿n.
                           BEGIN
                              SELECT frevisio
                                INTO v_frevisio
                                FROM seguros_aho
                               WHERE sseguro = p_sseguro;

                              num_err :=
                                 pac_cfg.f_get_user_accion_permitida(f_user,
                                                                     'CARTERA_NO_REVISA',
                                                                     p_sproduc, pempresa,
                                                                     v_crealiza);

                              IF num_err <> 1 THEN
                                 IF v_frevisio < p_fcaranu THEN
                                    num_err := 9901723;
                                 -- La fecha de revisi¿n es anterior a la renovaci¿n de la p¿liza
                                 ELSE
                                    num_err := 0;
                                 END IF;
                              ELSE
                                 num_err := 0;
                              END IF;
                           EXCEPTION
                              WHEN NO_DATA_FOUND THEN
                                 NULL;
                           END;
                        END IF;

                        IF num_err <> 0 THEN
                           algun_error := 1;
                           indice_error := indice_error + 1;
                        ELSE
                           -- Se comprueba si el seguro tiene regularizacion y
                           -- si es as¿ se calcula el importe de regularizaci¿n y se genera
                           -- el recibo de extorno
                           -- La prima anterior se calcula con la funci¿n
                           -- f_recprima, no es el iprianu de seguros
                           dia := SUBSTR(LPAD(p_nrenova, 4, '0'), 3, 2);
                           --   fechini := f_summeses(p_fcaranu, -12, dia);
                           num_err := f_ultrenova(p_sseguro, p_fcaranu, fultrenova, nmovimi);

                           IF num_err <> 0 THEN
                              algun_error := 1;
                              indice_error := indice_error + 1;
                           ELSE
                              primaant := f_recprima(p_sseguro, fultrenova, p_fcaranu);
                              num_err := f_regulariza(p_sseguro, primaant, fultrenova,
                                                      p_fcaranu, ppsproces, vfemisio,
                                                      piregula);

                              IF num_err <> 0
                                 AND num_err <> 1000 THEN
                                 algun_error := 1;
                                 indice_error := indice_error + 1;
                              ELSE
                                 num_err := 0;

                                 BEGIN
                                    SELECT cgtarif
                                      INTO tipo
                                      FROM codiram
                                     WHERE cramo = p_cramo;
                                 EXCEPTION
                                    WHEN NO_DATA_FOUND THEN
                                       num_err := 101904;
                                       algun_error := 1;
                                       indice_error := indice_error + 1;
                                    WHEN OTHERS THEN
                                       num_err := 104793;
                                       algun_error := 1;
                                       indice_error := indice_error + 1;
                                 END;

                                 IF num_err = 0 THEN
                                    -- Se busca el par¿metro num_risc
                                    BEGIN
                                       SELECT COUNT(*)
                                         INTO num_risc
                                         FROM riesgos
                                        WHERE sperson IS NOT NULL
                                          AND sseguro = p_sseguro;
                                    EXCEPTION
                                       WHEN OTHERS THEN
                                          num_risc := 0;
                                    END;

                                    -- Selecci¿n que nos permite saber si se tarifa por
                                    -- el m¿todo tradicional o por sgt.

                                    --0031786:NSS:09/10/2014 Eliminar la tabla SGT_PRODUCTOS. Es una tabla obsoleta que no tiene sentido mantener.
                                    /*
                                    SELECT COUNT(cramo)
                                      INTO encontrado
                                      FROM sgt_productos
                                     WHERE cramo = p_cramo
                                       AND cmodali = p_cmodali
                                       AND ctipseg = p_ctipseg
                                       AND ccolect = p_ccolect;
                                    */

                                    --Llamamos a la funci¿n f_garantarifa que nos calcula la tarifa
-----------------------------------------------------------
                                    --IF encontrado = 1 THEN
                                    IF NVL(f_parproductos_v(p_sproduc, 'DETALLE_GARANT'), 0) IN
                                                                                         (1, 2) THEN
                                       num_err :=
                                          pac_dincartera.f_garantarifa_sgt_det
                                                                          ('R', p_sseguro,
                                                                           p_cramo, p_cmodali,
                                                                           p_cobjase,
                                                                           p_ctipseg,
                                                                           p_ccolect, tipo,
                                                                           p_nduraci,
                                                                           conta_proces,
                                                                           p_ndurcob,
                                                                           p_fcarpro, pmes,
                                                                           panyo, tipo,
                                                                           p_cagrpro,
                                                                           p_ctarman,
                                                                           p_cactivi,
                                                                           num_risc, vfemisio,
                                                                           p_fefecto,
                                                                           movimiento,
                                                                           anulado, pmoneda,
                                                                           parms_transitorios,
                                                                           lbonifica,
                                                                           laplica_bonifica,
                                                                           p_sproduc,
                                                                           p_cforpag, pidioma,
                                                                           pcgarant_regu,
                                                                           pnorden, pcprimin,
                                                                           piprimin, pcclapri,
                                                                           pnedamar, pciedmar,
                                                                           p_fcaranu);
                                    ELSE
                                       num_err :=
                                          pac_dincartera.f_garantarifa_sgt
                                                                          ('R', p_sseguro,
                                                                           p_cramo, p_cmodali,
                                                                           p_cobjase,
                                                                           p_ctipseg,
                                                                           p_ccolect, tipo,
                                                                           p_nduraci,
                                                                           conta_proces,
                                                                           p_ndurcob,
                                                                           p_fcarpro, pmes,
                                                                           panyo, tipo,
                                                                           p_cagrpro,
                                                                           p_ctarman,
                                                                           p_cactivi,
                                                                           num_risc, vfemisio,
                                                                           p_fefecto,
                                                                           movimiento,
                                                                           anulado, pmoneda,
                                                                           parms_transitorios,
                                                                           lbonifica,
                                                                           laplica_bonifica,
                                                                           p_sproduc,
                                                                           p_cforpag, pidioma,
                                                                           pcgarant_regu,
                                                                           pnorden, pcprimin,
                                                                           piprimin, pcclapri,
                                                                           pnedamar, pciedmar,
                                                                           p_fcaranu);
                                    --END IF;
                                    END IF;
                                 -- Despues de la funcion, podemos haber anulado el seguro o
                                 -- algun riesgo, y por lo tanto haber hecho ya el movimiento de
                                 -- seguro
                                 END IF;

                                 IF num_err = 0 THEN
                                    IF anulado = 0 THEN   -- si el seguro no se ha anulado
                                       IF movimiento IS NULL THEN   -- si no se han anulado riesgos
                                          -- Se hace un movimiento de seguro de cartera
                                          -- Llamamos la funci¿n f_movseguro----
                                          -- Se pasa pcimpres = null para coger
                                          -- el estado de impresion del ultimo movimiento

                                          -- BUG 0005557 - 29-01-09 - jmf - INI 0005557: CRE - Suplementos autom¿ticos
                                          IF n_retafrac = 1
                                             AND(p_fcarpro <> p_fcaranu) THEN
                                             num_err :=
                                                f_movseguro(p_sseguro, NULL, 821, 2,
                                                            p_fcarpro, NULL, NULL, NULL,
                                                            mes_conta, movimiento, vfemisio);
                                          -- BUG 0005557 - 29-01-09 - jmf - FIN 0005557: CRE - Suplementos autom¿ticos
                                          ELSE
                                             v_cmotmov :=
                                                f_renovacion_anual(p_sseguro, p_fcaranu,
                                                                   p_sproduc);
                                             num_err :=
                                                f_movseguro(p_sseguro, NULL, v_cmotmov, 2,
                                                            p_fcarpro, NULL, NULL, NULL,
                                                            mes_conta, movimiento, vfemisio);
                                          END IF;

                                          IF num_err = 0 THEN
                                             -- Se llama a f_act_hisseg para guardar la
                                             -- situaci¿n anterior al suplemento.
                                             -- El nmovimi es el anterior al del suplemento,
                                             -- por eso se le resta uno al reci¿n creado.
                                             num_err :=
                                                       f_act_hisseg(p_sseguro, movimiento - 1);

                                             -- Si el parproducto 'RENOVA_REVISA' del producto = 0 - Revisa en cartera,
                                             -- se renueva el inter¿s t¿cnico en el proceso de cartera, sino se renueva
                                             -- en el proceso de renovaci¿n-revisi¿n
                                             IF NVL(f_parproductos_v(p_sproduc,
                                                                     'RENOVA_REVISA'),
                                                    0) = 0 THEN
                                                -- Se graba el inter¿s t¿cnico adicional del nuevo periodo
                                                IF num_err = 0 THEN
                                                   /*BEGIN
                                                                                                                                                                                                                                                                                                                                                                                                                                                SELECT COUNT (*)
                                                        INTO v_cont
                                                        FROM intertecprod
                                                       WHERE sproduc = p_sproduc;
                                                   EXCEPTION
                                                      WHEN OTHERS
                                                      THEN
                                                         num_err := 104742;
                                                   END;*/

                                                   --IF num_err <> 0 AND v_cont > 0
                                                   --THEN

                                                   -- Tarea 2674: Intereses para LRC.A¿adimos ndesde y nhasta. Hemos de poner todos los tramos (periodo-anualidad) para la p¿liza.
                                                   --Esta funci¿n nos informar¿ el inter¿s que toca en INTERTECSEG, y en el caso de LRC, los intereses de cada una de las anualidades que tocan.
                                                   num_err :=
                                                      pac_prod_comu.f_grabar_inttec
                                                                                   (p_sproduc,
                                                                                    p_sseguro,
                                                                                    p_fcarpro,
                                                                                    2, NULL,
                                                                                    'SEG');

                                                   IF num_err <> 0 THEN
                                                      RETURN num_err;
                                                      p_control_error ('JRB', 'sri', 'return 3');
                                                   END IF;
                                                -- Tarea 2674: Comentamos lo anterior
                                                /*num_err :=
                                                                                                                                                                                                                                                                                                                                                                                                                                    pac_inttec.f_int_seguro_alta_renova
                                                    ('SEG',
                                                   p_sseguro,
                                                  2,
                                                  p_fcarpro,
                                                  v_pinttec
                                                  );
                                                  IF num_err <> 0
                                                  THEN
                                                     RETURN num_err;
                                                  END IF;
                                                  num_err :=
                                                     Pk_Nueva_Produccion.f_ins_intertecseg
                                                                       ('SEG',
                                                                       p_sseguro,
                                                                       movimiento,
                                                                       p_fcarpro,
                                                       v_pinttec
                                                                      );*/
                                                --END IF;
                                                END IF;
                                             END IF;
                                          END IF;
                                       END IF;

                                       IF num_err <> 0 THEN
                                          algun_error := 1;
                                          indice_error := indice_error + 1;
                                       ELSE
                                          -- Ya no se compara, se graban todos
                                          --los registros de garancar en garanseg con nmovimi = pnmovimi
                                          ---Llamamos la funci¿n f_traspasgar que nos traspasa las
                                          --garant¿as de garancar a garanseg
                                          num_err :=
                                             pac_dincartera.f_traspasgar(conta_proces,
                                                                         p_sseguro, p_fcarpro,
                                                                         movimiento);

                                          IF num_err <> 0 THEN
                                             algun_error := 1;
                                             indice_error := indice_error + 1;
                                          END IF;
----------------------
-- Bug 23940 - APD - 09/11/2012
-- Se pasa m¿s abajo el c¿digo que hab¿a aqu¿
-- el cual realiza modifica las fechas de cartera
-- en la tabla seguros y genera los recibos.
-- Esto se hace por si ha saltado alguna
-- PSU POST poder volver a pasar la cartera
-- desde el punto donde salt¿ la PSU.
----------------------
                                       END IF;
                                    END IF;
                                 ELSE
                                    algun_error := 1;
                                    indice_error := indice_error + 1;
                                 END IF;
                              END IF;
                           END IF;
                        END IF;
                     END IF;   -- fin Bug 23940 - APD - 09/11/2012
                  END IF;   -- fin Bug 27048/155371 - APD - 17/12/2013

----------------------
-- Bug 23940 - APD - 09/11/2012
-- Se ha pasado aqu¿ el c¿digo por si ha habido PSU POST
                  IF algun_error = 0 THEN
                     -- Bug 23940 - APD - 09/11/2012 - si ya existia el movimiento
                     -- de cartera, se debe buscar cual es
                     IF v_existe_mov_cartera <> 0 THEN
                        SELECT MAX(nmovimi)
                          INTO movimiento
                          FROM movseguro
                         WHERE sseguro = p_sseguro
                           AND cmotmov IN(404, 407, 821, 406)
                           --Mantis 34469/0205354 - BLA - DD25/MM05/2015 :add 406
                           AND fefecto = p_fcarpro
                           AND cmovseg NOT IN(6, 52);
                                            -- movimiento no anulado (v.f. 16)
                     -- Bug 29665/177284 - 12/06/2014 - AMC
                     END IF;

                     -- Bug 23940 - APD - 18/10/2012 -- se validan las PSU POST de Cartera
                     num_err := pac_dincartera.f_genera_psu('R', 4, p_sseguro, p_fcarpro,
                                                            ppsproces, pidioma, indice,
                                                            indice_error, pcreteni);

                     IF num_err <> 0
                        OR(num_err = 0
                           AND NVL(pcreteni, 0) <> 0) THEN
                        -- Volvemos porque ha fallado la PSU o porque hay error de controles de PSU
                        --RETURN num_err;
                        algun_error := 1;
                     END IF;

                     -- fin Bug 23940 - APD - 18/10/2012
                     IF algun_error = 0 THEN
                        ----Ya est¿n todas las garant¿as de GARANSEG y GARANCOLEC tarificadas---
                        ----Llamamos la funci¿n que actualiza datos de la pr¿xima cartera-----
                        num_err := f_acproxcar(p_sseguro, fcarantnueva, fcarpronueva,
                                               fcaranunueva, nanualinueva, nfraccinueva,
                                               frenovanueva);

                        IF num_err <> 0 THEN
                           algun_error := 1;
                           indice_error := indice_error + 1;
                        ELSE
                           -- Calculamos la nueva iprianu de SEGUROS
                           -- Se calcula la prima a fecha de la renovaci¿n (fcarantnueva)
                           prima := f_segprima(p_sseguro, fcarantnueva);

                           BEGIN
                              UPDATE seguros
                                 SET fcarant = fcarantnueva,
                                     fcarpro = fcarpronueva,
                                     fcaranu = fcaranunueva,
                                     nanuali = nanualinueva,
                                     nfracci = nfraccinueva,
                                     iprianu = prima,
                                     frenova = frenovanueva
                               WHERE sseguro = p_sseguro;
                           EXCEPTION
                              WHEN OTHERS THEN
                                 num_err := 102361;
                                 algun_error := 1;
                                 indice_error := indice_error + 1;
                           END;
                        END IF;
                     END IF;

                     -- Bug 23940 - APD - 18/10/2012 - se crea la funcion f_genera_recibo_reaseguro
                       -- para pasar c¿digo de p_cartera a dicha funcion
                     IF algun_error = 0 THEN
                        num_err := pac_dincartera.f_genera_recibo_reaseguro(p_sseguro,
                                                                            movimiento,
                                                                            p_sproduc,
                                                                            p_fcarpro,
                                                                            p_fcaranu,
                                                                            pfemisio,
                                                                            n_retafrac,
                                                                            ppsproces,
                                                                            pidioma, pmoneda,
                                                                            indice_error);

                        IF num_err <> 0 THEN
                           algun_error := 1;
                        END IF;
                     END IF;

                     -- fin Bug 23940 - APD - 18/10/2012
                     IF algun_error = 0 THEN
                        -- Bug 23940 - APD - 18/10/2012 - se crea la funcion f_genera_recibo
                        -- para pasar c¿digo de p_cartera a dicha funcion
                        num_err := pac_dincartera.f_genera_recibo(pmes, panyo, pempresa,
                                                                  p_sseguro, movimiento,
                                                                  p_cagrpro, p_cforpag,
                                                                  fcarpronueva, fcarantnueva,
                                                                  fcaranunueva, nanualinueva,
                                                                  nfraccinueva, p_ccobban,
                                                                  p_ctipreb, p_sproduc,
                                                                  pfemisio, ppsproces,
                                                                  pidioma, indice_error);

                        IF num_err <> 0 THEN
                           algun_error := 1;
                        ELSE
                           -- BUG 34469/205354 - CONTROLAMOS EL MOVIMIENTO ANIVERSARIO
                           num_err := f_modif_cmovseg_aniversario(p_sseguro, fcarantnueva);

                           IF num_err <> 0 THEN
                              algun_error := 1;
                              indice_error := indice_error + 1;
                           END IF;
                        END IF;
                     -- fin Bug 23940 - APD - 18/10/2012
                     END IF;
                  END IF;
-- fin Bug 23940 - APD - 09/11/2012
----------------------
               ELSE   -- NO RENOVACI¿N, S¿LO RECIBO
                  ----Llamamos la funci¿n que actualiza datos de la pr¿xima cartera-----
                  num_err := f_acproxcar(p_sseguro, fcarantnueva, fcarpronueva, fcaranunueva,
                                         nanualinueva, nfraccinueva, frenovanueva);

                  --BUG 0011604 - FAL - 29/02/2010
                  IF p_sproduc = 375 THEN
                     BEGIN
                        SELECT fcaranu
                          INTO vfcaranu
                          FROM seguros
                         WHERE sseguro = p_sseguro;

                        IF fcarpronueva > vfcaranu THEN
                           --se escoge la fecha menor entre la fvencim del recibo y la fcaranu
                           fcarpronueva := vfcaranu;
                        END IF;
                     EXCEPTION
                        WHEN OTHERS THEN
                           NULL;
                     END;
                  END IF;

                  --Fi BUG 0011604 - FAL - 29/02/2010
                  IF num_err <> 0 THEN
                     algun_error := 1;
                     indice_error := indice_error + 1;
                  ELSE
                     BEGIN
                        UPDATE seguros
                           SET fcarant = fcarantnueva,
                               fcarpro = fcarpronueva,
                               fcaranu = fcaranunueva,
                               nanuali = nanualinueva,
                               nfracci = nfraccinueva,
                               frenova = frenovanueva
                         WHERE sseguro = p_sseguro;
                     EXCEPTION
                        WHEN OTHERS THEN
                           num_err := 102361;
                           algun_error := 1;
                           indice_error := indice_error + 1;
                     END;

                     -- No se genera movimiento de seguro. Se busca
                     -- el ¿ltimo movimiento vigente
                     num_err := f_buscanmovimi(p_sseguro, 1, 1, pnmovimi2);

                     -- el ¿ltimo movimiento vigente
                     IF num_err <> 0 THEN
                        algun_error := 1;
                        indice_error := indice_error + 1;
                     ELSE
                        IF p_cagrpro = 2 THEN
                           pcmovimi := 2;   -- indica aportaci¿n peri¿dica
                        ELSE
                           pcmovimi := NULL;
                        END IF;

                        --Llamamos la funci¿n de calcular recibos
                        IF NVL(pac_parametros.f_parempresa_n(pempresa, 'FEMISIO_IS_SYSDATE'),
                               0) = 1 THEN
                           vfemisio := f_sysdate;
                        ELSE
                           vfemisio := TO_DATE('1/' || TO_CHAR(TO_NUMBER(pmes)) || '/'
                                               || TO_CHAR(panyo),
                                               'dd/mm/yyyy');
                        END IF;

                        -- Se mira si es nueva producci¿n o cartera para
                        -- aplicar como modo de comision un 1 o un 2
                        IF f_es_renovacion(p_sseguro) = 0 THEN   -- es cartera
                           modcom := 2;
                        ELSE   -- si es 1 es nueva produccion
                           modcom := 1;
                        END IF;

                        --BUG9028-XVM-01102009 inici
                        IF NVL(pac_parametros.f_parinstalacion_n('CALCULO_RECIBO'), 1) = 0 THEN
                           IF (NVL(f_parproductos_v(p_sproduc, 'SEPARA_RIESGO_AHORRO'), 0) = 1
                               AND pac_seguros.f_tiene_garanahorro(NULL, p_sseguro,
                                                                   fcarpronueva) = 1)
                              OR NVL(f_parproductos_v(p_sproduc, 'SEPARA_RIESGO_AHORRO'), 0) =
                                                                                              0 THEN
                              num_err := pac_adm.f_recries(p_ctipreb, p_sseguro, NULL,
                                                           vfemisio, fcarantnueva,
                                                           fcarpronueva, 3, nanualinueva,
                                                           nfraccinueva, p_ccobban, NULL,
                                                           ppsproces, 22, 'R', modcom,
                                                           fcaranunueva, NULL, pcmovimi,
                                                           pempresa, pnmovimi2, 1, pnimport2);
                           END IF;
                        ELSE
                           IF (NVL(f_parproductos_v(p_sproduc, 'SEPARA_RIESGO_AHORRO'), 0) = 1
                               AND pac_seguros.f_tiene_garanahorro(NULL, p_sseguro,
                                                                   fcarpronueva) = 1)
                              OR NVL(f_parproductos_v(p_sproduc, 'SEPARA_RIESGO_AHORRO'), 0) =
                                                                                              0 THEN
                              num_err := f_recries(p_ctipreb, p_sseguro, NULL, vfemisio,
                                                   fcarantnueva, fcarpronueva, 3,
                                                   nanualinueva, nfraccinueva, p_ccobban,
                                                   NULL, ppsproces, 22, 'R', modcom,
                                                   fcaranunueva, NULL, pcmovimi, pempresa,
                                                   pnmovimi2, 1, pnimport2);
                           END IF;
                        END IF;

                        -- Bug 23940 - APD - 02/11/2012
                        IF num_err <> 0 THEN
                           algun_error := 1;
                           indice_error := indice_error + 1;
                        ELSE
                           num_err := pac_dincartera.f_set_recibos_col(ppsproces, p_sseguro,
                                                                       fcarantnueva);

                              -- fin Bug 23940 - APD - 02/11/2012
                           --BUG9028-XVM-01102009 fi
                           IF num_err <> 0 THEN
                              algun_error := 1;
                              indice_error := indice_error + 1;
                           ELSE
                              -- Bug 19096 - RSC - 03/08/2011 - LCOL - Parametrizaci¿n b¿sica producto Vida Individual Pagos Permanentes (Afegim 'RRIE')
                              IF NVL(f_parproductos_v(p_sproduc, 'SEPARA_RIESGO_AHORRO'), 0) =
                                                                                             1 THEN
                                 IF NVL(pac_parametros.f_parinstalacion_n('CALCULO_RECIBO'),
                                        1) = 0 THEN
                                    num_err := pac_adm.f_recries(p_ctipreb, p_sseguro, NULL,
                                                                 vfemisio, fcarantnueva,
                                                                 fcarpronueva, 3,
                                                                 nanualinueva, nfraccinueva,
                                                                 p_ccobban, NULL, ppsproces,
                                                                 22, 'RRIE', modcom,
                                                                 fcaranunueva, NULL, pcmovimi,
                                                                 pempresa, pnmovimi2, 1,
                                                                 pnimport2);
                                 ELSE
                                    num_err := f_recries(p_ctipreb, p_sseguro, NULL, vfemisio,
                                                         fcarantnueva, fcarpronueva, 3,
                                                         nanualinueva, nfraccinueva,
                                                         p_ccobban, NULL, ppsproces, 22,
                                                         'RRIE', modcom, fcaranunueva, NULL,
                                                         pcmovimi, pempresa, pnmovimi2, 1,
                                                         pnimport2);
                                 END IF;
                              END IF;

                              -- Bug 23940 - APD - 02/11/2012
                              IF num_err <> 0 THEN
                                 algun_error := 1;
                                 indice_error := indice_error + 1;
                              ELSE
                                 num_err := pac_dincartera.f_set_recibos_col(ppsproces,
                                                                             p_sseguro,
                                                                             fcarantnueva);

                                 -- fin Bug 23940 - APD - 02/11/2012
                                 IF num_err <> 0 THEN
                                    algun_error := 1;
                                    indice_error := indice_error + 1;
                                 ELSE
                                    -- ini Bug 0022701 - 03/09/2012 - JMF
                                    IF pac_retorno.f_tiene_retorno(NULL, p_sseguro, NULL) = 1 THEN
                                       num_err :=
                                          pac_retorno.f_generar_retorno(p_sseguro, pnmovimi2,
                                                                        NULL, ppsproces);

                                       IF num_err <> 0 THEN
                                          algun_error := 1;
                                          indice_error := indice_error + 1;
                                          pnnumlin := NULL;
                                          texto :=
                                             'pac_retorno:'
                                             || f_axis_literales(num_err, pidioma);
                                          num_err :=
                                             f_proceslin(ppsproces, texto, p_sseguro,
                                                         pnnumlin);
                                          num_err := 0;
                                       -- ini bug 0026261 - 06/05/2013 - JMC
                                       ELSE
                                          num_err :=
                                             pac_dincartera.f_set_recibos_col(ppsproces,
                                                                              p_sseguro,
                                                                              fcarantnueva);

                                          IF num_err <> 0 THEN
                                             indice_error := indice_error + 1;
                                          END IF;
                                       -- fin    bug 0026261 - 06/05/2013 - JMC
                                       END IF;
                                    END IF;

                                    -- fin Bug 0022701 - 03/09/2012 - JMF

                                    --Bug.: 20923 - 14/01/2012 - ICV
                                    --Si todo OK env¿amos Todos recibos del movimiento al ERP.
                                    IF NVL(pac_parametros.f_parempresa_n(pempresa,
                                                                         'GESTIONA_COBPAG'),
                                           0) = 1
                                       AND num_err = 0 THEN
                                       num_err :=
                                          pac_ctrl_env_recibos.f_proc_recpag_mov(pempresa,
                                                                                 p_sseguro,
                                                                                 pnmovimi2, 4,
                                                                                 ppsproces);
                                    /*IF num_err <> 0 THEN
                                       algun_error := 1;
                                       indice_error := indice_error + 1;
                                    END IF;*/
                                    END IF;
p_control_error ('JRB', 'sri', num_err || ' -frenovaant ' || frenovaant || ' -fcarproant ' || fcarproant || ' -p_sseguro ' || p_sseguro || ' -fcarantnueva ' || fcarantnueva || ' -fcarpronueva ' || fcarpronueva || ' -fcaranunueva ' || fcaranunueva
                                          || ' -nanualinueva ' || nanualinueva || ' -nfraccinueva ' || nfraccinueva || ' -prima ' || prima || ' -frenovanueva ' || frenovanueva);
                                    --Fin Bug.: 20923
                                    IF num_err = 0 THEN
                                       IF NVL(pac_parametros.f_parempresa_n(pempresa,
                                                                            'ENVIO_SRI'),
                                              0) = 1
                                          AND num_err = 0 THEN
                                          p_control_error ('JRB', 'sri', frenovaant || ' -fcarproant ' || fcarproant || ' -p_sseguro ' || p_sseguro || ' -fcarantnueva ' || fcarantnueva || ' -fcarpronueva ' || fcarpronueva || ' -fcaranunueva ' || fcaranunueva
                                          || ' -nanualinueva ' || nanualinueva || ' -nfraccinueva ' || nfraccinueva || ' -prima ' || prima || ' -frenovanueva ' || frenovanueva);
                                          IF frenovaant = fcarproant THEN
                                             num_err :=
                                                pac_sri.p_envio_sri(pempresa, p_sseguro,
                                                                    pnmovimi2, 1);

                                             --Si ha dado error
                                             IF num_err <> 0 THEN
                                                p_tab_error(f_sysdate, f_user,
                                                            'pac_dincartera.p_cartera_psu', 8,
                                                            'pempresa = ' || pempresa
                                                            || ' p_sseguro = ' || p_sseguro
                                                            || ' pnmovimi2 = ' || pnmovimi2,
                                                            num_err);
                                             END IF;
                                          END IF;
                                       END IF;
                                    END IF;
                                 END IF;   -- fin Bug 23940 - APD - 02/11/2012
                              END IF;   -- fin Bug 23940 - APD - 02/11/2012
                           -- Fin Bug 19096
                           END IF;
                        END IF;   -- fin Bug 23940 - APD - 02/11/2012
                     END IF;
                  END IF;
               END IF;
            END IF;

            IF algun_error = 0 THEN
               -- Se borran los registros de GARANCAR
               BEGIN
                  --
                  DELETE FROM garancar
                        WHERE sproces = ppsproces
                          AND sseguro = p_sseguro;

                  -- FBL. 25/06/2014 MSV Bug 0028974
                  DELETE FROM garancarcom
                        WHERE sproces = ppsproces
                          AND sseguro = p_sseguro;

                  -- Fin FBL. 25/06/2014 MSV Bug 0028974
                  DELETE      preguncar
                        WHERE sproces = ppsproces
                          AND sseguro = p_sseguro;

                  DELETE      pregungarancar
                        WHERE sproces = ppsproces
                          AND sseguro = p_sseguro;

                  DELETE      pregunpolcar
                        WHERE sproces = ppsproces
                          AND sseguro = p_sseguro;

                  DELETE      tmp_garanseg
                        WHERE sseguro = p_sseguro;
               EXCEPTION
                  WHEN OTHERS THEN
                     NULL;
               END;

               -- Se graba el seguro en la tabla SEGCARTERA
               num_err := f_inssegcartera(ppsproces, p_sseguro, p_fcarpro, p_fcaranu,
                                          p_fcarant, p_nanuali, p_nfracci);
               v_mes_anteri := TO_NUMBER(TO_CHAR(p_fcarpro, 'MM'));

               IF num_err <> 0 THEN
                  algun_error := 1;
                  indice_error := indice_error + 1;
               ELSE
                  pcorrecte := 1;
                  p_fcarant := fcarantnueva;
                  p_fcarpro := fcarpronueva;
                  p_fcaranu := fcaranunueva;
                  p_nanuali := nanualinueva;
                  p_nfracci := nfraccinueva;
               END IF;
            END IF;
         END LOOP;
      END IF;

      --
      -- Por ultimo, trataremos los recibos extraordinarios
      --
      FOR r_dat IN c_motextra LOOP
         num_err := f_prevrecriesextra(r_dat.sseguro, pempresa, ppsproces, 'R', pnrecibo);

         IF num_err <> 0 THEN
            RETURN num_err;
            p_control_error ('JRB', 'sri', 'return 4');
         ELSE
            BEGIN
               UPDATE extrarec
                  SET nrecibo = pnrecibo
                WHERE sseguro = r_dat.sseguro
                  AND nrecibo IS NULL
                  AND ADD_MONTHS(falta, f_parinstalacion_n('CEXTRNMES')) <= f_sysdate;
            EXCEPTION
               WHEN OTHERS THEN
                  RETURN 111939;   -- Error actualizando la tabla EXTRAREC
                  p_control_error ('JRB', 'sri', 'return 5');
            END;
         END IF;
      END LOOP;

      RETURN num_err;
      p_control_error ('JRB', 'sri', 'return 6 ' || num_err);
   END p_cartera_psu;

------------------------------------------------------------------------------------
   FUNCTION p_cartera(
      pmoneda IN NUMBER,
      pidioma IN NUMBER,
      pmes IN NUMBER,
      panyo IN NUMBER,
      p_sseguro IN NUMBER,
      p_cramo IN NUMBER,
      p_cmodali IN NUMBER,
      p_ctipseg IN NUMBER,
      p_ccolect IN NUMBER,
      p_ctarman IN NUMBER,
      p_ccobban IN NUMBER,
      p_nrenova IN NUMBER,
      p_ctipreb IN NUMBER,
      p_cforpag IN NUMBER,
      p_nduraci IN NUMBER,
      p_ndurcob IN NUMBER,
      p_cactivi IN OUT NUMBER,
      p_csubpro IN NUMBER,
      p_cobjase IN NUMBER,
      p_cagrpro IN NUMBER,
      p_fefecto IN DATE,
      p_fvencim IN DATE,
      p_fcarpro IN OUT DATE,
      p_fcaranu IN OUT DATE,
      p_nanuali OUT NUMBER,
      p_nfracci OUT NUMBER,
      p_fcarant OUT DATE,
      ppsproces IN NUMBER,
      indice IN OUT NUMBER,
      indice_error IN OUT NUMBER,
      pfemisio IN DATE,
      pcorrecte OUT NUMBER,
      p_sproduc IN NUMBER,
      p_nsuplem IN NUMBER,
      pcgarant_regu IN NUMBER,
      pnorden IN NUMBER,
      pcprimin IN NUMBER,
      piprimin IN NUMBER,
      pcclapri IN NUMBER,
      pnedamar IN NUMBER,
      pciedmar IN NUMBER,
      pempresa IN NUMBER,
      p_csituac IN NUMBER,
      pfcartera IN DATE DEFAULT NULL)   --JRH MSV-3
      RETURN NUMBER IS
      -- A¿adimos los parametros pempresa y p_csituac.
      -- La empresa es para cuestiones de recibos.El csituac para los
      -- casos en que es propuesta de suplemento.
      vfemisio       DATE;
      encontrado     NUMBER := 0;
      codi_ramo      NUMBER;
      mes_conta      DATE;
      algun_error    NUMBER := 0;
      num_err        NUMBER := 0;
      prevcap        NUMBER(13, 2);
      texto          VARCHAR2(400);
      piprima        NUMBER(13, 2);
      psperson       NUMBER(6);
      conta_proces   NUMBER;
      error          NUMBER;
      fcarproant seguros.fcarpro%TYPE:=NULL;
      frenovaant seguros.frenova%TYPE:=NULL;
      fcarpronueva   seguros.fcarpro%TYPE := NULL;
--       fcarpronueva   DATE := NULL; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      fcarantnueva   seguros.fcarant%TYPE := NULL;
--       fcarantnueva   DATE := NULL; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      fcaranunueva   seguros.fcaranu%TYPE := NULL;
--       fcaranunueva   DATE := NULL; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      nanualinueva   seguros.nanuali%TYPE := NULL;
--       nanualinueva   NUMBER := NULL; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      nfraccinueva   seguros.nfracci%TYPE;
      --       nfraccinueva   NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      pnrecibo       extrarec.nrecibo%TYPE;
      --       pnrecibo       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      tipo           codiram.cgtarif%TYPE;
      --       tipo           NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      frenovanueva   seguros.frenova%TYPE := NULL;
      fec            VARCHAR2(20);
      texto2         VARCHAR2(60);
      num            NUMBER;
      ttexto         VARCHAR2(30);
      piregula       NUMBER;
      ptempresa      VARCHAR2(70);
      pnnumlin       NUMBER;
      num_risc       NUMBER;
      pnimport2      NUMBER;
      pcmovimi       NUMBER;
      pnmovimi2      NUMBER;
      movimiento     NUMBER;
      anulado        NUMBER;
      fecha_carpro   empresas.fcarpro%TYPE;
      --       fecha_carpro   DATE; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      fecha_carant   empresas.fcarant%TYPE;
      --       fecha_carant   DATE; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      dia            VARCHAR2(4);
      fechini        DATE;
      primaant       NUMBER;
      pfech          DATE;
      prima          seguros.iprianu%TYPE;
      --       prima          NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      modcom         NUMBER;
      fultrenova     DATE;
      nmovimi        NUMBER;
      parms_transitorios pac_parm_tarifas.parms_transitorios_tabtyb;
      lbonifica      NUMBER;
      laplica_bonifica NUMBER;
      lcumple        NUMBER;
      num_lin        NUMBER;
      lcactivi       NUMBER;
      v_cont         NUMBER;
      v_pinttec      tmp_garancar.nparben%TYPE;
--       v_pinttec      NUMBER(9, 6); --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      -- BUG 0005557 - 29-01-09 - jmf - 0005557: CRE - Suplementos autom¿ticos
      n_retafrac     NUMBER(1);
      v_cursor       NUMBER;
      ss             VARCHAR2(3000);
      funcion        VARCHAR2(40);
      v_filas        NUMBER;
      w_creaseg      NUMBER;   -- bug:11623 AVT 28-10-2009
      vfcaranu       seguros.fcaranu%TYPE;
--       vfcaranu       DATE;   -- bug 0011604 FAL 25-02-2010 --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      v_frevisio     seguros_aho.frevisio%TYPE;
      --       v_frevisio     DATE; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      v_crealiza     cfg_accion.crealiza%TYPE;
      -- Bug 19096 - RSC - 03/08/2011 - LCOL - Parametrizaci¿n b¿sica producto Vida Individual Pagos Permanentes (Afegim 'RRIE')
      v_recibo_ahorro recibos.nrecibo%TYPE;
      v_recibo_riesgo recibos.nrecibo%TYPE;
      v_listarec     t_lista_id;
      v_obrec        ob_lista_id;
      v_cmotmov      NUMBER := 404;
      -- Fin Bug 19096

      -- Bug 23428 - RSC - 07/09/2012 - EMISI¿N ¿ CARTERA - COBRO VENCIDO / ANTICIPADO
      v_ctipcob      seguroscol.ctipcob%TYPE;
      --       v_ctipcob      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      v_fcartera     DATE;
      -- FIn bug 23428
      v_cbloqueocol  seguros.cbloqueocol%TYPE;
      -- Bug 23940 - APD - 31/12/2012
      vcuser         VARCHAR2(40);
      -- Bug 28821/0176979 - APD - 10/06/2014
      vcontexto      NUMBER;   -- Bug 28821/0176979 - APD - 10/06/2014
      v_funcion      VARCHAR2(1000);
      vcempres       NUMBER;

      -- BUG 0005557 - 29-01-09 - jmf - 0005557: CRE - Suplementos autom¿ticos
      CURSOR c_motextra IS
         SELECT DISTINCT (sseguro) sseguro
                    FROM extrarec
                   WHERE nrecibo IS NULL
                     AND ADD_MONTHS(falta, f_parinstalacion_n('CEXTRNMES')) <= f_sysdate;
   BEGIN
      pcorrecte := 0;
      vfemisio := pfemisio;
      conta_proces := ppsproces;
      fcarantnueva := NULL;
      fcarpronueva := NULL;
      fcaranunueva := NULL;
      nanualinueva := NULL;
      nfraccinueva := NULL;
      frenovanueva := NULL;

      IF p_fcarpro IS NOT NULL THEN
         indice := indice + 1;
         algun_error := 0;
         num_err := 0;

         -- Bug 23428 - RSC - 07/09/2012 - EMISI¿N ¿ CARTERA - COBRO VENCIDO / ANTICIPADO
         BEGIN
            SELECT ctipcob
              INTO v_ctipcob
              FROM seguroscol
             WHERE sseguro = p_sseguro;
         EXCEPTION
            WHEN NO_DATA_FOUND THEN
               v_ctipcob := 2;
            WHEN OTHERS THEN
               v_ctipcob := 2;
         END;

         SELECT DECODE(v_ctipcob,
                       1, ADD_MONTHS((LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo, 'mmyyyy'))
                                      + 1),
                                     -1),
                       (LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo, 'mmyyyy')) + 1))
           INTO v_fcartera
           FROM DUAL;

        begin
        select fcarpro, frenova
        into fcarproant, frenovaant
        from seguros where sseguro = p_sseguro;
        exception when others then
        fcarproant := p_fcarpro;
        end;

         IF pfcartera IS NOT NULL THEN   --JRH MSV-3 Error , genera m¿s recibos de la cuenta cuando hay carteras pendientes.
            SELECT DECODE(v_ctipcob, 1, ADD_MONTHS(pfcartera + 1, -1), pfcartera + 1)
              INTO v_fcartera
              FROM DUAL;
         END IF;

         -- Fin Bug 23428
         WHILE(p_fcarpro < v_fcartera
               AND algun_error = 0
               AND(p_fcarpro < p_fvencim
                   OR p_fvencim IS NULL)) LOOP
            -- BUG 0005557 - 29-01-09 - jmf - INI 0005557: CRE - Suplementos autom¿ticos
            n_retafrac := NULL;

            -- Bug 23940 - APD - 31/12/2012 - si la poliza est¿ bloqueada en renovacion no permitir renovar
            IF (p_fcarpro = p_fcaranu
                AND p_csituac <> 5
                AND n_retafrac IS NULL)
               OR(n_retafrac = 1) THEN
               SELECT cbloqueocol
                 INTO v_cbloqueocol
                 FROM seguros
                WHERE sseguro = p_sseguro;

               IF v_cbloqueocol = 2 THEN
                  RETURN 152212;   -- Poliza bloqueada.
               END IF;
            END IF;

            -- fin Bug 23940 - APD - 31/12/2012

            -- Bug 28821/0176979 - APD - 10/06/2014
            -- Nos guardamos el usuario
            SELECT f_user
              INTO vcuser
              FROM DUAL;

            -- Se cambia el usuario de conexion
            SELECT pac_contexto.f_inicializarctx
                                (pac_parametros.f_parempresa_t(pac_md_common.f_get_cxtempresa,
                                                               'USER_BBDD'))
              INTO vcontexto
              FROM DUAL;

            -- fin Bug 28821/0176979 - APD - 10/06/2014

            -- BUG15823:DRA:27/10/2010:Inici
            -- Bug 9905 - 24/04/2009 - RSC - Suplemento de cambio de forma de pago diferido
            IF pac_sup_diferidos.f_eval_diferidos(p_sseguro, p_fcarpro) = 1 THEN
               num_err := pac_sup_diferidos.f_gen_supl_diferidos(p_sseguro, p_fcarpro,
                                                                 ppsproces);
            END IF;

            -- Fin Bug 9905
            IF num_err <> 0 THEN
               algun_error := 1;

               -- Bug 28821/0176979 - APD - 10/06/2014
               -- Se cambia el usuario de conexion por el usuario inicial
               SELECT pac_contexto.f_inicializarctx(vcuser)
                 INTO vcontexto
                 FROM DUAL;

               -- fin Bug 28821/0176979 - APD - 10/06/2014

               -- Volvemos porque ha fallado el suplemento
               RETURN num_err;
            ELSE
               -- Bug 9153 - 17/04/2009 - RSC - Suplementos autom¿ticos
               IF pac_sup_diferidos.f_eval_automaticos(p_sseguro) = 1 THEN
                  num_err := pac_sup_diferidos.f_gen_supl_automaticos(p_sseguro, p_fcarpro,
                                                                      ppsproces);

                  -- Bug 10908 - 28/08/2009 - JMF
                  -- Bug 16095 - 05/11/2010 - APD - Si pac_sup_diferidos.f_gen_supl_automaticos
                  -- devuelve el num_err 9901538 no se debe tratar como un error
                  IF num_err <> 0
                     AND num_err <> 9901538 THEN
                     indice_error := indice_error + 1;
                  END IF;
               -- Bug 16095 - 05/11/2010 - APD
               -- Bug 10908 - 28/08/2009 - JMF
               END IF;

               -- Fin Bug 9153
               IF num_err <> 0 THEN
                  -- Volvemos porque ha fallado el suplemento
                  IF num_err = 9901538 THEN   -- Bug 16095 - 05/11/2010 - APD
                     COMMIT;   -- Bug 16095 - 05/11/2010 - APD
                  END IF;

                  -- Bug 28821/0176979 - APD - 10/06/2014
                  -- Se cambia el usuario de conexion por el usuario inicial
                  SELECT pac_contexto.f_inicializarctx(vcuser)
                    INTO vcontexto
                    FROM DUAL;

                  -- fin Bug 28821/0176979 - APD - 10/06/2014
                  RETURN num_err;
               END IF;

               --JRH 05/2016
               IF pac_anulacion.f_anula_vto_cartera(p_sseguro, NULL, p_fcarpro) = 1 THEN
                  num_err := pac_anulacion.f_anula_vto_garantias(p_sseguro, p_fcarpro,
                                                                 ppsproces);
               END IF;

               IF num_err <> 0 THEN
                  algun_error := 1;
                  indice_error := indice_error + 1;
                  texto := f_axis_literales(151372, pidioma);
                  texto := texto || '.' || p_sseguro;
                  num_lin := NULL;
                  num_err := f_proceslin(ppsproces, texto, p_sseguro, num_lin);
                  num_err := 151372;
               -- fin Bug 28821/0176979 - APD - 10/06/2014
               -- RETURN num_err;
               END IF;
            END IF;

            -- Bug 28821/0176979 - APD - 10/06/2014
            -- Se cambia el usuario de conexion por el usuario inicial
            SELECT pac_contexto.f_inicializarctx(vcuser)
              INTO vcontexto
              FROM DUAL;

            -- fin Bug 28821/0176979 - APD - 10/06/2014

            -- BUG15823:DRA:27/10/2010:Fi
            IF NVL(f_parproductos_v(p_sproduc, 'FRACCIONARIO'), 0) = 1 THEN
               SELECT MAX(tvalpar)
                 INTO funcion
                 FROM detparpro
                WHERE cparpro = 'F_PRFRACCIONARIAS'
                  AND cidioma = 2
                  AND cvalpar = (SELECT cvalpar
                                   FROM parproductos
                                  WHERE sproduc = p_sproduc
                                    AND cparpro = 'F_PRFRACCIONARIAS');

               IF funcion IS NOT NULL THEN
                  ss := 'begin :n_retafrac := ' || funcion || '; end;';

                  IF DBMS_SQL.is_open(v_cursor) THEN
                     DBMS_SQL.close_cursor(v_cursor);
                  END IF;

                  v_cursor := DBMS_SQL.open_cursor;
                  DBMS_SQL.parse(v_cursor, ss, DBMS_SQL.native);

                  IF INSTR(ss, ':psseguro') > 0 THEN
                     DBMS_SQL.bind_variable(v_cursor, ':psseguro', p_sseguro);
                  END IF;

                  IF INSTR(ss, ':pfecha') > 0 THEN
                     DBMS_SQL.bind_variable(v_cursor, ':pfecha', p_fcarpro);
                  END IF;

                  IF INSTR(ss, ':n_retafrac') > 0 THEN
                     DBMS_SQL.bind_variable(v_cursor, ':n_retafrac', num_err);
                  END IF;

                  v_filas := DBMS_SQL.EXECUTE(v_cursor);
                  DBMS_SQL.variable_value(v_cursor, 'n_retafrac', n_retafrac);

                  IF DBMS_SQL.is_open(v_cursor) THEN
                     DBMS_SQL.close_cursor(v_cursor);
                  END IF;
               END IF;
            END IF;

            -- BUG 0005557 - 29-01-09 - jmf - FIN 0005557: CRE - Suplementos autom¿ticos
            IF algun_error = 0 THEN
               -- A¿adimos a la condici¿n que no este en Prop. de suplemento.
               -- BUG 0005557 - 29-01-09 - jmf - FIN 0005557: CRE - Suplementos autom¿ticos
               IF (p_fcarpro = p_fcaranu
                   AND p_csituac <> 5
                   AND n_retafrac IS NULL)
                  OR(n_retafrac = 1) THEN
                  --
                  num_err := pac_cambiocartera.cambiocartera('R', p_sproduc, p_cactivi,
                                                             p_sseguro, p_cramo, p_cmodali,
                                                             p_ctipseg, p_ccolect, p_fcaranu,
                                                             p_nsuplem, lcumple, lcactivi);

                  IF lcumple = 1
                     AND num_err = 0 THEN
                     p_cactivi := lcactivi;
                     texto := f_axis_literales(110406, pidioma);
                     texto := texto || '.' || p_sseguro;
                     num_lin := NULL;
                     num_err := f_proceslin(ppsproces, texto, p_sseguro, num_lin);

                     IF num_err = 0 THEN
                        COMMIT;
                     END IF;
                  ------
                  END IF;

                  IF num_err = 0 THEN
                     -- La p¿lissa renova , cal comprovar si te bonificaci¿
                     -- per no sinistralitat
                     num_err := pac_bonifica.f_bonifica_poliza(p_cramo, p_cmodali, p_ctipseg,
                                                               p_ccolect, p_sseguro,
                                                               p_fcaranu, p_fefecto,
                                                               lbonifica, laplica_bonifica);
                  END IF;

                  IF num_err = 0 THEN
                     -- BUG 16903 - 09/12/2010 - JMP - No renovamos si fecha de revisi¿n anterior a la de renovaci¿n.
                     BEGIN
                        SELECT frevisio
                          INTO v_frevisio
                          FROM seguros_aho
                         WHERE sseguro = p_sseguro;

                        num_err := pac_cfg.f_get_user_accion_permitida(f_user,
                                                                       'CARTERA_NO_REVISA',
                                                                       p_sproduc, pempresa,
                                                                       v_crealiza);

                        IF num_err <> 1 THEN
                           IF v_frevisio < p_fcaranu THEN
                              num_err := 9901723;
                           -- La fecha de revisi¿n es anterior a la renovaci¿n de la p¿liza
                           ELSE
                              num_err := 0;
                           END IF;
                        ELSE
                           num_err := 0;
                        END IF;
                     EXCEPTION
                        WHEN NO_DATA_FOUND THEN
                           NULL;
                     END;
                  END IF;

                  IF num_err <> 0 THEN
                     algun_error := 1;
                     indice_error := indice_error + 1;
                  ELSE
                     -- Se comprueba si el seguro tiene regularizacion y
                     -- si es as¿ se calcula el importe de regularizaci¿n y se genera
                     -- el recibo de extorno
                     -- La prima anterior se calcula con la funci¿n
                     -- f_recprima, no es el iprianu de seguros
                     dia := SUBSTR(LPAD(p_nrenova, 4, '0'), 3, 2);
                     --   fechini := f_summeses(p_fcaranu, -12, dia);
                     num_err := f_ultrenova(p_sseguro, p_fcaranu, fultrenova, nmovimi);

                     IF num_err <> 0 THEN
                        algun_error := 1;
                        indice_error := indice_error + 1;
                     ELSE
                        primaant := f_recprima(p_sseguro, fultrenova, p_fcaranu);
                        num_err := f_regulariza(p_sseguro, primaant, fultrenova, p_fcaranu,
                                                ppsproces, vfemisio, piregula);

                        IF num_err <> 0
                           AND num_err <> 1000 THEN
                           algun_error := 1;
                           indice_error := indice_error + 1;
                        ELSE
                           num_err := 0;

                           BEGIN
                              SELECT cgtarif
                                INTO tipo
                                FROM codiram
                               WHERE cramo = p_cramo;
                           EXCEPTION
                              WHEN NO_DATA_FOUND THEN
                                 num_err := 101904;
                                 algun_error := 1;
                                 indice_error := indice_error + 1;
                              WHEN OTHERS THEN
                                 num_err := 104793;
                                 algun_error := 1;
                                 indice_error := indice_error + 1;
                           END;

                           IF num_err = 0 THEN
                              -- Se busca el par¿metro num_risc
                              BEGIN
                                 SELECT COUNT(*)
                                   INTO num_risc
                                   FROM riesgos
                                  WHERE sperson IS NOT NULL
                                    AND sseguro = p_sseguro;
                              EXCEPTION
                                 WHEN OTHERS THEN
                                    num_risc := 0;
                              END;

                              -- Selecci¿n que nos permite saber si se tarifa por
                              -- el m¿todo tradicional o por sgt.

                              --0031786:NSS:09/10/2014 Eliminar la tabla SGT_PRODUCTOS. Es una tabla obsoleta que no tiene sentido mantener.
                                    /*
                              SELECT COUNT(cramo)
                                INTO encontrado
                                FROM sgt_productos
                               WHERE cramo = p_cramo
                                 AND cmodali = p_cmodali
                                 AND ctipseg = p_ctipseg
                                 AND ccolect = p_ccolect;
                                */

                              --Llamamos a la funci¿n f_garantarifa que nos calcula la tarifa
-----------------------------------------------------------
/*
                              IF encontrado = 1 THEN*/
                              IF NVL(f_parproductos_v(p_sproduc, 'DETALLE_GARANT'), 0) IN
                                                                                         (1, 2) THEN
                                 num_err :=
                                    pac_dincartera.f_garantarifa_sgt_det('R', p_sseguro,
                                                                         p_cramo, p_cmodali,
                                                                         p_cobjase, p_ctipseg,
                                                                         p_ccolect, tipo,
                                                                         p_nduraci,
                                                                         conta_proces,
                                                                         p_ndurcob, p_fcarpro,
                                                                         pmes, panyo, tipo,
                                                                         p_cagrpro, p_ctarman,
                                                                         p_cactivi, num_risc,
                                                                         vfemisio, p_fefecto,
                                                                         movimiento, anulado,
                                                                         pmoneda,
                                                                         parms_transitorios,
                                                                         lbonifica,
                                                                         laplica_bonifica,
                                                                         p_sproduc, p_cforpag,
                                                                         pidioma,
                                                                         pcgarant_regu,
                                                                         pnorden, pcprimin,
                                                                         piprimin, pcclapri,
                                                                         pnedamar, pciedmar,
                                                                         p_fcaranu);
                              ELSE
                                 num_err :=
                                    pac_dincartera.f_garantarifa_sgt('R', p_sseguro, p_cramo,
                                                                     p_cmodali, p_cobjase,
                                                                     p_ctipseg, p_ccolect,
                                                                     tipo, p_nduraci,
                                                                     conta_proces, p_ndurcob,
                                                                     p_fcarpro, pmes, panyo,
                                                                     tipo, p_cagrpro,
                                                                     p_ctarman, p_cactivi,
                                                                     num_risc, vfemisio,
                                                                     p_fefecto, movimiento,
                                                                     anulado, pmoneda,
                                                                     parms_transitorios,
                                                                     lbonifica,
                                                                     laplica_bonifica,
                                                                     p_sproduc, p_cforpag,
                                                                     pidioma, pcgarant_regu,
                                                                     pnorden, pcprimin,
                                                                     piprimin, pcclapri,
                                                                     pnedamar, pciedmar,
                                                                     p_fcaranu);
                              END IF;
                           -- END IF;

                           -- Despues de la funcion, podemos haber anulado el seguro o
                           -- algun riesgo, y por lo tanto haber hecho ya el movimiento de
                           -- seguro
                           END IF;

                           IF num_err = 0 THEN
                              IF anulado = 0 THEN   -- si el seguro no se ha anulado
                                 IF movimiento IS NULL THEN   -- si no se han anulado riesgos
                                    -- Se hace un movimiento de seguro de cartera
                                    -- Llamamos la funci¿n f_movseguro----
                                    -- Se pasa pcimpres = null para coger
                                    -- el estado de impresion del ultimo movimiento

                                    -- BUG 0005557 - 29-01-09 - jmf - INI 0005557: CRE - Suplementos autom¿ticos
                                    IF n_retafrac = 1
                                       AND(p_fcarpro <> p_fcaranu) THEN
                                       num_err :=
                                          f_movseguro(p_sseguro, NULL, 821, 2, p_fcarpro,
                                                      NULL, NULL, NULL, mes_conta, movimiento,
                                                      vfemisio);
                                    -- BUG 0005557 - 29-01-09 - jmf - FIN 0005557: CRE - Suplementos autom¿ticos
                                    ELSE
                                       v_cmotmov :=
                                           f_renovacion_anual(p_sseguro, p_fcaranu, p_sproduc);
                                       num_err :=
                                          f_movseguro(p_sseguro, NULL, v_cmotmov, 2,
                                                      p_fcarpro, NULL, NULL, NULL, mes_conta,
                                                      movimiento, vfemisio);
                                    END IF;

                                    IF num_err = 0 THEN
                                       -- Se llama a f_act_hisseg para guardar la
                                       -- situaci¿n anterior al suplemento.
                                       -- El nmovimi es el anterior al del suplemento,
                                       -- por eso se le resta uno al reci¿n creado.
                                       num_err := f_act_hisseg(p_sseguro, movimiento - 1);

                                       -- Si el parproducto 'RENOVA_REVISA' del producto = 0 - Revisa en cartera,
                                       -- se renueva el inter¿s t¿cnico en el proceso de cartera, sino se renueva
                                       -- en el proceso de renovaci¿n-revisi¿n
                                       IF NVL(f_parproductos_v(p_sproduc, 'RENOVA_REVISA'), 0) =
                                                                                             0 THEN
                                          -- Se graba el inter¿s t¿cnico adicional del nuevo periodo
                                          IF num_err = 0 THEN
                                             /*BEGIN
                                                                                                                                                                                                                                                                                                                                                                                                                                          SELECT COUNT (*)
                                                  INTO v_cont
                                                  FROM intertecprod
                                                 WHERE sproduc = p_sproduc;
                                             EXCEPTION
                                                WHEN OTHERS
                                                THEN
                                                   num_err := 104742;
                                             END;*/

                                             --IF num_err <> 0 AND v_cont > 0
                                             --THEN

                                             -- Tarea 2674: Intereses para LRC.A¿adimos ndesde y nhasta. Hemos de poner todos los tramos (periodo-anualidad) para la p¿liza.
                                             --Esta funci¿n nos informar¿ el inter¿s que toca en INTERTECSEG, y en el caso de LRC, los intereses de cada una de las anualidades que tocan.
                                             num_err :=
                                                pac_prod_comu.f_grabar_inttec(p_sproduc,
                                                                              p_sseguro,
                                                                              p_fcarpro, 2,
                                                                              NULL, 'SEG');

                                             IF num_err <> 0 THEN
                                                RETURN num_err;
                                             END IF;
                                          -- Tarea 2674: Comentamos lo anterior
                                          /*num_err :=
                                                                                                                                                                                                                                                                                                                                                                                                                              pac_inttec.f_int_seguro_alta_renova
                                              ('SEG',
                                             p_sseguro,
                                            2,
                                            p_fcarpro,
                                            v_pinttec
                                            );
                                            IF num_err <> 0
                                            THEN
                                               RETURN num_err;
                                            END IF;
                                            num_err :=
                                               Pk_Nueva_Produccion.f_ins_intertecseg
                                                                 ('SEG',
                                                                 p_sseguro,
                                                                 movimiento,
                                                                 p_fcarpro,
                                                 v_pinttec
                                                                );*/
                                          --END IF;
                                          END IF;
                                       END IF;
                                    END IF;
                                 END IF;

                                 IF num_err <> 0 THEN
                                    algun_error := 1;
                                    indice_error := indice_error + 1;
                                 ELSE
                                    -- Ya no se compara, se graban todos
                                    --los registros de garancar en garanseg con nmovimi = pnmovimi
                                    ---Llamamos la funci¿n f_traspasgar que nos traspasa las
                                    --garant¿as de garancar a garanseg
                                    num_err := pac_dincartera.f_traspasgar(conta_proces,
                                                                           p_sseguro,
                                                                           p_fcarpro,
                                                                           movimiento);

                                    IF num_err <> 0 THEN
                                       algun_error := 1;
                                       indice_error := indice_error + 1;
                                    ELSE
                                       ----Ya est¿n todas las garant¿as de GARANSEG y GARANCOLEC tarificadas---
                                       ----Llamamos la funci¿n que actualiza datos de la pr¿xima cartera-----
                                       num_err :=
                                          f_acproxcar(p_sseguro, fcarantnueva, fcarpronueva,
                                                      fcaranunueva, nanualinueva,
                                                      nfraccinueva, frenovanueva);

                                       IF num_err <> 0 THEN
                                          algun_error := 1;
                                          indice_error := indice_error + 1;
                                       ELSE
                                          -- Calculamos la nueva iprianu de SEGUROS
                                          -- Se calcula la prima a fecha de la renovaci¿n (fcarantnueva)
                                          prima := f_segprima(p_sseguro, fcarantnueva);

                                          BEGIN
                                             UPDATE seguros
                                                SET fcarant = fcarantnueva,
                                                    fcarpro = fcarpronueva,
                                                    fcaranu = fcaranunueva,
                                                    nanuali = nanualinueva,
                                                    nfracci = nfraccinueva,
                                                    iprianu = prima,
                                                    frenova = frenovanueva
                                              WHERE sseguro = p_sseguro;
                                          EXCEPTION
                                             WHEN OTHERS THEN
                                                num_err := 102361;
                                                algun_error := 1;
                                                indice_error := indice_error + 1;
                                          END;
                                       END IF;

                                       SELECT pac_parametros.f_parproducto_t(p_sproduc,
                                                                             'F_POST_CARTERA')
                                         INTO v_funcion
                                         FROM DUAL;

                                       IF v_funcion IS NOT NULL THEN
                                          ss := 'begin :num_err := ' || v_funcion
                                                || '(:v_sproces, :v_sseguro); end;';

                                          EXECUTE IMMEDIATE ss
                                                      USING OUT num_err, IN ppsproces,
                                                            IN p_sseguro;
                                       END IF;

                                       -- Mantis 11845.12/2009.NMM.CRE - Ajustar reasseguran¿a d'estalvi .i.
                                       IF pac_cesionesrea.producte_reassegurable(p_sproduc) = 1 THEN
                                          --      REASEGURO
                                          -- Bug: 11623 AVT 28-10-2009 control del reaseguro abans de cridar a les funcions
                                          -- s'haur¿ d'acabar substituint per la crida a PAC_CESIONESREA.PRODUCTE_REASEGURABLE
                                          /*BEGIN
                                                                                                                                                                                                                                                                                                                                                                                                                                       SELECT creaseg
                                               INTO w_creaseg
                                               FROM productos
                                              WHERE sproduc = p_sproduc;
                                          EXCEPTION
                                             WHEN NO_DATA_FOUND THEN
                                                error := 104347;
                                             WHEN OTHERS THEN
                                                error := 102705;
                                          END;
                                          IF w_creaseg = 1 THEN*/
                                          -- Bug: 11623 AVT 28-10-2009 fi
                                          IF algun_error = 0 THEN
                                             -- REASEGURO
                                             -- Bug 10782 - RSC - 24/07/2009 - CRE - Incid¿ncia Reaseguro Cr¿dit Salut
                                             IF n_retafrac = 1
                                                AND(p_fcarpro <> p_fcaranu) THEN   -- Motivo: 821
                                                num_err :=
                                                   f_buscactrrea(p_sseguro, movimiento,
                                                                 ppsproces, 4, pmoneda);
                                             ELSE
                                                -- Fin Bug 10782
                                                num_err :=
                                                   f_buscactrrea(p_sseguro, movimiento,
                                                                 ppsproces, 5, pmoneda);
                                             END IF;

                                             IF num_err <> 0
                                                AND num_err <> 99 THEN
                                                algun_error := 1;
                                                indice_error := indice_error + 1;
                                             ELSIF num_err = 99 THEN   -- Error controlado
                                                --NULL; Per coher¿ncia amb el P_EMITIR_PROPUESTA.
                                                num_err := 0;
                                             ELSE
                                                -- Bug 10782 - RSC - 24/07/2009 - CRE - Incid¿ncia Reaseguro Cr¿dit Salut
                                                IF n_retafrac = 1
                                                   AND(p_fcarpro <> p_fcaranu) THEN   -- Motivo: 821
                                                   num_err := f_cessio(ppsproces, 4, pmoneda);
                                                ELSE
                                                   -- Fin Bug 10782
                                                   num_err := f_cessio(ppsproces, 5, pmoneda);
                                                END IF;

                                                IF num_err <> 0
                                                   AND num_err <> 99 THEN
                                                   algun_error := 1;
                                                   indice_error := indice_error + 1;
                                                ELSIF num_err = 99 THEN   -- Falta facultativo
                                                   -- Aturem la cartera si falta facultatiu i gravem l'error que ho indica
                                                   algun_error := 1;
                                                   indice_error := indice_error + 1;
                                                   texto := f_axis_literales(105382, pidioma);
                                                   pnnumlin := NULL;
                                                   num_err :=
                                                      f_proceslin(ppsproces, texto, p_sseguro,
                                                                  pnnumlin);

                                                   -- Mantis 10251/10809.#6.01/06/2009.Ini.0010251: CRE - Incidencia Cartera con Facultativo.NMM.
                                                   -- FAL - 10/05/2011 - Bug 0018514: MSGV003 - Modificacions en la retenci¿ per facultatiu
                                                   -- Recupera el riesgo de facpendientes para insertar motivo retencion por riesgo
                                                   FOR reg IN
                                                      (SELECT DISTINCT (NVL(nriesgo, 1))
                                                                                      nriesgo
                                                                  FROM facpendientes
                                                                 WHERE sseguro = p_sseguro
                                                                   AND nmovimi = movimiento
                                                                   AND sproces = ppsproces) LOOP
                                                      num_err :=
                                                         pac_emision_mv.f_retener_poliza
                                                                                 (NULL,
                                                                                  p_sseguro,
                                                                                  reg.nriesgo,

                                                                                  -- num_risc
                                                                                  movimiento,
                                                                                  10
                                                                                    -- MOTIU RETENCIO ( Pendent quadre facultatiu)
                                                                                  , 1
                                                                                     -- CODI RETENCIO
                                                                                  ,
                                                                                  pfemisio);
                                                   END LOOP;

                                                   UPDATE seguros
                                                      SET csituac = 5
                                                    WHERE sseguro = p_sseguro;

                                                   --
                                                   UPDATE movseguro
                                                      SET femisio = NULL
                                                    WHERE sseguro = p_sseguro
                                                      AND nmovimi = movimiento;
                                                -- Mantis 10251/10809.#6.06/2009.Fi.
                                                END IF;
                                             END IF;
                                          END IF;
                                       END IF;   -- Bug: 11623 AVT Fi del IF...

                                       IF algun_error = 0 THEN
                                          -- Se utiliza la funci¿n f_recries para calcular el recibo
                                          -- Se controlan las p¿lizas de ahorro
                                          IF p_cagrpro = 2 THEN
                                             pcmovimi := 2;
                                          -- indica aportaci¿n peri¿dica
                                          ELSE
                                             pcmovimi := NULL;
                                          END IF;

                                          --BUG 9658 - JTS - 29/05/2009
                                          num_err :=
                                             pac_propio.f_graba_com_adq(p_sseguro, movimiento,
                                                                        'R', NULL);

                                          IF num_err <> 0 THEN
                                             algun_error := 1;
                                             indice_error := indice_error + 1;
                                          ELSE
                                             -- Bug 19777/95194 - 26/10/2011 -AMC
                                             IF f_es_renovacion(p_sseguro) = 0 THEN   -- es cartera
                                                modcom := 2;
                                             ELSE
                                                -- si es 1 es nueva produccion
                                                modcom := 1;
                                             END IF;

                                             -- Fi Bug 19777/95194 - 26/10/2011 -AMC

                                             --Fi BUG 9658 - JTS - 29/05/2009
                                             -- Si la forma de pago es ¿nica no se genera recibo
                                             IF p_cforpag <> 0 THEN
                                                --Llamamos la funci¿n de calcular recibos
                                                IF NVL
                                                      (pac_parametros.f_parempresa_n
                                                                         (pempresa,
                                                                          'FEMISIO_IS_SYSDATE'),
                                                       0) = 1 THEN
                                                   vfemisio := f_sysdate;
                                                ELSE
                                                   vfemisio :=
                                                      TO_DATE('01/'
                                                              || TO_CHAR(TO_NUMBER(pmes))
                                                              || '/' || TO_CHAR(panyo),
                                                              'dd/mm/yyyy');
                                                END IF;

                                                --BUG9028-XVM-01102009 inici
                                                IF NVL
                                                      (pac_parametros.f_parinstalacion_n
                                                                              ('CALCULO_RECIBO'),
                                                       1) = 0 THEN
                                                   IF (NVL
                                                          (f_parproductos_v
                                                                        (p_sproduc,
                                                                         'SEPARA_RIESGO_AHORRO'),
                                                           0) = 1
                                                       AND pac_seguros.f_tiene_garanahorro
                                                                                  (NULL,
                                                                                   p_sseguro,
                                                                                   fcarpronueva) =
                                                                                              1)
                                                      OR NVL
                                                           (f_parproductos_v
                                                                        (p_sproduc,
                                                                         'SEPARA_RIESGO_AHORRO'),
                                                            0) = 0 THEN
                                                      num_err :=
                                                         pac_adm.f_recries(p_ctipreb,
                                                                           p_sseguro, NULL,
                                                                           pfemisio,
                                                                           fcarantnueva,
                                                                           fcarpronueva, 3,
                                                                           nanualinueva,
                                                                           nfraccinueva,
                                                                           p_ccobban, NULL,
                                                                           ppsproces, 21, 'R',
                                                                           modcom,
                                                                           fcaranunueva, NULL,
                                                                           pcmovimi, pempresa,
                                                                           movimiento, 1,
                                                                           pnimport2);
                                                   END IF;
                                                ELSE
                                                   IF (NVL
                                                          (f_parproductos_v
                                                                        (p_sproduc,
                                                                         'SEPARA_RIESGO_AHORRO'),
                                                           0) = 1
                                                       AND pac_seguros.f_tiene_garanahorro
                                                                                  (NULL,
                                                                                   p_sseguro,
                                                                                   fcarpronueva) =
                                                                                              1)
                                                      OR NVL
                                                           (f_parproductos_v
                                                                        (p_sproduc,
                                                                         'SEPARA_RIESGO_AHORRO'),
                                                            0) = 0 THEN
                                                      num_err :=
                                                         f_recries(p_ctipreb, p_sseguro, NULL,
                                                                   pfemisio, fcarantnueva,
                                                                   fcarpronueva, 3,
                                                                   nanualinueva, nfraccinueva,
                                                                   p_ccobban, NULL, ppsproces,
                                                                   21, 'R', modcom,
                                                                   fcaranunueva, NULL,
                                                                   pcmovimi, pempresa,
                                                                   movimiento, 1, pnimport2);
                                                   END IF;
                                                END IF;

                                                --BUG9028-XVM-01102009 fi
                                                IF num_err <> 0 THEN
                                                   algun_error := 1;
                                                   indice_error := indice_error + 1;
                                                ELSE
                                                   -- Bug 19096 - RSC - 03/08/2011 - LCOL - Parametrizaci¿n b¿sica producto Vida Individual Pagos Permanentes (Afegim 'RRIE')
                                                   IF NVL
                                                         (f_parproductos_v
                                                                       (p_sproduc,
                                                                        'SEPARA_RIESGO_AHORRO'),
                                                          0) = 1 THEN
                                                      IF NVL
                                                            (pac_parametros.f_parinstalacion_n
                                                                             ('CALCULO_RECIBO'),
                                                             1) = 0 THEN
                                                         num_err :=
                                                            pac_adm.f_recries(p_ctipreb,
                                                                              p_sseguro, NULL,
                                                                              pfemisio,
                                                                              fcarantnueva,
                                                                              fcarpronueva, 3,
                                                                              nanualinueva,
                                                                              nfraccinueva,
                                                                              p_ccobban, NULL,
                                                                              ppsproces, 21,
                                                                              'RRIE', modcom,
                                                                              fcaranunueva,
                                                                              NULL, pcmovimi,
                                                                              pempresa,
                                                                              movimiento, 1,
                                                                              pnimport2);
                                                      ELSE
                                                         num_err :=
                                                            f_recries(p_ctipreb, p_sseguro,
                                                                      NULL, pfemisio,
                                                                      fcarantnueva,
                                                                      fcarpronueva, 3,
                                                                      nanualinueva,
                                                                      nfraccinueva, p_ccobban,
                                                                      NULL, ppsproces, 21,
                                                                      'RRIE', modcom,
                                                                      fcaranunueva, NULL,
                                                                      pcmovimi, pempresa,
                                                                      movimiento, 1,
                                                                      pnimport2);
                                                      END IF;
                                                   END IF;

                                                   IF num_err <> 0 THEN
                                                      algun_error := 1;
                                                      indice_error := indice_error + 1;
                                                   ELSE
                                                      -- Fin Bug 19096

                                                      -- si todo ha ido bien y hay que grabar provision
                                                      num_err :=
                                                         pac_provmat_formul.f_ins_garansegprovmat
                                                                                    (p_sseguro);

                                                      IF num_err <> 0 THEN
                                                         algun_error := 1;
                                                         indice_error := indice_error + 1;
                                                      END IF;

                                                      -- ini Bug 0022701 - 03/09/2012 - JMF
                                                      IF pac_retorno.f_tiene_retorno
                                                                                    (NULL,
                                                                                     p_sseguro,
                                                                                     NULL) = 1 THEN
                                                         num_err :=
                                                            pac_retorno.f_generar_retorno
                                                                                  (p_sseguro,
                                                                                   movimiento,
                                                                                   NULL,
                                                                                   ppsproces);

                                                         IF num_err <> 0 THEN
                                                            algun_error := 1;
                                                            indice_error := indice_error + 1;
                                                            pnnumlin := NULL;
                                                            texto :=
                                                               'pac_retorno:'
                                                               || f_axis_literales(num_err,
                                                                                   pidioma);
                                                            num_err :=
                                                               f_proceslin(ppsproces, texto,
                                                                           p_sseguro,
                                                                           pnnumlin);
                                                            num_err := 0;
                                                         END IF;
                                                      END IF;

                                                      -- fin Bug 0022701 - 03/09/2012 - JMF

                                                      --Bug.: 20923 - 14/01/2012 - ICV
                                                      --Si todo OK env¿amos Todos recibos del movimiento al ERP.
                                                      IF NVL
                                                            (pac_parametros.f_parempresa_n
                                                                             (pempresa,
                                                                              'GESTIONA_COBPAG'),
                                                             0) = 1
                                                         AND num_err = 0 THEN
                                                         num_err :=
                                                            pac_ctrl_env_recibos.f_proc_recpag_mov
                                                                                  (pempresa,
                                                                                   p_sseguro,
                                                                                   movimiento,
                                                                                   4,
                                                                                   ppsproces);
                                                      /* IF num_err <> 0 THEN
                                                          algun_error := 1;
                                                          indice_error := indice_error + 1;
                                                       END IF;*/ --No se devuelve el error ya que el movimiento se ha de enviar
                                                      END IF;

                                                      IF algun_error = 0 THEN
                                                         -- bug 34469/205354 controlamos el movimiento de aniversario
                                                         num_err :=
                                                            f_modif_cmovseg_aniversario
                                                                                 (p_sseguro,
                                                                                  fcarantnueva);

                                                         IF num_err <> 0 THEN
                                                            algun_error := 1;
                                                            indice_error := indice_error + 1;
                                                         END IF;
                                                      END IF;

                                                      --Fin Bug.: 20923
                                                      vcempres :=
                                                         NVL(pac_md_common.f_get_cxtempresa,
                                                             f_parinstalacion_n('EMPRESADEF'));

p_control_error ('JRB', 'sri', num_err || ' -frenovaant ' || frenovaant || ' -fcarproant ' || fcarproant || ' -p_sseguro ' || p_sseguro || ' -fcarantnueva ' || fcarantnueva || ' -fcarpronueva ' || fcarpronueva || ' -fcaranunueva ' || fcaranunueva
                                          || ' -nanualinueva ' || nanualinueva || ' -nfraccinueva ' || nfraccinueva || ' -prima ' || prima || ' -frenovanueva ' || frenovanueva);

                                                      IF num_err = 0 THEN
                                                         IF NVL
                                                               (pac_parametros.f_parempresa_n
                                                                                  (vcempres,
                                                                                   'ENVIO_SRI'),
                                                                0) = 1
                                                            AND num_err = 0 THEN
                                                             p_control_error ('JRB', 'sri', frenovaant || ' -fcarproant ' || fcarproant || ' -p_sseguro ' || p_sseguro
                                          || ' -fcarantnueva ' || fcarantnueva || ' -fcarpronueva ' || fcarpronueva || ' -fcaranunueva ' || fcaranunueva
                                          || ' -nanualinueva ' || nanualinueva || ' -nfraccinueva ' || nfraccinueva || ' -prima ' || prima || ' -frenovanueva ' || frenovanueva);
                                                            IF fcarproant = frenovaant THEN
                                                               num_err :=
                                                                  pac_sri.p_envio_sri
                                                                                  (vcempres,
                                                                                   p_sseguro,
                                                                                   movimiento,
                                                                                   1);

                                                               --Si ha dado error
                                                               IF num_err <> 0 THEN
                                                                  p_tab_error
                                                                     (f_sysdate, f_user,
                                                                      'pac_dincartera.p_cartera',
                                                                      8,
                                                                      'vcempres = '
                                                                      || vcempres
                                                                      || ' p_sseguro = '
                                                                      || p_sseguro
                                                                      || ' movimiento = '
                                                                      || movimiento,
                                                                      num_err);
                                                               END IF;
                                                            END IF;
                                                         END IF;
                                                      END IF;
                                                   END IF;
                                                END IF;
                                             END IF;
                                          END IF;
                                       END IF;
                                    END IF;
                                 END IF;
                              END IF;
                           ELSE
                              algun_error := 1;
                              indice_error := indice_error + 1;
                           END IF;
                        END IF;
                     END IF;
                  END IF;
               ELSE   -- NO RENOVACI¿N, S¿LO RECIBO
                  ----Llamamos la funci¿n que actualiza datos de la pr¿xima cartera-----
                  num_err := f_acproxcar(p_sseguro, fcarantnueva, fcarpronueva, fcaranunueva,
                                         nanualinueva, nfraccinueva, frenovanueva);

                  --BUG 0011604 - FAL - 29/02/2010
                  IF p_sproduc = 375 THEN
                     BEGIN
                        SELECT fcaranu
                          INTO vfcaranu
                          FROM seguros
                         WHERE sseguro = p_sseguro;

                        IF fcarpronueva > vfcaranu THEN
                           --se escoge la fecha menor entre la fvencim del recibo y la fcaranu
                           fcarpronueva := vfcaranu;
                        END IF;
                     EXCEPTION
                        WHEN OTHERS THEN
                           NULL;
                     END;
                  END IF;

                  --Fi BUG 0011604 - FAL - 29/02/2010
                  IF num_err <> 0 THEN
                     algun_error := 1;
                     indice_error := indice_error + 1;
                  ELSE
                     BEGIN
                        UPDATE seguros
                           SET fcarant = fcarantnueva,
                               fcarpro = fcarpronueva,
                               fcaranu = fcaranunueva,
                               nanuali = nanualinueva,
                               nfracci = nfraccinueva,
                               frenova = frenovanueva
                         WHERE sseguro = p_sseguro;
                     EXCEPTION
                        WHEN OTHERS THEN
                           num_err := 102361;
                           algun_error := 1;
                           indice_error := indice_error + 1;
                     END;

                     -- No se genera movimiento de seguro. Se busca
                     -- el ¿ltimo movimiento vigente
                     num_err := f_buscanmovimi(p_sseguro, 1, 1, pnmovimi2);

                     -- el ¿ltimo movimiento vigente
                     IF num_err <> 0 THEN
                        algun_error := 1;
                        indice_error := indice_error + 1;
                     ELSE
                        IF p_cagrpro = 2 THEN
                           pcmovimi := 2;   -- indica aportaci¿n peri¿dica
                        ELSE
                           pcmovimi := NULL;
                        END IF;

                        --Llamamos la funci¿n de calcular recibos
                        IF NVL(pac_parametros.f_parempresa_n(pempresa, 'FEMISIO_IS_SYSDATE'),
                               0) = 1 THEN
                           vfemisio := f_sysdate;
                        ELSE
                           vfemisio := TO_DATE('1/' || TO_CHAR(TO_NUMBER(pmes)) || '/'
                                               || TO_CHAR(panyo),
                                               'dd/mm/yyyy');
                        END IF;

                        -- Se mira si es nueva producci¿n o cartera para
                        -- aplicar como modo de comision un 1 o un 2
                        IF f_es_renovacion(p_sseguro) = 0 THEN   -- es cartera
                           modcom := 2;
                        ELSE   -- si es 1 es nueva produccion
                           modcom := 1;
                        END IF;

                        --BUG9028-XVM-01102009 inici
                        IF NVL(pac_parametros.f_parinstalacion_n('CALCULO_RECIBO'), 1) = 0 THEN
                           IF (NVL(f_parproductos_v(p_sproduc, 'SEPARA_RIESGO_AHORRO'), 0) = 1
                               AND pac_seguros.f_tiene_garanahorro(NULL, p_sseguro,
                                                                   fcarpronueva) = 1)
                              OR NVL(f_parproductos_v(p_sproduc, 'SEPARA_RIESGO_AHORRO'), 0) =
                                                                                              0 THEN
                              num_err := pac_adm.f_recries(p_ctipreb, p_sseguro, NULL,
                                                           vfemisio, fcarantnueva,
                                                           fcarpronueva, 3, nanualinueva,
                                                           nfraccinueva, p_ccobban, NULL,
                                                           ppsproces, 22, 'R', modcom,
                                                           fcaranunueva, NULL, pcmovimi,
                                                           pempresa, pnmovimi2, 1, pnimport2);
                           END IF;
                        ELSE
                           IF (NVL(f_parproductos_v(p_sproduc, 'SEPARA_RIESGO_AHORRO'), 0) = 1
                               AND pac_seguros.f_tiene_garanahorro(NULL, p_sseguro,
                                                                   fcarpronueva) = 1)
                              OR NVL(f_parproductos_v(p_sproduc, 'SEPARA_RIESGO_AHORRO'), 0) =
                                                                                              0 THEN
                              num_err := f_recries(p_ctipreb, p_sseguro, NULL, vfemisio,
                                                   fcarantnueva, fcarpronueva, 3,
                                                   nanualinueva, nfraccinueva, p_ccobban,
                                                   NULL, ppsproces, 22, 'R', modcom,
                                                   fcaranunueva, NULL, pcmovimi, pempresa,
                                                   pnmovimi2, 1, pnimport2);
                           END IF;
                        END IF;

                        --BUG9028-XVM-01102009 fi
                        IF num_err <> 0 THEN
                           algun_error := 1;
                           indice_error := indice_error + 1;
                        ELSE
                           -- Bug 19096 - RSC - 03/08/2011 - LCOL - Parametrizaci¿n b¿sica producto Vida Individual Pagos Permanentes (Afegim 'RRIE')
                           IF NVL(f_parproductos_v(p_sproduc, 'SEPARA_RIESGO_AHORRO'), 0) = 1 THEN
                              IF NVL(pac_parametros.f_parinstalacion_n('CALCULO_RECIBO'), 1) =
                                                                                             0 THEN
                                 num_err := pac_adm.f_recries(p_ctipreb, p_sseguro, NULL,
                                                              vfemisio, fcarantnueva,
                                                              fcarpronueva, 3, nanualinueva,
                                                              nfraccinueva, p_ccobban, NULL,
                                                              ppsproces, 22, 'RRIE', modcom,
                                                              fcaranunueva, NULL, pcmovimi,
                                                              pempresa, pnmovimi2, 1,
                                                              pnimport2);
                              ELSE
                                 num_err := f_recries(p_ctipreb, p_sseguro, NULL, vfemisio,
                                                      fcarantnueva, fcarpronueva, 3,
                                                      nanualinueva, nfraccinueva, p_ccobban,
                                                      NULL, ppsproces, 22, 'RRIE', modcom,
                                                      fcaranunueva, NULL, pcmovimi, pempresa,
                                                      pnmovimi2, 1, pnimport2);
                              END IF;
                           END IF;

                           IF num_err <> 0 THEN
                              algun_error := 1;
                              indice_error := indice_error + 1;
                           END IF;

                           -- ini Bug 0022701 - 03/09/2012 - JMF
                           IF pac_retorno.f_tiene_retorno(NULL, p_sseguro, NULL) = 1 THEN
                              num_err := pac_retorno.f_generar_retorno(p_sseguro, pnmovimi2,
                                                                       NULL, ppsproces);

                              IF num_err <> 0 THEN
                                 algun_error := 1;
                                 indice_error := indice_error + 1;
                                 pnnumlin := NULL;
                                 texto := 'pac_retorno:' || f_axis_literales(num_err, pidioma);
                                 num_err := f_proceslin(ppsproces, texto, p_sseguro, pnnumlin);
                                 num_err := 0;
                              END IF;
                           END IF;

                           -- fin Bug 0022701 - 03/09/2012 - JMF

                           --Bug.: 20923 - 14/01/2012 - ICV
                           --Si todo OK env¿amos Todos recibos del movimiento al ERP.
                           IF NVL(pac_parametros.f_parempresa_n(pempresa, 'GESTIONA_COBPAG'),
                                  0) = 1
                              AND num_err = 0 THEN
                              num_err := pac_ctrl_env_recibos.f_proc_recpag_mov(pempresa,
                                                                                p_sseguro,
                                                                                pnmovimi2, 4,
                                                                                ppsproces);
                           /*IF num_err <> 0 THEN
                              algun_error := 1;
                              indice_error := indice_error + 1;
                           END IF;*/
                           END IF;
                        --Fin Bug.: 20923

                        -- Fin Bug 19096
                        END IF;
                     END IF;
                  END IF;
               END IF;
            END IF;

            IF algun_error = 0 THEN
               -- Se borran los registros de GARANCAR
               BEGIN
                  --
                  DELETE FROM garancar
                        WHERE sproces = ppsproces
                          AND sseguro = p_sseguro;

                  DELETE FROM garancarcom
                        WHERE sproces = ppsproces
                          AND sseguro = p_sseguro;

                  DELETE      preguncar
                        WHERE sproces = ppsproces
                          AND sseguro = p_sseguro;

                  DELETE      pregungarancar
                        WHERE sproces = ppsproces
                          AND sseguro = p_sseguro;

                  DELETE      pregunpolcar
                        WHERE sproces = ppsproces
                          AND sseguro = p_sseguro;

                  DELETE      tmp_garanseg
                        WHERE sseguro = p_sseguro;
               EXCEPTION
                  WHEN OTHERS THEN
                     NULL;
               END;

               -- Se graba el seguro en la tabla SEGCARTERA
               num_err := f_inssegcartera(ppsproces, p_sseguro, p_fcarpro, p_fcaranu,
                                          p_fcarant, p_nanuali, p_nfracci);

               IF num_err <> 0 THEN
                  algun_error := 1;
                  indice_error := indice_error + 1;
               ELSE
                  pcorrecte := 1;
                  p_fcarant := fcarantnueva;
                  p_fcarpro := fcarpronueva;
                  p_fcaranu := fcaranunueva;
                  p_nanuali := nanualinueva;
                  p_nfracci := nfraccinueva;
               END IF;
            END IF;
         END LOOP;
      END IF;

      --
      -- Por ultimo, trataremos los recibos extraordinarios
      --
      FOR r_dat IN c_motextra LOOP
         num_err := f_prevrecriesextra(r_dat.sseguro, pempresa, ppsproces, 'R', pnrecibo);

         IF num_err <> 0 THEN
            RETURN num_err;
         ELSE
            BEGIN
               UPDATE extrarec
                  SET nrecibo = pnrecibo
                WHERE sseguro = r_dat.sseguro
                  AND nrecibo IS NULL
                  AND ADD_MONTHS(falta, f_parinstalacion_n('CEXTRNMES')) <= f_sysdate;
            EXCEPTION
               WHEN OTHERS THEN
                  RETURN 111939;   -- Error actualizando la tabla EXTRAREC
            END;
         END IF;
      END LOOP;

      RETURN num_err;
   END p_cartera;

----------------------------------------------------------------------------------------
   -- ini Bug 0016856 - 26/01/2011 - JMF
   -- Bug 0020932 - 20/01/2012 - JMF
   /***********************************************************************
      Funci¿n que ejecuta acciones de forma din¿mica, para el producto del seguro
      param in pn_sproces      : N¿mero de proceso cartera, para guardar incidencias.
      param in pn_sproduc      : Producto del que tenemos que buscar posibles acciones a realizar.
      param in pn_sseguro      : Seguro en el que realizarmos las acciones.
      param in pd_fecha        : Fecha de cartera.
      return                   : Number (0 --> Correcto, 1 --> Error).
   ***********************************************************************/
   FUNCTION f_genera_acc_cartera(
      pn_ctipo IN NUMBER,
      pn_sproces IN NUMBER,
      pn_sproduc IN NUMBER,
      pn_sseguro IN NUMBER,
      pd_fecha IN DATE)
      RETURN NUMBER IS
      vobject        VARCHAR2(200) := 'PAC_DINCARTERA.F_GENERA_ACC_CARTERA';
      vparam         VARCHAR2(400)
         := 't=' || pn_ctipo || ' p= ' || pn_sproduc || ' s=' || pn_sseguro || ' f='
            || pd_fecha;
      vpasexec       NUMBER := 1;
      ss             VARCHAR2(3000);
      v_cursor       NUMBER;
      retorno        NUMBER;
      v_filas        NUMBER;
      texto          procesoslin.tprolin%TYPE;
      num_lin        NUMBER;
      num_err        NUMBER;
      n_procerror    NUMBER;
      n_idioma       NUMBER := pac_parametros.f_parempresa_n(f_empres, 'IDIOMA_DEF');
   BEGIN
      n_procerror := 0;

      -- Bug 0020932 - 20/01/2012 - JMF: El producto solicitado mas el generico (producto 0).
      FOR f3 IN (SELECT   norden, dinaccion, tcampo
                     FROM pds_acc_cartera
                    WHERE sproduc = pn_sproduc
                      AND ctipo = pn_ctipo
                 UNION
                 SELECT   norden, dinaccion, tcampo
                     FROM pds_acc_cartera p1
                    WHERE sproduc = 0
                      AND ctipo = pn_ctipo
                 ORDER BY 1) LOOP
         IF f3.dinaccion = 'F' THEN
            ss := 'BEGIN ' || ' :RETORNO := ' || f3.tcampo || ' ; ' || 'END;';

            IF DBMS_SQL.is_open(v_cursor) THEN
               DBMS_SQL.close_cursor(v_cursor);
            END IF;

            v_cursor := DBMS_SQL.open_cursor;
            DBMS_SQL.parse(v_cursor, ss, DBMS_SQL.native);
            DBMS_SQL.bind_variable(v_cursor, ':RETORNO', retorno);

            IF INSTR(ss, ':FECHA') > 0 THEN
               DBMS_SQL.bind_variable(v_cursor, ':FECHA', pd_fecha);
            END IF;

            IF INSTR(ss, ':SSEGURO') > 0 THEN
               DBMS_SQL.bind_variable(v_cursor, ':SSEGURO', pn_sseguro);
            END IF;

            -- ini Bug 0018967 - 30/09/2011 - JMF
            IF INSTR(ss, ':SPROCES') > 0 THEN
               DBMS_SQL.bind_variable(v_cursor, ':SPROCES', pn_sproces);
            END IF;

            -- fin Bug 0018967 - 30/09/2011 - JMF
            v_filas := DBMS_SQL.EXECUTE(v_cursor);
            DBMS_SQL.variable_value(v_cursor, 'RETORNO', retorno);

            IF DBMS_SQL.is_open(v_cursor) THEN
               DBMS_SQL.close_cursor(v_cursor);
            END IF;

            IF retorno = 0 THEN
               COMMIT;
            ELSE
               ROLLBACK;
               n_procerror := 1;
               texto := SUBSTR(vobject || ' (' || pn_sproduc || '/' || f3.norden || ')' || ' '
                               || f_axis_literales(retorno, n_idioma),
                               1, 120);
               num_lin := NULL;
               num_err := f_proceslin(pn_sproces, texto, pn_sseguro, num_lin);

               IF num_err = 0 THEN
                  COMMIT;
               END IF;
            END IF;
         END IF;
      END LOOP;

      RETURN n_procerror;
   END f_genera_acc_cartera;

   -- fin Bug 0016856 - 26/01/2011 - JMF
----------------------------------------------------------------------------------------

   -- ini Bug 0018967 - 30/09/2011 - JMF
   /***********************************************************************
      Funci¿n que ejecuta acciones de forma din¿mica, despues de finalizar la cartera.
      param in pn_sproces      : N¿mero de proceso cartera
      return                   : Number (0 --> Correcto, 1 --> Error).
   ***********************************************************************/
   FUNCTION f_post_cartera_producte(p_sproces IN NUMBER)
      RETURN NUMBER IS
      vobject        VARCHAR2(200) := 'PAC_DINCARTERA.F_POST_CARTERA_PRODUCTE';
      vparam         VARCHAR2(400) := 'p=' || p_sproces;
      vpasexec       NUMBER := 1;
      v_cempres      procesoscab.cempres%TYPE;
      v_propio       parempresas.tvalpar%TYPE;
      v_sent         VARCHAR2(3000);
      v_cursor       NUMBER;
      v_filas        NUMBER;
      v_retorno      NUMBER;
      ex_nodeclared  EXCEPTION;
      PRAGMA EXCEPTION_INIT(ex_nodeclared, -6550);
   -- Se debe declarar el componente
   BEGIN
      SELECT cempres
        INTO v_cempres
        FROM procesoscab
       WHERE sproces = p_sproces;

      SELECT pac_parametros.f_parempresa_t(v_cempres, 'PAC_PROPIO')
        INTO v_propio
        FROM DUAL;

      v_sent := 'BEGIN :RETORNO := ' || v_propio || '.f_post_cartera_producte(' || p_sproces
                || '); END;';

      IF DBMS_SQL.is_open(v_cursor) THEN
         DBMS_SQL.close_cursor(v_cursor);
      END IF;

      v_cursor := DBMS_SQL.open_cursor;
      DBMS_SQL.parse(v_cursor, v_sent, DBMS_SQL.native);
      DBMS_SQL.bind_variable(v_cursor, ':RETORNO', v_retorno);
      v_filas := DBMS_SQL.EXECUTE(v_cursor);
      DBMS_SQL.variable_value(v_cursor, 'RETORNO', v_retorno);

      IF DBMS_SQL.is_open(v_cursor) THEN
         DBMS_SQL.close_cursor(v_cursor);
      END IF;

      RETURN v_retorno;
   EXCEPTION
      WHEN ex_nodeclared THEN
         IF DBMS_SQL.is_open(v_cursor) THEN
            DBMS_SQL.close_cursor(v_cursor);
         END IF;

         RETURN 0;
   END f_post_cartera_producte;

   -- fin Bug 0018967 - 30/09/2011 - JMF

   -- BUG 0019627: GIP102 - Reunificaci¿n de recibos - FAL - 10/11/2011 -- Renovaci¿n de certificados 0 si RECUNIF = 3 (agrupaci¿n de recibos seg¿n forma pago certif 0)
   FUNCTION f_cartera_certif0(
      pcramo IN NUMBER,
      pcmodali IN NUMBER,
      pctipseg IN NUMBER,
      pccolect IN NUMBER,
      pmes IN NUMBER,
      panyo IN NUMBER,
      pfcartera IN DATE,
      pempresa IN NUMBER,
      pfemisio IN DATE,
      pidioma IN NUMBER,
      psproces IN NUMBER,
      indice IN OUT NUMBER,
      indice_error IN OUT NUMBER,
      psseguro IN NUMBER DEFAULT NULL,
      pnpoliza IN NUMBER DEFAULT NULL,
      pncertif IN NUMBER DEFAULT NULL)
      RETURN NUMBER IS
      CURSOR c_seg_certif0 IS
         SELECT *
           FROM seguros
          WHERE cramo = pcramo
            AND cmodali = pcmodali
            AND ctipseg = pctipseg
            AND ccolect = pccolect
            AND sseguro = NVL(psseguro, sseguro)   --AMC
            AND((csituac = 5)
                OR(creteni = 0
                   AND csituac NOT IN(7, 8, 9, 10)))
            AND fcarpro < NVL(pfcartera,
                              (LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo, 'mmyyyy')) + 1))
            --           AND (fvencim > (last_day(to_date(lpad(pmes,2,'0')||panyo,'mmyyyy'))) OR fvencim is null)
            AND(fvencim > NVL(pfcartera,
                              (LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo, 'mmyyyy'))))
                OR(fvencim <= NVL(pfcartera,
                                  (LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo, 'mmyyyy'))))
                   AND TO_CHAR(fvencim, 'mmyyyy') = LPAD(pmes, 2, '0') || panyo
                   AND fvencim > fcarpro
                   AND NVL(f_parproductos_v(sproduc, 'RECMESVENCI'), 1) = 1)
                OR fvencim IS NULL)
            AND(EXISTS(SELECT sseguro
                         FROM movseguro m
                        WHERE nmovimi = (SELECT MAX(nmovimi)
                                           FROM movseguro m3
                                          WHERE m3.sseguro = m.sseguro
                                            AND TRUNC(m3.fefecto) <=
                                                  NVL(pfcartera,
                                                      LAST_DAY(TO_DATE(LPAD(pmes, 2, '0')
                                                                       || panyo,
                                                                       'mmyyyy')))
                                            AND m3.cmovseg NOT IN(6, 52))
                          AND cmovseg <> 3
                          AND femisio IS NOT NULL
                          AND sseguro = seguros.sseguro)
                OR(csituac = 5
                   AND ccartera = 1))
            AND npoliza = NVL(pnpoliza, npoliza)
            AND ncertif = NVL(pncertif, ncertif)
            AND(NVL(f_parproductos_v(f_sproduc_ret(cramo, cmodali, ctipseg, ccolect),
                                     'RECUNIF'),
                    0) = 3
                AND ncertif = 0)
            -- Bug 23940 - APD - 13/11/2012 - la poliza no puede estar bloqueada
            AND NVL(cbloqueocol, 0) = 0;

      CURSOR c_recs_certifn(pnpoliza IN NUMBER) IS   -- Recibos de certificados N para pnpoliza con certif 0
         SELECT r.nrecibo
           FROM recibos r, seguros s
          WHERE r.sseguro = s.sseguro
            AND s.npoliza = pnpoliza
            AND s.ncertif <> 0
            AND NVL(f_cestrec(r.nrecibo, NULL), 0) = 0
            -- que no esten cobrados
            AND r.nrecibo NOT IN(SELECT nrecibo
                                   FROM adm_recunif)
/*
            AND TRUNC(r.fefecto) >= (SELECT NVL(fcarant, fefecto)
                                       FROM seguros
                                      WHERE npoliza = pnpoliza
                                        AND ncertif = 0)
*/
            AND TRUNC(r.fefecto) <= (SELECT fcarpro
                                       FROM seguros
                                      WHERE npoliza = pnpoliza
                                        AND ncertif = 0);

      v_listarec     t_lista_id;
      v_obrec        ob_lista_id;
      num_err        NUMBER := 0;
      fcarantnueva   DATE;
      fcarpronueva   DATE;
      fcaranunueva   DATE;
      nanualinueva   NUMBER;
      nfraccinueva   NUMBER;
      frenovanueva   DATE;
      texto          VARCHAR2(400);
      num_lin        NUMBER;
      waux           NUMBER;
   BEGIN
      FOR reg IN c_seg_certif0 LOOP
         indice := indice + 1;
         v_listarec := t_lista_id();   -- crea lista

         -- v_listarec := NULL;
         FOR rebs IN c_recs_certifn(reg.npoliza) LOOP
            -- Necesario para la agrupacion
            UPDATE recibos
               SET cestaux = 2
             WHERE nrecibo = rebs.nrecibo;

            v_obrec := ob_lista_id();   -- crea objeto lista
            v_obrec.idd := rebs.nrecibo;
            v_listarec.EXTEND;
            v_listarec(v_listarec.LAST) := v_obrec;
         END LOOP;

         waux := 0;

         SELECT COUNT(*)
           INTO waux
           FROM recibos r, seguros s
          WHERE r.sseguro = s.sseguro
            AND s.npoliza = reg.npoliza
            AND s.ncertif <> 0
            --AND r.cestaux = 2
            --AND r.fefecto <= s.fcarpro
            AND r.fefecto BETWEEN s.fcarant AND s.fcarpro
            AND NVL(f_cestrec(r.nrecibo, NULL), 0) = 0
            -- que no esten cobrados
            AND r.nrecibo NOT IN(SELECT nrecibo
                                   FROM adm_recunif);

         IF waux > 0 THEN
            num_err := pac_gestion_rec.f_agruparecibo(f_sproduc_ret(pcramo, pcmodali,
                                                                    pctipseg, pccolect),
                                                      NULL, pfemisio, pempresa, v_listarec);
         END IF;

         IF num_err = 0 THEN
            num_err := f_acproxcar(reg.sseguro, fcarantnueva, fcarpronueva, fcaranunueva,
                                   nanualinueva, nfraccinueva, frenovanueva);

            IF num_err <> 0 THEN
               --algun_error := 1;
               indice_error := indice_error + 1;
            ELSE
               BEGIN
                  UPDATE seguros
                     SET fcarant = fcarantnueva,
                         fcarpro = fcarpronueva,
                         fcaranu = fcaranunueva,
                         nanuali = nanualinueva,
                         nfracci = nfraccinueva,
                         frenova = frenovanueva
                   WHERE sseguro = reg.sseguro;
               EXCEPTION
                  WHEN OTHERS THEN
                     num_err := 102361;
                     --algun_error := 1;
                     indice_error := indice_error + 1;
               END;
            END IF;
         ELSE
            ROLLBACK;
            texto := f_axis_literales(num_err, pidioma);
            texto := texto || '.' || reg.sseguro;
            num_lin := NULL;
            num_err := f_proceslin(psproces, texto, reg.sseguro, num_lin);

            IF num_err = 0 THEN
               COMMIT;
            END IF;

            RETURN num_err;
         END IF;
      END LOOP;

      -- 1 cursor sobre polizas a renovar del certificado 0
      -- dentro del lopp, otro para recibos a unificar de la poliza
      RETURN 0;
   END f_cartera_certif0;

   -- FI Bug 19627

   -- Bug 23940 - APD - 18/10/2012 - se crea la funcion
   FUNCTION f_genera_cartera_psu(
      v_seg IN OUT seguros%ROWTYPE,
      pempresa IN NUMBER,
      psproces IN NUMBER,
      pmes IN NUMBER,
      panyo IN NUMBER,
      pfemisio IN DATE,
      pidioma IN NUMBER,
      lmoneda IN NUMBER,
      lcsubpro IN NUMBER,
      lcobjase IN NUMBER,
      lcagrpro IN NUMBER,
      lcgarant_regu IN NUMBER,
      lnorden IN NUMBER,
      lcprimin IN NUMBER,
      liprimin IN NUMBER,
      lcclapri IN NUMBER,
      lnedamar IN NUMBER,
      lciedmar IN NUMBER,
      indice IN OUT NUMBER,
      indice_error IN OUT NUMBER)
      RETURN NUMBER IS
      num_err        NUMBER := 0;
      vtraza         NUMBER := 0;
      texto          VARCHAR2(400);
      num_lin        NUMBER;
      v_seguir       BOOLEAN;
      v_existe       NUMBER;
      pcorrecte      NUMBER := 0;
      algun_error    NUMBER := 0;
      vcreteni       NUMBER;   -- Bug 23940 - APD - 17/10/2012
      vsaltapsu      NUMBER := 0;
      v_nmovimi      NUMBER;   -- BUG19069:DRA:04/11/2011
      v_fcarproa_ant DATE := v_seg.fcarpro;
   --Mantis 34469/0205354 - BLA - DD25/MM05/2015.
   BEGIN
      -- BUG17886:DRA:04/03/2010:Inici: Comprovem que no hagin canviat les condicions de la p¿lissa
      -- Pot passar que la p¿lissa s'anul.li en el moment de passar cartera i que el cursor principal
      -- no la detecti llavors com anulada
      v_seguir := TRUE;

      --v_fcarproa_ant := v_seg.fcarpro;   --Mantis 34469/0205354 - BLA - DD25/MM05/2015.
      IF NOT((v_seg.csituac = 5)
             OR(v_seg.creteni = 0
                AND v_seg.csituac NOT IN(7, 8, 9, 10))) THEN
         v_seguir := FALSE;
      END IF;

      SELECT COUNT(1)
        INTO v_existe
        FROM movseguro m
       WHERE m.nmovimi = (SELECT MAX(m3.nmovimi)
                            FROM movseguro m3
                           WHERE m3.sseguro = m.sseguro
                             AND TRUNC(m3.fefecto) <=
                                        LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo, 'mmyyyy'))
                             AND m3.cmovseg NOT IN(6, 52))
         -- Bug 29665/177284 - 12/06/2014 - AMC
         AND m.cmovseg <> 3
         AND m.femisio IS NOT NULL
         AND m.sseguro = v_seg.sseguro;

      IF NOT(v_existe > 0
             OR(v_seg.csituac = 5
                AND v_seg.ccartera = 1)) THEN
         v_seguir := FALSE;
      END IF;

      -- BUG17886:DRA:04/03/2010:Fi
      pcorrecte := 0;
      vtraza := 1;

      IF v_seguir THEN
         -- Bug 7926 - 27/05/2009 - RSC - Fecha de vencimiento a nivel de garant¿a
         IF pac_anulacion.f_anula_vto_cartera(v_seg.sseguro, NULL, v_seg.fcarpro) = 1 THEN
            vtraza := 2;
            num_err := pac_anulacion.f_anula_vto_garantias(v_seg.sseguro, v_seg.fcarpro,
                                                           psproces);
         END IF;

         IF num_err <> 0 THEN
            ROLLBACK;
            texto := f_axis_literales(num_err, pidioma);
            texto := texto || '.' || v_seg.sseguro;
            num_lin := NULL;
            num_err := f_proceslin(psproces, texto, v_seg.sseguro, num_lin);

            IF num_err = 0 THEN
               COMMIT;
            END IF;
         ELSE
            vtraza := 3;
            -- Fin Bug 7926
            -- ini Bug 0020932 - 20/01/2012 - JMF: Procesos din¿mics abans de fer cartera.
            num_err := pac_dincartera.f_genera_acc_cartera(0, psproces, v_seg.sproduc,
                                                           v_seg.sseguro, v_seg.fcarpro);
            vtraza := 4;

            IF num_err = 1 THEN
               ROLLBACK;
               algun_error := 1;
               indice_error := indice_error + 1;
            ELSE
               -- fin Bug 0020932 - 20/01/2012
               BEGIN
                  vtraza := 5;
                  num_err := p_cartera_psu(lmoneda, pidioma, pmes, panyo, v_seg.sseguro,
                                           v_seg.cramo, v_seg.cmodali, v_seg.ctipseg,
                                           v_seg.ccolect, v_seg.ctarman, v_seg.ccobban,
                                           v_seg.nrenova, v_seg.ctipreb, v_seg.cforpag,
                                           v_seg.nduraci, v_seg.ndurcob, v_seg.cactivi,
                                           lcsubpro, lcobjase, lcagrpro, v_seg.fefecto,
                                           v_seg.fvencim, v_seg.fcarpro, v_seg.fcaranu,
                                           v_seg.nanuali, v_seg.nfracci, v_seg.fcarant,
                                           psproces, indice, indice_error, pfemisio,
                                           pcorrecte, v_seg.sproduc, v_seg.nsuplem,
                                           lcgarant_regu, lnorden, lcprimin, liprimin,
                                           lcclapri, lnedamar, lciedmar, pempresa,
                                           v_seg.csituac, vcreteni);
                  vtraza := 6;

                  -- bug 19416:ASN:11/11/2011 ini
                  -- Bug 23940 - APD - 18/10/2012 - si vcreteni = 0 no ha habido
                  -- error por controles de PSU
                  IF num_err = 0
                     AND NVL(vcreteni, 0) = 0 THEN
                     -- si ha quedado previamente en Propuesta de Cartera
                     -- si ahora ha ido todo bien, dejar la poliza nuevamente
                     -- vigente
                     UPDATE seguros
                        SET csituac = 0
                      WHERE sseguro = v_seg.sseguro
                        AND csituac = 17;

                     -- fin Bug 23940 - APD - 18/10/2012
                     IF pac_propio.f_esta_en_exoneracion(v_seg.sseguro) = 1 THEN
                        vtraza := 7;
                        num_err := pac_propio.f_exonera_recibos(v_seg.sseguro, pfemisio);
                     END IF;
                  -- Bug 23940 - APD - 18/10/2012
                     -- hay error de controles de PSU
                  ELSIF num_err = 0
                        AND NVL(vcreteni, 0) != 0 THEN
                     -- dejar la poliza en Propuesta de Cartera Pendiente Autorizaci¿n
                     UPDATE seguros
                        SET csituac = 17,
                            creteni = 2
                      WHERE sseguro = v_seg.sseguro;

                     vsaltapsu := 1;
                  END IF;

                  -- fin Bug 23940 - APD - 18/10/2012

                  -- bug 19416:ASN:11/11/2011 fin
                  --Bug 23940 - APD - 22/10/2012 - si ha habido errores de PSU
                  -- realizar el commit (esto de momento hasta que se saque de la
                  -- cartera_producte la funcion pac_corretaje.f_tiene_corretaje
                  -- que tiene que ir en p_cartera, pues sino no se ejecutar¿
                  -- la funcion pac_corretaje.f_tiene_corretaje para los certificados
                  -- de colectivos)
                  IF vsaltapsu = 1 THEN
                     COMMIT;
                  ELSIF num_err = 0 THEN
                  -- Bug 26341 - APD - 22/03/2013 - el reparto del correteje
                  -- se extrae de esta funcion ya que no se quiere que se ejecute
                  -- para el ncertif = 0
/*
                     -- BUG19069:DRA:03/10/2011:Inici
                     IF pac_corretaje.f_tiene_corretaje(v_seg.sseguro, NULL) = 1 THEN
                        SELECT MAX(m.nmovimi)
                          INTO v_nmovimi
                          FROM movseguro m
                         WHERE m.sseguro = v_seg.sseguro;

                        num_err := pac_corretaje.f_reparto_corretaje(v_seg.sseguro, v_nmovimi,
                                                                     NULL);
                     END IF;

                     IF num_err <> 0 THEN
                        ROLLBACK;
                        algun_error := 1;
                        indice_error := indice_error + 1;
                        texto := f_axis_literales(num_err, pidioma);
                        texto := texto || '.' || v_seg.sseguro;
                        num_lin := NULL;
                        num_err := f_proceslin(psproces, texto, v_seg.sseguro, num_lin);

                        IF num_err = 0 THEN
                           COMMIT;
                        END IF;

                        p_tab_error(f_sysdate, f_user, 'pac_dincartera.cartera_producte', 1,
                                    'pempresa = ' || pempresa || ' v_seg.npoliza = '
                                    || v_seg.npoliza || ' v_seg.ncertif = ' || v_seg.ncertif
                                    || ' v_seg.sseguro = ' || v_seg.sseguro || ' pmes = '
                                    || pmes || ' panyo = ' || panyo || ' psproces = '
                                    || psproces || ' pfemisio = ' || pfemisio || 'pidioma = '
                                    || pidioma || 'num_err = ' || num_err,
                                    texto);
                     END IF;

                     -- BUG19069:DRA:29/09/2011:Fi
*/
                  -- fin Bug 26341 - APD - 22/03/2013
                     COMMIT;
                  ELSE
                     ROLLBACK;
                     vtraza := 8;
                     texto := f_axis_literales(num_err, pidioma);
                     texto := texto || '.' || v_seg.sseguro;
                     num_lin := NULL;
                     num_err := f_proceslin(psproces, texto, v_seg.sseguro, num_lin);

                     IF num_err = 0 THEN
                        COMMIT;
                     END IF;
                  END IF;

                  /* --Inicio Mantis 34469/0205354 - BLA - DD25/MM05/2015.
                   num_err := pac_dincartera.f_modif_cmovseg_aniversario(v_seg.sseguro,
                                                                         v_fcarproa_ant);

                   IF num_err = 0 THEN
                      COMMIT;
                   ELSE
                      ROLLBACK;
                      algun_error := 1;
                      indice_error := indice_error + 1;
                      texto := f_axis_literales(num_err, pidioma);
                      texto := texto || '.' || v_seg.sseguro;
                      num_lin := NULL;
                      num_err := f_proceslin(psproces, texto, v_seg.sseguro, num_lin);
                   END IF;

                   -- Fin Mantis 34469/0205354 - BLA - DD25/MM05/2015.
                   */
                  vtraza := 9;
                  -- ini Bug 0020932 - 20/01/2012 - JMF: Procesos din¿mics despres de fer cartera.
                  num_err := pac_dincartera.f_genera_acc_cartera(1, psproces, v_seg.sproduc,
                                                                 v_seg.sseguro, v_seg.fcarpro);

                  IF num_err = 1 THEN
                     algun_error := 1;
                     indice_error := indice_error + 1;
                  END IF;
               -- fin Bug 0016856 - 26/01/2011 - JMF
               EXCEPTION
                  WHEN OTHERS THEN
                     p_tab_error(f_sysdate, f_user, 'PAC_DINCARTERA', vtraza, 'ERROR 111533',
                                 SQLERRM);
                     --DBMS_OUTPUT.put_line (SQLERRM);
                     RETURN 111533;
               END;
            END IF;
         END IF;
      END IF;

      RETURN 0;
   END f_genera_cartera_psu;

----------------------------------------------------------------------------------------
   FUNCTION cartera_producte(
      pempresa IN NUMBER,
      psproces_prod IN NUMBER,
      psproces IN NUMBER,
      pmes IN NUMBER,
      panyo IN NUMBER,
      pidioma IN NUMBER,
      pmoneda IN NUMBER,
      pfemisio IN DATE,
      indice OUT NUMBER,
      indice_error OUT NUMBER,
      psseguro IN NUMBER DEFAULT NULL,
      pnpoliza IN NUMBER DEFAULT NULL,
      pncertif IN NUMBER DEFAULT NULL,
      pskiprenova IN NUMBER DEFAULT NULL,
      prenovcero IN NUMBER DEFAULT 0,
      pfcartera IN DATE DEFAULT NULL)
      RETURN NUMBER IS
      --
      fecha_empresa  DATE;
      fecha_producto DATE;
      num_total_registres NUMBER;
      v_seg          seguros%ROWTYPE;
      cartera        NUMBER;
      encontrado     NUMBER := 0;
      --      PCRAMO                  NUMBER;
      --      PCMODALI                        NUMBER;
      --      PCTIPSEG                        NUMBER;
      --      PCCOLECT                        NUMBER;
      --      PPRODUCTO                       VARCHAR2(70);
      curblk         VARCHAR2(30);
      codi_ramo      NUMBER;
      mes_conta      DATE;
      pcsubpro       NUMBER;
      algun_error    NUMBER := 0;
      num_err        NUMBER := 0;
      num_err2       NUMBER := 0;
      prevcap        NUMBER(13, 2);
      texto          VARCHAR2(500);
      piprima        NUMBER(13, 2);
      psperson       NUMBER(6);
      conta_proces   NUMBER;
      error          NUMBER;
      fcarpronueva   DATE := NULL;
      fcarantnueva   DATE := NULL;
      fcaranunueva   DATE := NULL;
      nanualinueva   NUMBER := NULL;
      frenovanueva   DATE := NULL;
      nfraccinueva   NUMBER;
      pnrecibo       NUMBER;
      tipo           NUMBER;
      pcobjase       NUMBER;
      pnduraci       NUMBER;
      pndurcob       NUMBER;
      fec            VARCHAR2(20);
      texto2         VARCHAR2(60);
      pcagrpro       NUMBER;
      num            NUMBER;
      ttexto         VARCHAR2(30);
      piregula       NUMBER;
      ptempresa      VARCHAR2(70);
      pnnumlin       NUMBER;
      pcactivi       NUMBER;
      num_risc       NUMBER;
      pnimport2      NUMBER;
      pcmovimi       NUMBER;
      pnmovimi2      NUMBER;
      movimiento     NUMBER;
      anulado        NUMBER;
      fecha_carpro   DATE;
      fecha_carant   DATE;
      dia            VARCHAR2(4);
      fechini        DATE;
      primaant       NUMBER;
      pfech          DATE;
      prima          NUMBER;
      modcom         NUMBER;
      fultrenova     DATE;
      nmovimi        NUMBER;
      vwhere         VARCHAR2(100);
      vccarpro       NUMBER;
      num_prod       NUMBER;
      pcorrecte      NUMBER := 0;
      wrecord        NUMBER;
      lcsubpro       NUMBER;
      lcobjase       NUMBER;
      lcagrpro       NUMBER;
      num_lin        NUMBER;
      lcprimin       NUMBER;
      liprimin       NUMBER;
      lcclapri       NUMBER;
      lcgarant_regu  NUMBER;
      lnorden        NUMBER;
      lmoneda        NUMBER;
      -- NO UTILITZEM LA MONEDA DEL PAR¿METRE SINO LA DEL PRODUCTE
      lnedamar       NUMBER;
      lciedmar       NUMBER;
      cont_fec_ant   NUMBER;
      excep_supl     EXCEPTION;
      v_sproduc      NUMBER;
      -- Bug 9383 - 04/03/2009 - RSC - CRE: Unificaci¿n de recibos
      vfcarant       DATE;
      -- Fin Bug 9383
      v_count        NUMBER;
      --bug 16146--07/10/2010 - ETM --CEM - Fechas de cartera en procesos previo y real
      fcarant_min    DATE;
      fcarpro_min    DATE;
      --FIN bug 16146
      -- BUG17886:DRA:04/03/2011:Inici
      v_seguir       BOOLEAN;
      v_existe       NUMBER;
      v_nmovimi      NUMBER;   -- BUG19069:DRA:04/11/2011
      -- BUG17886:DRA:04/03/2011:Fi
      v_es_col_admin NUMBER;   -- Bug 23940 - APD - 06/11/2012
      v_es_col_agrup NUMBER;   -- Bug 23940 - APD - 06/11/2012
      vnmovimi_out   NUMBER;   -- Bug 23940 - APD - 26/10/2012
      vrecunif       NUMBER;   -- Bug 28640/160626 - 25/03/2014 - AMC
      vadmincertif   NUMBER;   -- Bug 28640/160626 - 25/03/2014 - AMC
      v_traza        NUMBER := 0;
      v_fcarproa_ant DATE := v_seg.fcarpro;
      indice_error_certif0 NUMBER := 0;
      -- BUG 0038828 - FAL - 11/12/2015
      indice_error_certifx NUMBER := 0;

      -- BUG 0038828 - FAL - 11/12/2015

      --Mantis 34469/0205354 - BLA - DD25/MM05/2015.

      -- A¿ado a la select la select a seguroscar para que las polizas que no han realizado los supl. de cartera de forma correcta no pasen la cartera.
      -- Modificaci¿n de la select para que las poliza en propuesta de suplemento y ccartera = 1 pasen cartera, a¿adimos un parametro al p_cartera para que sepa la situaci¿n de la poliza.
      -- Pasamos el cempres que obtenemos del pcempres por parametro al procedimiento p_cartera.
      CURSOR c_prod IS
         SELECT *
           FROM carteraaux
          WHERE sproces = psproces_prod;

      CURSOR c_seg(wram NUMBER, wmod NUMBER, wtip NUMBER, wcol NUMBER) IS
         SELECT s.*
           FROM seguros s, seguroscol sc, agentes_agente_pol aa
          WHERE s.cempres = aa.cempres
            -- Al ser cartera descentralizada incluimos el nivel de visi¿n
            AND s.cagente = aa.cagente
            AND s.cramo = wram
            AND s.cmodali = wmod
            AND s.ctipseg = wtip
            AND s.ccolect = wcol
            AND s.sseguro = NVL(psseguro, s.sseguro)   --AMC
            AND s.sseguro = sc.sseguro(+)
            AND((s.csituac = 5)
                OR(s.creteni = 0
                   AND s.csituac NOT IN(7, 8, 9, 10)))
            AND s.fcarpro < DECODE(pfcartera,
                                   NULL, DECODE
                                             (sc.ctipcob,
                                              1, ADD_MONTHS
                                                          ((LAST_DAY(TO_DATE(LPAD(pmes, 2, '0')
                                                                             || panyo,
                                                                             'mmyyyy'))
                                                            + 1),
                                                           -1),
                                              (LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo,
                                                                'mmyyyy'))
                                               + 1)),
                                   DECODE(sc.ctipcob,
                                          1, ADD_MONTHS(pfcartera + 1, -1),
                                          pfcartera + 1))
            AND(s.fvencim > DECODE(pfcartera,
                                   NULL, DECODE
                                              (sc.ctipcob,
                                               1, ADD_MONTHS
                                                           ((LAST_DAY(TO_DATE(LPAD(pmes, 2,
                                                                                   '0')
                                                                              || panyo,
                                                                              'mmyyyy'))),
                                                            -1),
                                               (LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo,
                                                                 'mmyyyy')))),
                                   DECODE(sc.ctipcob, 1, ADD_MONTHS(pfcartera, -1), pfcartera))
                OR(s.fvencim <=
                      DECODE(pfcartera,
                             NULL, DECODE(sc.ctipcob,
                                          1, ADD_MONTHS((LAST_DAY(TO_DATE(LPAD(pmes, 2, '0')
                                                                          || panyo,
                                                                          'mmyyyy'))),
                                                        -1),
                                          (LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo,
                                                            'mmyyyy')))),
                             DECODE(sc.ctipcob, 1, ADD_MONTHS(pfcartera, -1), pfcartera))
                   AND TO_CHAR(s.fvencim, 'mmyyyy') =
                         DECODE(pfcartera,
                                NULL, DECODE(sc.ctipcob,
                                             1, TO_CHAR(ADD_MONTHS(TO_DATE('01'
                                                                           || LPAD(pmes, 2,
                                                                                   '0')
                                                                           || panyo,
                                                                           'ddmmyyyy'),
                                                                   -1),
                                                        'mmyyyy'),
                                             LPAD(pmes, 2, '0') || panyo),
                                DECODE(sc.ctipcob,
                                       1, TO_CHAR(ADD_MONTHS(pfcartera, -1), 'mmyyyy'),
                                       TO_CHAR(pfcartera, 'mmyyyy')))
                   AND s.fvencim > s.fcarpro
                   AND NVL(f_parproductos_v(s.sproduc, 'RECMESVENCI'), 1) = 1)
                OR s.fvencim IS NULL)
            AND(EXISTS(
                   SELECT sseguro
                     FROM movseguro m
                    WHERE nmovimi =
                             (SELECT MAX(nmovimi)
                                FROM movseguro m3
                               WHERE m3.sseguro = m.sseguro
                                 AND TRUNC(m3.fefecto) <=
                                       DECODE
                                          (pfcartera,
                                           NULL, DECODE
                                               (sc.ctipcob,
                                                1, ADD_MONTHS
                                                            (LAST_DAY(TO_DATE(LPAD(pmes, 2,
                                                                                   '0')
                                                                              || panyo,
                                                                              'mmyyyy')),
                                                             -1),
                                                LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo,
                                                                 'mmyyyy'))),
                                           DECODE(sc.ctipcob,
                                                  1, ADD_MONTHS(pfcartera, -1),
                                                  pfcartera))
                                 AND m3.cmovseg NOT IN(6, 52))
                      -- Bug 29665/177284 - 12/06/2014 - AMC
                      AND cmovseg <> 3
                      AND femisio IS NOT NULL
                      AND sseguro = s.sseguro)
                OR(s.csituac = 5
                   AND s.ccartera = 1))
            -- BUG 17153 - 31/12/2010 - JMP - Permitir pasar la cartera a un colectivo entero o a un certificado
            AND s.npoliza = NVL(pnpoliza, npoliza)
            AND s.ncertif = NVL(pncertif, ncertif)
            -- BUG 0019627: GIP102 - Reunificaci¿n de recibos - FAL - 10/11/2011
            -- NO seleccionar certificados 0 para RECUNIF = 3 (agrupac¿¿n de recibos en funi¿n de la forma pago del certif 0)
            AND((NVL(f_parproductos_v(f_sproduc_ret(s.cramo, s.cmodali, s.ctipseg, s.ccolect),
                                      'RECUNIF'),
                     0) = 3
                 AND s.ncertif <> 0)
                OR(NVL(f_parproductos_v(f_sproduc_ret(s.cramo, s.cmodali, s.ctipseg, s.ccolect),
                                        'RECUNIF'),
                       0) <> 3))
            -- Bug 23940 - APD - 13/11/2012 - la poliza no puede estar bloqueada para cartera
            AND NVL(s.cbloqueocol, 0) <> 1;

      -- Fi Bug 19627

      --AND sseguro NOT IN(SELECT sseguro
      --                     FROM seguroscar sc
      --                    WHERE sc.sseguro = sseguro
      --                      AND(nerror IS NULL
      --                          OR nerror = 0))
      --AND NVL(f_ultima_cartera(sseguro, fcarpro), fcarpro) >= fcarpro;
      --BUG 14438 - JTS - 12/05/2010
      CURSOR c_rebcartera(ppfecha DATE, psproduc NUMBER) IS
         SELECT r.nrecibo
           FROM recibos r, seguros s
          WHERE r.ctiprec = 3   -- de cartera
            AND r.cestaux = 2   -- Los de cartera de productos colectivos con
            -- certificados se deber¿n crear en este estado
            AND r.fefecto <= ppfecha
            AND r.sseguro = s.sseguro
            AND s.sproduc = psproduc
            AND r.esccero = 1   -- del certificado 0
            AND NVL(f_cestrec(r.nrecibo, NULL), 0) = 0
            -- que no esten cobrados
            AND r.cestimp != 0
            AND s.sseguro = NVL(psseguro, s.sseguro)
            AND s.npoliza = NVL(pnpoliza, s.npoliza)
            AND s.ncertif = NVL(pncertif, s.ncertif)
            AND r.nrecibo NOT IN(SELECT nrecibo
                                   FROM adm_recunif);

      --Fi bug 14438
      v_fcarpro_his  seguros.fcarpro%TYPE;
      v_fcaranu_his  seguros.fcaranu%TYPE;
      v_fcarant_his  seguros.fcarant%TYPE;
      v_frenova_his  seguros.frenova%TYPE;
      v_nrenova_his  seguros.nrenova%TYPE;
      v_nfracci_his  seguros.nfracci%TYPE;
      v_nmovimi_his  movseguro.nmovimi%TYPE;
      v_fcarpro_pb   seguros.fcarpro%TYPE;
      v_cmotmov      movseguro.cmotmov%TYPE;
      v_cmotven      movseguro.cmotven%TYPE;
      v_femisio      movseguro.femisio%TYPE;
      vfestrec       DATE;   -- MMS 20150505 Bug 35386
      v_funcion      VARCHAR2(50);
      ss             VARCHAR2(3000);
      --INI BUG CONF-186  Fecha (22/08/2016) - HRE - proceso de marcas
      cur_marcas     sys_refcursor;
      v_sperson        per_agr_marcas.sperson%TYPE;
      v_area           VARCHAR2(500);
      v_cmarca         per_agr_marcas.cmarca%TYPE;
      v_descripcion    VARCHAR2(500);
      v_tipo           VARCHAR2(50);
      v_caacion        agr_marcas.caacion%TYPE;
      v_accion         VARCHAR2(50);
      v_persona        VARCHAR2(500);
      v_rol            VARCHAR2(50);
      v_validaMarca    BOOLEAN := FALSE;
      mensajes         T_IAX_MENSAJES;
      --FIN BUG CONF-186  - Fecha (22/08/2016) - HRE

   BEGIN
      indice := 0;
      indice_error := 0;
      -- suplementos de cartera.
      -- Solo llamamos al pac_propio una vez
      /*     FOR v_prod IN c_prod  LOOP
              SELECT sproduc INTO v_sproduc
             FROM productos
             WHERE cramo = v_prod.cramo
                        AND cmodali = v_prod.cmodali
                        AND ctipseg = v_prod.ctipseg
                        AND ccolect = v_prod.ccolect;
      */

      /* num_err := pac_propio.f_suplem_cartera(0, psproces_prod, pmes, panyo, NULL, NULL, NULL,   --v_sproduc,
                                                   NULL, pidioma);
            IF num_err = 0 THEN
               COMMIT;
            ELSE
               ROLLBACK;
               p_literal2(num_err, pidioma, texto);
               texto := texto || '.' || ' sproduc =' || v_sproduc;
               num_lin := NULL;
               num_err := f_proceslin(psproces, texto, v_sproduc, num_lin);
               RETURN num_err;
            END IF;
      */

      --      END LOOP;
      indice := indice_error;

      IF psseguro IS NOT NULL THEN   --AMC
         COMMIT;
      END IF;

      --INI BUG CONF-186  Fecha (22/08/2016) - HRE - proceso de marcas
      IF (psseguro IS NOT NULL) THEN
         cur_marcas := pac_md_marcas.f_get_marcas_poliza(pempresa, psseguro, 'POL', mensajes);
         FETCH cur_marcas
            INTO v_sperson, v_area, v_cmarca, v_descripcion, v_tipo, v_caacion, v_accion, v_persona, v_rol;
         WHILE cur_marcas%FOUND LOOP
            IF v_caacion != 0 THEN
               v_validaMarca := TRUE;
               num_err := pac_marcas.f_ins_log_marcaspoliza(pempresa, psproces, v_sperson, v_cmarca, psseguro);
            END IF;

         FETCH cur_marcas
           INTO v_sperson, v_area, v_cmarca, v_descripcion, v_tipo, v_caacion, v_accion, v_persona, v_rol;
         END LOOP;

         IF (v_validaMarca) THEN
            num_err := 9909325;
            -- Tiene marcas y no se permite generar la cartera
            texto := f_axis_literales(num_err, pidioma);
            texto := texto;
            num_lin := NULL;
            num_err2 := f_proceslin(psproces, texto, pnpoliza, num_lin);
            COMMIT;
            RETURN num_err;
         END IF;
      END IF;
      --FIN BUG CONF-186  - Fecha (22/08/2016) - HRE

      -- Bug 23940 - APD - 17/12/2012 - se valida el nivel de visi¿n
      IF psseguro IS NOT NULL
         OR pnpoliza IS NOT NULL THEN
         SELECT COUNT(1)
           INTO v_count
           FROM seguros s
          WHERE (s.sseguro = psseguro
                 OR(s.npoliza = pnpoliza
                    AND s.ncertif = NVL(pncertif, 0)))
            AND(s.cagente, s.cempres) IN(SELECT cagente, cempres
                                           FROM agentes_agente_pol);

         IF v_count = 0 THEN
            num_err := 9904649;
-- No tiene permisos para ejecutar la cartera de esta p¿liza. Revise su nivel de visi¿n.
            texto := f_axis_literales(num_err, pidioma);
            texto := texto;
            num_lin := NULL;
            num_err2 := f_proceslin(psproces, texto, pnpoliza, num_lin);
            RETURN num_err;
         END IF;
      END IF;

      -- fin Bug 23940 - APD - 17/12/2012

      --      indice_error := 0;
      FOR v_prod IN c_prod LOOP
         v_traza := 1;

         BEGIN
            SELECT sproduc
              INTO v_sproduc
              FROM productos
             WHERE cramo = v_prod.cramo
               AND cmodali = v_prod.cmodali
               AND ctipseg = v_prod.ctipseg
               AND ccolect = v_prod.ccolect;

--------------------------------------------------
-- Per cada producte, farem el trasp¿s de diferits
-- del mes
--------------------------------------------------
--     pac_trans_diferits.p_traspaso_diferits(
--      LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo, 'mmyyyy')),
--    v_prod.cramo, v_prod.cmodali, v_prod.ctipseg, v_prod.ccolect);

            -------------------------------------------------
-- Mirem si el producte contempla la prima m¿nima
-------------------------------------------------
-- Si s'ha de comprovar la prima m¿nima, cal veure si hi ha garantia
-- de regularitzaci¿.
            garantia_regularitzacio(v_prod.cramo, v_prod.cmodali, v_prod.ctipseg,
                                    v_prod.ccolect, lcprimin, liprimin, lcclapri,
                                    lcgarant_regu, lnorden);
            v_traza := 2;

            IF psseguro IS NULL THEN
               -- Bug 30393/168070 - 05/05/2014 - AMC
               IF NVL(pac_parametros.f_parproducto_n(v_sproduc, 'CARTERA_DESCENTRAL'), 0) = 1 THEN
                  BEGIN
                     -- Controlamos si el MES y el A¿O que se pasan son mas peque¿os
                     -- o iguales a la fecha anterior de PRODCARTERA(FCARANT) no se realiza actualizacion.
                     BEGIN
                        INSERT INTO prodagecartera
                                    (cempres, sproduc, cagente,
                                     fcarant,
                                     fcarpro,
                                     cramo, cmodali, ctipseg,
                                     ccolect)
                             VALUES (pempresa, v_sproduc, ff_agente_usuario(f_user),
                                     TO_DATE('01' || LPAD(pmes, 2, '0') || panyo, 'ddmmyyyy'),
                                     ADD_MONTHS(TO_DATE('01' || LPAD(pmes, 2, '0') || panyo,
                                                        'ddmmyyyy'),
                                                1),
                                     v_prod.cramo, v_prod.cmodali, v_prod.ctipseg,
                                     v_prod.ccolect);
                     EXCEPTION
                        WHEN DUP_VAL_ON_INDEX THEN
                           IF pfcartera IS NULL
                              OR(pfcartera IS NOT NULL
                                 AND pfcartera = LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo,
                                                                  'mmyyyy'))) THEN
                              UPDATE prodagecartera
                                 SET fcarpro = ADD_MONTHS(TO_DATE('01' || LPAD(pmes, 2, '0')
                                                                  || panyo,
                                                                  'ddmmyyyy'),
                                                          1),
                                     fcarant = TO_DATE('01' || LPAD(pmes, 2, '0') || panyo,
                                                       'ddmmyyyy')
                               WHERE cempres = pempresa
                                 AND cagente = ff_agente_usuario(f_user)
                                 AND cramo = v_prod.cramo
                                 AND cmodali = v_prod.cmodali
                                 AND ctipseg = v_prod.ctipseg
                                 AND ccolect = v_prod.ccolect;
                           END IF;
                     END;

                     COMMIT;
--                      END IF;
                  EXCEPTION
                     WHEN OTHERS THEN
                        RETURN 102705;
                  END;
               ELSE
                  BEGIN
                     -- Controlamos si el MES y el A¿O que se pasan son mas peque¿os
                     -- o iguales a la fecha anterior de PRODCARTERA(FCARANT) no se realiza actualizacion.
                     SELECT COUNT(sproduc)
                       INTO cont_fec_ant
                       FROM prodcartera
                      WHERE cempres = pempresa
                        AND cramo = v_prod.cramo
                        AND cmodali = v_prod.cmodali
                        AND ctipseg = v_prod.ctipseg
                        AND ccolect = v_prod.ccolect
                        AND TRUNC(fcarant, 'mm') >=
                                         TO_DATE(LPAD(pmes, 2, '0') || TO_CHAR(panyo),
                                                 'mmyyyy');

                     IF cont_fec_ant = 0 THEN
                        IF pfcartera IS NULL
                           OR(pfcartera IS NOT NULL
                              AND pfcartera = LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo,
                                                               'mmyyyy'))) THEN
                           UPDATE prodcartera
                              SET fcarpro = ADD_MONTHS(TO_DATE('01' || LPAD(pmes, 2, '0')
                                                               || panyo,
                                                               'ddmmyyyy'),
                                                       1),
                                  fcarant = TO_DATE('01' || LPAD(pmes, 2, '0') || panyo,
                                                    'ddmmyyyy')
                            WHERE cempres = pempresa
                              AND cramo = v_prod.cramo
                              AND cmodali = v_prod.cmodali
                              AND ctipseg = v_prod.ctipseg
                              AND ccolect = v_prod.ccolect;
                        END IF;

                        COMMIT;
                     END IF;
                  EXCEPTION
                     WHEN OTHERS THEN
                        RETURN 102705;
                  END;
               END IF;
            -- Fi Bug 30393/168070 - 05/05/2014 - AMC
            END IF;

            v_traza := 3;

            BEGIN
               SELECT csubpro, cobjase, cagrpro,
-- JLB - I - BUG 18423 COjo la moneda del producto
                                          --    DECODE(cdivisa, 3, 1, 2),
                                                pac_monedas.f_moneda_producto(sproduc),
-- JLB - F - BUG 18423 COjo la moneda del producto
                      nedamar, ciedmar
                 INTO lcsubpro, lcobjase, lcagrpro, lmoneda,
                      lnedamar, lciedmar
                 FROM productos
                WHERE cramo = v_prod.cramo
                  AND cmodali = v_prod.cmodali
                  AND ctipseg = v_prod.ctipseg
                  AND ccolect = v_prod.ccolect;
            EXCEPTION
               WHEN OTHERS THEN
                  RETURN 102705;
            END;

            -- Bug 23940 - APD - 12/11/2012 -- de momento se crea el PARPRODUCTO
            -- 'CARTERA_PSU' para indicar si se debe o no validar las PSU en la
            -- renovaci¿n de cartera, aunque se duplique c¿digo, para que el
            -- c¿digo que se ha modificado si CARTERA_PSU = 1 NO haga que
            -- deje de funcionar la cartera para otras empresas.
            -- De momento s¿lo tienen 'CARTERA_PSU' = 1 los productos del ramo
            -- Vida Grupo de LCOL.
            -- M¿s adelante, si el c¿digo de 'CARTERA_PSU' = 1 funciona bien
            -- para el resto de empresas, se podr¿a mirar de eliminar el c¿digo
            -- antiguo y dejar el nuevo (aunque un producto tenga 'CARTERA_PSU' = 1,
            -- si no tiene parametrizadas las PSU, no se validar¿n estas)
            IF NVL(f_parproductos_v(v_sproduc, 'CARTERA_PSU'), 0) = 1 THEN
-------------------------------------
-- Se realiza la cartera CON PSU's --
-------------------------------------
               vrecunif := f_parproductos_v(v_sproduc, 'RECUNIF');
               -- Bug 28640/160626 - 25/03/2014 - AMC
               vadmincertif := f_parproductos_v(v_sproduc, 'ADMITE_CERTIFICADOS');
               -- Bug 28640/160626 - 25/03/2014 - AMC
               v_traza := 4;
               v_seguir := TRUE;--BUG CONF-186  Fecha (22/08/2016) - HRE - proceso de marcas
               FOR v_seg IN c_seg_psu(v_prod.cramo, v_prod.cmodali, v_prod.ctipseg,
                                      v_prod.ccolect, psseguro, pnpoliza, pncertif, pmes,
                                      panyo, pfcartera, pskiprenova,
                                      vrecunif   -- Bug 28640/160626 - 25/03/2014 - AMC
                                              ) LOOP

                  --INI BUG CONF-186  Fecha (22/08/2016) - HRE - proceso de marcas
                  IF (v_seg.sseguro IS NOT NULL) THEN
                     cur_marcas := pac_md_marcas.f_get_marcas_poliza(pempresa, v_seg.sseguro, 'POL', mensajes);
                     FETCH cur_marcas
                        INTO v_sperson, v_area, v_cmarca, v_descripcion, v_tipo, v_caacion, v_accion, v_persona, v_rol;
                     WHILE cur_marcas%FOUND LOOP
                        IF v_caacion != 0 THEN
                           v_validaMarca := TRUE;
                           num_err := pac_marcas.f_ins_log_marcaspoliza(pempresa, psproces, v_sperson, v_cmarca, psseguro);
                        END IF;

                     FETCH cur_marcas
                       INTO v_sperson, v_area, v_cmarca, v_descripcion, v_tipo, v_caacion, v_accion, v_persona, v_rol;
                     END LOOP;

                     IF (v_validaMarca) THEN
                        v_seguir := FALSE;
                        num_err := 9909325;
                        -- Tiene marcas y no se permite generar la cartera
                        texto := f_axis_literales(num_err, pidioma);
                        texto := texto || '.' || v_seg.sseguro || ' (' || v_seg.npoliza
                                    || '-' || v_seg.ncertif || ')';
                        num_lin := NULL;
                        num_err2 := f_proceslin(psproces, texto, pnpoliza, num_lin);
                        IF num_err2 = 0 THEN
                           COMMIT;
                        END IF;

                     END IF;
                  END IF;
                  --FIN BUG CONF-186  - Fecha (22/08/2016) - HRE

                  indice_error_certif0 := 0;
                  -- BUG 0038828 - FAL - 11/12/2015
                  indice_error_certifx := 0;
               IF (v_seguir) THEN --FIN BUG CONF-186  - Fecha (22/08/2016) - HRE
                  -- BUG 0038828 - FAL - 11/12/2015
                  v_traza := 5;
                  v_es_col_admin := pac_seguros.f_es_col_admin(v_seg.sseguro, 'POL');
                  v_es_col_agrup := pac_seguros.f_es_col_agrup(v_seg.sseguro, 'POL');
                  num_err := 0;

-- DRA:25597:07/11/2013: Se inicializa o al encontrar una bloqueada o con error ya no sigue con el resto

                  /*------------------------------
                   Renovacion de colectivos administrados/agrupados
                   -------------------------------*/
                  IF (v_es_col_admin = 1
                      OR v_es_col_agrup = 1)
                     AND v_seg.ncertif = 0 THEN
                     -- Bug 0027539/0154962 - JSV (08/10/2013) - INI
                     -- Bug 28640/160626 - 25/03/2014 - AMC
                     IF (NVL(vadmincertif, 0) = 1
                         AND v_es_col_admin = 1
                         AND v_seg.ncertif = 0)
                        OR NVL(vadmincertif, 0) = 0 THEN
                        IF pac_seguros.f_suspendida(v_seg.sseguro, v_seg.fcarpro) = 1 THEN
                           num_err := 9904539;
                           texto := f_axis_literales(num_err, pidioma) || '. '
                                    || f_axis_literales(112522, pidioma);
                           texto := texto || '.' || v_seg.sseguro || ' (' || v_seg.npoliza
                                    || '-' || v_seg.ncertif || ')';
                           num_lin := NULL;
                           num_err2 := f_proceslin(psproces, texto, v_seg.sseguro, num_lin);

                           IF num_err2 = 0 THEN
                              COMMIT;
                           END IF;
                        END IF;
                     END IF;

                     -- Bug 0027539/0154962 - JSV (08/10/2013) - FIN
                     v_traza := 6;

                     -- si el certificado 0 est¿ bloqueado para cartera no se puede pasar cartera
                     IF prenovcero = 0 THEN
                        IF NVL(v_seg.cbloqueocol, 0) = 1 THEN
                           num_err := 152212;   -- Poliza bloqueada.
                           texto := f_axis_literales(num_err, pidioma) || '. '
                                    || f_axis_literales(112522, pidioma);
                           texto := texto || '.' || v_seg.sseguro || ' (' || v_seg.npoliza
                                    || '-' || v_seg.ncertif || ')';
                           num_lin := NULL;
                           num_err2 := f_proceslin(psproces, texto, v_seg.sseguro, num_lin);

                           IF num_err2 = 0 THEN
                              COMMIT;
                           END IF;
                        END IF;
                     END IF;

                     SELECT cmotmov, cmotven, femisio
                       INTO v_cmotmov, v_cmotven, v_femisio
                       FROM movseguro
                      WHERE sseguro = v_seg.sseguro
                        AND cmovseg NOT IN(6, 52)
                        AND nmovimi = (SELECT MAX(m2.nmovimi)
                                         FROM movseguro m2
                                        WHERE m2.sseguro = movseguro.sseguro
                                          AND m2.cmovseg NOT IN(6, 52));

                     IF v_es_col_admin = 1
                        AND v_cmotmov IN(996, 997)
                        AND v_cmotven = 998
                        AND v_femisio IS NULL THEN
                        num_err := 9906865;
                        -- Pendiente de finalizar la emisi¿n del colectivo administrado.
                        texto := f_axis_literales(num_err, pidioma) || '. '
                                 || f_axis_literales(112522, pidioma);
                        texto := texto || '.' || v_seg.sseguro || ' (' || v_seg.npoliza || '-'
                                 || v_seg.ncertif || ')';
                        num_lin := NULL;
                        num_err2 := f_proceslin(psproces, texto, v_seg.sseguro, num_lin);

                        IF num_err2 = 0 THEN
                           COMMIT;
                        END IF;
                     END IF;

                     IF num_err = 0 THEN
                        /*IF v_es_col_admin = 1 THEN
                           IF pskiprenova = 1 THEN
                              NULL;
                           ELSE
                              --se valida si se pueden renovar los certificados X del certificado 0
                              v_traza := 7;
                              num_err := f_permite_renovar(v_prod.cramo, v_prod.cmodali,
                                                           v_prod.ctipseg, v_prod.ccolect,
                                                           v_seg.npoliza, pmes, panyo);

                              IF num_err <> 0 THEN
                                 ROLLBACK;
                                 texto := f_axis_literales(num_err, pidioma);
                                 texto := texto || '.' || v_seg.sseguro || ' ('
                                          || v_seg.npoliza || '-' || v_seg.ncertif || ')';
                                 num_lin := NULL;
                                 num_err2 := f_proceslin(psproces, texto, v_seg.sseguro,
                                                         num_lin);

                                 IF num_err2 = 0 THEN
                                    COMMIT;
                                 END IF;
                              END IF;
                           END IF;
                        END IF;*/
                        IF num_err = 0 THEN
                           SELECT fcarpro, fcaranu, fcarant, frenova,
                                  nrenova, nfracci
                             INTO v_fcarpro_his, v_fcaranu_his, v_fcarant_his, v_frenova_his,
                                  v_nrenova_his, v_nfracci_his
                             FROM seguros
                            WHERE sseguro = v_seg.sseguro;

                           v_traza := 8;
                           -- la funcion f_genera_cartera ya realiza el COMMIT o ROLLBACK
                           num_err := f_genera_cartera_psu(v_seg, pempresa, psproces, pmes,
                                                           panyo, pfemisio, pidioma, lmoneda,
                                                           lcsubpro,
                                                           NVL(v_seg.cobjase, lcobjase),
                                                           lcagrpro, lcgarant_regu, lnorden,
                                                           lcprimin, liprimin, lcclapri,
                                                           lnedamar, lciedmar, indice,

                                                           --indice_error);
                                                           indice_error_certif0);

                           -- BUG 0038828 - FAL - 11/12/2015

                           -- si la cartera del certificado 0 ha ido bien, se puede realizar la
                           -- cartera de sus certificados
                           --IF indice_error = 0 THEN   -- BUG 0038828 - FAL - 11/12/2015
                           IF indice_error_certif0 = 0 THEN
                              IF prenovcero = 1 THEN
                                 num_err := f_delete_carteraaux(psproces_prod);
                                 COMMIT;
                                 RETURN 0;
                              END IF;

                                 -- Bug 23940 - APD - 18/10/2012 - Para los administrados, se bloquea el
                              -- el certificado 0 y se crea el movimiento de Propuesta Cartera
                              -- Antes de realizar la renovacion de los certificados X del certificado 0
                              -- se debe crear el movimiento 403 en el certificado 0 si no existe ya o no
                              -- existe el 404 para indicar que en ese momento se va a realizar la
                              -- renovacion de los certificados X del certificado 0
                              IF v_es_col_admin = 1 THEN
                                 -- Si no hay generado el movimiento de 403.-Propuesta Cartera o 404.-Cartera
                                 -- o 407.-Actualizaci¿n anual (se puede crear en pac_dincartera.f_renovacion_anual),
                                 -- se crea el movimiendo de 403.-Propuesta de Cartera.
                                 -- En el caso de la cartera fraccionada (la que solo genera recibos) si no
                                 -- ha saltado la PSU seguro que no existe el movimiento 403 ni el 404 ni el 407
                                 SELECT COUNT(1)
                                   INTO v_count
                                   FROM movseguro
                                  WHERE sseguro = v_seg.sseguro
                                    AND cmotmov IN(403, 404, 407, 821, 406)
                                    --Mantis 34469/0205354 - BLA - DD25/MM05/2015 :add 406
                                    AND fefecto = v_seg.fcarant
                                    AND cmovseg NOT IN(6, 52);

                                 -- movimiento no anulado (v.f. 16)

                                 -- Bug 29665/177284 - 12/06/2014 - AMC
                                 IF v_count = 0 THEN
                                    -- generar un movimiento de Propuesta de Cartera
                                    num_err := f_movseguro(v_seg.sseguro, NULL, 403, 1,
                                                           v_seg.fcarant, NULL, NULL, 0, NULL,
                                                           vnmovimi_out, f_sysdate, NULL,
                                                           NULL);

                                    IF num_err <> 0 THEN
                                       ROLLBACK;
                                       indice_error := indice_error + 1;
                                       indice_error_certif0 := indice_error;
                                       -- BUG 0038828 - FAL - 11/12/2015
                                       texto := f_axis_literales(num_err, pidioma);
                                       texto := texto || '.' || v_seg.sseguro || ' ('
                                                || v_seg.npoliza || '-' || v_seg.ncertif
                                                || ')';
                                       num_lin := NULL;
                                       num_err :=
                                          f_proceslin(psproces, texto, v_seg.sseguro, num_lin);

                                       IF num_err = 0 THEN
                                          COMMIT;
                                       END IF;
                                    END IF;

                                    IF indice_error = 0 THEN
                                       -- Se llama a f_act_hisseg para guardar la
                                       -- situaci¿n anterior al suplemento.
                                       -- El nmovimi es el anterior al del suplemento,
                                       -- por eso se le resta uno al reci¿n creado.
                                       SELECT MAX(nmovimi)
                                         INTO v_nmovimi
                                         FROM movseguro
                                        WHERE sseguro = v_seg.sseguro
                                          AND nmovimi < vnmovimi_out
                                          AND cmovseg NOT IN(6, 52);

                                       -- no anulado -- Bug 29665/177284 - 12/06/2014 - AMC
                                       num_err := f_act_hisseg(v_seg.sseguro, v_nmovimi);

                                       IF num_err <> 0 THEN
                                          ROLLBACK;
                                          indice_error := indice_error + 1;
                                          indice_error_certif0 := indice_error;
                                          -- BUG 0038828 - FAL - 11/12/2015
                                          texto := f_axis_literales(num_err, pidioma);
                                          texto :=
                                             texto || '.' || v_seg.sseguro || ' ('
                                             || v_seg.npoliza || '-' || v_seg.ncertif || ')';
                                          num_lin := NULL;
                                          num_err :=
                                             f_proceslin(psproces, texto, v_seg.sseguro,
                                                         num_lin);

                                          IF num_err = 0 THEN
                                             COMMIT;
                                          END IF;
                                       ELSE
                                          SELECT NVL(MAX(nmovimi), v_nmovimi)
                                            --Si no encontramos nada, que haga lo mismo que hasta ahora
                                          INTO   v_nmovimi_his
                                            FROM movseguro
                                           WHERE sseguro = v_seg.sseguro
                                             AND nmovimi <= v_nmovimi
                                             AND cmovseg NOT IN(52, 6);

                                          UPDATE historicoseguros
                                             SET fcarpro = v_fcarpro_his,
                                                 fcaranu = v_fcaranu_his,
                                                 fcarant = v_fcarant_his,
                                                 frenova = v_frenova_his,
                                                 nrenova = v_nrenova_his,
                                                 nfracci = v_nfracci_his
                                           WHERE sseguro = v_seg.sseguro
                                             AND nmovimi = v_nmovimi_his;
                                       END IF;
                                    END IF;
                                 ELSE
                                    SELECT MAX(nmovimi)
                                      INTO vnmovimi_out
                                      FROM movseguro
                                     WHERE sseguro = v_seg.sseguro
                                       AND cmotmov IN(403, 404, 407, 821, 406)
                                       --Mantis 34469/0205354 - BLA - DD25/MM05/2015 :add 406
                                       AND fefecto = v_seg.fcarant
                                       AND cmovseg NOT IN(6, 52);
                                            -- movimiento no anulado (v.f. 16)
                                 -- Bug 29665/177284 - 12/06/2014 - AMC
                                 END IF;

                                 -- dejar la poliza en Propuesta de Cartera, por si ha habido algun
                                 -- certificado cuya renovacion ha fallado
                                 IF indice_error = 0 THEN
                                    UPDATE seguros
                                       SET csituac = 17
                                     WHERE sseguro = v_seg.sseguro;
                                 END IF;
                              ELSE
                                 -- actualizar el campo cbloqueocol
                                 num_err := pac_propio.f_act_cbloqueocol(v_seg.sseguro);

                                 IF num_err <> 0 THEN
                                    ROLLBACK;
                                    indice_error := indice_error + 1;
                                    indice_error_certif0 := indice_error;
                                    -- BUG 0038828 - FAL - 11/12/2015
                                    texto := f_axis_literales(9904712, pidioma);
                                    texto := texto || '.' || v_seg.sseguro;
                                    num_lin := NULL;
                                    num_err := f_proceslin(psproces, texto, v_seg.sseguro,
                                                           num_lin);

                                    IF num_err = 0 THEN
                                       COMMIT;
                                    END IF;
                                 END IF;
                              END IF;

                              --IF indice_error = 0 THEN
                              IF indice_error_certif0 = 0 THEN
-- BUG 0038828 - FAL - 11/12/2015. Si algun certificado da error ya no procesa el resto de certificados evaluando indice_error. Por eso se usa indice_error_certif0
                                 -- si todo lo anterior Ok, se debe realizar COMMIT de las
                                 -- modificaciones anteriores
                                 COMMIT;
                                 v_traza := 9;

                                 -- se renuevan los certificados X del certificado 0
                                 FOR v_seg_col IN c_seg_col_psu(v_prod.cramo, v_prod.cmodali,
                                                                v_prod.ctipseg,
                                                                v_prod.ccolect, v_seg.npoliza,
                                                                pmes, panyo) LOOP
                                    indice_error_certifx := 0;
                                            -- BUG 0038828 - FAL - 11/12/2015
                                    -- la funcion f_genera_cartera ya realiza el COMMIT o ROLLBACK
                                    v_fcarpro_pb := v_seg_col.fcarpro;
                                    num_err := f_genera_cartera_psu(v_seg_col, pempresa,
                                                                    psproces, pmes, panyo,
                                                                    pfemisio, pidioma,
                                                                    lmoneda, lcsubpro,
                                                                    NVL(v_seg_col.cobjase,
                                                                        lcobjase),
                                                                    lcagrpro, lcgarant_regu,
                                                                    lnorden, lcprimin,
                                                                    liprimin, lcclapri,
                                                                    lnedamar, lciedmar,
                                                                    indice,
                                                                    indice_error_certifx);

                                    -- BUG 0038828 - FAL - 11/12/2015

                                    -- IF indice_error = 0 THEN   -- Bug 26341 - APD - 22/03/2013
                                    IF indice_error_certifx = 0 THEN   -- BUG 0038828 - FAL - 11/12/2015
                                       -- Bug 26341 - APD - 22/03/2013 - el reparto del corretaje
                                       -- solo se debe hacer a los ncertificados no al certificado 0
                                       -- por eso se extrae de la funcion f_genera_cartera_psu y se
                                       -- pasa aqu¿ el codigo
                                       IF pac_corretaje.f_tiene_corretaje(v_seg_col.sseguro,
                                                                          NULL) = 1 THEN
                                          num_err :=
                                             pac_corretaje.f_reparto_corretaje
                                                                           (v_seg_col.sseguro,
                                                                            NULL, NULL);
                                       END IF;

                                       IF num_err <> 0 THEN
                                          ROLLBACK;
                                          algun_error := 1;
                                          indice_error := indice_error + 1;
                                          indice_error_certifx := indice_error;
                                          -- BUG 0038828 - FAL - 11/12/2015
                                          texto := f_axis_literales(num_err, pidioma);
                                          texto := texto || '.' || v_seg_col.sseguro;
                                          num_lin := NULL;
                                          num_err :=
                                             f_proceslin(psproces, texto, v_seg_col.sseguro,
                                                         num_lin);

                                          IF num_err = 0 THEN
                                             COMMIT;
                                          END IF;
                                       END IF;

                                       -- fin Bug 26341 - APD - 22/03/2013
                                       IF indice_error = 0 THEN
                                          -- actualizar el campo cbloqueocol
                                          num_err :=
                                               pac_propio.f_act_cbloqueocol(v_seg_col.sseguro);

                                          IF num_err <> 0 THEN
                                             ROLLBACK;
                                             indice_error := indice_error + 1;
                                             indice_error_certifx := indice_error;
                                             -- BUG 0038828 - FAL - 11/12/2015
                                             texto := f_axis_literales(9904712, pidioma);
                                             texto := texto || '.' || v_seg_col.sseguro;
                                             num_lin := NULL;
                                             num_err :=
                                                f_proceslin(psproces, texto,
                                                            v_seg_col.sseguro, num_lin);

                                             IF num_err = 0 THEN
                                                COMMIT;
                                             END IF;
                                          END IF;
                                       END IF;

                                       -- Bug 29943 - 22/04/2014 - JTT
                                       IF indice_error = 0 THEN
                                          num_err :=
                                             pac_dincartera.f_tratamiento_pb
                                                                           (pempresa,
                                                                            v_sproduc,
                                                                            v_seg_col.sseguro,
                                                                            v_fcarpro_pb,
                                                                            NULL, 'R', NULL,
                                                                            psproces);

                                          IF num_err <> 0 THEN
                                             indice_error := indice_error + 1;
                                             indice_error_certifx := indice_error;
                                             -- BUG 0038828 - FAL - 11/12/2015
                                             texto := f_axis_literales(9906703, pidioma);
                                             texto :=
                                                texto || '. ' || v_seg_col.sseguro || ' '
                                                || pfemisio;
                                             num_lin := NULL;
                                             num_err :=
                                                f_proceslin(psproces, texto,
                                                            v_seg_col.sseguro, num_lin);
                                             COMMIT;
                                          END IF;
                                       END IF;
                                    -- Fi bug 29943
                                    ELSE   -- BUG 0038828 - FAL - 11/12/2015
                                       indice_error := indice_error + 1;
                                    END IF;
                                 -- fin Bug 26341 - APD - 22/03/2013
                                 END LOOP;
                              ELSE   -- BUG 0038828 - FAL - 11/12/2015
                                 indice_error := indice_error + 1;
                              END IF;

                              IF indice_error = 0 THEN
                                 IF v_es_col_admin = 1 THEN
                                    -- AGRUPACION RECIBOS
                                    -- se debe hacer antes de volver a poner el certificado 0 a
                                    -- csituac = 0 ya que si ha fallado la agrupacion de recibos
                                    -- el certificado 0 debe quedar en 17.-Prop. Cartera
                                    num_err := f_agruparecibos(psproces, v_seg.sseguro);

                                    IF num_err <> 0 THEN
                                       ROLLBACK;
                                       indice_error := indice_error + 1;
                                       texto := f_axis_literales(num_err, pidioma);
                                       texto := texto || '.' || v_seg.sseguro;
                                       num_lin := NULL;
                                       num_err :=
                                          f_proceslin(psproces, texto, v_seg.sseguro, num_lin);

                                       IF num_err = 0 THEN
                                          COMMIT;
                                       END IF;
                                    END IF;

                                    IF indice_error = 0 THEN
                                       -- si todo Ok y es un colectivo administrado
                                       -- se deja la poliza del certificado 0 otra vez en csituac = 0.-Vigente
                                       UPDATE seguros
                                          SET csituac = 0
                                        WHERE sseguro = v_seg.sseguro;
                                    END IF;

                                    IF indice_error = 0 THEN
                                       -- actualizar el campo cbloqueocol
                                       num_err := pac_propio.f_act_cbloqueocol(v_seg.sseguro);

                                       IF num_err <> 0 THEN
                                          ROLLBACK;
                                          indice_error := indice_error + 1;
                                          texto := f_axis_literales(9904712, pidioma);
                                          texto := texto || '.' || v_seg.sseguro;
                                          num_lin := NULL;
                                          num_err :=
                                             f_proceslin(psproces, texto, v_seg.sseguro,
                                                         num_lin);

                                          IF num_err = 0 THEN
                                             COMMIT;
                                          END IF;
                                       END IF;

                                       IF indice_error = 0 THEN
                                          COMMIT;
                                       END IF;
                                    END IF;
                                 END IF;
                              END IF;
                           END IF;
                        END IF;
                     END IF;
                  ELSE
                     --Bug 27539/156989 - JSV - 28/10/2013 - INI
                     IF pac_seguros.f_suspendida(v_seg.sseguro, v_seg.fcarpro) = 1 THEN
                        num_err := 9904539;
                        texto := f_axis_literales(num_err, pidioma) || '. '
                                 || f_axis_literales(112522, pidioma);
                        texto := texto || '.' || v_seg.sseguro || ' (' || v_seg.npoliza || '-'
                                 || v_seg.ncertif || ')';
                        num_lin := NULL;
                        num_err2 := f_proceslin(psproces, texto, v_seg.sseguro, num_lin);

                        IF num_err2 = 0 THEN
                           COMMIT;
                        END IF;
                     END IF;

                     --Bug 27539/156989 - JSV - 28/10/2013 - FIN
                        /*------------------------------
                          Renovacion de polizas individuales
                         --------------------------------*/
                     IF prenovcero = 0 THEN
                        -- si la poliza est¿ bloqueada para cartera no se puede pasar cartera
                        IF NVL(v_seg.cbloqueocol, 0) = 1 THEN
                           num_err := 152212;   -- Poliza bloqueada.
                           texto := f_axis_literales(num_err, pidioma) || '. '
                                    || f_axis_literales(112522, pidioma);
                           texto := texto || '.' || v_seg.sseguro || ' (' || v_seg.npoliza
                                    || '-' || v_seg.ncertif || ')';
                           num_lin := NULL;
                           num_err2 := f_proceslin(psproces, texto, v_seg.sseguro, num_lin);

                           IF num_err2 = 0 THEN
                              COMMIT;
                           END IF;
                        END IF;
                     END IF;

                     IF num_err = 0 THEN
                        -- la funcion f_genera_cartera ya realiza el COMMIT o ROLLBACK
                        v_fcarpro_pb := v_seg.fcarpro;
                        num_err := f_genera_cartera_psu(v_seg, pempresa, psproces, pmes,
                                                        panyo, pfemisio, pidioma, lmoneda,
                                                        lcsubpro,
                                                        NVL(v_seg.cobjase, lcobjase),
                                                        lcagrpro, lcgarant_regu, lnorden,
                                                        lcprimin, liprimin, lcclapri,
                                                        lnedamar, lciedmar, indice,
                                                        indice_error);

                        IF indice_error = 0 THEN   -- Bug 26341 - APD - 22/03/2013
                           -- Bug 26341 - APD - 22/03/2013 - el reparto del corretaje
                           -- solo se debe hacer a los ncertificados no al certificado 0
                           -- por eso se extrae de la funcion f_genera_cartera_psu y se
                           -- pasa aqu¿ el codigo
                           IF pac_corretaje.f_tiene_corretaje(v_seg.sseguro, NULL) = 1 THEN
                              num_err := pac_corretaje.f_reparto_corretaje(v_seg.sseguro,
                                                                           NULL, NULL);
                           END IF;

                           IF num_err <> 0 THEN
                              ROLLBACK;
                              algun_error := 1;
                              indice_error := indice_error + 1;
                              texto := f_axis_literales(num_err, pidioma);
                              texto := texto || '.' || v_seg.sseguro || ' (' || v_seg.npoliza
                                       || '-' || v_seg.ncertif || ')';
                              num_lin := NULL;
                              num_err := f_proceslin(psproces, texto, v_seg.sseguro, num_lin);

                              IF num_err = 0 THEN
                                 COMMIT;
                              END IF;

                              p_tab_error(f_sysdate, f_user, 'pac_dincartera.cartera_producte',
                                          1,
                                          'pempresa = ' || pempresa || ' pnpoliza = '
                                          || pnpoliza || ' pncertif = ' || pncertif
                                          || ' v_seg.sseguro = ' || v_seg.sseguro || ' pmes = '
                                          || pmes || ' panyo = ' || panyo || ' pfcartera = '
                                          || pfcartera || ' psproces = ' || psproces
                                          || ' pfemisio = ' || pfemisio || ' pmoneda = '
                                          || pmoneda || 'pidioma = ' || pidioma || 'num_err = '
                                          || num_err,
                                          texto);
                           END IF;

                           -- fin Bug 26341 - APD - 22/03/2013
                           IF indice_error = 0 THEN
                              -- actualizar el campo cbloqueocol
                              num_err := pac_propio.f_act_cbloqueocol(v_seg.sseguro);

                              IF num_err <> 0 THEN
                                 ROLLBACK;
                                 indice_error := indice_error + 1;
                                 texto := f_axis_literales(9904712, pidioma);
                                 texto := texto || '.' || v_seg.sseguro;
                                 num_lin := NULL;
                                 num_err := f_proceslin(psproces, texto, v_seg.sseguro,
                                                        num_lin);

                                 IF num_err = 0 THEN
                                    COMMIT;
                                 END IF;
                              END IF;

                              IF indice_error = 0 THEN
                                 COMMIT;
                              END IF;
                           END IF;

                           -- Bug 29943 - 22/04/2014 - JTT
                           IF indice_error = 0 THEN
                              num_err := pac_dincartera.f_tratamiento_pb(pempresa, v_sproduc,
                                                                         v_seg.sseguro,
                                                                         v_fcarpro_pb, NULL,
                                                                         'R', NULL, psproces);

                              IF num_err <> 0 THEN
                                 indice_error := indice_error + 1;
                                 texto := f_axis_literales(9906703, pidioma);
                                 texto := texto || '. ' || v_seg.sseguro || ' ' || pfemisio;
                                 num_lin := NULL;
                                 num_err := f_proceslin(psproces, texto, v_seg.sseguro,
                                                        num_lin);
                                 COMMIT;
                              END IF;
                           END IF;
                        -- Fi bug 29943
                        END IF;   -- fin Bug 26341 - APD - 22/03/2013
                     END IF;
                  END IF;
               END IF; --BUG CONF-186  - Fecha (22/08/2016) - HRE
               END LOOP;
            ELSE
 -------------------------------------
-- Se realiza la cartera SIN PSU's --
-------------------------------------
-- fin Bug 23940 - APD - 12/11/2012
               FOR v_seg IN c_seg(v_prod.cramo, v_prod.cmodali, v_prod.ctipseg,
                                  v_prod.ccolect) LOOP
                  -- BUG17886:DRA:04/03/2010:Inici: Comprovem que no hagin canviat les condicions de la p¿lissa
                  v_seguir := TRUE;
                  v_traza := 31;

                  IF NOT((v_seg.csituac = 5)
                         OR(v_seg.creteni = 0
                            AND v_seg.csituac NOT IN(7, 8, 9, 10))) THEN
                     v_seguir := FALSE;
                  END IF;

                  SELECT COUNT(1)
                    INTO v_existe
                    FROM movseguro m
                   WHERE m.nmovimi = (SELECT MAX(m3.nmovimi)
                                        FROM movseguro m3
                                       WHERE m3.sseguro = m.sseguro
                                         AND TRUNC(m3.fefecto) <=
                                               LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo,
                                                                'mmyyyy'))
                                         AND m3.cmovseg NOT IN(6, 52))
                     -- Bug 29665/177284 - 12/06/2014 - AMC
                     AND m.cmovseg <> 3
                     AND m.femisio IS NOT NULL
                     AND m.sseguro = v_seg.sseguro;

                  v_traza := 32;

                  IF pac_seguros.f_suspendida(v_seg.sseguro, v_seg.fcarpro) = 1 THEN
                     v_seguir := FALSE;
                  END IF;

                  IF NOT(v_existe > 0
                         OR(v_seg.csituac = 5
                            AND v_seg.ccartera = 1)) THEN
                     v_seguir := FALSE;
                  END IF;

                  -- BUG17886:DRA:04/03/2010:Fi
                  pcorrecte := 0;

                  --INI BUG CONF-186  Fecha (22/08/2016) - HRE - proceso de marcas
                  IF (v_seg.sseguro IS NOT NULL) THEN
                     cur_marcas := pac_md_marcas.f_get_marcas_poliza(pempresa, v_seg.sseguro, 'POL', mensajes);
                     FETCH cur_marcas
                        INTO v_sperson, v_area, v_cmarca, v_descripcion, v_tipo, v_caacion, v_accion, v_persona, v_rol;
                     WHILE cur_marcas%FOUND LOOP
                        IF v_caacion != 0 THEN
                           v_validaMarca := TRUE;
                           num_err := pac_marcas.f_ins_log_marcaspoliza(pempresa, psproces, v_sperson, v_cmarca, psseguro);
                        END IF;

                     FETCH cur_marcas
                       INTO v_sperson, v_area, v_cmarca, v_descripcion, v_tipo, v_caacion, v_accion, v_persona, v_rol;
                     END LOOP;

                     IF (v_validaMarca) THEN
                        v_seguir := FALSE;
                        num_err := 9909325;
                        -- Tiene marcas y no se permite generar la cartera
                        texto := f_axis_literales(num_err, pidioma);
                        texto := texto || '.' || v_seg.sseguro || ' (' || v_seg.npoliza
                                    || '-' || v_seg.ncertif || ')';
                        num_lin := NULL;
                        num_err2 := f_proceslin(psproces, texto, pnpoliza, num_lin);
                        IF num_err2 = 0 THEN
                           COMMIT;
                        END IF;

                     END IF;
                  END IF;
                  --FIN BUG CONF-186  - Fecha (22/08/2016) - HRE

                  IF v_seguir THEN
                     -- Bug 7926 - 27/05/2009 - RSC - Fecha de vencimiento a nivel de garant¿a
                     -- DRA 02/06/2016: Trasladamos este c¿digo al p_cartera porque en un cartera de varios meses no se ejecutar¿a para cada mes
                     /*IF pac_anulacion.f_anula_vto_cartera(v_seg.sseguro, NULL, v_seg.fcarpro) =
                                                                                             1 THEN
                        num_err := pac_anulacion.f_anula_vto_garantias(v_seg.sseguro,
                                                                       v_seg.fcarpro,
                                                                       psproces);
                     END IF;*/
                     num_err := 0;

                     IF num_err <> 0 THEN
                        ROLLBACK;
                        texto := f_axis_literales(num_err, pidioma);
                        texto := texto || '.' || v_seg.sseguro;
                        num_lin := NULL;
                        num_err := f_proceslin(psproces, texto, v_seg.sseguro, num_lin);

                        IF num_err = 0 THEN
                           COMMIT;
                        END IF;
                     ELSE
                        -- Fin Bug 7926

                        -- ini Bug 0020932 - 20/01/2012 - JMF: Procesos din¿mics abans de fer cartera.
                        num_err := pac_dincartera.f_genera_acc_cartera(0, psproces,
                                                                       v_seg.sproduc,
                                                                       v_seg.sseguro,
                                                                       v_seg.fcarpro);

                        IF num_err = 1 THEN
                           ROLLBACK;
                           algun_error := 1;
                           indice_error := indice_error + 1;
                        ELSE
                           -- fin Bug 0020932 - 20/01/2012
                           BEGIN
                              v_traza := 11;
                              v_fcarpro_pb := v_seg.fcarpro;
                              num_err := p_cartera(lmoneda, pidioma, pmes, panyo,
                                                   v_seg.sseguro, v_seg.cramo, v_seg.cmodali,
                                                   v_seg.ctipseg, v_seg.ccolect,
                                                   v_seg.ctarman, v_seg.ccobban,
                                                   v_seg.nrenova, v_seg.ctipreb,
                                                   v_seg.cforpag, v_seg.nduraci,
                                                   v_seg.ndurcob, v_seg.cactivi, lcsubpro,
                                                   lcobjase, lcagrpro, v_seg.fefecto,
                                                   v_seg.fvencim, v_seg.fcarpro,
                                                   v_seg.fcaranu, v_seg.nanuali,
                                                   v_seg.nfracci, v_seg.fcarant, psproces,
                                                   indice, indice_error, pfemisio, pcorrecte,
                                                   v_seg.sproduc, v_seg.nsuplem,
                                                   lcgarant_regu, lnorden, lcprimin, liprimin,
                                                   lcclapri, lnedamar, lciedmar, pempresa,
                                                   v_seg.csituac, pfcartera);
                              v_traza := 12;

                              -- Bug 23940 - APD - 02/01/2013 - se actualiza el campo cbloqueocol
                              IF num_err = 0 THEN
                                 -- actualizar el campo cbloqueocol
                                 num_err := pac_propio.f_act_cbloqueocol(v_seg.sseguro);

                                 IF num_err <> 0 THEN
                                    ROLLBACK;
                                    indice_error := indice_error + 1;
                                    texto := f_axis_literales(9904712, pidioma);
                                    texto := texto || '.' || v_seg.sseguro;
                                    num_lin := NULL;
                                    num_err := f_proceslin(psproces, texto, v_seg.sseguro,
                                                           num_lin);

                                    IF num_err = 0 THEN
                                       COMMIT;
                                    END IF;
                                 END IF;
                              END IF;

                              -- fin Bug 23940 - APD - 02/01/2013
                              v_traza := 14;

                              -- bug 19416:ASN:11/11/2011 ini
                              IF num_err = 0 THEN
                                 IF pac_propio.f_esta_en_exoneracion(v_seg.sseguro) = 1 THEN
                                    num_err := pac_propio.f_exonera_recibos(v_seg.sseguro,
                                                                            pfemisio);
                                 END IF;
                              END IF;

                              v_traza := 15;

                              -- bug 19416:ASN:11/11/2011 fin
                              IF num_err = 0 THEN
                                 -- BUG19069:DRA:03/10/2011:Inici
                                 IF pac_corretaje.f_tiene_corretaje(v_seg.sseguro, NULL) = 1 THEN
                                    num_err :=
                                       pac_corretaje.f_reparto_corretaje(v_seg.sseguro, NULL,
                                                                         NULL);
                                 END IF;

                                 IF num_err <> 0 THEN
                                    ROLLBACK;
                                    algun_error := 1;
                                    indice_error := indice_error + 1;
                                    texto := f_axis_literales(num_err, pidioma);
                                    texto := texto || '.' || v_seg.sseguro;
                                    num_lin := NULL;
                                    num_err := f_proceslin(psproces, texto, v_seg.sseguro,
                                                           num_lin);

                                    IF num_err = 0 THEN
                                       COMMIT;
                                    END IF;

                                    p_tab_error(f_sysdate, f_user,
                                                'pac_dincartera.cartera_producte', 1,
                                                'pempresa = ' || pempresa || ' pnpoliza = '
                                                || pnpoliza || ' pncertif = ' || pncertif
                                                || ' v_seg.sseguro = ' || v_seg.sseguro
                                                || ' pmes = ' || pmes || ' panyo = ' || panyo
                                                || 'pfcartera = ' || pfcartera
                                                || ' psproces = ' || psproces || ' pfemisio = '
                                                || pfemisio || ' pmoneda = ' || pmoneda
                                                || 'pidioma = ' || pidioma || 'num_err = '
                                                || num_err,
                                                texto);
                                 END IF;

                                 -- BUG19069:DRA:29/09/2011:Fi
                                 COMMIT;
                              ELSE
                                 ROLLBACK;
                                 texto := f_axis_literales(num_err, pidioma);
                                 texto := texto || '.' || v_seg.sseguro;
                                 num_lin := NULL;
                                 num_err := f_proceslin(psproces, texto, v_seg.sseguro,
                                                        num_lin);

                                 IF num_err = 0 THEN
                                    COMMIT;
                                 END IF;
                              END IF;

                              -- Bug 29943 - 03/04/2014 - JTT
                              IF num_err = 0 THEN
                                 num_err := pac_dincartera.f_tratamiento_pb(pempresa,
                                                                            v_sproduc,
                                                                            v_seg.sseguro,
                                                                            v_fcarpro_pb,
                                                                            NULL, 'R', NULL,
                                                                            psproces);

                                 IF num_err <> 0 THEN
                                    indice_error := indice_error + 1;
                                    texto := f_axis_literales(9906703, pidioma);
                                    texto := texto || '. ' || v_seg.sseguro || ' ' || pfemisio;
                                    num_lin := NULL;
                                    num_err := f_proceslin(psproces, texto, v_seg.sseguro,
                                                           num_lin);
                                    COMMIT;
                                 END IF;
                              END IF;

                              -- Fi bug 29943

                              /*--Inicio Mantis 34469/0205354 - BLA - DD25/MM05/2015.
                              num_err :=
                                 pac_dincartera.f_modif_cmovseg_aniversario(v_seg.sseguro,
                                                                            v_fcarproa_ant);

                              IF num_err = 0 THEN
                                 COMMIT;
                              ELSE
                                 ROLLBACK;
                                 algun_error := 1;
                                 indice_error := indice_error + 1;
                                 texto := f_axis_literales(num_err, pidioma);
                                 texto := texto || '.' || v_seg.sseguro;
                                 num_lin := NULL;
                                 num_err := f_proceslin(psproces, texto, v_seg.sseguro,
                                                        num_lin);
                              END IF;

                              -- Fin Mantis 34469/0205354 - BLA - DD25/MM05/2015.
                              */

                              -- ini Bug 0020932 - 20/01/2012 - JMF: Procesos din¿mics despres de fer cartera.
                              num_err := pac_dincartera.f_genera_acc_cartera(1, psproces,
                                                                             v_seg.sproduc,
                                                                             v_seg.sseguro,
                                                                             v_seg.fcarpro);

                              IF num_err = 1 THEN
                                 algun_error := 1;
                                 indice_error := indice_error + 1;
                              END IF;
                           -- fin Bug 0016856 - 26/01/2011 - JMF
                           EXCEPTION
                              WHEN OTHERS THEN
                                 p_tab_error(f_sysdate, f_user, 'PAC_DINCARTERA', v_traza,
                                             'ERROR 111533', SQLERRM);
                                 --DBMS_OUTPUT.put_line (SQLERRM);
                                 RETURN 111533;
                           END;
                        END IF;
                     END IF;
                  END IF;
               /*SELECT pac_parametros.f_parproducto_t (v_seg.sproduc,
                                                      'F_POST_CARTERA'
                                                     )
                 INTO v_funcion
                 FROM DUAL;

               IF v_funcion IS NOT NULL
               THEN
                  ss :=
                        'begin :num_err := '
                     || v_funcion
                     || '(:v_sproces, :v_sseguro); end;';

                  EXECUTE IMMEDIATE ss
                              USING OUT    num_err, IN psproces,
                                    IN     v_seg.sseguro;
               END IF;*/
               END LOOP;
            END IF;   -- fin Bug 23940 - APD - 12/11/2012 'CARTERA_PSU'
         EXCEPTION
            WHEN OTHERS THEN
               p_tab_error(f_sysdate, f_user, 'PAC_DINCARTERA', v_traza, 'ERROR 111534',
                           SQLERRM);
               --DBMS_OUTPUT.put_line (SQLERRM);
               RETURN 111534;
         END;

         -- Bug 9383 - 04/03/2009 - RSC - CRE: Unificaci¿n de recibos
         IF pskiprenova IS NULL THEN
            IF NVL(f_parproductos_v(f_sproduc_ret(v_prod.cramo, v_prod.cmodali,
                                                  v_prod.ctipseg, v_prod.ccolect),
                                    'RECUNIF'),
                   0) = 1 THEN
               --BUG 14438 - JTS - 12/05/2010
               IF NVL(f_parproductos_v(f_sproduc_ret(v_prod.cramo, v_prod.cmodali,
                                                     v_prod.ctipseg, v_prod.ccolect),
                                       'RECUNIF_NO_CARTERA'),
                      0) = 0 THEN
                  --FI BUG 14438
                  num_err := pac_gestion_rec.f_agruparecibo(f_sproduc_ret(v_prod.cramo,
                                                                          v_prod.cmodali,
                                                                          v_prod.ctipseg,
                                                                          v_prod.ccolect),
                                                            NVL(pfcartera,
                                                                TO_DATE('01'
                                                                        || LPAD(pmes, 2, '0')
                                                                        || panyo,
                                                                        'ddmmyyyy')),
                                                            pfemisio, pempresa);

                  IF num_err = 0 THEN
                     COMMIT;
                  ELSE
                     ROLLBACK;
                     texto := f_axis_literales(num_err, pidioma);
                     texto := texto || '.' || v_seg.sseguro;
                     num_lin := NULL;
                     num_err := f_proceslin(psproces, texto, v_seg.sseguro, num_lin);

                     IF num_err = 0 THEN
                        COMMIT;
                     END IF;
                  END IF;
               --BUG 14438 - JTS - 12/05/2010
               ELSE
                  -- Inicio Bug 35386 MMS 20150505
                  -- Revisamos la fecha. Si la fecha de cartera est¿ informada pasamos ese dato. Sino el ¿ltimo dia del mes de la cartera
                  IF pfcartera IS NOT NULL THEN
                     vfestrec := pfcartera;
                  ELSE
                     vfestrec := LAST_DAY(TO_DATE('01' || LPAD(pmes, 2, '0') || panyo,
                                                  'ddmmyyyy'));
                  END IF;

                  -- Fin Bug 35386 MMS 20150505
                  FOR i IN c_rebcartera(vfestrec,
                                        f_sproduc_ret(v_prod.cramo, v_prod.cmodali,
                                                      v_prod.ctipseg, v_prod.ccolect)) LOOP
                     BEGIN
                        UPDATE recibos
                           SET cestimp = 0,
                               cestaux = 0   -- MMS 20150505 Bug 35386
                         WHERE nrecibo = i.nrecibo;
                     EXCEPTION
                        WHEN OTHERS THEN
                           ROLLBACK;
                           texto := f_axis_literales(num_err, pidioma);
                           texto := texto || '.' || v_seg.sseguro;
                           num_lin := NULL;
                           num_err := f_proceslin(psproces, texto, v_seg.sseguro, num_lin);

                           IF num_err = 0 THEN
                              COMMIT;
                           END IF;
                     END;

                     COMMIT;
                  END LOOP;
               END IF;
            --FI BUG 14438
            -- BUG 0019627: GIP102 - Reunificaci¿n de recibos - FAL - 10/11/2011
            ELSIF NVL(f_parproductos_v(f_sproduc_ret(v_prod.cramo, v_prod.cmodali,
                                                     v_prod.ctipseg, v_prod.ccolect),
                                       'RECUNIF'),
                      0) = 3 THEN
               num_err := pac_dincartera.f_cartera_certif0(v_prod.cramo, v_prod.cmodali,
                                                           v_prod.ctipseg, v_prod.ccolect,
                                                           pmes, panyo, pfcartera, pempresa,
                                                           pfemisio, pidioma, psproces,
                                                           indice, indice_error, psseguro,
                                                           pnpoliza, pncertif);
            -- FI BUG 0019627
            END IF;
         END IF;

         -- Fin Bug 9383

         -- AMC
         -- CPM 1/3/06: Calculem les cesiones de les PU que es reaseguren
         pac_propio.f_renova_cesiones_pu(psproces, pmes, panyo, v_prod.cramo, v_prod.cmodali,
                                         v_prod.ctipseg, v_prod.ccolect, psseguro);
      END LOOP;

      -- ini Bug 0018967 - 30/09/2011 - JMF
      num_err := pac_dincartera.f_post_cartera_producte(psproces);

      IF NVL(num_err, 0) > 0 THEN
         p_tab_error(f_sysdate, f_user, 'pac_dincartera.cartera_producte', 0,
                     'psproces=' || psproces, 'num_err=' || num_err);
      END IF;

      -- fin Bug 0018967 - 30/09/2011 - JMF
      -- Ini Bug 148321 --ECP-- 04/07/2013 Se agrega AND autmanual IS NULL
      SELECT COUNT(*)
        INTO num_total_registres
        FROM prodcartera
       WHERE cempres = pempresa
         AND autmanual IS NULL;

      SELECT COUNT(*)
        INTO num_prod
        FROM prodcartera
       WHERE cempres = pempresa
         AND fcarant >= TO_DATE('01' || LPAD(pmes, 2, '0') || panyo, 'ddmmyyyy')
         AND autmanual IS NULL;

      --bug 16146--07/10/2010 - ETM --CEM - Fechas de cartera en procesos previo y real
      SELECT MIN(fcarant), MIN(fcarpro)
        INTO fcarant_min, fcarpro_min
        FROM prodcartera
       WHERE cempres = pempresa
         AND autmanual IS NULL;

      -- Fin Bug 148321 --ECP-- 04/07/2013
      --FIN --bug 16146
      IF num_total_registres = num_prod
         AND psseguro IS NULL   --AMC
                             THEN
         -- Se actualiza fcarpro de EMPRESAS.
         BEGIN
            SELECT fcarpro, fcarant
              INTO fecha_carpro, fecha_carant
              FROM empresas
             WHERE cempres = pempresa;

            IF TO_CHAR(fecha_carpro, 'mmyyyy') <= LPAD(pmes, 2, '0') || panyo THEN
               UPDATE empresas
                  SET fcarpro = fcarpro_min,
                      --bug 16146--antes- ADD_MONTHS(fecha_carpro, 1),
                      fcarant = fcarant_min
                --bug 16146--antes-ADD_MONTHS(fecha_carant, 1)
               WHERE  cempres = pempresa;

               COMMIT;
            END IF;
         EXCEPTION
            WHEN OTHERS THEN
               --                                      p_error(102531,ppsproces, sqlcode);
               algun_error := 1;
         END;
      END IF;

      --BUG24572 Docs de cartera
      IF ((pnpoliza IS NOT NULL
           AND pncertif IS NOT NULL)
          OR psseguro IS NOT NULL) THEN
         pac_isql.p_docs_cartera(psproces, psseguro, pnpoliza, pncertif);
      ELSE
         -- INI RLLF 10/03/2015 BUG-33230 No llama a la generaci¿n de documentaci¿n.
         --pac_isql.p_docs_cartera(psproces, pmes, panyo);
         pac_isql.p_docs_cartera(psproces, NULL, NULL, NULL, pmes, panyo);
      -- FIN RLLF 10/03/2015 BUG-33230 No llama a la generaci¿n de documentaci¿n.
      END IF;

      --Fi BUG24572

      -- BUIDEM LA LLISTA DE PRODUCTES
      -- JLB - I - 17/10/2013 -- bloqueo de la cartera
       -- DELETE FROM carteraaux
        --      WHERE sproces = psproces_prod;
      num_err := f_delete_carteraaux(psproces_prod);
      -- JLB - F - 17/10/2013 -- bloqueo de la cartera
      COMMIT;
      RETURN 0;
   EXCEPTION
      WHEN OTHERS THEN
         texto := SUBSTR(SQLERRM, 1, 100);
         ROLLBACK;
         num_lin := NULL;
         num_err := f_proceslin(psproces, texto, 0, num_lin);
         COMMIT;

         DELETE FROM garancar
               WHERE sproces = psproces;

         DELETE      preguncar
               WHERE sproces = psproces;

         DELETE      pregungarancar
               WHERE sproces = psproces;

         DELETE      pregunpolcar
               WHERE sproces = psproces;

         -- JLB - 17/10/2013 -- bloqueo de la cartera
         -- BUIDEM LA LLISTA DE PRODUCTES
          -- DELETE FROM carteraaux
           --      WHERE sproces = psproces_prod;
         num_err := f_delete_carteraaux(psproces_prod);
         -- JLB - F - 17/10/2013 -- bloqueo de la cartera
         COMMIT;
         RETURN 112608;
   END cartera_producte;

-------------------------------------------------------------------------------------
--BUG 0026638: FAC LCOL - TEC - Cartera para Autos. (id 176-19)
   FUNCTION f_act_homologo_valores(
      psproces IN NUMBER,
      psseguro IN NUMBER,
      pnriesgo IN NUMBER,
      pcversion IN VARCHAR2,
      psproduc IN NUMBER)
      RETURN NUMBER IS
      verror         NUMBER;
      vconta         NUMBER;
      vtraza         NUMBER;
      pvalorcomercial NUMBER;
      pvalorcomercial_nuevo NUMBER;
      vcestado_version NUMBER;
      vcversionhomologo aut_versiones.cversionhomologo%TYPE;
   BEGIN
      vtraza := 1;

      SELECT COUNT(1)
        INTO vconta
        FROM aut_versiones av, aut_tipoactiprod t0
       WHERE av.cversion = pcversion
         AND av.ctipveh = t0.ctipveh
         AND t0.sproduc = psproduc
         AND av.cempres = t0.cempres
         AND t0.cactivi = NVL(t0.cactivi, 0)
         AND av.cestado NOT IN(2)
         AND av.cempres = pac_md_common.f_get_cxtempresa;

      IF vconta = 0 THEN
         RETURN 9904758;
      ELSE
         --Bug 26638/160933 - 11/12/2013 - AMC
         BEGIN
            SELECT av.cversionhomologo
              INTO vcversionhomologo
              FROM aut_versiones_anyo d, aut_versiones av, autriesgoscar ar
             WHERE d.cversion = pcversion
               AND av.cversion = d.cversion
               AND ar.anyo = d.anyo
               AND ar.sseguro = psseguro
               AND ar.nriesgo = pnriesgo
               AND av.cversion = ar.cversion
               AND ar.sproces = psproces;

            vtraza := 2;

            UPDATE autriesgoscar
               SET cversion = vcversionhomologo
             WHERE sproces = psproces
               AND sseguro = psseguro
               AND nriesgo = pnriesgo;
         EXCEPTION
            WHEN NO_DATA_FOUND THEN
               RETURN NULL;
         END;

         verror := pac_autos.f_get_valorauto(psseguro, pnriesgo, psproces, pcversion, 1,
                                             pvalorcomercial, pvalorcomercial_nuevo);

         UPDATE autriesgoscar
            SET ivehinue = NVL(pvalorcomercial_nuevo, ivehinue),
                ivehicu = NVL(pvalorcomercial, ivehicu)
          WHERE sproces = psproces
            AND sseguro = psseguro
            AND nriesgo = pnriesgo;
      --Fi Bug 26638/160933 - 11/12/2013 - AMC
      END IF;

      RETURN 0;
   EXCEPTION
      WHEN OTHERS THEN
         p_tab_error(f_sysdate, f_user, 'PAC_DINCARTERA.f_act_homologo_valores', vtraza,
                     f_axis_literales(1000455), SQLERRM);
         RETURN 1000455;
   END f_act_homologo_valores;

   FUNCTION f_act_antiguedad(psproces IN NUMBER, psseguro IN NUMBER, pnriesgo IN NUMBER)
      RETURN NUMBER IS
      verror         NUMBER;
      vconta         NUMBER;
      vtraza         NUMBER;
   BEGIN
      vtraza := 1;

      UPDATE autconductorescar
         SET exper_manual = NVL(exper_manual, 0) + 1
       WHERE sproces = psproces
         AND sseguro = psseguro
         AND nriesgo = pnriesgo
         AND cprincipal = 1;

      RETURN 0;
   EXCEPTION
      WHEN OTHERS THEN
         p_tab_error(f_sysdate, f_user, 'PAC_DINCARTERA.f_act_antiguedad', vtraza,
                     f_axis_literales(1000455), SQLERRM);
         RETURN 1000455;
   END f_act_antiguedad;

   FUNCTION f_act_num_siniestros(
      psproces IN NUMBER,
      psseguro IN NUMBER,
      pnriesgo IN NUMBER,
      pnsiniestros IN NUMBER)
      RETURN NUMBER IS
      verror         NUMBER;
      vconta         NUMBER;
      vtraza         NUMBER;
   BEGIN
      vtraza := 1;

      UPDATE preguncar
         SET crespue = pnsiniestros
       WHERE sseguro = psseguro
         AND nriesgo = pnriesgo
         AND cpregun = 4926
         AND sproces = psproces;

      RETURN 0;
   EXCEPTION
      WHEN OTHERS THEN
         p_tab_error(f_sysdate, f_user, 'PAC_DINCARTERA.f_act_antiguedad', vtraza,
                     f_axis_literales(1000455), SQLERRM);
         RETURN 1000455;
   END f_act_num_siniestros;

   --FIN BUG 0026638: FAC LCOL - TEC - Cartera para Autos. (id 176-19)
   FUNCTION f_garantarifa_sgt(
      pmodo IN VARCHAR2,
      psseguro IN NUMBER,
      pcramo IN NUMBER,
      pcmodali IN NUMBER,
      pcobjase IN NUMBER,
      pctipseg IN NUMBER,
      pccolect IN NUMBER,
      pctipo IN NUMBER,
      pnduraci IN NUMBER,
      conta_proces IN NUMBER,
      pcdurcob IN NUMBER,
      pfcarpro IN DATE,
      pmes IN VARCHAR2,
      panyo IN NUMBER,
      tipo IN NUMBER,
      pcagrpro IN NUMBER,
      pcmanual IN NUMBER,
      pcactivi IN NUMBER,
      num_risc IN NUMBER,
      pfemisio IN DATE,
      pfefecto IN DATE,   -- nununu
      movimiento OUT NUMBER,
      anulado OUT NUMBER,
      pmoneda IN NUMBER,
      parms_transitorios IN OUT pac_parm_tarifas.parms_transitorios_tabtyb,
      pbonifica IN NUMBER,
      paplica_bonifica IN NUMBER,
      psproduc IN NUMBER,
      pcforpag IN NUMBER,
      pidioma IN NUMBER,
      pcgarant_regu IN NUMBER,
      pnorden IN NUMBER,
      pcprimin IN NUMBER,
      piprimin IN NUMBER,
      pcclapri IN NUMBER,
      pnedamar IN NUMBER,
      pciedmar IN NUMBER,
      pfcaranu IN DATE)
-- Bug 10828 - RSC -08/09/2009 - CRE - Revisi¿n de los productos PPJ din¿mico y Pla Estudiant (ajustes)
   RETURN NUMBER IS
      /***********************************************************************************************
                                                     F_GARANTARIFA_SGT: 1.- Revaloriza el seguro
                          2.- Tarifica
                          3.- Grabamos en GARANCAR
      ************************************************************************************************/
      num_err        NUMBER := 0;
      prevcap        NUMBER;
      piprima        NUMBER;
      cont           tmp_garancar.contador%TYPE := 0;
--       cont           NUMBER := 0; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      texto          VARCHAR2(80);
      registros      NUMBER;
      estat_garan    VARCHAR2(20);
      tecnico        NUMBER;   -- Si hay descuento tecnico
      porcen         NUMBER;   -- Porcentaje del coaseguro
      old_riesgo     NUMBER := 0;
      total_prima    NUMBER;
      wsperson       NUMBER;
      wedad          NUMBER;
      wcsexper       NUMBER;
      wfnacimi       DATE;
      mensa          VARCHAR2(100);
      lprima_bonif   NUMBER;
      laplica_actual NUMBER;
      lcanvia_tarifa NUMBER;
      lcanvia_tarifa_pro NUMBER;   -- aquesta mant¿ la del producte
      lcanvia_tarifa_gar NUMBER;   -- aquesta la de la garantia
      aux            NUMBER;
      vpasexec       NUMBER(5) := 1;
      -- Ini Bug 21907 - MDS - 03/05/2012
      pidtotec       tmp_garancar.idtotec%TYPE := 0;
--       pidtotec       NUMBER := 0; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      pireccom       tmp_garancar.ireccom%TYPE := 0;
--       pireccom       NUMBER := 0; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      -- Fin Bug 21907 - MDS - 03/05/2012
      vapldtosenform NUMBER;   --bfp bug 22212
      vcplan         NUMBER;   --Bug 33145/192139 - 01/12/2014 - AMC
      vnewcapital    NUMBER;   --Bug 33145/192139 - 01/12/2014 - AMC

      ------
-- I -- JLB - OPTIMI
--      CURSOR tmp(wses NUMBER) IS
--         SELECT *
--           FROM sgt_parms_transitorios
--          WHERE sesion = wses;
-- F -- JLB - OPTIMI
      -------
      CURSOR cur_risc IS
         SELECT DISTINCT sseguro, nriesgo
                    FROM garanseg
                   WHERE sseguro = psseguro
                     AND ffinefe IS NULL;

      -- Bug 9794 - YIL - 21/04/2009 -- Se modifica el order by del cursor de garant¿as para
      --                                dejarlo igual que el cursor de pac_tarifas (seg¿n el par¿metro 'ORDEN_TARIF')
      -- Bug 9524 - YIL - 30/04/2009 -- Se modifica el order by de los cursores de garant¿as
      --                                para que tenga en cuenta el par¿metro ORDEN_TARIF_CARTERA en lugar del ORDEN_TARIF
      -- Bug 7926 - RSC - 28/05/2009 -- Se modifica la select del cursor  para que tenga en
      --                                cuenta si la garant¿a ha vencido ya (solo para el previo, ya que en la cartera
      --                                real ya se da de baja la garant¿a antes y por tanto la garant¿a ya no entra en el cursor.

      --Bug 26638/160974 - 03/04/2014 - AMC   - Se a¿ade la tabla garanseg_aux a la select
      CURSOR c_garanseg_risc(wnriesgo IN NUMBER) IS
         SELECT   NVL(g.sseguro, gg.sseguro) sseguro, NVL(g.cgarant, gg.cgarant) cgarant,
                  NVL(g.nriesgo, gg.nriesgo) nriesgo, NVL(g.nmovimi, gg.nmovimi) nmovimi,
                  NVL(g.finiefe, gg.finiefe) finiefe, NVL(g.norden, gg.norden) norden,
                  NVL(g.ctarifa, gg.ctarifa) ctarifa, NVL(g.icaptot, gg.icaptot) icapital,
                  NVL(g.precarg, gg.precarg) precarg, NVL(g.ipritot, gg.ipritot) iprianu,
                  NVL(g.ffinefe, gg.ffinefe) ffinefe, NVL(g.cformul, gg.cformul) cformul,
                  NVL(g.iextrap, gg.iextrap) iextrap, NVL(g.ctipfra, gg.ctipfra) ctipfra,
                  NVL(g.ifranqu, gg.ifranqu) ifranqu, NVL(g.irecarg, gg.irecarg) irecarg,
                  NVL(g.idtocom, gg.idtocom) idtocom, NVL(g.pdtocom, gg.pdtocom) pdtocom,
                  NVL(g.ipritar, gg.ipritar) ipritar, NVL(g.crevali, gg.crevali) crevali,
                  NVL(g.prevali, gg.prevali) prevali, NVL(g.irevali, gg.irevali) irevali,
                  NVL(g.itarifa, gg.itarifa) itarifa, NVL(g.itarrea, gg.itarrea) itarrea,
                  NVL(g.ftarifa, gg.ftarifa) ftarifa, NVL(g.crevalcar, gg.crevalcar) crevalcar,
                  NVL(g.cderreg, gg.cderreg) cderreg, NVL(g.feprev, gg.feprev) feprev,
                  NVL(g.fpprev, gg.fpprev) fpprev, NVL(g.percre, gg.percre) percre,
                  NVL(g.cref, gg.cref) cref, NVL(g.cintref, gg.cintref) cintref,
                  NVL(g.pdif, gg.pdif) pdif, NVL(g.pinttec, gg.pinttec) pinttec,
                  NVL(g.nparben, gg.nparben) nparben, NVL(g.nbns, gg.nbns) nbns,
                  NVL(g.tmgaran, gg.tmgaran) tmgaran, NVL(g.cmatch, gg.cmatch) cmatch,
                  NVL(g.tdesmat, gg.tdesmat) tdesmat, NVL(g.pintfin, gg.pintfin) pintfin,
                  NVL(g.nfactor, gg.nfactor) nfactor, NVL(g.nmovima, gg.nmovima) nmovima
             FROM garanseg g, garanseg_aux gg
            WHERE g.sseguro = psseguro
              AND gg.sseguro(+) = g.sseguro
              AND g.nriesgo = wnriesgo
              AND gg.nriesgo(+) = g.nriesgo
              AND gg.nmovimi(+) = g.nmovimi
              AND g.ffinefe IS NULL
              AND pfcarpro < DECODE(pmodo,
                                    'P', NVL(pac_seguros.f_vto_garantia(g.sseguro, g.nriesgo,
                                                                        g.cgarant, g.nmovimi),
                                             pfcarpro + 1),
                                    pfcarpro + 1)
         ORDER BY g.nriesgo,
                  DECODE(NVL(pac_parametros.f_pargaranpro_n(psproduc, pcactivi, g.cgarant,
                                                            'ORDEN_TARIF_CARTERA'),
                             0),
                         0, g.cgarant,
                         pac_parametros.f_pargaranpro_n(psproduc, pcactivi, g.cgarant,
                                                        'ORDEN_TARIF_CARTERA'));

      --ORDER BY nriesgo;
      -- Bug 9794 - YIL - 21/04/2009 -- Fin
      -- Bug 9524 - YIL - 30/04/2009 -- Fin
      -- Bug 7926 - RSC - 28/05/2009 -- Fin

      -- Bug 9794 - YIL - 21/04/2009 -- Se modifica el order by del cursor de garant¿as para dejarlo igual que el cursor de pac_tarifas (seg¿n el par¿metro 'ORDEN_TARIF')
      -- Bug 9524 - YIL - 30/04/2009 -- Se modifica el order by de los cursores de garant¿as para que tenga en cuenta el par¿metro ORDEN_TARIF_CARTERA
      --en lugar del ORDEN_TARIF
      -- Bug 7926 - RSC - 28/05/2009 -- Se modifica la select del cursor  para que tenga en
      --                                cuenta si la garant¿a ha vencido ya (solo para el previo, ya que en la cartera
      --                                real ya se da de baja la garant¿a antes y por tanto la garant¿a ya no entra en el cursor.
      CURSOR c_garancar(wnriesgo IN NUMBER) IS
         SELECT   sseguro, cgarant, nriesgo, finiefe, norden, ctarifa, icapital, precarg,
                  iprianu, ffinefe, cformul, iextrap, sproces, ctipfra, ifranqu, irecarg,
                  ipritar, idtocom, pdtocom, crevali, prevali, irevali, itarifa, itarrea,
                  ftarifa, cderreg, feprev, fpprev, percre, cref, cintref, pdif, pinttec,
                  nparben, nbns, tmgaran, cmatch, tdesmat, pintfin, nmovi_ant, nmovima,
                  ctarman
-- Bug 14429 - RSC - 16/09/2010 - AGA005 - Primes manuals pels productes de Llar
         FROM     garancar
            WHERE sseguro = psseguro
              AND nriesgo = wnriesgo
              AND sproces = conta_proces
              AND pfcarpro < DECODE(pmodo,
                                    'P', NVL(pac_seguros.f_vto_garantia(sseguro, nriesgo,
                                                                        cgarant, nmovi_ant),
                                             pfcarpro + 1),
                                    pfcarpro + 1)
         ORDER BY DECODE(NVL(pac_parametros.f_pargaranpro_n(psproduc, pcactivi, cgarant,
                                                            'ORDEN_TARIF_CARTERA'),
                             0),
                         0, cgarant,
                         pac_parametros.f_pargaranpro_n(psproduc, pcactivi, cgarant,
                                                        'ORDEN_TARIF_CARTERA'));

      --ORDER BY nriesgo;
      -- Bug 9794 - YIL - 21/04/2009 -- Fin
      -- Bug 9524 - YIL - 30/04/2009 -- Fin
      -- Bug 7926 - RSC - 28/05/2009 -- Fin

      -- Bug 21127 - APD - 14/03/2012 - se crea el cursor como copia del cursor
      -- anterior c_garancar pero con la tabla tmp_garancar
      CURSOR c_tmp_garancar(wnriesgo IN NUMBER) IS
         SELECT   sseguro, cgarant, nriesgo, finiefe, norden, ctarifa, icapital, precarg,
                  iprianu, ffinefe, cformul, iextrap, sproces, ctipfra, ifranqu, irecarg,
                  ipritar, idtocom, pdtocom, crevali, prevali, irevali, itarifa, itarrea,
                  ftarifa, cderreg, feprev, fpprev, percre, cref, cintref, pdif, pinttec,
                  nparben, nbns, tmgaran, cmatch, tdesmat, pintfin, nmovi_ant, nmovima,
                  ctarman,
-- Bug 14429 - RSC - 16/09/2010 - AGA005 - Primes manuals pels productes de Llar
                                                       -- Ini Bug 21907 - MDS - 03/05/2012
                          pdtotec, preccom, idtotec, ireccom
             -- FIN Bug 21907 - MDS - 03/05/2012
         FROM     tmp_garancar
            WHERE sseguro = psseguro
              AND nriesgo = wnriesgo
              AND sproces = conta_proces
              AND pfcarpro < DECODE(pmodo,
                                    'P', NVL(pac_seguros.f_vto_garantia(sseguro, nriesgo,
                                                                        cgarant, nmovi_ant),
                                             pfcarpro + 1),
                                    pfcarpro + 1)
         ORDER BY DECODE(NVL(pac_parametros.f_pargaranpro_n(psproduc, pcactivi, cgarant,
                                                            'ORDEN_TARIF_CARTERA'),
                             0),
                         0, cgarant,
                         pac_parametros.f_pargaranpro_n(psproduc, pcactivi, cgarant,
                                                        'ORDEN_TARIF_CARTERA'));

      -- fin Bug 21127 - APD - 14/03/2012

      -- Gastos a nivel de garant¿a
      CURSOR cur_garanseggas(wnriesgo IN NUMBER, wcgarant IN NUMBER) IS
         SELECT gg.sseguro, gg.nriesgo, gg.cgarant, gg.nmovimi, gg.finiefe, gg.cgastos,
                gg.pvalor, gg.pvalres, gg.nprima, gg.cmatch, gg.tdesmat, gg.pintfin
           FROM garanseggas gg, garanseg g
          WHERE gg.sseguro = g.sseguro
            AND gg.sseguro = psseguro
            AND gg.cgarant = g.cgarant
            AND gg.cgarant = wcgarant
            AND gg.nriesgo = g.nriesgo
            AND gg.finiefe = g.finiefe
            AND gg.nriesgo = wnriesgo;

      -- Comisiones a nivel de garant¿a
-- FBL. 25/06/2014 MSV Bug 0028974
      CURSOR cur_garansegcom(wnriesgo IN NUMBER, wcgarant IN NUMBER) IS
         SELECT gg.sseguro, gg.nriesgo, gg.cgarant, gg.nmovimi, gg.finiefe, gg.cmodcom,
                gg.pcomisi, gg.ninialt, gg.nfinalt, gg.pcomisicua, gg.falta, gg.cusualt,
                gg.fmodifi, gg.cusumod   -- bfp bug 21947
           FROM garansegcom gg, garanseg g
          WHERE gg.sseguro = g.sseguro
            AND gg.sseguro = psseguro
            AND gg.cgarant = g.cgarant
            AND gg.cgarant = wcgarant
            AND gg.nriesgo = g.nriesgo
            AND gg.finiefe = g.finiefe
            AND gg.nriesgo = wnriesgo
            AND pac_parametros.f_parproducto_n(psproduc, 'AFECTA_COMISESPPROD') = 0;

-- Fin FBL. 25/06/2014 MSV Bug 0028974

      -- Sobreprimas a nivel de garant¿a
      CURSOR cur_garansegsbpri(wnriesgo IN NUMBER, wcgarant IN NUMBER) IS
         SELECT   gg.sseguro, gg.nriesgo, gg.cgarant, gg.nmovimi, gg.finiefe, gg.norden,
                  gg.ctipsbr, gg.ccalsbr, gg.pvalor, gg.ncomisi
             FROM garanseg_sbpri gg, garanseg g
            WHERE gg.sseguro = g.sseguro
              AND gg.sseguro = psseguro
              AND gg.cgarant = g.cgarant
              AND gg.cgarant = wcgarant
              AND gg.nriesgo = g.nriesgo
              AND gg.finiefe = g.finiefe
              AND gg.nriesgo = wnriesgo
         ORDER BY gg.norden;

-- FBL. 25/06/2014 MSV Bug 0028974
      CURSOR c_garansegcom(
         p_seguro NUMBER,
         p_cgarant NUMBER,
         p_nriesgo NUMBER,
         p_nmovimi NUMBER,
         p_fecha DATE) IS
         SELECT cmodcom
           FROM garansegcom seg
          WHERE seg.sseguro = p_seguro
            AND seg.nriesgo = p_nriesgo
            AND seg.cgarant = p_cgarant
            AND(seg.nmovimi = p_nmovimi
                OR(seg.nmovimi < p_nmovimi
                   AND seg.nmovimi = (SELECT MAX(seg2.nmovimi)
                                        FROM garansegcom seg2
                                       WHERE seg2.sseguro = seg.sseguro
                                         AND seg2.nriesgo = seg.nriesgo
                                         AND seg2.cgarant = seg.cgarant)));

--         and p_fecha between add_months (seg.finiefe, (ninialt - 1)*12)
--                         and add_months(seg.finiefe, 12 * seg.nfinalt);
-- Fin FBL. 25/06/2014 MSV Bug 0028974
      ppsproces      garancar.sproces%TYPE := conta_proces;
--       ppsproces      NUMBER := conta_proces; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      piprianu       NUMBER := 0;
      pipritar       NUMBER := 0;
      pirecarg       tmp_garancar.irecarg%TYPE := 0;
--       pirecarg       NUMBER := 0; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      pidtocom       tmp_garancar.idtocom%TYPE := 0;
--       pidtocom       NUMBER := 0; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      prima          tmp_garancar.iprianu%TYPE := 0;
--       prima          NUMBER := 0; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      prevprima      NUMBER;
      pnnumlin       NUMBER;
      garantia       NUMBER;
      wprima         NUMBER;
      --psesion      sgt_parms_transitorios.sesion%TYPE;   --       psesion        NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      psesion        PLS_INTEGER;
      -- jlb - optimizaci¿n
      tasa           NUMBER := 0;
      lnmovimi       NUMBER;
      lcte           NUMBER := 0;
      lcdo           NUMBER := 0;
      lprima_minima  NUMBER;
      formula        sgt_formulas.formula%TYPE;
--       formula        VARCHAR2(2000); --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      lprima_regu    garancar.iprianu%TYPE;
      --       lprima_regu    NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      lcvalpar       NUMBER;
      laplicaprmin   NUMBER;
      vctarman       garanpro.ctarman%TYPE;
      --       vctarman       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      v_factor       NUMBER;   --factor multiplicador.
      --
      v_resp         NUMBER;
      v_nmovimi      NUMBER;
      xdecprev       NUMBER;
      xtmgaran       NUMBER;
      xctabla        NUMBER;
      xltabla        NUMBER;
      xfefecto       DATE;
      --
      vmovgar        NUMBER;
      num_err2       NUMBER;
      pmensa         VARCHAR2(100);
      v_extraprima   NUMBER;   -- BUG19532:DRA:26/09/2011
      -- BUG 20666-  01/2012 - JRH  -  20666:  Buscar en las CAR
      vcapital_ini   NUMBER;
      vcapital_def   NUMBER;
      vcrespuesta    NUMBER;
      vcprimin       productos.cprimin%TYPE;
      --       vcprimin       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
         -- Fi BUG 20666-  01/2012 - JRH
      v_tregconcep   pac_parm_tarifas.tregconcep_tabtyp;
      -- Bug 21121 - APD - 23/02/2012
      v_cversion     aut_versiones.cversion%TYPE;
      vcont          NUMBER;
      vfrenova       DATE;
      vnmovimi       NUMBER;
      vnsiniestros   NUMBER;
-- FBL. 25/06/2014 MSV Bug 0028974
      v_iprianu_ant  NUMBER;
      v_nmovimi_ant  NUMBER;
      v_ipricom      NUMBER;
      v_mensajes     t_iax_mensajes;
      v_res          NUMBER;
-- Fin FBL. 25/06/2014 MSV Bug 0028974
      v_crespue_4942 pregungaranseg.crespue%TYPE;
      v_crespue_4945 pregungaranseg.crespue%TYPE;
      vcapital2      NUMBER;
      vcount         NUMBER;
      vcempres       NUMBER;
      vactfranqbonus NUMBER;
      vaplicaplanben NUMBER;
   BEGIN
      --bug 33488/ QT S/N CARTERA COLECTIVOS

      -- Inicializamos esta variable por que no esta bien inicializada al lanzar cartera, y si es un producto de autos colectivo en el certificado cero
      -- esta tarificando cuando no debe.   parametro = 'POLIZACER0'
      DECLARE
         vsproduc       NUMBER;
         vnpoliza       NUMBER;
      BEGIN
         SELECT sproduc, npoliza
           INTO vsproduc, vnpoliza
           FROM seguros
          WHERE sseguro = psseguro;

         IF pac_seguros.f_soycertifcero(vsproduc, vnpoliza, psseguro) = 0 THEN
            p_tab_error(f_sysdate, f_user, 'PAC_TARIFAS.F_TARIFAR_RISC', 1,
                        'Entramos es true', NULL);
            pac_iax_produccion.isaltacol := TRUE;
         ELSE
            p_tab_error(f_sysdate, f_user, 'PAC_TARIFAS.F_TARIFAR_RISC', 1,
                        'ENTRAMOS ES FALSE', NULL);
            pac_iax_produccion.isaltacol := FALSE;
         END IF;
      END;

      parms_transitorios.DELETE;

      -- Inicializo la matriz de parms_transitorios

      -- Seleccionamos el n¿mero de sesi¿n del proceso.
      SELECT sgt_sesiones.NEXTVAL
        INTO psesion
        FROM DUAL;

      BEGIN
         -- I - JLB - OPTIMIZA
         --   INSERT INTO sgt_parms_transitorios
         --               (sesion, parametro, valor)
          --       VALUES (psesion, 'SESION', psesion);
         num_err := pac_sgt.put(psesion, 'SESION', psesion);

         IF num_err <> 0 THEN
            RAISE NO_DATA_FOUND;
         END IF;
      -- F - JLB - OPTIMINIZA
      EXCEPTION
         WHEN OTHERS THEN
            RETURN 108438;
      END;

      -- Cal veure si el producte aplica canvi de tarifa al renovar
      num_err := f_parproductos(psproduc, 'NOVATARIFA', lcanvia_tarifa_pro);

      IF num_err <> 0 THEN
         RETURN num_err;
      END IF;

      -- Cal veure si per aquesta p¿lissa en concret existeix l'excepci¿ de no
      -- aplicar la prima m¿nima (Valor fixe 820, concepte = 1), etc.
      num_err := pac_dincartera.f_excepcionsegu(psseguro, 1, laplicaprmin);

      IF num_err <> 0 THEN
         RETURN num_err;
      END IF;

      vpasexec := 2;

      SELECT cprimin
        INTO vcprimin
        FROM productos
       WHERE sproduc = psproduc;

-------------------
-- Cursor de riscos
-------------------
      FOR v_risc IN cur_risc LOOP
         -- Inicialitzar parms
         parms_transitorios.DELETE;
         --
         -- I - JLB - OPTIMI
         -- DELETE FROM sgt_parms_transitorios
         --      WHERE sesion = psesion
         --        AND parametro <> 'SESION';
         num_err := pac_sgt.del(psesion);
         num_err := pac_sgt.put(psesion, 'SESION', psesion);

         -- F - JLB - OPTIMIZA

         ------------------------------------------------------------------------
--Pasamos garanseg a tmp_garancar
------------------------------------------------------------------------
         BEGIN
            SELECT MAX(nmovimi)
              INTO vmovgar
              FROM garanseg
             WHERE sseguro = psseguro
               AND ffinefe IS NULL;

            IF vmovgar IS NULL THEN
               RETURN 10000000000;
            END IF;
         END;

         vpasexec := 3;
         num_err := pac_tarifas.f_tmpgarancar(NULL, conta_proces, psseguro, v_risc.nriesgo,
                                              vmovgar);

         IF num_err <> 0 THEN
            --DBMS_OUTPUT.put_line ('traspaso garantias ' || num_err);
            RETURN num_err;
         END IF;

         ---BUG 0026638: FAC LCOL - TEC - Cartera para Autos. (id 176-19)
         SELECT COUNT(1)
           INTO vcont
           FROM autriesgoscar
          WHERE sproces = conta_proces
            AND sseguro = psseguro
            AND nriesgo = v_risc.nriesgo;

         IF vcont <> 0 THEN
            SELECT cversion
              INTO v_cversion
              FROM autriesgoscar
             WHERE sproces = conta_proces
               AND sseguro = psseguro
               AND nriesgo = v_risc.nriesgo;

            num_err := f_act_homologo_valores(conta_proces, psseguro, v_risc.nriesgo,
                                              v_cversion, psproduc);

            IF num_err <> 0 THEN
               RETURN num_err;
            END IF;

            num_err := f_act_antiguedad(conta_proces, psseguro, v_risc.nriesgo);

            IF num_err <> 0 THEN
               RETURN num_err;
            END IF;

            vnsiniestros := pac_planbenef.f_autos_siniestros('CAR', psseguro, v_risc.nriesgo,
                                                             vfrenova, vnmovimi, NULL, NULL,
                                                             NULL, NULL, 4926);
            num_err := f_act_num_siniestros(conta_proces, psseguro, v_risc.nriesgo,
                                            vnsiniestros);

            IF num_err <> 0 THEN
               RETURN num_err;
            END IF;

            -- Bug 26638/160974 - 19/12/2013 - AMC
            num_err := f_parproductos(psproduc, 'APLICAPLANBEN', vaplicaplanben);

            IF NVL(vaplicaplanben, 0) = 1 THEN
               num_err := pac_planbenef.f_set_planbeneficios(psseguro, v_risc.nriesgo,
                                                             vnmovimi, conta_proces, 'CAR');

               IF num_err <> 0 THEN
                  RETURN num_err;
               END IF;
            END IF;

            -- Bug 26638/161264 - 14/04/2013 - AMC
            num_err := f_parproductos(psproduc, 'ACTFRANQBONUS', vactfranqbonus);

            IF NVL(vactfranqbonus, 0) = 1 THEN
               SELECT cempres
                 INTO vcempres
                 FROM seguros
                WHERE sseguro = psseguro;

               num_err := pac_dincartera.f_actualizar_franq(conta_proces, psproduc, pcactivi,
                                                            v_risc.nriesgo, psseguro, vmovgar,
                                                            pfefecto, psseguro, NULL, NULL,
                                                            NULL, NULL, NULL, NULL, NULL, NULL,
                                                            NULL, NULL, NULL, NULL, FALSE,
                                                            FALSE, vcempres, pidioma);

               IF num_err <> 0 THEN
                  RETURN num_err;
               END IF;

               -- Bug 26638/161275 - 14/04/2013 - AMC
               num_err := pac_dincartera.f_set_bonus_malus(conta_proces, psseguro,
                                                           v_risc.nriesgo, vmovgar + 1,
                                                           psproduc, pfefecto, vcempres);

               IF num_err <> 0 THEN
                  RETURN num_err;
               END IF;
            END IF;
         END IF;

         --FIN BUG 0026638: FAC LCOL - TEC - Cartera para Autos. (id 176-19)

         -------------------------------------------------------------------------
-- Es comprova l'anul.laci¿ per edat
-- las inicializaciones se hacen dentro
-- las preguntas se insertan a dentro de la funcion que tarifa ya
-- que para tarifar se necesitan las respuestas.
-------------------------------------------------------------------------
         cont := 0;

         FOR v_gar IN c_garanseg_risc(v_risc.nriesgo) LOOP
            --SMF ara mirem que la nova data de tarifa a nivell de garantia
            num_err := f_pargaranpro(pcramo, pcmodali, pctipseg, pccolect, pcactivi,
                                     v_gar.cgarant, 'NOVATARIFAGAR', lcanvia_tarifa_gar);

            IF num_err <> 0 THEN
               RETURN num_err;
            END IF;

            lcanvia_tarifa := NVL(lcanvia_tarifa_gar, lcanvia_tarifa_pro);

            IF NVL(lcanvia_tarifa, 0) = 1 THEN
               v_gar.ftarifa := pfcarpro;
            END IF;

            -- Modifiquem la bonificacio
            IF paplica_bonifica = 1 THEN
               -- La bonificaci¿ la posem al descompte.
               v_gar.pdtocom := pbonifica;
            END IF;

            -- Ini 30417/11637 -- ECP -- 05/03/2014
            IF NVL(f_parproductos_v(psproduc, 'VALIDA_ANULEDAD'), 1) = 1 THEN
               -- Miramos si se tiene que anular la garant¿a por la edad.
               -- Si fuera as¿ en la funci¿n anuledad ya se anula
               num_err := f_anuledad(psseguro, v_gar.nriesgo, v_gar.cgarant, v_gar.nmovimi,
                                     v_gar.finiefe, pfcarpro, pcramo, pcmodali, pctipseg,
                                     pccolect, pcobjase, pmodo, NULL   --ptablas
                                                                    , pnedamar, pciedmar,
                                     estat_garan);

               IF num_err <> 0 THEN
                  RETURN num_err;
               END IF;
            ELSE
               estat_garan := 'NO_CAMBIADA';
            END IF;

            -- Fin 30417/11637 -- ECP -- 05/03/2014
            vpasexec := 4;

            IF estat_garan = 'NO_CAMBIADA' THEN   -- si la garant¿a no se anula por la edad
               cont := cont + 1;

               -- Insertamos los gastos a nivel de garant¿a
               FOR v_gasgaran IN cur_garanseggas(v_risc.nriesgo, v_gar.cgarant) LOOP
                  BEGIN
                     INSERT INTO garanseggas
                                 (sseguro, nriesgo, cgarant, nmovimi,
                                  finiefe, cgastos, pvalor,
                                  pvalres, nprima, cmatch,
                                  tdesmat, pintfin)
                          VALUES (psseguro, v_risc.nriesgo, v_gar.cgarant, v_gar.nmovimi + 1,
                                  v_gasgaran.finiefe, v_gasgaran.cgastos, v_gasgaran.pvalor,
                                  v_gasgaran.pvalres, v_gasgaran.nprima, v_gasgaran.cmatch,
                                  v_gasgaran.tdesmat, v_gasgaran.pintfin);
                  EXCEPTION
                     WHEN DUP_VAL_ON_INDEX THEN
                        BEGIN
                           UPDATE garanseggas
                              SET pvalor = v_gasgaran.pvalor,
                                  pvalres = v_gasgaran.pvalres,
                                  nprima = v_gasgaran.nprima,
                                  cmatch = v_gasgaran.cmatch,
                                  tdesmat = v_gasgaran.tdesmat,
                                  pintfin = v_gasgaran.pintfin
                            WHERE sseguro = psseguro
                              AND nriesgo = v_risc.nriesgo
                              AND cgarant = v_gar.cgarant
                              AND nmovimi = v_gar.nmovimi + 1
                              AND finiefe = v_gasgaran.finiefe
                              AND cgastos = v_gasgaran.cgastos;
                        EXCEPTION
                           WHEN OTHERS THEN
                              RETURN 111782;
                        END;
                     WHEN OTHERS THEN
                        RETURN 111781;
                  END;
               END LOOP;   -- Fin cur_garanseggas

               vpasexec := 5;

               -- Insertamos las comisiones a nivel de garant¿a
               FOR v_comgaran IN cur_garansegcom(v_risc.nriesgo, v_gar.cgarant) LOOP
                  BEGIN
                     INSERT INTO garansegcom
                                 (sseguro, nriesgo, cgarant, nmovimi,
                                  finiefe, cmodcom, pcomisi,
                                  ninialt, nfinalt,
                                  pcomisicua)
                          VALUES (psseguro, v_risc.nriesgo, v_gar.cgarant, v_gar.nmovimi + 1,
                                  v_comgaran.finiefe, v_comgaran.cmodcom, v_comgaran.pcomisi,
                                  v_comgaran.ninialt, v_comgaran.nfinalt,
                                  v_comgaran.pcomisicua);   --bfp bug 21947
                  EXCEPTION
                     WHEN DUP_VAL_ON_INDEX THEN
                        BEGIN
                           UPDATE garansegcom
                              SET pcomisi = v_comgaran.pcomisi
                            WHERE sseguro = psseguro
                              AND nriesgo = v_risc.nriesgo
                              AND cgarant = v_gar.cgarant
                              AND nmovimi = v_gar.nmovimi + 1
                              AND finiefe = v_comgaran.finiefe
                              AND cmodcom = v_comgaran.cmodcom;
                        EXCEPTION
                           WHEN OTHERS THEN
                              RETURN 111783;
                        END;
                     WHEN OTHERS THEN
                        RETURN 111784;
                  END;
               END LOOP;   -- Fin cur_garansegcom

               IF NVL(f_parproductos_v(psproduc, 'TARIFA_CARTERA'), 1) = 0
                  AND pac_parametros.f_parproducto_n(psproduc, 'AFECTA_COMISESPPROD') = 1 THEN
                  --
                  BEGIN
                     --
                     SELECT iprianu, nmovimi
                       INTO v_iprianu_ant, v_nmovimi_ant
                       FROM garanseg
                      WHERE sseguro = psseguro
                        AND cgarant = v_gar.cgarant
                        AND nriesgo = v_gar.nriesgo
                        AND nmovima = v_gar.nmovima
                        AND ffinefe IS NULL;

                     --
                     v_ipricom := v_gar.iprianu;

                     --
                     FOR i IN c_garansegcom(psseguro, v_gar.cgarant, v_gar.nriesgo,
                                            v_nmovimi_ant, v_gar.finiefe) LOOP
                        --
                        v_res :=
                           pac_comisiones.f_grabarcomisionmovimiento
                                                 (p_cempres => pac_md_common.f_get_cxtempresa,
                                                  p_sseguro => psseguro,
                                                  p_cgarant => v_gar.cgarant,
                                                  p_nriesgo => v_gar.nriesgo,
                                                  p_nmovimi => NULL, p_fecha => pfcarpro,
                                                  p_modo => pmodo, p_ipricom => v_ipricom,
                                                  p_cmodcom => i.cmodcom,
                                                  p_sproces => conta_proces,
                                                  p_mensajes => v_mensajes);
                     --
                     END LOOP;
                  --
                  EXCEPTION
                     WHEN OTHERS THEN
                        --
                        v_iprianu_ant := 0;
                  --
                  END;
               --
               END IF;

               --
               vpasexec := 6;

               -- Insertamos las sobreprimas a nivel de garant¿a
               FOR v_sbprigaran IN cur_garansegsbpri(v_risc.nriesgo, v_gar.cgarant) LOOP
                  BEGIN
                     INSERT INTO garanseg_sbpri
                                 (sseguro, nriesgo, cgarant, nmovimi,
                                  finiefe, norden,
                                  ctipsbr, ccalsbr,
                                  pvalor, ncomisi)
                          VALUES (psseguro, v_risc.nriesgo, v_gar.cgarant, v_gar.nmovimi + 1,
                                  v_sbprigaran.finiefe, v_sbprigaran.norden,
                                  v_sbprigaran.ctipsbr, v_sbprigaran.ccalsbr,
                                  v_sbprigaran.pvalor, v_sbprigaran.ncomisi);
                  EXCEPTION
                     WHEN DUP_VAL_ON_INDEX THEN
                        BEGIN
                           UPDATE garanseg_sbpri
                              SET ctipsbr = v_sbprigaran.ctipsbr,
                                  ccalsbr = v_sbprigaran.ccalsbr,
                                  pvalor = v_sbprigaran.pvalor,
                                  ncomisi = v_sbprigaran.ncomisi
                            WHERE sseguro = psseguro
                              AND nriesgo = v_risc.nriesgo
                              AND cgarant = v_gar.cgarant
                              AND nmovimi = v_gar.nmovimi + 1
                              AND finiefe = v_sbprigaran.finiefe
                              AND norden = v_sbprigaran.norden;
                        EXCEPTION
                           WHEN OTHERS THEN
                              RETURN 111788;
                        END;
                     WHEN OTHERS THEN
                        RETURN 111787;
                  END;
               END LOOP;   -- Fin cur_garansegsbpri

               vpasexec := 7;

-----------------------------------------------------------
--BUSQUEDA DEL ctarman de la garantia. Si el de la poliza=5
----------------------------------------------------------
               IF (pcmanual = 5) THEN
                  BEGIN
                     SELECT ctarman
                       INTO vctarman
                       FROM garanpro
                      WHERE cgarant = v_gar.cgarant
                        AND cramo = pcramo
                        AND cmodali = pcmodali
                        AND ctipseg = pctipseg
                        AND ccolect = pccolect
                        AND cactivi = pcactivi;
                  EXCEPTION
                     WHEN NO_DATA_FOUND THEN
                        --si no la encontramos, buscamos la actividad 0
                        BEGIN
                           SELECT ctarman
                             INTO vctarman
                             FROM garanpro
                            WHERE cgarant = v_gar.cgarant
                              AND cramo = pcramo
                              AND cmodali = pcmodali
                              AND ctipseg = pctipseg
                              AND ccolect = pccolect
                              AND cactivi = 0;
                        EXCEPTION
                           WHEN OTHERS THEN
                              texto := f_axis_literales(111832, pidioma);
                              texto := texto || v_gar.cgarant;
                              aux := NULL;
                              num_err := f_proceslin(conta_proces, texto, psseguro, aux);
                              RETURN 111832;
                        --Error al cercar el ctarman per la garantia :
                        END;
                     WHEN OTHERS THEN
                        texto := f_axis_literales(111832, pidioma);
                        texto := texto || v_gar.cgarant;
                        aux := NULL;
                        num_err := f_proceslin(conta_proces, texto, psseguro, aux);
                        RETURN 111832;   --error al leer de garanpro
                  END;

                  --comprobaci¿n que ctarman encontrado es correcto.
                  IF vctarman IS NULL THEN
                     texto := f_axis_literales(111456, pidioma);
                     aux := NULL;
                     num_err := f_proceslin(conta_proces, texto, psseguro, aux);
                     RETURN 111456;
                  --El campo CTARMAN esta a nulo en GARANPRO
                  END IF;
               END IF;   --fin --pcmanual=5

               vpasexec := 8;
-----------------------------------------------------------
-- inicializamos las variables, con el codigo de garantia
-- de riesgo y la forma de tarificaci¿n.
-----------------------------------------------------------
               piprianu := NULL;
               pipritar := NULL;
               prevcap := NULL;
               prevprima := NULL;
               parms_transitorios(cont).cgarant := v_gar.cgarant;
               parms_transitorios(cont).nriesgo := v_gar.nriesgo;
               parms_transitorios(cont).ctarman := NVL(vctarman, pcmanual);
               parms_transitorios(cont).nfactor := v_gar.nfactor;
               --Bug 33145/192139 - 01/12/2014 - AMC
               num_err := f_parproductos(psproduc, 'APLICAPLANBEN', vaplicaplanben);

               IF NVL(vaplicaplanben, 0) = 1 THEN
                  SELECT cempres
                    INTO vcempres
                    FROM seguros
                   WHERE sseguro = psseguro;

                  vcplan := pac_planbenef.f_get_planbenef('CAR', psseguro, v_gar.nriesgo,
                                                          v_gar.nmovimi);

                  IF vcplan IS NOT NULL THEN
                     vnewcapital := pac_planbenef.f_capital_planbenef(vcempres, vcplan, 2,
                                                                      v_gar.cgarant);

                     IF num_err <> 0 THEN
                        RETURN num_err;
                     END IF;
                  END IF;
               END IF;

               --Fi Bug 33145/192139 - 01/12/2014 - AMC

               --revalorizamos aqui..
               IF pcforpag <> 0
                  OR NVL(f_parproductos_v(psproduc, 'REVALORIZA_CAPITAL'), 0) = 1 THEN   -- BUG24804:DRA:01/03/2013
                  vpasexec := 9;

                  IF NVL(v_gar.crevalcar, 1) = 1 THEN
                     vpasexec := 10;

                     -- Bug 10828 - RSC - 14/09/2009 - CRE - Revisi¿n de los productos PPJ din¿mico y Pla Estudiant (ajustes)
                     IF pac_propio.f_garan_reducida(psseguro, v_gar.cgarant) = 0 THEN   -- Garant¿a no reducida
                        -- Fin Bug 10828
                        vpasexec := 11;

                        IF v_gar.ipritar = 0 THEN
                           wprima := v_gar.iprianu;
                        ELSE
                           wprima := v_gar.ipritar;
                        END IF;

                        vpasexec := 12;

                        -- Bug 10828 - RSC - 08/09/2009 - CRE - Revisi¿n de los productos PPJ din¿mico y Pla Estudiant (ajustes)
                        IF (NVL(f_parproductos_v(psproduc, 'SOLO_TARIFA_CARTERA'), 0) <> 1)
                           OR(NVL(f_parproductos_v(psproduc, 'SOLO_TARIFA_CARTERA'), 0) = 1
                              AND pfcarpro = pfcaranu) THEN
                           vpasexec := 13;

                           --Bug 33145/192139 - 01/12/2014 - AMC
                           IF NVL(vaplicaplanben, 0) = 1 THEN
                              prevcap := vnewcapital;
                           ELSE
                              -- Bug 9794 - YIL - 21/04/2009 - Se le pasa el nuevo par¿metro a f_revalgar: v_gar.nriesgo
                              num_err := f_revalgar(psseguro, NVL(vctarman, pcmanual),
                                                    v_gar.cgarant, pcactivi, pcramo, pcmodali,
                                                    pctipseg, pccolect, v_gar.icapital,
                                                    wprima, v_gar.crevali, v_gar.irevali,
                                                    v_gar.prevali, TO_NUMBER(pmes), panyo,
                                                    prevcap, prevprima, v_factor,
                                                    v_gar.nriesgo);
                           -- Bug 9794 - YIL - 21/04/2009 - Fin
                           END IF;

                           --Fi Bug 33145/192139 - 01/12/2014 - AMC
                           vpasexec := 14;
                           parms_transitorios(cont).nfactor :=
                                                           v_gar.nfactor
                                                           *(1 +(v_factor / 100));
                           parms_transitorios(cont).nfactor :=
                                                           v_gar.nfactor
                                                           *(1 +(v_factor / 100));

                           IF num_err <> 0 THEN
                              texto := f_axis_literales(num_err, pidioma);
                              aux := NULL;
                              num_err2 := f_proceslin(conta_proces, texto, psseguro, aux);
                              RETURN num_err;
                           END IF;
                        END IF;
                     -- Bug 10828 - RSC - 14/09/2009 - CRE - Revisi¿n de los productos PPJ din¿mico y Pla Estudiant (ajustes)
                     ELSE
                        vpasexec := 15;

                        --Bug 33145/192139 - 01/12/2014 - AMC
                        IF NVL(vaplicaplanben, 0) = 1 THEN
                           prevcap := vnewcapital;
                        ELSE
                           prevcap := v_gar.icapital;
                        END IF;
                     --Fi Bug 33145/192139 - 01/12/2014 - AMC
                     END IF;
                  -- Fin Bug 10828
                  ELSE
                     vpasexec := 16;

                     --Bug 33145/192139 - 01/12/2014 - AMC
                     IF NVL(vaplicaplanben, 0) = 1 THEN
                        prevcap := vnewcapital;
                     ELSE
                        prevcap := v_gar.icapital;
                     END IF;
                  --Fi Bug 33145/192139 - 01/12/2014 - AMC
                  END IF;
               ELSE
                  vpasexec := 17;

                  --Bug 33145/192139 - 01/12/2014 - AMC
                  IF NVL(vaplicaplanben, 0) = 1 THEN
                     prevcap := vnewcapital;
                  ELSE
                     prevcap := v_gar.icapital;
                  END IF;
               --Fi Bug 33145/192139 - 01/12/2014 - AMC
               END IF;   -- De si revaloriza o no

               vpasexec := 18;

               -- Bug 9794 - YIL - 21/04/2009 - se a¿ade  ELSIF NVL(vctarman, pcmanual) IN (0) then
               IF NVL(vctarman, pcmanual) IN(1, 3) THEN   -- Manual
                  piprianu := prevprima;
                  pipritar := prevprima;
               ELSIF NVL(vctarman, pcmanual) IN(0) THEN
                  piprianu := prevprima;
                  pipritar := prevprima;
               ELSE   -- Revaloritza prima
                  IF NVL(vctarman, pcmanual) IN(2, 4) THEN   --Automatico.
                     pipritar := prevprima;
                     piprianu := prevprima;
                  --ELSE
                  -- pipritar := NULL;
                  -- piprianu := NULL;
                  END IF;
               END IF;

               -- Bug 9794 - YIL - 21/04/2009 - Fin

               ---------------------------------------------------
-- copiamos los k y primas que hemos econtrado.
---------------------------------------------------
               parms_transitorios(cont).icapital := NVL(prevcap, v_gar.icapital);
               parms_transitorios(cont).iprianu := NVL(piprianu, v_gar.iprianu);
               parms_transitorios(cont).ipritar := NVL(pipritar, v_gar.ipritar);

               --DBMS_OUTPUT.put_line (   ' el capital ' || parms_transitorios (cont).icapital  || ' el conmptador '    || cont   );

               -- actualizamos la tabla tmp_garancar para que coja, las primas
               -- y capitales revalorizadas
               UPDATE tmp_garancar
                  SET icapital = parms_transitorios(cont).icapital,
                      iprianu = parms_transitorios(cont).iprianu,
                      ipritar = parms_transitorios(cont).ipritar,
                      nfactor = parms_transitorios(cont).nfactor,
                      ftarifa = v_gar.ftarifa   -- nunu
                WHERE sseguro = psseguro
                  AND sproces = conta_proces
                  AND cgarant = v_gar.cgarant
                  AND nriesgo = v_gar.nriesgo;

               --   return 0;
               -- Revalorizaci¿n
               --num_err := Pac_cartera.F_Reval_Par (v_gar.crevali,v_gar.prevali,v_gar.irevali,v_gar.finiefe,
               --              v_gar.icapital,pcramo,pcmodali,pctipseg,pccolect,pcactivi,
               --              v_gar.cgarant,cont,parms_transitorios);
               --IF num_err <> 0 THEN
               --  RETURN num_err;
               --END IF;
               vpasexec := 19;
            ELSE
               --           dbms_output.put_line('garantia anulada '||v_gar.cgarant);
               UPDATE tmp_garancar
                  SET canulado = 1
                WHERE sproces = conta_proces
                  AND cgarant = v_gar.cgarant
                  AND nriesgo = v_risc.nriesgo
                  AND sseguro = psseguro;

               vpasexec := 20;
            END IF;   -- si no_cambiada
         END LOOP;

         vpasexec := 21;

         -- Bug 7926 - 28/05/2009 - RSC - Fecha de vencimiento a nivel de garant¿a
         -- PAC_TARIFAS.f_tmpgarancar inserta todas las garant¿as en TMP_GARANCAR
         -- aunque estas est¿n vencidas para la cartera
         IF pmodo = 'P' THEN   -- PREVI CARTERA TAR
            FOR regs IN (SELECT sseguro, cgarant, nriesgo
                           FROM garanseg
                          WHERE sseguro = psseguro
                            AND nriesgo = v_risc.nriesgo
                            AND ffinefe IS NULL
                            AND pfcarpro >= NVL(pac_seguros.f_vto_garantia(sseguro, nriesgo,
                                                                           cgarant, nmovimi),
                                                pfcarpro + 1)) LOOP
               --MINUS
               --SELECT sseguro, cgarant, nriesgo
               --  FROM garanseg
               -- WHERE sseguro = psseguro
               --   AND nriesgo = v_risc.nriesgo
               --   AND ffinefe IS NULL
               --   AND pfcarpro < NVL(pac_seguros.f_vto_garantia(sseguro, nriesgo,
               --                                                   cgarant, nmovimi),
               --                      pfcarpro + 1)) LOOP

               -- La garant¿a vence y por tanto la anulamos en TMP_GARANCAR
               -- Al anularla aqu¿ la tarificaci¿n ya no la tendr¿ en cuenta
               UPDATE tmp_garancar
                  SET canulado = 1
                WHERE sproces = conta_proces
                  AND cgarant = regs.cgarant
                  AND nriesgo = regs.nriesgo
                  AND sseguro = psseguro;
            END LOOP;
         END IF;

         vpasexec := 22;

         IF NVL(f_parproductos_v(psproduc, 'TARIFA_CARTERA'), 1) = 1 THEN
            -- Fin Bug 7926
            SELECT COUNT(1)
              INTO num_err
              FROM tmp_garancar
             WHERE sproces = conta_proces
               AND nriesgo = v_risc.nriesgo
               AND sseguro = psseguro
               AND NVL(canulado, 0) <> 1;

            IF num_err <> 0 THEN   --miro si hay garantias vigentes.
               --DBMS_OUTPUT.put_line ('---- efefcte a tarifar risc ' || pfefecto);
               num_err := pac_tarifas.f_tarifar_risc(ppsproces, NULL, 'CAR', pmodo, pcramo,
                                                     pcmodali, pctipseg, pccolect, psproduc,
                                                     pcactivi, paplica_bonifica, pbonifica,
                                                     psseguro, v_risc.nriesgo, pfcarpro,   --pfemisio, nununu
                                                     pfefecto, pcmanual, pcobjase, pcforpag,
                                                     pidioma, pmes, panyo, pmoneda,
                                                     parms_transitorios, total_prima, pmensa,
                                                     'CAR', vmovgar);

               IF num_err <> 0 THEN
                  RETURN num_err;
               END IF;

               -- Bug 21127 - APD - 14/03/2012 - todo este c¿digo estaba m¿s abajo y
               -- se cambia aqu¿
               -- Inicializo la matriz de parms_transitorios
               --  Realitzem un bucle per calcular els descomptes
               --  (despres d'haver tingut en compte les respostes de les preguntes)
               -- Per la bonificaci¿, comprovem quina prima ¿s la menor entre la nova
               -- i l'anualitat anterior
               laplica_actual := NULL;

               IF NVL(paplica_bonifica, 0) = 1 THEN
                  -- Retorna 1 si s'aplica el descompte a la prima actual
                  -- Retorna 0 si s'aplica el descompte a la prima de l'anualitat anterior
                  laplica_actual := pac_bonifica.calcul_bonificacio_actual(psseguro,
                                                                           conta_proces, NULL,
                                                                           lnmovimi);
               END IF;

-------------------------------------------------------------------------
-- 4art bucle de garanties (garancar ). Descomptes i rec¿rrecs
-------------------------------------------------------------------------
               FOR v_gar IN c_tmp_garancar(v_risc.nriesgo) LOOP   -- loop de descomptes i rec¿rrecs
                  --         dbms_output.put_line(v_gar.cgarant||'  '||v_gar.iprianu );
                  IF NVL(laplica_actual, 1) = 1 THEN
                     lprima_bonif := v_gar.iprianu;
                  ELSE
                     lprima_bonif := pac_bonifica.calcul_prima_ant(psseguro, lnmovimi,
                                                                   v_gar.nriesgo,
                                                                   v_gar.cgarant);

                     IF lprima_bonif IS NULL THEN
                        lprima_bonif := 0;
                     END IF;
                  END IF;

                  prima := v_gar.iprianu;
                  -- Veure si se li aplica el descompte amb el par¿metre APLICABONI
                  num_err := f_pargaranpro(pcramo, pcmodali, pctipseg, pccolect, pcactivi,
                                           v_gar.cgarant, 'APLICABONI', lcvalpar);

                  IF NVL(lcvalpar, 1) = 1 THEN
                     -- BUG 20666-  01/2012 - JRH  -  20666:   -- BUG 20666-  01/2012 - JRH  -  20666:  Buscar en las CAR Si tenemos el capitalo inicial informado la extraprima utiliza este capital
                     vcapital_ini := NULL;
                     vcapital_def := NULL;

                     --DCT 03/02/2014
                     --Si tenemos parametrizado el producto a 1 no obtendremos el capital Inicial sino el que toque(revalorizado)
                     IF NVL(f_parproductos_v(psproduc, 'CAPITAL_REVAL'), 0) <> 1 THEN
                        num_err := pac_preguntas.f_get_pregungaranseg(psseguro, v_gar.cgarant,
                                                                      v_gar.nriesgo, 4071,
                                                                      'TMP', vcapital_ini,
                                                                      ppsproces);

                        IF num_err = 0 THEN
                           vcapital_def := vcapital_ini;
                        ELSIF num_err = 120135 THEN
                           vcapital_def := v_gar.icapital;
                        ELSE
                           p_tab_error(f_sysdate, f_user, 'pac_dincartera.f_garantarifa_sgt',
                                       vpasexec, 'Error extraprima',
                                       num_err || ' - ' || 'Erro buscando capital inicial');
                           RETURN num_err;
                        END IF;
                     ELSE
                        vcapital_def := v_gar.icapital;
                     END IF;

                     -- Bug 24704 - RSC - 17/12/2013
                     v_crespue_4942 :=
                        NVL(pac_preguntas.f_get_pregungaranseg_v(psseguro, v_gar.cgarant,
                                                                 v_gar.nriesgo, 4942, 'TMP',
                                                                 ppsproces),
                            0);
                     v_crespue_4945 :=
                        NVL(pac_preguntas.f_get_pregungaranseg_v(psseguro, v_gar.cgarant,
                                                                 v_gar.nriesgo, 4945, 'TMP',
                                                                 ppsproces),
                            0);
                     -- Fin bug 24704

                     --  FiBUG 20666-  01/2012 - JRH
                     --bfp bug 22212 ini
                     vapldtosenform := NVL(f_parproductos_v(psproduc, 'APLDTOSENFORM'), 0);

                     IF vapldtosenform <> 1 THEN
                           --bfp bug 22212 fi
                        -- Bug 21907 - MDS - 03/05/2012
                        -- a¿adir par¿metros nuevos : v_gar.pdtotec, v_gar.preccom, pidtotec, pireccom
                        num_err := f_recdto(v_gar.precarg, v_gar.pdtocom, pirecarg, pidtocom,
                                            v_gar.pdtotec, v_gar.preccom, pidtotec, pireccom,   -- Bug 21907 - MDS - 03/05/2012
                                            v_gar.iextrap, vcapital_def, v_extraprima,   -- BUG19532:DRA:26/09/2011
                                            prima, pmoneda, paplica_bonifica, lprima_bonif,
                                            v_crespue_4942, v_crespue_4945, psproduc);   --DCT 02/12/2014

                        IF num_err <> 0 THEN
                           RETURN num_err;
                        END IF;
                     --bfp bug 22212 ini
                     END IF;

                     --bfp buf 22212 fi

                     -- Bug 14429 - RSC - 16/09/2010 - AGA005 - Primes manuals pels productes de Llar
                     IF NVL(v_gar.ctarman, 0) <> 1 THEN
                        prima := f_round_forpag(prima, pcforpag, pmoneda, psproduc);
                     END IF;

                     -- Fin Bug 14429

                     -- FBL. 25/06/2014 MSV Bug 0028974
                     IF pac_parametros.f_parproducto_n(psproduc, 'AFECTA_COMISESPPROD') = 1 THEN
                        BEGIN
                           /*p_tab_error(f_sysdate, f_user, 'pac_dincartera.f_garantarifa_sgt',
                                       vpasexec, 'pac_din_cartera renovacion comisiones',
                                       num_err);*/
                           SELECT iprianu, nmovimi
                             INTO v_iprianu_ant, v_nmovimi_ant
                             FROM garanseg
                            WHERE sseguro = psseguro
                              AND cgarant = v_gar.cgarant
                              AND nriesgo = v_gar.nriesgo
                              AND nmovima = v_gar.nmovima
                              AND ffinefe IS NULL;

                           --v_ipricom := v_gar.iprianu - v_iprianu_ant;
                           /*p_tab_error(f_sysdate, f_user, 'pac_dincartera.f_garantarifa_sgt',
                                       vpasexec,
                                       'v_iprianu_ant ' || v_iprianu_ant || ' v_gar.iprianu '
                                       || v_gar.iprianu || ' v_nmovimi_ant ' || v_nmovimi_ant||' pmodo '||pmodo,
                                       num_err);*/
                           v_ipricom := v_gar.iprianu;

--asigno esto porque siempre tendr¿ que calcular comisiones para recibos de renovcacion rdd

                           --IF v_ipricom != 0 THEN
                              -- hay diferencias en la primas, sean positivas o negativas, con lo cual hay que grabar la comisi¿n y actualizrgi.ar el ipricom.
                              -- falta saber el movimiento de donde lo saco... pendiente respuesta sergi. Por ahora v_nmovimi_ant + 1
                           FOR i IN c_garansegcom(psseguro, v_gar.cgarant, v_gar.nriesgo,
                                                  v_nmovimi_ant, v_gar.finiefe) LOOP
                              v_res :=
                                 pac_comisiones.f_grabarcomisionmovimiento
                                                 (p_cempres => pac_md_common.f_get_cxtempresa,
                                                  p_sseguro => psseguro,
                                                  p_cgarant => v_gar.cgarant,
                                                  p_nriesgo => v_gar.nriesgo,
                                                  p_nmovimi => NULL
                                                                   --v_nmovimi_ant + 1???
                                                  , p_fecha => pfcarpro, p_modo => pmodo,
                                                  p_ipricom => v_ipricom,
                                                  p_cmodcom => i.cmodcom,
                                                  p_sproces => conta_proces,
                                                  p_mensajes => v_mensajes);
                           END LOOP;
                        --END IF;
                        EXCEPTION
                           WHEN OTHERS THEN
                              v_iprianu_ant := 0;
                        END;
                     END IF;

                     -- Fin FBL. 25/06/2014 MSV Bug 0028974

                     -- Modificamos la tabla GARANCAR con las primas nuevas
                     -- Se redondea la prima en funcion de la forma de pago
                     BEGIN
                        -- FBL. 25/06/2014 MSV Bug 0028974
                        UPDATE tmp_garancar
                           SET irecarg = pirecarg,
                               idtocom = pidtocom,
                               idtotec = pidtotec,
                               -- Bug 21907 - MDS - 03/05/2012
                               ireccom = pireccom,
                               iprianu = prima,
                               ipricom = v_ipricom
                         WHERE sseguro = psseguro
                           AND cgarant = v_gar.cgarant
                           AND nriesgo = v_gar.nriesgo
                           AND finiefe = v_gar.finiefe
                           AND sproces = v_gar.sproces
                           AND nmovima = v_gar.nmovima;
                     -- Fin FBL. 25/06/2014 MSV Bug 0028974
                     -- Bug 21907 - MDS - 03/05/2012
                     -- Bug 14429 - RSC - 16/09/2010 - AGA005 - Primes manuals pels productes de Llar
                     EXCEPTION
                        WHEN OTHERS THEN
                           RETURN 101998;
                     END;
                  END IF;

                  -- Bug 30171/173304 - 12/05/2014 - AMC
                  num_err := pac_tarifas.f_factor_proteccion(psproduc, pcactivi, v_gar.cgarant,
                                                             psseguro, v_gar.nriesgo, vmovgar,
                                                             v_gar.nmovima, v_gar.finiefe,
                                                             v_gar.sproces, prima, 'CAR');
               END LOOP;   -- loop de descomptes i rec¿rrecs

               -- bug 33488/ QT S/N CARTERA COLECTIVOS
               -- Que no calcule la prima minima si estamos en un colectivo certificado cero.
               IF (NOT(pac_iax_produccion.isaltacol
                       AND NVL(pac_parametros.f_parproducto_n(psproduc, 'TARIFA_POLIZACERO'),
                               0) = 0))
                  OR NVL(pac_parametros.f_parproducto_n(psproduc, 'TARIFA_POLIZACERO'), 0) = 1 THEN
                  -- Bug 21127 - APD - 07/03/2012 - se aplica la prima minima
                  -- Bug 26923/0146769 - APD - 21/06/2013 - se a¿ade el parametro pmoneda
                  num_err := pac_tarifas.f_prima_minima('SEG', psseguro, v_risc.nriesgo,
                                                        psproduc, pfefecto,
                                                        parms_transitorios, conta_proces,
                                                        pcactivi, 'CAR', 2,   --pcnivel (Riesgo)
                                                        1,
                                                        --pcposicion 1 (Despu¿s tarificar)
                                                        vmovgar, pmoneda);

                  IF num_err <> 0 THEN
                     p_tab_error(f_sysdate, f_user, 'pac_dincartera.f_garantarifa_sgt',
                                 vpasexec, 'llama al pac_tarifas.f_prima_minima', num_err);
                     RETURN num_err;
                  END IF;
               -- fin Bug 21127 - APD - 07/03/2012
               END IF;

               -- Bug 21127 - APD - 07/03/2012 - se calcula el bonus/malus
               num_err := pac_tarifas.f_calcula_bonusmalus('SEG', psseguro, v_risc.nriesgo,
                                                           psproduc, pfefecto,
                                                           parms_transitorios, conta_proces,
                                                           pcactivi, 'CAR', vmovgar);

               IF num_err <> 0 THEN
                  p_tab_error(f_sysdate, f_user, 'pac_dincartera.f_garantarifa_sgt', vpasexec,
                              'llama al pac_tarifas.f_prima_minima', num_err);
                  RETURN num_err;
               END IF;

               -- bug 33488/ QT S/N CARTERA COLECTIVOS
               -- Que no calcule la prima minima si estamos en un colectivo certificado cero.
               IF (NOT(pac_iax_produccion.isaltacol
                       AND NVL(pac_parametros.f_parproducto_n(psproduc, 'TARIFA_POLIZACERO'),
                               0) = 0))
                  OR NVL(pac_parametros.f_parproducto_n(psproduc, 'TARIFA_POLIZACERO'), 0) = 1 THEN
                  -- Bug 21127 - APD - 07/03/2012 - se aplica la prima minima
                  -- Bug 26923/0146769 - APD - 21/06/2013 - se a¿ade el parametro pmoneda
                  num_err := pac_tarifas.f_prima_minima('SEG', psseguro, v_risc.nriesgo,
                                                        psproduc, pfefecto,
                                                        parms_transitorios, conta_proces,
                                                        pcactivi, 'CAR', 2,   --pcnivel (Riesgo)
                                                        2,
                                                        --pcposicion 2 (Despu¿s bonus malsu)
                                                        vmovgar, pmoneda);

                  IF num_err <> 0 THEN
                     p_tab_error(f_sysdate, f_user, 'pac_dincartera.f_garantarifa_sgt',
                                 vpasexec, 'llama al pac_tarifas.f_prima_minima', num_err);
                     RETURN num_err;
                  END IF;
               -- fin Bug 21127 - APD - 07/03/2012
                  -- fin Bug 21127 - APD - 14/03/2012

               -- bug 33488/ QT S/N CARTERA COLECTIVOS
               -- Que no calcule la prima minima si estamos en un colectivo certificado cero.
               END IF;
            END IF;
         END IF;

         vpasexec := 23;

         --traspasa a tmp_garancar ctarman = 1(manuals)
         -- FBL. 25/06/2014 MSV Bug 0028974
         -- Ini Bug 21907 - MDS - 03/05/2012
         INSERT INTO garancar
                     (sseguro, cgarant, nriesgo, finiefe, norden, ctarifa, icapital, precarg,
                      iprianu, ffinefe, cformul, iextrap, ctipfra, ifranqu, sproces, irecarg,
                      ipritar, pdtocom, idtocom, crevali, prevali, irevali, itarifa, itarrea,
                      ipritot, icaptot, ftarifa, cderreg, feprev, fpprev, percre, cref,
                      cintref, pdif, pinttec, nparben, nbns, tmgaran, cmatch, tdesmat, pintfin,
                      canulado, nfactor, nmovi_ant, idtoint, ccampanya, nversio, cageven,
                      nlinea, nmovima, ctarman, pdtotec, preccom, idtotec, ireccom, ipricom)
            SELECT sseguro, cgarant, nriesgo, pfcarpro, norden, ctarifa, icapital, precarg,
                   iprianu, ffinefe, cformul, iextrap, ctipfra, ifranqu, sproces, irecarg,
                   ipritar, pdtocom, idtocom, crevali, prevali, irevali, itarifa, itarrea,
                   ipritot, icaptot, ftarifa, cderreg, feprev, fpprev, percre, cref, cintref,
                   pdif, pinttec, nparben, nbns, tmgaran, cmatch, tdesmat, pintfin, canulado,
                   nfactor, nmovi_ant, idtoint, ccampanya, nversio, cageven, nlinea, nmovima,
                   ctarman, pdtotec, preccom, idtotec, ireccom, v_ipricom
              FROM tmp_garancar
             WHERE sproces = ppsproces
               AND sseguro = psseguro
               AND nriesgo = v_risc.nriesgo;

            -- Fin Bug 21907 - MDS - 03/05/2012
         -- Fin FBL. 25/06/2014 MSV Bug 0028974
         vpasexec := 24;

         --BUGAGM-49-XVM-14/07/2016.Inicio
         SELECT SUM(iprianu)
           INTO total_prima
           FROM tmp_garancar g
          WHERE g.sseguro = psseguro
            AND g.nriesgo = v_risc.nriesgo
            AND sproces = ppsproces
            AND NVL(f_pargaranpro_v(pcramo, pcmodali, pctipseg, pccolect, pcactivi, g.cgarant,
                                    'SUMA_PRIMA'),
                    1) <> 0;
         --BUGAGM-49-XVM-14/07/2016.Fin

         --
         DELETE FROM tmp_garancar
               WHERE sproces = ppsproces;

         --Bug 26638/160974 - 03/04/2014 - AMC
         DELETE FROM garanseg_aux
               WHERE sseguro = psseguro;

         ------------------------------------------------
         -- COMPROVACI¿ de prima m¿nima, cal regularitzar
------------------------------------------------
-- Si s'ha de comprovar la prima m¿nima, cal veure si hi ha garantia
-- de regularitzaci¿.
-- Si la prima m¿nima ¿s calculada, cal cridar al SGT
         IF NVL(vcprimin, 0) <> 3 THEN   --JRH No vamos por el nuevo modelo de prima m¿nima
            lprima_minima := NULL;

            IF pcgarant_regu IS NOT NULL
               AND NVL(pcprimin, 0) = 1
               AND NVL(laplicaprmin, 1) = 1 THEN
               --DBMS_OUTPUT.put_line ('vaig a calcular pm       ');
               BEGIN
                  SELECT formula
                    INTO formula
                    FROM sgt_formulas
                   WHERE clave = pcclapri;

                  -- Bug 21121 - APD - 23/02/2012 - se a¿ade el parametro v_tregconcep
                  pac_parm_tarifas.inserta_parametro(psesion, pcclapri, 1, parms_transitorios,
                                                     num_err, NULL, v_tregconcep);

                  -- fin Bug 21121 - APD - 23/02/2012
                  IF num_err <> 0 THEN
                     mensa := pcgarant_regu || '.Regulariza';
                     RETURN(num_err);
                  END IF;

                  --DBMS_OUTPUT.put_line (' PARAMETRES DE LA PRIMA MINIMA ');

                  --FOR c IN tmp (psesion)
                  --LOOP
                  -- DBMS_OUTPUT.put_line (c.parametro || ' ' || c.valor);
                  --END LOOP;

                  -- Insertem el par¿metre pfunci¿n per saber qu¿ estem fent
                  -- desde SGT ( Cartera, Alta, suplement, Reasseg )
                    -- I - JLB - OPTIMIZA
                  --       BEGIN
                  --INSERT INTO sgt_parms_transitorios
                  --            (sesion, parametro, valor)
                  --     VALUES (psesion, 'FUNCION', 3);
                  num_err := pac_sgt.put(psesion, 'FUNCION', 3);

                  IF num_err <> 0 THEN
                     RETURN 109843;
                  END IF;

                  -- F - JLB - OPTIMIZA
                    --       EXCEPTION
                      --        WHEN OTHERS THEN
                        --         RETURN 109843;
                        --   END;
                  -- F - JLB - OPTIMIZA

                  ---nunu

                  --trobem el valor de la prima minima
                  lprima_minima := pk_formulas.eval(formula, psesion);
               --DBMS_OUTPUT.put_line ('lprima_minima ' || lprima_minima);
               EXCEPTION
                  WHEN OTHERS THEN
                     texto := f_axis_literales(101150, pidioma);
                     pnnumlin := NULL;
                     num_err := f_proceslin(ppsproces, texto, psseguro, pnnumlin);
                     RETURN 101150;
               END;
            ELSIF pcgarant_regu IS NOT NULL
                  AND NVL(pcprimin, 1) = 0
                  AND NVL(laplicaprmin, 1) = 1 THEN
               lprima_minima := piprimin;
            END IF;

            vpasexec := 25;

            --DBMS_OUTPUT.put_line ('lprima_minima ' || lprima_minima);
            --DBMS_OUTPUT.put_line ('total prima ' || total_prima);
            IF total_prima < NVL(lprima_minima, 0)
               AND NVL(laplicaprmin, 1) = 1 THEN
               -- Insertem a garancar la garantia de regularitzaci¿
               BEGIN
                  lprima_regu := lprima_minima - total_prima;

                      --DBMS_OUTPUT.put_line ('lprima_regu ' || lprima_regu);
                  -- FBL. 25/06/2014 MSV Bug 0028974
                  INSERT INTO garancar
                              (sseguro, cgarant, nriesgo, finiefe, norden,
                               ctarifa, icapital, precarg, iprianu, ffinefe, cformul,
                               iextrap, ctipfra, ifranqu, sproces, irecarg, ipritar, pdtocom,
                               idtocom, crevali, prevali, irevali, itarifa, itarrea, ipritot,
                               icaptot, ftarifa, ipricom)
                       VALUES (psseguro, pcgarant_regu, v_risc.nriesgo, pfcarpro, pnorden,
                               NULL, NULL, NULL, lprima_regu, NULL, NULL,
                               NULL, NULL, NULL, ppsproces, NULL, NULL, NULL,
                               NULL, 0, NULL, NULL, NULL, NULL, lprima_regu,
                               NULL, pfcarpro, v_ipricom);
               -- Fin FBL. 25/06/2014 MSV Bug 0028974
               EXCEPTION
                  WHEN DUP_VAL_ON_INDEX THEN
                     UPDATE garancar
                        SET iprianu = lprima_regu
                      WHERE sproces = ppsproces
                        AND sseguro = psseguro
                        AND nriesgo = v_risc.nriesgo
                        AND cgarant = pcgarant_regu;
                  WHEN OTHERS THEN
                     RETURN 101998;
               END;
            ELSE
               -- Esborrem la garantia de regularitzaci¿ si no n'ha de tenir, pq tenim la
               -- del moviment anterior
               DELETE FROM garancar
                     WHERE sproces = ppsproces
                       AND sseguro = psseguro
                       AND nriesgo = v_risc.nriesgo
                       AND cgarant = pcgarant_regu;
            END IF;
         END IF;

         vpasexec := 26;
         pac_parm_tarifas.borra_parametro(psesion, pcclapri);
         -- I - JLB - OPTIMIZA
         --  DELETE FROM sgt_parms_transitorios
         --        WHERE sesion = psesion;
         num_err := pac_sgt.del(psesion);
         -- F - JLB - OPTIMIZA
         parms_transitorios.DELETE;
         -- Bug 21127 - APD - 14/03/2012 - se comenta todo este c¿digo ya que
         -- se pasa m¿s arriba, despues de pac_tarifas.f_tarifar_risc
         -- Inicializo la matriz de parms_transitorios
         --  Realitzem un bucle per calcular els descomptes
         --  (despres d'haver tingut en compte les respostes de les preguntes)
         -- Per la bonificaci¿, comprovem quina prima ¿s la menor entre la nova
         -- i l'anualitat anterior
--         laplica_actual := NULL;

      --         IF NVL(paplica_bonifica, 0) = 1 THEN
--            -- Retorna 1 si s'aplica el descompte a la prima actual
--            -- Retorna 0 si s'aplica el descompte a la prima de l'anualitat anterior
--            laplica_actual := pac_bonifica.calcul_bonificacio_actual(psseguro, conta_proces,
--                                                                     NULL, lnmovimi);
--         END IF;

      ---------------------------------------------------------------------------
---- 4art bucle de garanties (garancar ). Descomptes i rec¿rrecs
---------------------------------------------------------------------------
--         FOR v_gar IN c_garancar(v_risc.nriesgo) LOOP   -- loop de descomptes i rec¿rrecs
--            --         dbms_output.put_line(v_gar.cgarant||'  '||v_gar.iprianu );
--            IF NVL(laplica_actual, 1) = 1 THEN
--               lprima_bonif := v_gar.iprianu;
--            ELSE
--               lprima_bonif := pac_bonifica.calcul_prima_ant(psseguro, lnmovimi,
--                                                             v_gar.nriesgo, v_gar.cgarant);

      --               IF lprima_bonif IS NULL THEN
--                  lprima_bonif := 0;
--               END IF;
--            END IF;

      --            prima := v_gar.iprianu;
--            -- Veure si se li aplica el descompte amb el par¿metre APLICABONI
--            num_err := f_pargaranpro(pcramo, pcmodali, pctipseg, pccolect, pcactivi,
--                                     v_gar.cgarant, 'APLICABONI', lcvalpar);

      --            IF NVL(lcvalpar, 1) = 1 THEN
--               -- BUG 20666-  01/2012 - JRH  -  20666:   -- BUG 20666-  01/2012 - JRH  -  20666:  Buscar en las CAR Si tenemos el capitalo inicial informado la extraprima utiliza este capital
--               vcapital_ini := NULL;
--               vcapital_def := NULL;
--               num_err := pac_preguntas.f_get_pregungaranseg(psseguro, v_gar.cgarant,
--                                                             v_gar.nriesgo, 4071, 'CAR',
--                                                             vcapital_ini, ppsproces);

      --               IF num_err = 0 THEN
--                  vcapital_def := vcapital_ini;
--               ELSIF num_err = 120135 THEN
--                  vcapital_def := v_gar.icapital;
--               ELSE
--                  p_tab_error(f_sysdate, f_user, 'pac_dincartera.f_garantarifa_sgt', vpasexec,
--                              'Error extraprima',
--                              num_err || ' - ' || 'Erro buscando capital inicial');
--                  RETURN num_err;
--               END IF;

      --               --  FiBUG 20666-  01/2012 - JRH
--               num_err := f_recdto(v_gar.precarg, v_gar.pdtocom, pirecarg, pidtocom,
--                                   v_gar.iextrap, vcapital_def, v_extraprima,   -- BUG19532:DRA:26/09/2011
--                                   prima, pmoneda, paplica_bonifica, lprima_bonif);

      --               IF num_err <> 0 THEN
--                  RETURN num_err;
--               END IF;

      --               -- Bug 14429 - RSC - 16/09/2010 - AGA005 - Primes manuals pels productes de Llar
--               IF NVL(v_gar.ctarman, 0) <> 1 THEN
--                  prima := f_round_forpag(prima, pcforpag, pmoneda, psproduc);
--               END IF;

      --               -- Fin Bug 14429

      --               -- Modificamos la tabla GARANCAR con las primas nuevas
--               -- Se redondea la prima en funcion de la forma de pago
--               BEGIN
--                  UPDATE garancar
--                     SET irecarg = pirecarg,
--                         idtocom = pidtocom,
--                         iprianu =
--                            prima   -- Bug 14429 - RSC - 16/09/2010 - AGA005 - Primes manuals pels productes de Llar
--                   WHERE sseguro = psseguro
--                     AND cgarant = v_gar.cgarant
--                     AND nriesgo = v_gar.nriesgo
--                     AND finiefe = v_gar.finiefe
--                     AND sproces = v_gar.sproces
--                     AND nmovima = v_gar.nmovima;
--               EXCEPTION
--                  WHEN OTHERS THEN
--                     RETURN 101998;
--               END;
--            END IF;
--         END LOOP;   -- loop de descomptes i rec¿rrecs
         -- fin Bug 21127 - APD - 14/03/2012
      END LOOP;   --RIESGOS

      vpasexec := 27;
      -- Mirem si s'ha d'anular la p¿lissa despr¿s de tarifar tots els riscos.
      -- S'ha canviat de posisci¿ pq abans s'estava fent dins del bucle de riscos
      -- i si s'anulava el primer anulava la pol sense haver mirat els altres
      /******************************************************
                                                                      Se verifican las anulaciones
      *******************************************************/
      anulado := 0;

      IF pmodo = 'P' THEN
         BEGIN
            SELECT COUNT(*)
              INTO registros
              FROM garancar
             WHERE sseguro = psseguro
               AND sproces = conta_proces
               AND NVL(canulado, 0) <> 1;
         EXCEPTION
            WHEN OTHERS THEN
               registros := 0;
         END;

         --Si no hay registros grabados en GARANCAR se
         --anula el seguro
         IF registros = 0 THEN
            -- Grabamos un registro en PROCESLIN para avisar
            -- que el seguro se va a anular.
            anulado := 1;
            texto := f_axis_literales(105735, pidioma);
            pnnumlin := NULL;
            num_err := f_proceslin(ppsproces, texto, psseguro, pnnumlin);
            RETURN num_err;
         END IF;
      ELSIF pmodo = 'R' THEN
         --Hemos grabado las garant¿as que no se anulan en GARANCAR.
         -- Ahora tenemos que mirar si se anula algun riesgo o el seguro*/
         num_err := f_anular(psseguro, pfcarpro, conta_proces, pfcarpro, pfemisio, movimiento,
                             anulado, pmoneda);

         IF num_err <> 0 THEN
            --DBMS_OUTPUT.put_line ('error en dincartera.f_anular');
            RETURN num_err;
         END IF;
      END IF;

      vpasexec := 28;

           -- Bug 23183/126116 - 18/10/2012 - AMC
           /*
            IF anulado = 0 THEN
      --------------------------------------------------------------------------
      -- A¿adimos el COASEGURO!!!!!!!!!!!!!!!!!!!!!
      -- Se calcula el porcentaje tambi¿n para el coaseguro aceptado (ctipcoa <> 0)
               BEGIN
                  SELECT c.ploccoa
                    INTO porcen
                    FROM coacuadro c, seguros s
                   WHERE c.sseguro = s.sseguro
                     AND c.ncuacoa = s.ncuacoa
                     AND s.ctipcoa <> 0
                     AND s.sseguro = psseguro;
               EXCEPTION
                  WHEN OTHERS THEN
                     porcen := 100;   -- No hay coaseguro cedido
               END;

               num_err := f_garancoa('P', porcen, psseguro);

               IF num_err <> 0 THEN
                  RETURN num_err;
               END IF;
            END IF;
           */
      IF anulado = 0 THEN
         num_err := f_garancoa('P', 100, psseguro);

         IF num_err <> 0 THEN
            RETURN num_err;
         END IF;
      END IF;

      COMMIT;
      RETURN 0;
   EXCEPTION
      WHEN OTHERS THEN
         --DBMS_OUTPUT.put_line ('f_garantarifa ' || SQLERRM);
         --ROLLBACK;
         p_tab_error(f_sysdate, f_user, 'pac_dincartera.f_garantarifa_sgt', vpasexec,
                     'WHEN OTHERS General', SQLCODE || ' - ' || SQLERRM);
         RETURN 111916;
   END f_garantarifa_sgt;

------------------------------------------------------------------------------------
   FUNCTION f_anuledad(
      psseguro IN NUMBER,
      pnriesgo IN NUMBER,
      pcgarant IN NUMBER,
      pnmovimi IN NUMBER,
      pfiniefe IN DATE,
      pfcarpro IN DATE,
      pcramo IN NUMBER,
      pcmodali IN NUMBER,
      pctipseg IN NUMBER,
      pccolect IN NUMBER,
      pcobjase IN NUMBER,
      pmodo IN VARCHAR2,
      ptablas IN VARCHAR2,
      pnedamar IN NUMBER,
      pciedmar IN NUMBER,
      estat_garan OUT VARCHAR2)
      RETURN NUMBER IS
      num_err        NUMBER;
      edad           NUMBER;
      edadmax        edadrenova_permite.nedamargar%TYPE;
      --       edadmax        NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      actividad      NUMBER;
      real_actu      NUMBER;
      --
      v_select       VARCHAR2(4000);
      v_resp         NUMBER;
      vfnacimi       DATE;
      cur            PLS_INTEGER;   -- := DBMS_SQL.OPEN_CURSOR;
      cur1           PLS_INTEGER;   -- := DBMS_SQL.OPEN_CURSOR;
      cur2           PLS_INTEGER;   -- := DBMS_SQL.OPEN_CURSOR;
      fdbk           PLS_INTEGER;
      vpas           NUMBER;
      v_cduraci      seguros.cduraci%TYPE;
      vparam         VARCHAR2(2000)
         := 'psseguro =' || psseguro || ' pnriesgo =' || pnriesgo || ' pcgarant =' || pcgarant
            || ' pnmovimi =' || pnmovimi || ' pfiniefe =' || pfiniefe || ' pfcarpro = '
            || pfcarpro || ' pcramo =' || pcramo || ' pcmodali=' || pcmodali || ' pctipseg ='
            || pctipseg || ' pccolect =' || pccolect || ' pcobjase =' || pcobjase
            || ' pmodo =' || pmodo || ' ptablas =' || ptablas || ' pnedamar =' || pnedamar
            || ' pciedmar =' || pciedmar || ' estat_garan =' || estat_garan;
      vobject        VARCHAR2(200) := 'PAC_DINCARTERA.f_anuledad';
   BEGIN
      vpas := 1;
      estat_garan := 'NO_CAMBIADA';

      IF pcobjase = 1 THEN   -- si el tipo de riesgo es personal
         --Calculamos la edad del riesgo
         BEGIN
            vpas := 2;
            v_select := ' SELECT fnacimi' || ' FROM  ' || ptablas || 'per_personas p, '
                        || ptablas || 'riesgos r' || ' WHERE r.sseguro = ' || psseguro
                        || '   AND r.nriesgo = ' || pnriesgo || '   AND r.sperson = p.sperson';
            cur := DBMS_SQL.open_cursor;
            DBMS_SQL.parse(cur, v_select, DBMS_SQL.native);
            DBMS_SQL.define_column(cur, 1, vfnacimi);

            BEGIN
               fdbk := DBMS_SQL.EXECUTE(cur);
            EXCEPTION
               WHEN OTHERS THEN
                  DBMS_SQL.close_cursor(cur);
                  p_tab_error(f_sysdate, f_user, 'pac_dincartera.f_anuledad', vpas, SQLCODE,
                              SQLERRM);
                  RETURN 105709;
            END;

            vpas := 3;
            num_err := DBMS_SQL.fetch_rows(cur);
            DBMS_SQL.COLUMN_VALUE(cur, 1, vfnacimi);
            DBMS_SQL.close_cursor(cur);
         EXCEPTION
            WHEN NO_DATA_FOUND THEN
               IF DBMS_SQL.is_open(cur) THEN
                  DBMS_SQL.close_cursor(cur);
               END IF;

               --DBMS_OUTPUT.put_line ('105709' || SQLERRM);
               --Riesgo no encontrado en la tabla PERSONAS
               p_tab_error(f_sysdate, f_user, 'pac_dincartera.f_anuledad', vpas, SQLCODE,
                           SQLERRM);
               RETURN 105709;
         END;

         -- Comprovem si ha arribat a la data m¿xima de renovaci¿ per producte
         -- abans que per garantia.
         vpas := 4;

         IF pnedamar IS NOT NULL THEN
            IF NVL(pciedmar, 0) = 0 THEN
               real_actu := 2;
            ELSIF NVL(pciedmar, 0) = 1 THEN
               real_actu := 1;
            ELSE
               real_actu := 1;
            END IF;

            num_err := f_difdata(vfnacimi, pfcarpro, real_actu, 1, edad);

            IF pnedamar < edad THEN
               estat_garan := 'CAMBIADA';
            END IF;
         END IF;

         vpas := 5;

         IF estat_garan <> 'CAMBIADA' THEN
            -- Calculamos la edad m¿xima de esta garant¿a en este producto
            v_select := ' select cactivi, cduraci' || ' from ' || ptablas || 'seguros'
                        || ' where sseguro =' || psseguro;
            cur2 := DBMS_SQL.open_cursor;
            DBMS_SQL.parse(cur2, v_select, DBMS_SQL.native);
            DBMS_SQL.define_column(cur2, 1, actividad);
            DBMS_SQL.define_column(cur2, 2, v_cduraci);
            fdbk := DBMS_SQL.EXECUTE(cur2);
            num_err := DBMS_SQL.fetch_rows(cur2);
            DBMS_SQL.COLUMN_VALUE(cur2, 1, actividad);
            DBMS_SQL.COLUMN_VALUE(cur2, 2, v_cduraci);
            DBMS_SQL.close_cursor(cur2);
            vpas := 6;

            BEGIN
               SELECT nedamar, DECODE(NVL(ciedmar, 0), 0, 2, 1, 1)
                 INTO edadmax, real_actu
                 FROM garanpro
                WHERE cgarant = pcgarant
                  AND cramo = pcramo
                  AND cmodali = pcmodali
                  AND ctipseg = pctipseg
                  AND ccolect = pccolect
                  AND cactivi = actividad;
            EXCEPTION
               WHEN NO_DATA_FOUND THEN
                  vpas := 7;

                  BEGIN
                     SELECT nedamar, DECODE(NVL(ciedmar, 0), 0, 2, 1, 1)
                       INTO edadmax, real_actu
                       FROM garanpro
                      WHERE cgarant = pcgarant
                        AND cramo = pcramo
                        AND cmodali = pcmodali
                        AND ctipseg = pctipseg
                        AND ccolect = pccolect
                        AND cactivi = 0;
                  EXCEPTION
                     WHEN OTHERS THEN
                        --Garant¿a no encontrada en la tabla GARANPRO
                        p_tab_error(f_sysdate, f_user, 'pac_dincartera.f_anuledad', vpas,
                                    SQLCODE, SQLERRM);
                        RETURN 105710;
                  END;
               WHEN OTHERS THEN
                  --Garant¿a no encontrada en la tabla GARANPRO
                  p_tab_error(f_sysdate, f_user, 'pac_dincartera.f_anuledad', vpas, SQLCODE,
                              SQLERRM);
                  RETURN 105710;
            END;

            vpas := 8;

            --BUG  0025584/0135342 - 22/1/2013 - MMS
            IF v_cduraci = 7 THEN
               BEGIN
                  IF ptablas = 'EST' THEN
                     BEGIN
                        SELECT ep.nedamargar
                          INTO edadmax
                          FROM edadrenova_permite ep, estseguros s
                         WHERE ep.sproduc = s.sproduc
                           AND ep.nedamarprd = s.nedamar
                           AND s.sseguro = psseguro
                           AND ep.cgarant = pcgarant
                           AND ep.cactivi = actividad
                           AND s.cramo = pcramo
                           AND s.cmodali = pcmodali
                           AND s.ctipseg = pctipseg
                           AND s.ccolect = pccolect;
                     EXCEPTION
                        WHEN NO_DATA_FOUND THEN
                           BEGIN
                              SELECT ep.nedamargar
                                INTO edadmax
                                FROM edadrenova_permite ep, estseguros s
                               WHERE ep.sproduc = s.sproduc
                                 AND ep.nedamarprd = s.nedamar
                                 AND s.sseguro = psseguro
                                 AND ep.cgarant = pcgarant
                                 AND ep.cactivi = 0
                                 AND s.cramo = pcramo
                                 AND s.cmodali = pcmodali
                                 AND s.ctipseg = pctipseg
                                 AND s.ccolect = pccolect;
                           EXCEPTION
                              WHEN NO_DATA_FOUND THEN
                                 NULL;
-- si no existe el campo edadmax no se modifica y sigue con el valor de garanpro
                              WHEN OTHERS THEN
                                 --Garant¿a no encontrada en la tabla GARANPRO
                                 p_tab_error(f_sysdate, f_user, vobject, vpas,
                                             'Faltan parametros por informar: ' || vparam,
                                             SQLERRM);
                                 RETURN 105710;
                           END;
                        WHEN OTHERS THEN
                           --Garant¿a no encontrada en la tabla GARANPRO
                           p_tab_error(f_sysdate, f_user, 'pac_dincartera.f_anuledad', vpas,
                                       SQLCODE, SQLERRM);
                           RETURN 105710;
                     END;
                  ELSE
                     BEGIN
                        SELECT ep.nedamargar
                          INTO edadmax
                          FROM edadrenova_permite ep, seguros s
                         WHERE ep.sproduc = s.sproduc
                           AND ep.nedamarprd = s.nedamar
                           AND s.sseguro = psseguro
                           AND ep.cgarant = pcgarant
                           AND ep.cactivi = actividad
                           AND s.cramo = pcramo
                           AND s.cmodali = pcmodali
                           AND s.ctipseg = pctipseg
                           AND s.ccolect = pccolect;
                     EXCEPTION
                        WHEN NO_DATA_FOUND THEN
                           BEGIN
                              SELECT ep.nedamargar
                                INTO edadmax
                                FROM edadrenova_permite ep, seguros s
                               WHERE ep.sproduc = s.sproduc
                                 AND ep.nedamarprd = s.nedamar
                                 AND s.sseguro = psseguro
                                 AND ep.cgarant = pcgarant
                                 AND ep.cactivi = 0
                                 AND s.cramo = pcramo
                                 AND s.cmodali = pcmodali
                                 AND s.ctipseg = pctipseg
                                 AND s.ccolect = pccolect;
                           EXCEPTION
                              WHEN NO_DATA_FOUND THEN
                                 NULL;
-- si no existe el campo edadmax no se modifica y sigue con el valor de garanpro
                              WHEN OTHERS THEN
                                 --Garant¿a no encontrada en la tabla GARANPRO
                                 p_tab_error(f_sysdate, f_user, vobject, vpas,
                                             'Faltan parametros por informar: ' || vparam,
                                             SQLERRM);
                                 RETURN 105710;
                           END;
                        WHEN OTHERS THEN
                           --Garant¿a no encontrada en la tabla GARANPRO
                           p_tab_error(f_sysdate, f_user, 'pac_dincartera.f_anuledad', vpas,
                                       SQLCODE, SQLERRM);
                           RETURN 105710;
                     END;
                  END IF;
               EXCEPTION
                  WHEN NO_DATA_FOUND THEN
                     NULL;
-- si no existe el campo edadmax no se modifica y sigue con el valor de garanpro
               END;

               IF edadmax IS NULL THEN
                  BEGIN
                     SELECT nedamar
                       INTO edadmax
                       FROM productos
                      WHERE cramo = pcramo
                        AND cmodali = pcmodali
                        AND ctipseg = pctipseg
                        AND ccolect = pccolect;
                  EXCEPTION
                     WHEN NO_DATA_FOUND THEN
                        NULL;
-- si no existe el campo edadmax no se modifica y sigue con el valor de garanpro
                  END;
               END IF;
            END IF;

            --Fin BUG  0025584/0135342 - 22/1/2013 - MMS
            vpas := 9;

            -- Se calcula la edad en funcion del parametro del producto CIEDMAR
            IF edadmax IS NOT NULL THEN
               num_err := f_difdata(vfnacimi, pfcarpro, real_actu, 1, edad);

               IF num_err <> 0 THEN
                  p_tab_error(f_sysdate, f_user, 'pac_dincartera.f_anuledad', vpas,
                              'f_difdata num_err:' || num_err, SQLERRM);
                  RETURN num_err;
               END IF;
            END IF;

            vpas := 10;

            --      dbms_output.put_line('EDAD DEL SENYOR '||edad);
            IF edad > NVL(edadmax, 9999999) THEN
               estat_garan := 'CAMBIADA';
               vpas := 11;

               IF pmodo = 'R' THEN
                  BEGIN
                     vpas := 12;
                     v_select := ' UPDATE ' || ptablas || 'GARANSEG SET' || ' ffinefe ='
                                 || CHR(39) || pfcarpro || CHR(39) || ' WHERE sseguro = '
                                 || psseguro || ' AND nriesgo = ' || pnriesgo
                                 || ' AND cgarant = ' || pcgarant || ' AND nmovimi = '
                                 || pnmovimi || ' AND finiefe = ' || CHR(39) || pfiniefe
                                 || CHR(39);
                     cur1 := DBMS_SQL.open_cursor;   --nunu
                     DBMS_SQL.parse(cur1, v_select, DBMS_SQL.native);
                     fdbk := DBMS_SQL.EXECUTE(cur1);
                     DBMS_SQL.close_cursor(cur1);
                  EXCEPTION
                     WHEN OTHERS THEN
                        --DBMS_OUTPUT.put_line ('101959 ' || SQLERRM);
                        DBMS_SQL.close_cursor(cur1);
                        p_tab_error(f_sysdate, f_user, 'pac_dincartera.f_anuledad', vpas,
                                    SQLCODE, SQLERRM);
                        RETURN 101959;
                  END;
               END IF;
            END IF;
         END IF;
      END IF;

      IF DBMS_SQL.is_open(cur) THEN   --Cerramos el cursor si esta abierto.
         DBMS_SQL.close_cursor(cur);
      END IF;

      IF DBMS_SQL.is_open(cur1) THEN   --Cerramos el cursor si esta abierto.
         DBMS_SQL.close_cursor(cur1);
      END IF;

      IF DBMS_SQL.is_open(cur2) THEN   --Cerramos el cursor si esta abierto.
         DBMS_SQL.close_cursor(cur2);
      END IF;

      RETURN 0;
   EXCEPTION
      WHEN OTHERS THEN
         IF DBMS_SQL.is_open(cur) THEN   --Cerramos el cursor si esta abierto.
            DBMS_SQL.close_cursor(cur);
         END IF;

         IF DBMS_SQL.is_open(cur1) THEN   --Cerramos el cursor si esta abierto.
            DBMS_SQL.close_cursor(cur1);
         END IF;

         IF DBMS_SQL.is_open(cur2) THEN   --Cerramos el cursor si esta abierto.
            DBMS_SQL.close_cursor(cur2);
         END IF;

         p_tab_error(f_sysdate, f_user, 'pac_dincartera.f_anuledad', vpas, SQLCODE, SQLERRM);
         RETURN 105709;
   END f_anuledad;

------------------------------------------------------------------------------------
   FUNCTION f_anular(
      psseguro IN NUMBER,
      pfcaranu IN DATE,
      psproces IN NUMBER,
      pfcontab IN DATE,
      pfemisio IN DATE,
      pnmovimi OUT NUMBER,
      panulado OUT NUMBER,
      pmoneda IN NUMBER)
      RETURN NUMBER IS
      /**************************************************************************
                                            F_ANULAR : Anula el seguro o s¿lo riesgos dependiendo de lo que
                              se haya grabado en GARANCAR
                              Si se anula algun riesgo, ya genera el movim. de CARTERA,
                              y devuelve pnmovimi. Si no pnmovimi = null.
                              Si se anula el seguro, ya se genera un movim. de anulacion,
                              y panulado = 1.
      ****************************************************************************/
      CURSOR c_riesgos IS
         SELECT nriesgo
           FROM riesgos
          WHERE sseguro = psseguro
            AND(fanulac IS NULL
                OR fanulac > pfcaranu);

      num_riesgos    NUMBER;
      num_garant     NUMBER;
      num_err        NUMBER;
      registros      NUMBER;
      movimi         NUMBER;
      v_cmotmov      NUMBER := NULL;   --motivo de la baja
      v_cnotibaj     NUMBER := NULL;   --notificacion de baja
   BEGIN
      panulado := 0;
      -- inicializamos la variable que nos indica seguro anulado
      pnmovimi := NULL;

      -- Ahora miramos los registros que hemos grabado en GARANCAR
      BEGIN
         SELECT COUNT(*)
           INTO num_garant
           FROM garancar
          WHERE sseguro = psseguro
            AND sproces = psproces
            AND NVL(canulado, 0) <> 1;
      EXCEPTION
         WHEN OTHERS THEN
            RETURN 103502;
      END;

      IF num_garant = 0 THEN   -- no se ha grabado ningun registro
         -- Anulamos el seguro.
         -- A¿adir el campo de notificaci¿n de baja
         IF f_parinstalacion_n('NOTIFIBAJA') = 1 THEN
            v_cmotmov := 503;
            v_cnotibaj := 4;
         ELSE
            v_cmotmov := 503;
            v_cnotibaj := NULL;
         END IF;

         -- borramos los registros de la poliza anulada
         num_err := f_anulaseg(psseguro, 0, pfcaranu, v_cmotmov, NULL, 3, movimi, v_cnotibaj,
                               pmoneda);

         DELETE      garancar
               WHERE sseguro = psseguro
                 AND sproces = psproces;

         IF num_err <> 0 THEN
            RETURN num_err;
         ELSE
            panulado := 1;
            RETURN 0;
         END IF;
      ELSE   -- Se han grabado registros
         -- Miramos cuantos registros se han grabado por riesgo.
         FOR valor IN c_riesgos LOOP
            SELECT COUNT(*)
              INTO registros
              FROM garancar
             WHERE sseguro = psseguro
               AND sproces = psproces
               AND nriesgo = valor.nriesgo
               AND NVL(canulado, 0) <> 1;

            IF registros = 0 THEN
               --Si no hay registros grabados en GARANCAR se
               --anula el riesgo
               -- Primero generamos el movimiento de seguro de CARTERA
               -- si es el primer riesgo que se anula
               DELETE      garancar
                     WHERE sseguro = psseguro
                       AND sproces = psproces
                       AND nriesgo = valor.nriesgo;

               IF pnmovimi IS NULL THEN
                  -- Se pasa pcimpres = null para coger
                  -- el estado de impresion del ultimo movimiento
                  num_err := f_movseguro(psseguro, NULL, 404, 2, pfcaranu, NULL, NULL, NULL,
                                         pfcontab, pnmovimi, pfemisio);

                  IF num_err <> 0 THEN
                     RETURN num_err;
                  END IF;

                  -- Se llama a f_act_hisseg para guardar la
                  -- situaci¿n anterior al suplemento.
                  -- El nmovimi es el anterior al del suplemento,
                  -- por eso se le resta uno al reci¿n creado.
                  num_err := f_act_hisseg(psseguro, pnmovimi - 1);

                  IF num_err <> 0 THEN
                     RETURN num_err;
                  END IF;
               END IF;

               IF f_parinstalacion_n('NOTIFIBAJA') = 1 THEN
                  v_cmotmov := 503;
                  v_cnotibaj := 4;
               ELSE
                  v_cmotmov := NULL;
                  v_cnotibaj := NULL;
               END IF;

               num_err := f_anularisc(psseguro, valor.nriesgo, pfcaranu, pnmovimi, v_cnotibaj,
                                      v_cmotmov);

               IF num_err <> 0 THEN
                  RETURN num_err;
               END IF;
            END IF;
         END LOOP;
      END IF;

      RETURN 0;
   END;

------------------------------------------------------------------------------------
 -- Bug 23940 - APD - 01/11/2012 - se a¿ade el parametro ptablas para poder hacer el traspaso
 -- de los registros de GARANCAR a ESTGARANSEG
 -- En este caso, cuando ptablas = 'EST' se pasa el sseguro de las EST para saber
 -- de qu¿ poliza REAL de las tablas CAR se debe coger la informaci¿n para pasarla
 -- a la p¿liza de las EST. Lo mismo con el nmovimi.
   FUNCTION f_traspasgar(
      psproces IN NUMBER,
      psseguro IN NUMBER,
      pdata IN DATE,
      pnmovimi IN NUMBER,
      ptablas IN VARCHAR2 DEFAULT NULL,
      psseguro_est IN NUMBER DEFAULT NULL,
      pnmovimi_est IN NUMBER DEFAULT NULL)
      RETURN NUMBER IS
      /***********************************************************************
                                            F_COMPCAR : Se traspasan los registros grabados en GARANCAR a
                              GARANSEG y se informa ffinefe de los ¿ltimos registros de
                              GARANSEG
              ALLIBCTR - Gesti¿n de datos referentes a los seguros
      ***********************************************************************/
      num_err        NUMBER;
      sentencia      VARCHAR2(300);
      -- Bug 10350 - 04/06/2009 - RSC - Detalle garant¿as (tarificaci¿n)
      v_sproduc      seguros.sproduc%TYPE;
      v_num_err      NUMBER;
      v_contd1       NUMBER;
      v_contd2       NUMBER;
      v_finiefe      garanseg.finiefe%TYPE;
      v_nmovima      garanseg.nmovima%TYPE;
      v_nmovlast     garanseg.nmovimi%TYPE;
      -- Fin Bug 10350
      vtraza         NUMBER := 0;
   BEGIN
      -- Bug 23940 - APD - 01/11/2012 - Se traspasan los registros grabados en
      -- GARANCAR a ESTGARANSEG
      IF ptablas = 'EST' THEN
         vtraza := 1;

         SELECT sproduc
           INTO v_sproduc
           FROM estseguros
          WHERE sseguro = psseguro_est;

         v_nmovlast := pnmovimi;

         -- Insertamos en GARANSEG los registros de GARANCAR
         -- A¿adimos los campos ICAPTOT y IPRITAR

         --BUG 0026638: FAC LCOL - TEC - Cartera para Autos. (id 176-19)
         FOR reg IN (SELECT sseguro, nriesgo, nmovimi, cversion, ctipmat, cmatric, cuso,
                            csubuso, fmatric, nkilometros, cvehnue, ivehicu, npma, ntara,
                            ccolor, nbastid, nplazas, cgaraje, cusorem, cremolque, triesgo,
                            cpaisorigen, cmotor, cchasis, ivehinue, nkilometraje, ccilindraje,
                            cpintura, ccaja, ccampero, ctipcarroceria, cservicio, corigen,
                            ctransporte, codmotor, anyo, ciaant, ffinciant, cmodalidad, cpeso,
                            ctransmision, npuertas   --Bug 34371/199273 - 03/03/2015 - AMC
                       FROM autriesgoscar
                      WHERE sseguro = psseguro
                        AND sproces = psproces) LOOP
            BEGIN
               vtraza := 8;

               INSERT INTO estautriesgos
                           (sseguro, nriesgo, nmovimi, cversion,
                            ctipmat, cmatric, cuso, csubuso, fmatric,
                            nkilometros, cvehnue, ivehicu, npma, ntara,
                            ccolor, nbastid, nplazas, cgaraje, cusorem,
                            cremolque, triesgo, cpaisorigen, cmotor,
                            cchasis, ivehinue, nkilometraje, ccilindraje,
                            cpintura, ccaja, ccampero, ctipcarroceria,
                            cservicio, corigen, ctransporte, codmotor,
                            anyo, ciaant, ffinciant, cmodalidad, cpeso,
                            ctransmision,
                            npuertas   --Bug 34371/199273 - 03/03/2015 - AMC
                                    )
                    VALUES (psseguro_est, reg.nriesgo, reg.nmovimi, reg.cversion,
                            reg.ctipmat, reg.cmatric, reg.cuso, reg.csubuso, reg.fmatric,
                            reg.nkilometros, reg.cvehnue, reg.ivehicu, reg.npma, reg.ntara,
                            reg.ccolor, reg.nbastid, reg.nplazas, reg.cgaraje, reg.cusorem,
                            reg.cremolque, reg.triesgo, reg.cpaisorigen, reg.cmotor,
                            reg.cchasis, reg.ivehinue, reg.nkilometraje, reg.ccilindraje,
                            reg.cpintura, reg.ccaja, reg.ccampero, reg.ctipcarroceria,
                            reg.cservicio, reg.corigen, reg.ctransporte, reg.codmotor,
                            reg.anyo, reg.ciaant, reg.ffinciant, reg.cmodalidad, reg.cpeso,
                            reg.ctransmision,
                            reg.npuertas   --Bug 34371/199273 - 03/03/2015 - AMC
                                        );
            EXCEPTION
               WHEN DUP_VAL_ON_INDEX THEN
                  UPDATE estautriesgos
                     SET cversion = reg.cversion,
                         ctipmat = reg.ctipmat,
                         cmatric = reg.cmatric,
                         cuso = reg.cuso,
                         csubuso = reg.csubuso,
                         fmatric = reg.fmatric,
                         nkilometros = reg.nkilometros,
                         cvehnue = reg.cvehnue,
                         ivehicu = reg.ivehicu,
                         npma = reg.npma,
                         ntara = reg.ntara,
                         ccolor = reg.ccolor,
                         nbastid = reg.nbastid,
                         nplazas = reg.nplazas,
                         cgaraje = reg.cgaraje,
                         cusorem = reg.cusorem,
                         cremolque = reg.cremolque,
                         triesgo = reg.triesgo,
                         cpaisorigen = reg.cpaisorigen,
                         cmotor = reg.cmotor,
                         cchasis = reg.cchasis,
                         ivehinue = reg.ivehinue,
                         nkilometraje = reg.nkilometraje,
                         ccilindraje = reg.ccilindraje,
                         cpintura = reg.cpintura,
                         ccaja = reg.ccaja,
                         ccampero = reg.ccampero,
                         ctipcarroceria = reg.ctipcarroceria,
                         cservicio = reg.cservicio,
                         corigen = reg.corigen,
                         ctransporte = reg.ctransporte,
                         codmotor = reg.codmotor,
                         anyo = reg.anyo,
                         ciaant = reg.ciaant,
                         ffinciant = reg.ffinciant,
                         cmodalidad = reg.cmodalidad,
                         cpeso = reg.cpeso,
                         ctransmision = reg.ctransmision,
                         npuertas = reg.npuertas
                   --Bug 34371/199273 - 03/03/2015 - AMC
                  WHERE  sseguro = psseguro_est
                     AND nriesgo = reg.nriesgo
                     AND nmovimi = pnmovimi_est;
            END;

            FOR re IN (SELECT sseguro, nriesgo, nmovimi, norden, sperson, fnacimi, fcarnet,
                              csexo, npuntos, cdomici, cprincipal, exper_manual, exper_cexper,
                              exper_sinie, exper_sinie_manual   --Bug 26638 - 14/04/2014 - AMC
                         FROM autconductorescar
                        WHERE sseguro = psseguro
                          AND sproces = psproces
                          AND nriesgo = reg.nriesgo) LOOP
               BEGIN
                  vtraza := 10;

                  INSERT INTO estautconductores
                              (sseguro, nriesgo, nmovimi, norden, sperson,
                               fnacimi, fcarnet, csexo, npuntos, cdomici,
                               cprincipal, exper_manual, exper_cexper,
                               exper_sinie, exper_sinie_manual)
                       VALUES (psseguro_est, re.nriesgo, re.nmovimi, re.norden, re.sperson,
                               re.fnacimi, re.fcarnet, re.csexo, re.npuntos, re.cdomici,
                               re.cprincipal, re.exper_manual, re.exper_cexper,
                               re.exper_sinie, re.exper_sinie_manual
                                                                    --Bug 26638 - 14/04/2014 - AMC
                              );
               EXCEPTION
                  WHEN DUP_VAL_ON_INDEX THEN
                     vtraza := 11;

                     UPDATE estautconductores
                        SET sperson = re.sperson,
                            fnacimi = re.fnacimi,
                            fcarnet = re.fcarnet,
                            csexo = re.csexo,
                            npuntos = re.npuntos,
                            cdomici = re.cdomici,
                            cprincipal = re.cprincipal,
                            exper_manual = re.exper_manual,
                            exper_cexper = re.exper_cexper,
                            exper_sinie = re.exper_sinie,
                            exper_sinie_manual = re.exper_sinie_manual
                      --Bug 26638 - 14/04/2014 - AMC
                     WHERE  sseguro = psseguro_est
                        AND nriesgo = reg.nriesgo
                        AND nmovimi = pnmovimi_est
                        AND norden = re.norden;
               END;
            END LOOP;

            FOR re IN (SELECT sproces, sseguro, nriesgo, nmovimi, cversion, cdispositivo,
                              cpropdisp, ivaldisp, finicontrato, ffincontrato, ncontrato,
                              tdescdisp
                         FROM autdisriesgoscar
                        WHERE sseguro = psseguro
                          AND sproces = psproces
                          AND nriesgo = reg.nriesgo) LOOP
               BEGIN
                  vtraza := 12;

                  INSERT INTO estautdisriesgos
                              (sseguro, nriesgo, nmovimi, cversion,
                               cdispositivo, cpropdisp, ivaldisp, finicontrato,
                               ffincontrato, ncontrato, tdescdisp)
                       VALUES (psseguro_est, re.nriesgo, re.nmovimi, re.cversion,
                               re.cdispositivo, re.cpropdisp, re.ivaldisp, re.finicontrato,
                               re.ffincontrato, re.ncontrato, re.tdescdisp);
               EXCEPTION
                  WHEN DUP_VAL_ON_INDEX THEN
                     vtraza := 12;

                     UPDATE estautdisriesgos
                        SET cpropdisp = re.cpropdisp,
                            ivaldisp = re.ivaldisp,
                            finicontrato = re.finicontrato,
                            ffincontrato = re.ffincontrato,
                            ncontrato = re.ncontrato,
                            tdescdisp = re.tdescdisp
                      WHERE sseguro = psseguro_est
                        AND nriesgo = reg.nriesgo
                        AND nmovimi = pnmovimi_est
                        AND cversion = re.cversion
                        AND cdispositivo = re.cdispositivo;
               END;
            END LOOP;

            FOR re IN (SELECT sproces, sseguro, nriesgo, nmovimi, cversion, caccesorio,
                              ctipacc, fini, ivalacc, tdesacc, casegurable
                         FROM autdetriesgoscar
                        WHERE sseguro = psseguro
                          AND sproces = psproces
                          AND nriesgo = reg.nriesgo) LOOP
               BEGIN
                  vtraza := 13;

                  INSERT INTO estautdetriesgos
                              (sseguro, nriesgo, nmovimi, cversion,
                               caccesorio, ctipacc, fini, ivalacc, tdesacc,
                               casegurable)
                       VALUES (psseguro_est, re.nriesgo, re.nmovimi, re.cversion,
                               re.caccesorio, re.ctipacc, re.fini, re.ivalacc, re.tdesacc,
                               re.casegurable);
               EXCEPTION
                  WHEN DUP_VAL_ON_INDEX THEN
                     vtraza := 14;

                     UPDATE estautdetriesgos
                        SET ctipacc = re.ctipacc,
                            fini = re.fini,
                            ivalacc = re.ivalacc,
                            tdesacc = re.tdesacc,
                            casegurable = re.casegurable
                      WHERE sseguro = psseguro_est
                        AND nriesgo = reg.nriesgo
                        AND nmovimi = pnmovimi_est
                        AND cversion = re.cversion
                        AND caccesorio = re.caccesorio;
               END;
            END LOOP;
         END LOOP;

         IF NVL(f_parproductos_v(v_sproduc, 'DETALLE_GARANT'), 0) = 1 THEN
            vtraza := 2;

            FOR regs IN (SELECT   sseguro, cgarant, nriesgo, sproces, SUM(irevali) irevali,
                                  SUM(icapital) icapital, SUM(iprianu) iprianu,
                                  SUM(irecarg) irecarg, SUM(ipritar) ipritar,
                                  SUM(idtocom) idtocom, SUM(itarrea) itarrea,

                                  -- Ini Bug 21907 - MDS - 03/05/2012
                                  SUM(idtotec) idtotec, SUM(ireccom) ireccom
                             -- Fin Bug 21907 - MDS - 03/05/2012
                         FROM     garancar
                            WHERE sseguro = psseguro
                              AND sproces = psproces
                              AND NVL(canulado, 0) = 0
                              AND cunica = 0
                         GROUP BY sseguro, cgarant, nriesgo, sproces
                         ORDER BY sseguro, cgarant, nriesgo, sproces) LOOP
               vtraza := 3;

               FOR reg IN (SELECT sseguro, cgarant, nriesgo, pnmovimi_est, finiefe, norden,
                                  ctarifa, icapital, precarg, iprianu, cformul, iextrap,
                                  ctipfra, ifranqu, irecarg, idtocom, pdtocom, ipritar,
                                  crevali, prevali, irevali, itarifa, itarrea, icaptot,
                                  ipritot, ftarifa, cderreg, feprev, fpprev, percre, cref,
                                  cintref, pdif, pinttec, nparben, nbns, tmgaran, cmatch,
                                  tdesmat, pintfin, crevalcar, pdtoint, idtoint, ccampanya,
                                  nversio, nmovima, cageven, nlinea, nfactor, ctarman,

                                  -- Ini Bug 21907 - MDS - 03/05/2012
                                  pdtotec, preccom, idtotec, ireccom
                             -- Fin Bug 21907 - MDS - 03/05/2012
                           FROM   garanseg
                            WHERE sseguro = psseguro
                              AND cgarant = regs.cgarant
                              AND nriesgo = regs.nriesgo
                              AND nmovimi = v_nmovlast) LOOP
                  BEGIN
                     vtraza := 4;

                     INSERT INTO estgaranseg
                                 (sseguro, cgarant, nriesgo, nmovimi,
                                  finiefe, norden, ctarifa, icapital,
                                  precarg, iprianu, cformul, iextrap,
                                  ctipfra, ifranqu, irecarg, idtocom,
                                  pdtocom, ipritar, crevali, prevali,
                                  irevali, itarifa, itarrea, icaptot,
                                  ipritot, ftarifa, cderreg, feprev,
                                  fpprev, percre, cref, cintref, pdif,
                                  pinttec, nparben, nbns, tmgaran,
                                  cmatch, tdesmat, pintfin, crevalcar,
                                  pdtoint, idtoint, ccampanya, nversio,
                                  nmovima, cageven, nlinea, nfactor,
                                  ctarman, pdtotec, preccom, idtotec,
                                  ireccom)
                          VALUES (psseguro_est, reg.cgarant, reg.nriesgo, pnmovimi_est,
                                  reg.finiefe, reg.norden, reg.ctarifa, regs.icapital,
                                  reg.precarg, regs.iprianu, reg.cformul, reg.iextrap,
                                  reg.ctipfra, reg.ifranqu, regs.irecarg, regs.idtocom,
                                  reg.pdtocom, regs.ipritar, reg.crevali, reg.prevali,
                                  regs.irevali, reg.itarifa, regs.itarrea, regs.icapital,
                                  regs.iprianu, reg.ftarifa, reg.cderreg, reg.feprev,
                                  reg.fpprev, reg.percre, reg.cref, reg.cintref, reg.pdif,
                                  reg.pinttec, reg.nparben, reg.nbns, reg.tmgaran,
                                  reg.cmatch, reg.tdesmat, reg.pintfin, reg.crevalcar,
                                  reg.pdtoint, reg.idtoint, reg.ccampanya, reg.nversio,
                                  reg.nmovima, reg.cageven, reg.nlinea, reg.nfactor,
                                  reg.ctarman, reg.pdtotec, reg.preccom, regs.idtotec,
                                  regs.ireccom);
                  EXCEPTION
                     WHEN DUP_VAL_ON_INDEX THEN
                        vtraza := 5;

                        UPDATE estgaranseg
                           SET irevali = regs.irevali,
                               icapital = regs.icapital,
                               iprianu = regs.iprianu,
                               irecarg = regs.irecarg,
                               ipritar = regs.ipritar,
                               idtocom = regs.idtocom,
                               itarrea = regs.itarrea,
                               icaptot = regs.icapital,
                               -- ==> Detalle de Garant¿a: No Coaseguro
                               ipritot = regs.iprianu,
                                      -- ==> Detalle de Garant¿a: No Coaseguro
                               -- Ini Bug 21907 - MDS - 03/05/2012
                               idtotec = regs.idtotec,
                               ireccom = regs.ireccom
                         -- Fin Bug 21907 - MDS - 03/05/2012
                        WHERE  sseguro = psseguro_est
                           AND cgarant = regs.cgarant
                           AND nriesgo = regs.nriesgo
                           AND nmovimi = pnmovimi_est
                           AND finiefe = reg.finiefe;
                  END;
               END LOOP;

               vtraza := 6;

               FOR reg IN (SELECT sseguro, cgarant, nriesgo, pnmovimi_est, finiefe, ndetgar,
                                  fefecto, fvencim, ndurcob, ctarifa, pinttec, ftarifa,
                                  crevali, prevali, irevali, icapital, iprianu, precarg,
                                  irecarg, cparben, cprepost, ffincob, ipritar, provmat0,
                                  fprovmat0, provmat1, fprovmat1, pintmin, pdtocom, idtocom,
                                  ctarman, ipripur, ipriinv, itarrea, cageven, cunica
                             FROM garancar
                            WHERE sseguro = psseguro
                              AND sproces = psproces
                              AND cgarant = regs.cgarant
                              AND nriesgo = regs.nriesgo
                              AND NVL(canulado, 0) = 0)
                                                       --que no esten anuladas.
               LOOP
                  BEGIN
                     vtraza := 7;

                     INSERT INTO estdetgaranseg
                                 (sseguro, cgarant, nriesgo, nmovimi,
                                  finiefe, ndetgar, fefecto, fvencim,
                                  ndurcob, ctarifa, pinttec, ftarifa,
                                  crevali, prevali, irevali, icapital,
                                  iprianu, precarg, irecarg, cparben,
                                  cprepost, ffincob, ipritar, provmat0,
                                  fprovmat0, provmat1, fprovmat1, pintmin,
                                  pdtocom, idtocom, ctarman, ipripur,
                                  ipriinv, itarrea, cagente, cunica)
                          VALUES (psseguro_est, reg.cgarant, reg.nriesgo, pnmovimi_est,
                                  reg.finiefe, reg.ndetgar, reg.fefecto, reg.fvencim,
                                  reg.ndurcob, reg.ctarifa, reg.pinttec, reg.ftarifa,
                                  reg.crevali, reg.prevali, reg.irevali, reg.icapital,
                                  reg.iprianu, reg.precarg, reg.irecarg, reg.cparben,
                                  reg.cprepost, reg.ffincob, reg.ipritar, reg.provmat0,
                                  reg.fprovmat0, reg.provmat1, reg.fprovmat1, reg.pintmin,
                                  reg.pdtocom, reg.idtocom, reg.ctarman, reg.ipripur,
                                  reg.ipriinv, reg.itarrea, reg.cageven, reg.cunica);
                  EXCEPTION
                     WHEN DUP_VAL_ON_INDEX THEN
                        vtraza := 8;

                        UPDATE estdetgaranseg
                           SET fefecto = reg.fefecto,
                               fvencim = reg.fvencim,
                               ndurcob = reg.ndurcob,
                               ctarifa = reg.ctarifa,
                               pinttec = reg.pinttec,
                               ftarifa = reg.ftarifa,
                               crevali = reg.crevali,
                               prevali = reg.prevali,
                               irevali = reg.irevali,
                               icapital = reg.icapital,
                               iprianu = reg.iprianu,
                               precarg = reg.precarg,
                               irecarg = reg.irecarg,
                               cparben = reg.cparben,
                               cprepost = reg.cprepost,
                               ffincob = reg.ffincob,
                               ipritar = reg.ipritar,
                               provmat0 = reg.provmat0,
                               fprovmat0 = reg.fprovmat0,
                               provmat1 = reg.provmat1,
                               fprovmat1 = reg.fprovmat1,
                               pintmin = reg.pintmin,
                               pdtocom = reg.pdtocom,
                               idtocom = reg.idtocom,
                               ctarman = reg.ctarman,
                               ipripur = reg.ipripur,
                               ipriinv = reg.ipriinv,
                               itarrea = reg.itarrea,
                               cagente = reg.cageven,
                               cunica = reg.cunica
                         WHERE sseguro = psseguro_est
                           AND nriesgo = reg.nriesgo
                           AND cgarant = reg.cgarant
                           AND nmovimi = pnmovimi_est
                           AND finiefe = reg.finiefe
                           AND ndetgar = reg.ndetgar;
                  END;
               END LOOP;
            END LOOP;
         --FIN BUG 0026638: FAC LCOL - TEC - Cartera para Autos. (id 176-19)
         ELSE
            vtraza := 9;

            IF NVL(f_parproductos_v(v_sproduc, 'DETALLE_GARANT'), 0) = 2 THEN
               vtraza := 10;

               FOR reg IN (SELECT sseguro, cgarant, nriesgo, pnmovimi_est, finiefe, norden,
                                  NULL ctarifa, icapital, precarg, iprianu, ffinefe, cformul,
                                  iextrap, ctipfra, ifranqu, irecarg, idtocom, pdtocom,
                                  ipritar, crevali, prevali, irevali, itarifa, itarrea,
                                  icaptot, ipritot, ftarifa, cderreg, feprev, fpprev, percre,
                                  cref, cintref, pdif, pinttec, nparben, nbns, tmgaran,
                                  cmatch, tdesmat, pintfin, 1 crevalcar, pdtoint, idtoint,
                                  ccampanya, nversio, nmovima, cageven, nlinea, nfactor,
                                  ctarman
                             FROM garancar
                            WHERE sseguro = psseguro
                              AND sproces = psproces
                              AND NVL(canulado, 0) = 0)
                                                       --que no esten anuladas.
               LOOP
                  BEGIN
                     vtraza := 11;

                     INSERT INTO estgaranseg
                                 (sseguro, cgarant, nriesgo, nmovimi,
                                  finiefe, norden, ctarifa, icapital,
                                  precarg, iprianu, ffinefe, cformul,
                                  iextrap, ctipfra, ifranqu, irecarg,
                                  idtocom, pdtocom, ipritar, crevali,
                                  prevali, irevali, itarifa, itarrea,
                                  icaptot, ipritot, ftarifa, cderreg,
                                  feprev, fpprev, percre, cref, cintref,
                                  pdif, pinttec, nparben, nbns, tmgaran,
                                  cmatch, tdesmat, pintfin, crevalcar,
                                  pdtoint, idtoint, ccampanya, nversio,
                                  nmovima, cageven, nlinea, nfactor,
                                  ctarman)
                          VALUES (psseguro_est, reg.cgarant, reg.nriesgo, pnmovimi_est,
                                  reg.finiefe, reg.norden, reg.ctarifa, reg.icapital,
                                  reg.precarg, reg.iprianu, reg.ffinefe, reg.cformul,
                                  reg.iextrap, reg.ctipfra, reg.ifranqu, reg.irecarg,
                                  reg.idtocom, reg.pdtocom, reg.ipritar, reg.crevali,
                                  reg.prevali, reg.irevali, reg.itarifa, reg.itarrea,
                                  reg.icaptot, reg.ipritot, reg.ftarifa, reg.cderreg,
                                  reg.feprev, reg.fpprev, reg.percre, reg.cref, reg.cintref,
                                  reg.pdif, reg.pinttec, reg.nparben, reg.nbns, reg.tmgaran,
                                  reg.cmatch, reg.tdesmat, reg.pintfin, reg.crevalcar,
                                  reg.pdtoint, reg.idtoint, reg.ccampanya, reg.nversio,
                                  reg.nmovima, reg.cageven, reg.nlinea, reg.nfactor,
                                  reg.ctarman);
                  EXCEPTION
                     WHEN DUP_VAL_ON_INDEX THEN
                        vtraza := 12;

                        UPDATE estgaranseg
                           SET norden = reg.norden,
                               ctarifa = reg.ctarifa,
                               icapital = reg.icapital,
                               precarg = reg.precarg,
                               iprianu = reg.iprianu,
                               ffinefe = reg.ffinefe,
                               cformul = reg.cformul,
                               iextrap = reg.iextrap,
                               ctipfra = reg.ctipfra,
                               ifranqu = reg.ifranqu,
                               irecarg = reg.irecarg,
                               idtocom = reg.idtocom,
                               pdtocom = reg.pdtocom,
                               ipritar = reg.ipritar,
                               crevali = reg.crevali,
                               prevali = reg.prevali,
                               irevali = reg.irevali,
                               itarifa = reg.itarifa,
                               itarrea = reg.itarrea,
                               icaptot = reg.icaptot,
                               ipritot = reg.ipritot,
                               ftarifa = reg.ftarifa,
                               cderreg = reg.cderreg,
                               feprev = reg.feprev,
                               fpprev = reg.fpprev,
                               percre = reg.percre,
                               cref = reg.cref,
                               cintref = reg.cintref,
                               pdif = reg.pdif,
                               pinttec = reg.pinttec,
                               nparben = reg.nparben,
                               nbns = reg.nbns,
                               tmgaran = reg.tmgaran,
                               cmatch = reg.cmatch,
                               tdesmat = reg.tdesmat,
                               pintfin = reg.pintfin,
                               crevalcar = reg.crevalcar,
                               pdtoint = reg.pdtoint,
                               idtoint = reg.idtoint,
                               ccampanya = reg.ccampanya,
                               nversio = reg.nversio,
                               nmovima = reg.nmovima,
                               cageven = reg.cageven,
                               nlinea = reg.nlinea,
                               nfactor = reg.nfactor,
                               ctarman = reg.ctarman
                         WHERE sseguro = psseguro_est
                           AND nriesgo = reg.nriesgo
                           AND cgarant = reg.cgarant
                           AND nmovimi = pnmovimi_est
                           AND finiefe = reg.finiefe;
                  END;
               END LOOP;

               vtraza := 13;

               FOR reg IN (SELECT sseguro, cgarant, nriesgo, pnmovimi_est, finiefe, ndetgar,
                                  fefecto, fvencim, ndurcob, ctarifa, pinttec, ftarifa,
                                  crevali, prevali, irevali, icapital, iprianu, precarg,
                                  irecarg, cparben, cprepost, ffincob, ipritar, provmat0,
                                  fprovmat0, provmat1, fprovmat1, pintmin, pdtocom, idtocom,
                                  ctarman, ipripur, ipriinv, itarrea, cageven, cunica
                             FROM garancar
                            WHERE sseguro = psseguro
                              AND sproces = psproces
                              AND NVL(canulado, 0) = 0)
                                                       --que no esten anuladas.
               LOOP
                  BEGIN
                     vtraza := 14;

                     INSERT INTO estdetgaranseg
                                 (sseguro, cgarant, nriesgo, nmovimi,
                                  finiefe, ndetgar, fefecto, fvencim,
                                  ndurcob, ctarifa, pinttec, ftarifa,
                                  crevali, prevali, irevali, icapital,
                                  iprianu, precarg, irecarg, cparben,
                                  cprepost, ffincob, ipritar, provmat0,
                                  fprovmat0, provmat1, fprovmat1, pintmin,
                                  pdtocom, idtocom, ctarman, ipripur,
                                  ipriinv, itarrea, cagente, cunica)
                          VALUES (psseguro_est, reg.cgarant, reg.nriesgo, pnmovimi_est,
                                  reg.finiefe, reg.ndetgar, reg.fefecto, reg.fvencim,
                                  reg.ndurcob, reg.ctarifa, reg.pinttec, reg.ftarifa,
                                  reg.crevali, reg.prevali, reg.irevali, reg.icapital,
                                  reg.iprianu, reg.precarg, reg.irecarg, reg.cparben,
                                  reg.cprepost, reg.ffincob, reg.ipritar, reg.provmat0,
                                  reg.fprovmat0, reg.provmat1, reg.fprovmat1, reg.pintmin,
                                  reg.pdtocom, reg.idtocom, reg.ctarman, reg.ipripur,
                                  reg.ipriinv, reg.itarrea, reg.cageven, reg.cunica);
                  EXCEPTION
                     WHEN DUP_VAL_ON_INDEX THEN
                        vtraza := 15;

                        UPDATE estdetgaranseg
                           SET fefecto = reg.fefecto,
                               fvencim = reg.fvencim,
                               ndurcob = reg.ndurcob,
                               ctarifa = reg.ctarifa,
                               pinttec = reg.pinttec,
                               ftarifa = reg.ftarifa,
                               crevali = reg.crevali,
                               prevali = reg.prevali,
                               irevali = reg.irevali,
                               icapital = reg.icapital,
                               iprianu = reg.iprianu,
                               precarg = reg.precarg,
                               irecarg = reg.irecarg,
                               cparben = reg.cparben,
                               cprepost = reg.cprepost,
                               ffincob = reg.ffincob,
                               ipritar = reg.ipritar,
                               provmat0 = reg.provmat0,
                               fprovmat0 = reg.fprovmat0,
                               provmat1 = reg.provmat1,
                               fprovmat1 = reg.fprovmat1,
                               pintmin = reg.pintmin,
                               pdtocom = reg.pdtocom,
                               idtocom = reg.idtocom,
                               ctarman = reg.ctarman,
                               ipripur = reg.ipripur,
                               ipriinv = reg.ipriinv,
                               itarrea = reg.itarrea,
                               cagente = reg.cageven,
                               cunica = reg.cunica
                         WHERE sseguro = psseguro_est
                           AND nriesgo = reg.nriesgo
                           AND cgarant = reg.cgarant
                           AND nmovimi = pnmovimi_est
                           AND finiefe = reg.finiefe
                           AND ndetgar = reg.ndetgar;
                  END;
               END LOOP;
            ELSE
               vtraza := 16;

               FOR reg IN (SELECT sseguro, cgarant, nriesgo, pnmovimi_est, finiefe, norden,
                                  ctarifa, icapital, precarg, iprianu, ffinefe, cformul,
                                  iextrap, ctipfra, ifranqu, irecarg, idtocom, pdtocom,
                                  ipritar, crevali, prevali, irevali, itarifa, itarrea,
                                  icaptot, ipritot, ftarifa, cderreg, feprev, fpprev, percre,
                                  cref, cintref, pdif, pinttec, nparben, nbns, tmgaran,
                                  cmatch, tdesmat, pintfin, 1 crevalcar, pdtoint, idtoint,
                                  ccampanya, nversio, nmovima, cageven, nlinea, nfactor,
                                  ctarman, pdtotec, preccom, idtotec, ireccom
                             FROM garancar
                            WHERE sseguro = psseguro
                              AND sproces = psproces
                              AND NVL(canulado, 0) = 0)
                                                       --que no esten anuladas.
               LOOP
                  BEGIN
                     vtraza := 17;

                     INSERT INTO estgaranseg
                                 (sseguro, cgarant, nriesgo, nmovimi,
                                  finiefe, norden, ctarifa, icapital,
                                  precarg, iprianu, ffinefe, cformul,
                                  iextrap, ctipfra, ifranqu, irecarg,
                                  idtocom, pdtocom, ipritar, crevali,
                                  prevali, irevali, itarifa, itarrea,
                                  icaptot, ipritot, ftarifa, cderreg,
                                  feprev, fpprev, percre, cref, cintref,
                                  pdif, pinttec, nparben, nbns, tmgaran,
                                  cmatch, tdesmat, pintfin, crevalcar,
                                  pdtoint, idtoint, ccampanya, nversio,
                                  nmovima, cageven, nlinea, nfactor,
                                  ctarman, pdtotec, preccom, idtotec,
                                  ireccom)
                          VALUES (psseguro_est, reg.cgarant, reg.nriesgo, pnmovimi_est,
                                  reg.finiefe, reg.norden, reg.ctarifa, reg.icapital,
                                  reg.precarg, reg.iprianu, reg.ffinefe, reg.cformul,
                                  reg.iextrap, reg.ctipfra, reg.ifranqu, reg.irecarg,
                                  reg.idtocom, reg.pdtocom, reg.ipritar, reg.crevali,
                                  reg.prevali, reg.irevali, reg.itarifa, reg.itarrea,
                                  reg.icaptot, reg.ipritot, reg.ftarifa, reg.cderreg,
                                  reg.feprev, reg.fpprev, reg.percre, reg.cref, reg.cintref,
                                  reg.pdif, reg.pinttec, reg.nparben, reg.nbns, reg.tmgaran,
                                  reg.cmatch, reg.tdesmat, reg.pintfin, reg.crevalcar,
                                  reg.pdtoint, reg.idtoint, reg.ccampanya, reg.nversio,
                                  reg.nmovima, reg.cageven, reg.nlinea, reg.nfactor,
                                  reg.ctarman, reg.pdtotec, reg.preccom, reg.idtotec,
                                  reg.ireccom);
                  EXCEPTION
                     WHEN DUP_VAL_ON_INDEX THEN
                        vtraza := 18;

                        UPDATE estgaranseg
                           SET norden = reg.norden,
                               ctarifa = reg.ctarifa,
                               icapital = reg.icapital,
                               precarg = reg.precarg,
                               iprianu = reg.iprianu,
                               ffinefe = reg.ffinefe,
                               cformul = reg.cformul,
                               iextrap = reg.iextrap,
                               ctipfra = reg.ctipfra,
                               ifranqu = reg.ifranqu,
                               irecarg = reg.irecarg,
                               idtocom = reg.idtocom,
                               pdtocom = reg.pdtocom,
                               ipritar = reg.ipritar,
                               crevali = reg.crevali,
                               prevali = reg.prevali,
                               irevali = reg.irevali,
                               itarifa = reg.itarifa,
                               itarrea = reg.itarrea,
                               icaptot = reg.icaptot,
                               ipritot = reg.ipritot,
                               ftarifa = reg.ftarifa,
                               cderreg = reg.cderreg,
                               feprev = reg.feprev,
                               fpprev = reg.fpprev,
                               percre = reg.percre,
                               cref = reg.cref,
                               cintref = reg.cintref,
                               pdif = reg.pdif,
                               pinttec = reg.pinttec,
                               nparben = reg.nparben,
                               nbns = reg.nbns,
                               tmgaran = reg.tmgaran,
                               cmatch = reg.cmatch,
                               tdesmat = reg.tdesmat,
                               pintfin = reg.pintfin,
                               crevalcar = reg.crevalcar,
                               pdtoint = reg.pdtoint,
                               idtoint = reg.idtoint,
                               ccampanya = reg.ccampanya,
                               nversio = reg.nversio,
                               nmovima = reg.nmovima,
                               cageven = reg.cageven,
                               nlinea = reg.nlinea,
                               nfactor = reg.nfactor,
                               ctarman = reg.ctarman,
                               pdtotec = reg.pdtotec,
                               preccom = reg.preccom,
                               idtotec = reg.idtotec,
                               ireccom = reg.ireccom
                         WHERE sseguro = psseguro_est
                           AND nriesgo = reg.nriesgo
                           AND cgarant = reg.cgarant
                           AND nmovimi = pnmovimi_est
                           AND finiefe = reg.finiefe;
                  END;
               END LOOP;
            END IF;
         END IF;

         vtraza := 19;

         -- BUG14172:DRA:27/04/2010:Inici
         -- Insertamos en pregunseg los registros de preguncar
         FOR reg IN (SELECT pp.sseguro, pnmovimi_est, pp.nriesgo, pp.cpregun, pp.crespue,
                            pp.trespue
                       FROM preguncar pp, codipregun cp
                      WHERE pp.sseguro = psseguro
                        AND pp.sproces = psproces
                        AND cp.cpregun = pp.cpregun
                        AND((cp.ctippre IN(4, 5)
                             AND pp.trespue IS NOT NULL)
                            OR pp.crespue IS NOT NULL)) LOOP
            BEGIN
               vtraza := 20;

               INSERT INTO estpregunseg
                           (sseguro, nmovimi, nriesgo, cpregun,
                            crespue, trespue)
                    VALUES (psseguro_est, pnmovimi_est, reg.nriesgo, reg.cpregun,
                            reg.crespue, reg.trespue);
            EXCEPTION
               WHEN DUP_VAL_ON_INDEX THEN
                  vtraza := 21;

                  UPDATE estpregunseg
                     SET crespue = reg.crespue,
                         trespue = reg.trespue
                   WHERE sseguro = psseguro_est
                     AND nriesgo = reg.nriesgo
                     AND cpregun = reg.cpregun
                     AND nmovimi = pnmovimi_est;
            END;
         END LOOP;

         vtraza := 22;

         -- Insertamos en pregunsegtab los registros de preguncartab
         FOR reg IN (SELECT pp.sseguro, pnmovimi_est, pp.nriesgo, pp.cpregun, pp.nlinea,
                            pp.ccolumna, pp.tvalor, pp.fvalor, pp.nvalor
                       FROM preguncartab pp, codipregun cp
                      WHERE pp.sseguro = psseguro
                        AND pp.sproces = psproces
                        AND cp.cpregun = pp.cpregun
                        AND(cp.ctippre IN(7)
                            AND(pp.tvalor IS NOT NULL
                                OR pp.fvalor IS NOT NULL
                                OR pp.nvalor IS NOT NULL))) LOOP
            BEGIN
               vtraza := 23;

               INSERT INTO estpregunsegtab
                           (sseguro, nmovimi, nriesgo, cpregun, nlinea,
                            ccolumna, tvalor, fvalor, nvalor)
                    VALUES (psseguro_est, pnmovimi_est, reg.nriesgo, reg.cpregun, reg.nlinea,
                            reg.ccolumna, reg.tvalor, reg.fvalor, reg.nvalor);
            EXCEPTION
               WHEN DUP_VAL_ON_INDEX THEN
                  vtraza := 24;

                  UPDATE estpregunsegtab
                     SET tvalor = reg.tvalor,
                         fvalor = reg.fvalor,
                         nvalor = reg.nvalor
                   WHERE sseguro = psseguro_est
                     AND nriesgo = reg.nriesgo
                     AND cpregun = reg.cpregun
                     AND nmovimi = pnmovimi_est
                     AND nlinea = reg.nlinea
                     AND ccolumna = reg.ccolumna;
            END;
         END LOOP;

         vtraza := 25;

         -- Insertamos en pregungaranseg los registros de pregungarancar
         FOR reg IN (SELECT pp.sseguro, pp.nriesgo, pp.cgarant, pnmovimi_est, pp.cpregun,
                            pp.crespue, finiefe, pp.nmovima, pp.trespue
                       FROM pregungarancar pp, codipregun cp
                      WHERE pp.sseguro = psseguro
                        AND pp.sproces = psproces
                        AND cp.cpregun = pp.cpregun
                        AND((cp.ctippre IN(4, 5)
                             AND pp.trespue IS NOT NULL)
                            OR pp.crespue IS NOT NULL)) LOOP
            BEGIN
               vtraza := 26;

               INSERT INTO estpregungaranseg
                           (sseguro, nriesgo, cgarant, nmovimi,
                            cpregun, crespue, finiefe, nmovima, trespue)
                    VALUES (psseguro_est, reg.nriesgo, reg.cgarant, pnmovimi_est,
                            reg.cpregun, reg.crespue, reg.finiefe, reg.nmovima, reg.trespue);
            EXCEPTION
               WHEN DUP_VAL_ON_INDEX THEN
                  vtraza := 27;

                  UPDATE estpregungaranseg
                     SET crespue = reg.crespue,
                         trespue = reg.trespue
                   WHERE sseguro = psseguro_est
                     AND nriesgo = reg.nriesgo
                     AND cgarant = reg.cgarant
                     AND nmovimi = pnmovimi_est
                     AND cpregun = reg.cpregun
                     AND finiefe = reg.finiefe
                     AND nmovima = reg.nmovima;
            END;
         END LOOP;

         vtraza := 28;

         -- Insertamos en pregungaranseg los registros de pregungarancartab
         FOR reg IN (SELECT pp.sseguro, pp.nriesgo, pp.cgarant, pnmovimi_est, pp.cpregun,
                            pp.finiefe, pp.nmovima, pp.nlinea, pp.ccolumna, pp.tvalor,
                            pp.fvalor, pp.nvalor
                       FROM pregungarancartab pp, codipregun cp
                      WHERE pp.sseguro = psseguro
                        AND pp.sproces = psproces
                        AND cp.cpregun = pp.cpregun
                        AND(cp.ctippre IN(7)
                            AND(pp.tvalor IS NOT NULL
                                OR pp.fvalor IS NOT NULL
                                OR pp.nvalor IS NOT NULL))) LOOP
            BEGIN
               vtraza := 29;

               INSERT INTO estpregungaransegtab
                           (sseguro, nriesgo, cgarant, nmovimi,
                            cpregun, finiefe, nmovima, nlinea, ccolumna,
                            tvalor, fvalor, nvalor)
                    VALUES (psseguro_est, reg.nriesgo, reg.cgarant, pnmovimi_est,
                            reg.cpregun, reg.finiefe, reg.nmovima, reg.nlinea, reg.ccolumna,
                            reg.tvalor, reg.fvalor, reg.nvalor);
            EXCEPTION
               WHEN DUP_VAL_ON_INDEX THEN
                  vtraza := 30;

                  UPDATE estpregungaransegtab
                     SET tvalor = reg.tvalor,
                         fvalor = reg.fvalor,
                         nvalor = reg.nvalor
                   WHERE sseguro = psseguro_est
                     AND nriesgo = reg.nriesgo
                     AND cgarant = reg.cgarant
                     AND nmovimi = pnmovimi_est
                     AND cpregun = reg.cpregun
                     AND finiefe = reg.finiefe
                     AND nmovima = reg.nmovima
                     AND nlinea = reg.nlinea
                     AND ccolumna = reg.ccolumna;
            END;
         END LOOP;

         vtraza := 31;

         -- Insertamos en pregunpolseg los registros de pregunpolcar
         FOR reg IN (SELECT pp.sseguro, pp.cpregun, pp.crespue, pnmovimi_est, pp.trespue
                       FROM pregunpolcar pp, codipregun cp
                      WHERE pp.sseguro = psseguro
                        AND pp.sproces = psproces
                        AND cp.cpregun = pp.cpregun
                        AND((cp.ctippre IN(4, 5)
                             AND pp.trespue IS NOT NULL)
                            OR pp.crespue IS NOT NULL)) LOOP
            BEGIN
               vtraza := 32;

               INSERT INTO estpregunpolseg
                           (sseguro, cpregun, crespue, nmovimi, trespue)
                    VALUES (psseguro_est, reg.cpregun, reg.crespue, pnmovimi_est, reg.trespue);
            EXCEPTION
               WHEN DUP_VAL_ON_INDEX THEN
                  vtraza := 33;

                  UPDATE estpregunpolseg
                     SET crespue = reg.crespue,
                         trespue = reg.trespue
                   WHERE sseguro = psseguro_est
                     AND cpregun = reg.cpregun
                     AND nmovimi = pnmovimi_est;
            END;
         END LOOP;

         vtraza := 34;

         -- Insertamos en pregunpolseg los registros de pregunpolcartab
         FOR reg IN (SELECT pp.sseguro, pp.cpregun, pnmovimi_est, pp.nlinea, pp.ccolumna,
                            pp.tvalor, pp.fvalor, pp.nvalor
                       FROM pregunpolcartab pp, codipregun cp
                      WHERE pp.sseguro = psseguro
                        AND pp.sproces = psproces
                        AND cp.cpregun = pp.cpregun
                        AND(cp.ctippre IN(7)
                            AND(pp.tvalor IS NOT NULL
                                OR pp.fvalor IS NOT NULL
                                OR pp.nvalor IS NOT NULL))) LOOP
            BEGIN
               vtraza := 35;

               INSERT INTO estpregunpolsegtab
                           (sseguro, cpregun, nmovimi, nlinea,
                            ccolumna, tvalor, fvalor, nvalor)
                    VALUES (psseguro_est, reg.cpregun, pnmovimi_est, reg.nlinea,
                            reg.ccolumna, reg.tvalor, reg.fvalor, reg.nvalor);
            EXCEPTION
               WHEN DUP_VAL_ON_INDEX THEN
                  vtraza := 36;

                  UPDATE estpregunpolsegtab
                     SET tvalor = reg.tvalor,
                         fvalor = reg.fvalor,
                         nvalor = reg.nvalor
                   WHERE sseguro = psseguro_est
                     AND cpregun = reg.cpregun
                     AND nmovimi = pnmovimi_est
                     AND nlinea = reg.nlinea
                     AND ccolumna = reg.ccolumna;
            END;
         END LOOP;

         vtraza := 37;

         -- Bug 21121 - APD - 14/03/2012
         -- Insertamos en detprimas los registros de tmp_detprimas
         FOR reg IN (SELECT sseguro, nriesgo, cgarant, pnmovimi_est, finiefe, ccampo, cconcep,
                            norden, iconcep, iconcep2
                       FROM tmp_detprimas
                      WHERE sseguro = psseguro
                        AND sproces = psproces) LOOP
            BEGIN
               vtraza := 38;

               INSERT INTO estdetprimas
                           (sseguro, nriesgo, cgarant, nmovimi,
                            finiefe, ccampo, cconcep, norden, iconcep,
                            iconcep2)
                    VALUES (psseguro_est, reg.nriesgo, reg.cgarant, pnmovimi_est,
                            reg.finiefe, reg.ccampo, reg.cconcep, reg.norden, reg.iconcep,
                            reg.iconcep2);
            EXCEPTION
               WHEN DUP_VAL_ON_INDEX THEN
                  vtraza := 39;

                  UPDATE estdetprimas
                     SET norden = reg.norden,
                         iconcep = reg.iconcep,
                         iconcep2 = reg.iconcep2
                   WHERE sseguro = psseguro_est
                     AND nriesgo = reg.nriesgo
                     AND cgarant = reg.cgarant
                     AND nmovimi = pnmovimi_est
                     AND finiefe = reg.finiefe
                     AND ccampo = reg.ccampo
                     AND cconcep = reg.cconcep;
            END;
         END LOOP;

         vtraza := 40;

         -- fin Bug 21121 - APD - 14/03/2012
         FOR reg IN (SELECT sseguro, pnmovimi_est, finicoa, ffincoa, ploccoa, fcuacoa, ccompan,
                            npoliza
                       FROM coacuadro
                      WHERE sseguro = psseguro
                        AND ncuacoa = v_nmovlast) LOOP
            BEGIN
               vtraza := 41;

               INSERT INTO estcoacuadro
                           (sseguro, ncuacoa, finicoa, ffincoa,
                            ploccoa, fcuacoa, ccompan, npoliza)
                    VALUES (psseguro_est, pnmovimi_est, reg.finicoa, reg.ffincoa,
                            reg.ploccoa, reg.fcuacoa, reg.ccompan, reg.npoliza);
            EXCEPTION
               WHEN DUP_VAL_ON_INDEX THEN
                  vtraza := 42;

                  UPDATE estcoacuadro
                     SET finicoa = reg.finicoa,
                         ffincoa = reg.ffincoa,
                         ploccoa = reg.ploccoa,
                         fcuacoa = reg.fcuacoa,
                         ccompan = reg.ccompan,
                         npoliza = reg.npoliza
                   WHERE sseguro = psseguro_est
                     AND ncuacoa = pnmovimi_est;
            END;
         END LOOP;

         vtraza := 43;

         FOR reg IN (SELECT sseguro, pnmovimi_est, ccompan, pcescoa, pcomcoa, pcomcon, pcomgas,
                            pcesion
                       FROM coacedido
                      WHERE sseguro = psseguro
                        AND ncuacoa = v_nmovlast) LOOP
            BEGIN
               vtraza := 44;

               INSERT INTO estcoacedido
                           (sseguro, ncuacoa, ccompan, pcescoa,
                            pcomcoa, pcomcon, pcomgas, pcesion)
                    VALUES (psseguro_est, pnmovimi_est, reg.ccompan, reg.pcescoa,
                            reg.pcomcoa, reg.pcomcon, reg.pcomgas, reg.pcesion);
            EXCEPTION
               WHEN DUP_VAL_ON_INDEX THEN
                  vtraza := 45;

                  UPDATE estcoacedido
                     SET pcescoa = reg.pcescoa,
                         pcomcoa = reg.pcomcoa,
                         pcomcon = reg.pcomcon,
                         pcomgas = reg.pcomgas,
                         pcesion = reg.pcesion
                   WHERE sseguro = psseguro_est
                     AND ncuacoa = pnmovimi_est
                     AND ccompan = reg.ccompan;
            END;
         END LOOP;

         vtraza := 46;

         UPDATE estseguros
            SET ncuacoa = pnmovimi_est
          WHERE sseguro = psseguro;

         vtraza := 47;

         -- BUG24929:DRA:04/12/2012:Inici
         FOR reg IN (SELECT sseguro, cagente, nmovimi, nordage, pcomisi, ppartici, islider
                       FROM age_corretaje
                      WHERE sseguro = psseguro
                        AND nmovimi = v_nmovlast) LOOP
            BEGIN
               vtraza := 48;

               INSERT INTO estage_corretaje
                           (sseguro, cagente, nmovimi, nordage,
                            pcomisi, ppartici, islider)
                    VALUES (psseguro_est, reg.cagente, pnmovimi_est, reg.nordage,
                            reg.pcomisi, reg.ppartici, reg.islider);
            EXCEPTION
               WHEN DUP_VAL_ON_INDEX THEN
                  vtraza := 49;

                  UPDATE estage_corretaje
                     SET nordage = reg.nordage,
                         pcomisi = reg.pcomisi,
                         ppartici = reg.ppartici,
                         islider = reg.islider
                   WHERE sseguro = psseguro_est
                     AND nmovimi = pnmovimi_est
                     AND cagente = reg.cagente;
            END;
         END LOOP;

         --A¿adir retorno
         FOR reg IN (SELECT sseguro, sperson, nmovimi, pretorno, idconvenio
                       FROM rtn_convenio
                      WHERE sseguro = psseguro
                        AND nmovimi = v_nmovlast) LOOP
            BEGIN
               vtraza := 49;

               INSERT INTO estrtn_convenio
                           (sseguro, sperson, nmovimi, pretorno,
                            idconvenio)
                    VALUES (psseguro_est, reg.sperson, pnmovimi_est, reg.pretorno,
                            reg.idconvenio);
            EXCEPTION
               WHEN DUP_VAL_ON_INDEX THEN
                  vtraza := 50;

                  UPDATE estrtn_convenio
                     SET pretorno = reg.pretorno,
                         idconvenio = reg.idconvenio
                   WHERE sseguro = psseguro_est
                     AND nmovimi = pnmovimi_est
                     AND sperson = reg.sperson;
            END;
         END LOOP;

-- BUG24929:DRA:04/12/2012:Fi

         -- Bug 26638/161264 - 09/04/2014 - AMC
         FOR reg IN (SELECT sseguro, nriesgo, cgrup, csubgrup, cnivel, cversion, nmovimi,
                            finiefe, ctipgrup, cvalor1, impvalor1, cvalor2, impvalor2, cimpmin,
                            impmin, cimpmax, impmax, ffinefe, cniveldefecto
                       FROM bf_bonfransegcar
                      WHERE sseguro = psseguro
                        AND sproces = psproces
                        AND nmovimi = v_nmovlast) LOOP
            BEGIN
               INSERT INTO estbf_bonfranseg
                           (sseguro, nriesgo, cgrup, csubgrup, cnivel,
                            cversion, nmovimi, finiefe, ctipgrup,
                            cvalor1, impvalor1, cvalor2, impvalor2,
                            cimpmin, impmin, cimpmax, impmax, ffinefe,
                            cusualt, falta, cniveldefecto)
                    VALUES (reg.sseguro, reg.nriesgo, reg.cgrup, reg.csubgrup, reg.cnivel,
                            reg.cversion, reg.nmovimi, reg.finiefe, reg.ctipgrup,
                            reg.cvalor1, reg.impvalor1, reg.cvalor2, reg.impvalor2,
                            reg.cimpmin, reg.impmin, reg.cimpmax, reg.impmax, reg.ffinefe,
                            f_user, f_sysdate, reg.cniveldefecto);
            EXCEPTION
               WHEN DUP_VAL_ON_INDEX THEN
                  UPDATE estbf_bonfranseg
                     SET finiefe = reg.finiefe,
                         ctipgrup = reg.ctipgrup,
                         cvalor1 = reg.cvalor1,
                         impvalor1 = reg.impvalor1,
                         cvalor2 = reg.cvalor2,
                         impvalor2 = reg.impvalor2,
                         cimpmin = reg.cimpmin,
                         impmin = reg.impmin,
                         cimpmax = reg.cimpmax,
                         impmax = reg.impmax,
                         ffinefe = reg.ffinefe,
                         cniveldefecto = reg.cniveldefecto
                   WHERE sseguro = reg.sseguro
                     AND nriesgo = reg.nriesgo
                     AND cgrup = reg.cgrup
                     AND csubgrup = reg.csubgrup
                     AND cnivel = reg.cnivel
                     AND cversion = reg.cversion
                     AND nmovimi = reg.nmovimi;
            END;
         END LOOP;
      -- Fi  Bug 26638/161264 - 09/04/2014 - AMC

      ------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------
-------------------
-- TABLAS REALES --
-------------------
------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------
      ELSE
-- fin Bug 23940 - APD - 01/11/2012
-------------------
-- TABLAS REALES --
-------------------
         vtraza := 100;

         --Primero modificamos ffinefe de GARANSEG
         BEGIN
            UPDATE garanseg
               SET ffinefe = pdata
             WHERE sseguro = psseguro
               AND ffinefe IS NULL;
         EXCEPTION
            WHEN OTHERS THEN
               RETURN 101959;   --Error al modificar en GARANSEG
         END;

         vtraza := 110;
         -- Bug 10350 - 04/06/2009 - RSC - Detalle garant¿as (tarificaci¿n)
         v_num_err := pac_productos.f_get_sproduc(psseguro, v_sproduc);

         IF v_num_err <> 0 THEN
            RETURN 101959;
         END IF;

         -- Fin Bug 10350

         --Ini Bug.: 16919 - 03/01/2011 - ICV
         --Cogemos las garantias del ¿ltimo movimiento NO ANULADO.
         v_nmovlast := pnmovimi;
         vtraza := 120;

         SELECT MAX(m.nmovimi)
           INTO v_nmovlast
           FROM movseguro m, garanseg g
          WHERE m.sseguro = psseguro
            AND m.nmovimi < pnmovimi
            AND g.sseguro = m.sseguro
            AND g.nmovimi = m.nmovimi
            AND m.cmovseg NOT IN(6, 52);

         -- Bug 29665/177284 - 12/06/2014 - AMC

         --Fin Bug.: 16919
         vtraza := 130;

         --BUG 0026638: FAC LCOL - TEC - Cartera para Autos. (id 176-19)
         FOR reg IN (SELECT sseguro, nriesgo, nmovimi, cversion, ctipmat, cmatric, cuso,
                            csubuso, fmatric, nkilometros, cvehnue, ivehicu, npma, ntara,
                            ccolor, nbastid, nplazas, cgaraje, cusorem, cremolque, triesgo,
                            cpaisorigen, cmotor, cchasis, ivehinue, nkilometraje, ccilindraje,
                            cpintura, ccaja, ccampero, ctipcarroceria, cservicio, corigen,
                            ctransporte, codmotor, anyo, ciaant, ffinciant, cmodalidad, cpeso,
                            ctransmision, npuertas   --Bug 34371/199273 - 03/03/2015 - AMC
                       FROM autriesgoscar
                      WHERE sseguro = psseguro
                        AND sproces = psproces) LOOP
            BEGIN
               vtraza := 22;

               INSERT INTO autriesgos
                           (sseguro, nriesgo, nmovimi, cversion, ctipmat, cmatric, cuso,
                            csubuso, fmatric, nkilometros, cvehnue, ivehicu, npma, ntara,
                            ccolor, nbastid, nplazas, cgaraje, cusorem, cremolque, triesgo,
                            cpaisorigen, cmotor, cchasis, ivehinue, nkilometraje, ccilindraje,
                            cpintura, ccaja, ccampero, ctipcarroceria, cservicio, corigen,
                            ctransporte, codmotor, anyo, ciaant, ffinciant, cmodalidad, cpeso,
                            ctransmision, npuertas   --Bug 34371/199273 - 03/03/2015 - AMC
                                                  )
                  SELECT sseguro, nriesgo, pnmovimi, cversion, ctipmat, cmatric, cuso,
                         csubuso, fmatric, nkilometros, cvehnue, ivehicu, npma, ntara, ccolor,
                         nbastid, nplazas, cgaraje, cusorem, cremolque, triesgo, cpaisorigen,
                         cmotor, cchasis, ivehinue, nkilometraje, ccilindraje, cpintura,
                         ccaja, ccampero, ctipcarroceria, cservicio, corigen, ctransporte,
                         codmotor, anyo, ciaant, ffinciant, cmodalidad, cpeso, ctransmision,
                         npuertas   --Bug 34371/199273 - 03/03/2015 - AMC
                    FROM autriesgoscar
                   WHERE sseguro = psseguro
                     AND sproces = psproces
                     AND nriesgo = reg.nriesgo;
            EXCEPTION
               WHEN OTHERS THEN
                  RETURN 9905489;
            END;

            BEGIN
               vtraza := 24;

               INSERT INTO autconductores
                           (sseguro, nriesgo, nmovimi, norden, sperson, fnacimi, fcarnet,
                            csexo, npuntos, cdomici, cprincipal, exper_manual, exper_cexper,
                            exper_sinie, exper_sinie_manual   --Bug 26638 - 14/04/2014 - AMC
                                                           )
                  SELECT sseguro, nriesgo, pnmovimi, norden, sperson, fnacimi, fcarnet, csexo,
                         npuntos, cdomici, cprincipal, exper_manual, exper_cexper,
                         exper_sinie, exper_sinie_manual   --Bug 26638 - 14/04/2014 - AMC
                    FROM autconductorescar
                   WHERE sseguro = psseguro
                     AND sproces = psproces
                     AND nriesgo = reg.nriesgo;
            EXCEPTION
               WHEN OTHERS THEN
                  RETURN 9905492;
            END;

            BEGIN
               vtraza := 26;

               INSERT INTO autdisriesgos
                           (sseguro, nriesgo, nmovimi, cversion, cdispositivo, cpropdisp,
                            ivaldisp, finicontrato, ffincontrato, ncontrato, tdescdisp)
                  SELECT sseguro, nriesgo, pnmovimi, cversion, cdispositivo, cpropdisp,
                         ivaldisp, finicontrato, ffincontrato, ncontrato, tdescdisp
                    FROM autdisriesgoscar
                   WHERE sseguro = psseguro
                     AND sproces = psproces
                     AND nriesgo = reg.nriesgo;
            EXCEPTION
               WHEN OTHERS THEN
                  RETURN 9905491;
            END;

            BEGIN
               vtraza := 28;

               INSERT INTO autdetriesgos
                           (sseguro, nriesgo, nmovimi, cversion, caccesorio, ctipacc, fini,
                            ivalacc, tdesacc, casegurable)
                  SELECT sseguro, nriesgo, pnmovimi, cversion, caccesorio, ctipacc, fini,
                         ivalacc, tdesacc, casegurable
                    FROM autdetriesgoscar
                   WHERE sseguro = psseguro
                     AND sproces = psproces
                     AND nriesgo = reg.nriesgo;
            EXCEPTION
               WHEN OTHERS THEN
                  RETURN 9905490;
            END;
         END LOOP;

         --FIN BUG 0026638: FAC LCOL - TEC - Cartera para Autos. (id 176-19)
         vtraza := 138;

         -- Insertamos en GARANSEG los registros de GARANCAR
         -- A¿adimos los campos ICAPTOT y IPRITAR
         IF NVL(f_parproductos_v(v_sproduc, 'DETALLE_GARANT'), 0) = 1 THEN
            FOR regs IN (SELECT   sseguro, cgarant, nriesgo, sproces, SUM(irevali) irevali,
                                  SUM(icapital) icapital, SUM(iprianu) iprianu,
                                  SUM(irecarg) irecarg, SUM(ipritar) ipritar,
                                  SUM(idtocom) idtocom, SUM(itarrea) itarrea,

                                  -- Ini Bug 21907 - MDS - 03/05/2012
                                  SUM(idtotec) idtotec, SUM(ireccom) ireccom
                             -- Fin Bug 21907 - MDS - 03/05/2012
                         FROM     garancar
                            WHERE sseguro = psseguro
                              AND sproces = psproces
                              AND NVL(canulado, 0) = 0
                              AND cunica = 0
                         GROUP BY sseguro, cgarant, nriesgo, sproces
                         ORDER BY sseguro, cgarant, nriesgo, sproces) LOOP
               -- Copiamos tal cual el GARANSEG anterior
               vtraza := 140;

               BEGIN
                      -- FBL. 25/06/2014 MSV Bug 0028974
                  -- Ini Bug 21907 - MDS - 03/05/2012
                  INSERT INTO garanseg
                              (sseguro, cgarant, nriesgo, nmovimi, finiefe, norden, ctarifa,
                               icapital, precarg, iprianu, cformul, iextrap, ctipfra, ifranqu,
                               irecarg, idtocom, pdtocom, ipritar, crevali, prevali, irevali,
                               itarifa, itarrea, icaptot, ipritot, ftarifa, cderreg, feprev,
                               fpprev, percre, cref, cintref, pdif, pinttec, nparben, nbns,
                               tmgaran, cmatch, tdesmat, pintfin, crevalcar, pdtoint, idtoint,
                               ccampanya, nversio, nmovima, cageven, nlinea, nfactor, ctarman,
                               pdtotec, preccom, idtotec, ireccom, ipricom)
                     (SELECT sseguro, cgarant, nriesgo, pnmovimi, pdata, norden, ctarifa,
                             icapital, precarg, iprianu, cformul, iextrap, ctipfra, ifranqu,
                             irecarg, idtocom, pdtocom, ipritar, crevali, prevali, irevali,
                             itarifa, itarrea, icaptot, ipritot, ftarifa, cderreg, feprev,
                             fpprev, percre, cref, cintref, pdif, pinttec, nparben, nbns,
                             tmgaran, cmatch, tdesmat, pintfin, crevalcar, pdtoint, idtoint,
                             ccampanya, nversio, nmovima, cageven, nlinea, nfactor, ctarman,
                             pdtotec, preccom, idtotec, ireccom, ipricom
                        -- Fin Bug 21907 - MDS - 03/05/2012
                      FROM   garanseg
                       WHERE sseguro = psseguro
                         AND cgarant = regs.cgarant
                         AND nriesgo = regs.nriesgo
                         AND nmovimi = v_nmovlast);
               -- Fin Bug 21907 - MDS - 03/05/2012
                   -- Fin FBL. 25/06/2014 MSV Bug 0028974
                --AND nmovimi = pnmovimi - 1);
               EXCEPTION
                  WHEN OTHERS THEN
                     RETURN 101959;
               END;

               vtraza := 150;

               UPDATE garanseg
                  SET finiefe = pdata,
                      irevali = regs.irevali,
                      icapital = regs.icapital,
                      iprianu = regs.iprianu,
                      irecarg = regs.irecarg,
                      ipritar = regs.ipritar,
                      idtocom = regs.idtocom,
                      itarrea = regs.itarrea,
                      icaptot = regs.icapital,
                      -- ==> Detalle de Garant¿a: No Coaseguro
                      ipritot = regs.iprianu,
                                         -- ==> Detalle de Garant¿a: No Coaseguro
                      -- Ini Bug 21907 - MDS - 03/05/2012
                      idtotec = regs.idtotec,
                      ireccom = regs.ireccom
                -- Fin Bug 21907 - MDS - 03/05/2012
               WHERE  sseguro = psseguro
                  AND cgarant = regs.cgarant
                  AND nriesgo = regs.nriesgo
                  AND nmovimi = pnmovimi;

               vtraza := 160;

               BEGIN
                  INSERT INTO detgaranseg
                              (sseguro, cgarant, nriesgo, nmovimi, finiefe, ndetgar, fefecto,
                               fvencim, ndurcob, ctarifa, pinttec, ftarifa, crevali, prevali,
                               irevali, icapital, iprianu, precarg, irecarg, cparben,
                               cprepost, ffincob, ipritar, provmat0, fprovmat0, provmat1,
                               fprovmat1, pintmin, pdtocom, idtocom, ctarman, ipripur,
                               ipriinv, itarrea, cagente, cunica)
                     (SELECT sseguro, cgarant, nriesgo, pnmovimi, pdata, ndetgar, fefecto,
                             fvencim, ndurcob, ctarifa, pinttec, ftarifa, crevali, prevali,
                             irevali, icapital, iprianu, precarg, irecarg, cparben, cprepost,
                             ffincob, ipritar, provmat0, fprovmat0, provmat1, fprovmat1,
                             pintmin, pdtocom, idtocom, ctarman, ipripur, ipriinv, itarrea,
                             cageven, cunica
                        FROM garancar
                       WHERE sseguro = psseguro
                         AND sproces = psproces
                         AND cgarant = regs.cgarant
                         AND nriesgo = regs.nriesgo
                         AND NVL(canulado, 0) = 0);   --que no esten anuladas.
               EXCEPTION
                  WHEN OTHERS THEN
                     RETURN 101959;
               END;
            END LOOP;
         ELSE
            IF NVL(f_parproductos_v(v_sproduc, 'DETALLE_GARANT'), 0) = 2 THEN
               vtraza := 170;

               BEGIN
                  -- FBL. 25/06/2014 MSV Bug 0028974
                  INSERT INTO garanseg
                              (sseguro, cgarant, nriesgo, nmovimi, finiefe, norden, ctarifa,
                               icapital, precarg, iprianu, ffinefe, cformul, iextrap, ctipfra,
                               ifranqu, irecarg, idtocom, pdtocom, ipritar, crevali, prevali,
                               irevali, itarifa, itarrea, icaptot, ipritot, ftarifa, cderreg,
                               feprev, fpprev, percre, cref, cintref, pdif, pinttec, nparben,
                               nbns, tmgaran, cmatch, tdesmat, pintfin, crevalcar, pdtoint,
                               idtoint, ccampanya, nversio, nmovima, cageven, nlinea, nfactor,
                               ctarman, ipricom)
                     (SELECT sseguro, cgarant, nriesgo, pnmovimi, pdata, norden, NULL,
                             icapital, precarg, iprianu, ffinefe, cformul, iextrap, ctipfra,
                             ifranqu, irecarg, idtocom, pdtocom, ipritar, crevali, prevali,
                             irevali, itarifa, itarrea, icaptot, ipritot, ftarifa, cderreg,
                             feprev, fpprev, percre, cref, cintref, pdif, pinttec, nparben,
                             nbns, tmgaran, cmatch, tdesmat, pintfin, 1, pdtoint, idtoint,
                             ccampanya, nversio, nmovima, cageven, nlinea, nfactor, ctarman,
                             ipricom
                        FROM garancar
                       WHERE sseguro = psseguro
                         AND sproces = psproces
                         AND ndetgar = 0   -- 29943 - 03/06/2014 - JTT
                         AND NVL(canulado, 0) = 0);   --que no esten anuladas.
               -- Fin FBL. 25/06/2014 MSV Bug 0028974
               EXCEPTION
                  WHEN OTHERS THEN
                     RETURN 101959;
               END;

               vtraza := 180;

               BEGIN
                  INSERT INTO detgaranseg
                              (sseguro, cgarant, nriesgo, nmovimi, finiefe, ndetgar, fefecto,
                               fvencim, ndurcob, ctarifa, pinttec, ftarifa, crevali, prevali,
                               irevali, icapital, iprianu, precarg, irecarg, cparben,
                               cprepost, ffincob, ipritar, provmat0, fprovmat0, provmat1,
                               fprovmat1, pintmin, pdtocom, idtocom, ctarman, ipripur,
                               ipriinv, itarrea, cagente, cunica)
                     (SELECT sseguro, cgarant, nriesgo, pnmovimi, pdata, ndetgar, fefecto,
                             fvencim, ndurcob, ctarifa, pinttec, ftarifa, crevali, prevali,
                             irevali, icapital, iprianu, precarg, irecarg, cparben, cprepost,
                             ffincob, ipritar, provmat0, fprovmat0, provmat1, fprovmat1,
                             pintmin, pdtocom, idtocom, ctarman, ipripur, ipriinv, itarrea,
                             cageven, cunica
                        FROM garancar
                       WHERE sseguro = psseguro
                         AND sproces = psproces
                         AND NVL(canulado, 0) = 0);   --que no esten anuladas.
               EXCEPTION
                  WHEN OTHERS THEN
                     RETURN 101959;
               END;
            ELSE
               vtraza := 190;

               BEGIN
                  -- FBL. 25/06/2014 MSV Bug 0028974
                  INSERT INTO garanseg
                              (sseguro, cgarant, nriesgo, nmovimi, finiefe, norden, ctarifa,
                               icapital, precarg, iprianu, ffinefe, cformul, iextrap, ctipfra,
                               ifranqu, irecarg, idtocom, pdtocom, ipritar, crevali, prevali,
                               irevali, itarifa, itarrea, icaptot, ipritot, ftarifa, cderreg,
                               feprev, fpprev, percre, cref, cintref, pdif, pinttec, nparben,
                               nbns, tmgaran, cmatch, tdesmat, pintfin, crevalcar, pdtoint,
                               idtoint, ccampanya, nversio, nmovima, cageven, nlinea, nfactor,
                               ctarman, ipricom, pdtotec, preccom, idtotec, ireccom)
                     (SELECT sseguro, cgarant, nriesgo, pnmovimi, pdata, norden, ctarifa,
                             icapital, precarg, iprianu, ffinefe, cformul, iextrap, ctipfra,
                             ifranqu, irecarg, idtocom, pdtocom, ipritar, crevali, prevali,
                             irevali, itarifa, itarrea, icaptot, ipritot, ftarifa, cderreg,
                             feprev, fpprev, percre, cref, cintref, pdif, pinttec, nparben,
                             nbns, tmgaran, cmatch, tdesmat, pintfin, 1, pdtoint, idtoint,
                             ccampanya, nversio, nmovima, cageven, nlinea, nfactor, ctarman,
                             ipricom, pdtotec, preccom, idtotec, ireccom
                        FROM garancar
                       WHERE sseguro = psseguro
                         AND sproces = psproces
                         AND NVL(canulado, 0) = 0);   --que no esten anuladas.

                  INSERT INTO garansegcom
                              (sseguro, nriesgo, cgarant, nmovimi, finiefe, cmodcom, pcomisi,
                               ninialt, nfinalt, pcomisicua, falta, cusualt, fmodifi, cusumod,
                               cageven, ipricom)
                     (SELECT sseguro, nriesgo, cgarant, pnmovimi, pdata, cmodcom, pcomisi,
                             ninialt, nfinalt, pcomisicua, falta, cusualt, fmodifi, cusumod,
                             cageven,
                                     --rdd 27/11/2014
                                     ipricom
                        FROM garancarcom
                       WHERE sseguro = psseguro
                         AND sproces = psproces);
               -- Fin FBL. 25/06/2014 MSV Bug 0028974
               EXCEPTION
                  WHEN OTHERS THEN
                     RETURN 101959;
               END;
            END IF;
         END IF;

         vtraza := 200;

         -- BUG14172:DRA:27/04/2010:Inici
         -- Insertamos en pregunseg los registros de preguncar
         BEGIN
            INSERT INTO pregunseg
                        (sseguro, nmovimi, nriesgo, cpregun, crespue, trespue)
               SELECT pp.sseguro, pnmovimi, pp.nriesgo, pp.cpregun, pp.crespue, pp.trespue
                 FROM preguncar pp, codipregun cp
                WHERE pp.sseguro = psseguro
                  AND pp.sproces = psproces
                  AND cp.cpregun = pp.cpregun
                  AND((cp.ctippre IN(4, 5)
                       AND pp.trespue IS NOT NULL)
                      OR pp.crespue IS NOT NULL);
         EXCEPTION
            WHEN OTHERS THEN
               RETURN 110174;   --error al insertar en pregunseg
         END;

         vtraza := 210;

         -- Insertamos en pregunsegtab los registros de preguncartab
         BEGIN
            INSERT INTO pregunsegtab
                        (sseguro, nmovimi, nriesgo, cpregun, nlinea, ccolumna, tvalor, fvalor,
                         nvalor)
               SELECT pp.sseguro, pnmovimi, pp.nriesgo, pp.cpregun, pp.nlinea, pp.ccolumna,
                      pp.tvalor, pp.fvalor, pp.nvalor
                 FROM preguncartab pp, codipregun cp
                WHERE pp.sseguro = psseguro
                  AND pp.sproces = psproces
                  AND cp.cpregun = pp.cpregun
                  AND(cp.ctippre IN(7)
                      AND(pp.tvalor IS NOT NULL
                          OR pp.fvalor IS NOT NULL
                          OR pp.nvalor IS NOT NULL));
         EXCEPTION
            WHEN OTHERS THEN
               RETURN 110174;   --error al insertar en pregunseg
         END;

         vtraza := 220;

         -- Insertamos en pregungaranseg los registros de pregungarancar
         BEGIN
            INSERT INTO pregungaranseg
                        (sseguro, nriesgo, cgarant, nmovimi, cpregun, crespue, finiefe,
                         nmovima, trespue)
               SELECT pp.sseguro, pp.nriesgo, pp.cgarant, pnmovimi, pp.cpregun, pp.crespue,
                      pdata, pp.nmovima, pp.trespue
                 FROM pregungarancar pp, codipregun cp
                WHERE pp.sseguro = psseguro
                  AND pp.sproces = psproces
                  AND cp.cpregun = pp.cpregun
                  AND((cp.ctippre IN(4, 5)
                       AND pp.trespue IS NOT NULL)
                      OR pp.crespue IS NOT NULL);
         EXCEPTION
            WHEN OTHERS THEN
               RETURN 111795;   -- Error al insertar en PREGUNGARANSEG
         END;

         vtraza := 230;

         -- Insertamos en pregungaranseg los registros de pregungarancartab
         BEGIN
            INSERT INTO pregungaransegtab
                        (sseguro, nriesgo, cgarant, nmovimi, cpregun, finiefe, nmovima,
                         nlinea, ccolumna, tvalor, fvalor, nvalor)
               SELECT pp.sseguro, pp.nriesgo, pp.cgarant, pnmovimi, pp.cpregun, pdata,
                      pp.nmovima, pp.nlinea, pp.ccolumna, pp.tvalor, pp.fvalor, pp.nvalor
                 FROM pregungarancartab pp, codipregun cp
                WHERE pp.sseguro = psseguro
                  AND pp.sproces = psproces
                  AND cp.cpregun = pp.cpregun
                  AND(cp.ctippre IN(7)
                      AND(pp.tvalor IS NOT NULL
                          OR pp.fvalor IS NOT NULL
                          OR pp.nvalor IS NOT NULL));
         EXCEPTION
            WHEN OTHERS THEN
               RETURN 111795;   -- Error al insertar en PREGUNGARANSEG
         END;

         vtraza := 240;

         -- Insertamos en pregunpolseg los registros de pregunpolcar
         BEGIN
            INSERT INTO pregunpolseg
                        (sseguro, cpregun, crespue, nmovimi, trespue)
               SELECT pp.sseguro, pp.cpregun, pp.crespue, pnmovimi, pp.trespue
                 FROM pregunpolcar pp, codipregun cp
                WHERE pp.sseguro = psseguro
                  AND pp.sproces = psproces
                  AND cp.cpregun = pp.cpregun
                  AND((cp.ctippre IN(4, 5)
                       AND pp.trespue IS NOT NULL)
                      OR pp.crespue IS NOT NULL);
         EXCEPTION
            WHEN OTHERS THEN
               RETURN 111795;   -- Error al insertar en pregunpolcar
         END;

         vtraza := 250;

         -- Insertamos en pregunpolseg los registros de pregunpolcartab
         BEGIN
            INSERT INTO pregunpolsegtab
                        (sseguro, cpregun, nmovimi, nlinea, ccolumna, tvalor, fvalor, nvalor)
               SELECT pp.sseguro, pp.cpregun, pnmovimi, pp.nlinea, pp.ccolumna, pp.tvalor,
                      pp.fvalor, pp.nvalor
                 FROM pregunpolcartab pp, codipregun cp
                WHERE pp.sseguro = psseguro
                  AND pp.sproces = psproces
                  AND cp.cpregun = pp.cpregun
                  AND(cp.ctippre IN(7)
                      AND(pp.tvalor IS NOT NULL
                          OR pp.fvalor IS NOT NULL
                          OR pp.nvalor IS NOT NULL));
         EXCEPTION
            WHEN OTHERS THEN
               RETURN 111795;   -- Error al insertar en pregunpolsegtab
         END;

         vtraza := 260;

         -- notificacion de baja
         IF f_parinstalacion_n('NOTIFIBAJA') = 1 THEN
            IF NVL(f_parproductos_v(v_sproduc, 'DETALLE_GARANT'), 0) = 1 THEN
               FOR regs IN (SELECT   sseguro, cgarant, nriesgo, sproces
                                FROM garancar
                               WHERE sseguro = psseguro
                                 AND sproces = psproces
                            GROUP BY sseguro, cgarant, nriesgo, sproces) LOOP
                  vtraza := 270;

                  -- Contador de detalles anulados
                  SELECT COUNT(*)
                    INTO v_contd1
                    FROM garancar
                   WHERE sseguro = psseguro
                     AND sproces = psproces
                     AND cgarant = regs.cgarant
                     AND nriesgo = regs.nriesgo
                     AND NVL(canulado, 0) = 1;

                  vtraza := 280;

                  -- Contador de detalles total
                  SELECT COUNT(*)
                    INTO v_contd2
                    FROM garancar
                   WHERE sseguro = psseguro
                     AND sproces = psproces
                     AND cgarant = regs.cgarant
                     AND nriesgo = regs.nriesgo;

                  IF v_contd1 = v_contd2 THEN
                     vtraza := 290;

                     SELECT finiefe, nmovima
                       INTO v_finiefe, v_nmovima
                       FROM garanseg
                      WHERE sseguro = psseguro
                        AND cgarant = regs.cgarant
                        AND nriesgo = regs.nriesgo
                        AND nmovimi = v_nmovlast;

                     --AND nmovimi = pnmovimi - 1;
                     vtraza := 300;

                     BEGIN
                        INSERT INTO notibajagar
                                    (sseguro, nriesgo, cgarant, nmovimi,
                                     finiefe, nmovima, nmovimb, cnotibaja, cmotmov, fanulac,
                                     crehab, nmovrehab)
                             VALUES (psseguro, regs.nriesgo, regs.cgarant, v_nmovlast,   --pnmovimi - 1,
                                     v_finiefe, v_nmovima, pnmovimi, 4, 403, pdata,
                                     NULL, NULL);
                     EXCEPTION
                        WHEN OTHERS THEN
                           RETURN 111915;
                     END;
                  END IF;
               END LOOP;
            ELSE
               vtraza := 310;

               BEGIN
                  INSERT INTO notibajagar
                              (sseguro, nriesgo, cgarant, nmovimi, finiefe, nmovima, nmovimb,
                               cnotibaja, cmotmov, fanulac, crehab, nmovrehab)
                     SELECT psseguro, nriesgo, cgarant, nmovi_ant, finiefe, nmovima, pnmovimi,
                            4, 403, pdata, NULL, NULL
                       FROM garancar
                      WHERE sseguro = psseguro
                        AND NVL(canulado, 0) = 1;
               EXCEPTION
                  WHEN OTHERS THEN
                     --DBMS_OUTPUT.put_line (SQLERRM);
                     RETURN 111915;
               END;
            END IF;
         END IF;

         vtraza := 320;

         -- gestion de tarjetas sanitarias ALN
         IF f_parinstalacion_t('TARJET_ALN') = 'SI' THEN
            sentencia :=
               'begin  :num_err := pac_tarjetcard.f_genera_alta(:psseguro ,F_USER, NULL); end;';

            EXECUTE IMMEDIATE sentencia
                        USING OUT num_err, IN psseguro;

            IF num_err <> 0 THEN
               RETURN 112401;
            END IF;
         END IF;

         vtraza := 330;

         -- Bug 21121 - APD - 14/03/2012
         -- Insertamos en detprimas los registros de tmp_detprimas
         BEGIN
            INSERT INTO detprimas
                        (sseguro, nriesgo, cgarant, nmovimi, finiefe, ccampo, cconcep, norden,
                         iconcep, iconcep2)
               SELECT sseguro, nriesgo, cgarant, pnmovimi, pdata, ccampo, cconcep, norden,
                      iconcep, iconcep2
                 FROM tmp_detprimas
                WHERE sseguro = psseguro
                  AND sproces = psproces;
         EXCEPTION
            WHEN OTHERS THEN
               RETURN 9903444;   -- Error al insertar en la tabla DETPRIMAS
         END;

         vtraza := 331;

         -- Bug 26638/161264 - 09/04/2014 - AMC
         FOR reg IN (SELECT sseguro, nriesgo, cgrup, csubgrup, cnivel, cversion, nmovimi,
                            finiefe, ctipgrup, cvalor1, impvalor1, cvalor2, impvalor2, cimpmin,
                            impmin, cimpmax, impmax, ffinefe, cniveldefecto
                       FROM bf_bonfransegcar
                      WHERE sseguro = psseguro
                        AND sproces = psproces
                        AND nmovimi = pnmovimi) LOOP
            BEGIN
               INSERT INTO bf_bonfranseg
                           (sseguro, nriesgo, cgrup, csubgrup, cnivel,
                            cversion, nmovimi, finiefe, ctipgrup,
                            cvalor1, impvalor1, cvalor2, impvalor2,
                            cimpmin, impmin, cimpmax, impmax, ffinefe,
                            cusualt, falta, cniveldefecto)
                    VALUES (reg.sseguro, reg.nriesgo, reg.cgrup, reg.csubgrup, reg.cnivel,
                            reg.cversion, reg.nmovimi, reg.finiefe, reg.ctipgrup,
                            reg.cvalor1, reg.impvalor1, reg.cvalor2, reg.impvalor2,
                            reg.cimpmin, reg.impmin, reg.cimpmax, reg.impmax, reg.ffinefe,
                            f_user, f_sysdate, reg.cniveldefecto);
            EXCEPTION
               WHEN DUP_VAL_ON_INDEX THEN
                  UPDATE bf_bonfranseg
                     SET finiefe = reg.finiefe,
                         ctipgrup = reg.ctipgrup,
                         cvalor1 = reg.cvalor1,
                         impvalor1 = reg.impvalor1,
                         cvalor2 = reg.cvalor2,
                         impvalor2 = reg.impvalor2,
                         cimpmin = reg.cimpmin,
                         impmin = reg.impmin,
                         cimpmax = reg.cimpmax,
                         impmax = reg.impmax,
                         ffinefe = reg.ffinefe,
                         cniveldefecto = reg.cniveldefecto
                   WHERE sseguro = reg.sseguro
                     AND nriesgo = reg.nriesgo
                     AND cgrup = reg.cgrup
                     AND csubgrup = reg.csubgrup
                     AND cnivel = reg.cnivel
                     AND cversion = reg.cversion
                     AND nmovimi = reg.nmovimi;
            END;
         END LOOP;

         -- Fi  Bug 26638/161264 - 09/04/2014 - AMC

         -- BUG 34505 - FAL - 09/06/2015
         IF pac_md_convenios_emp.f_es_productoconvenios(v_sproduc) = 1 THEN
            BEGIN
               INSERT INTO cnv_conv_emp_seg
                           (sseguro, nmovimi, idversion, falta, cusualt)
                  (SELECT sseguro, pnmovimi, idversion, f_sysdate, f_user
                     FROM cnv_conv_emp_seg
                    WHERE sseguro = psseguro
                      AND nmovimi = v_nmovlast);
            EXCEPTION
               WHEN OTHERS THEN
                  RETURN 9908151;
            END;
         END IF;

-- FI BUG 34505 - FAL - 09/06/2015
         vtraza := 340;

         DELETE      garancarcom   --JRH MSV - 3
               WHERE sseguro = psseguro
                 AND sproces = psproces;

         -- fin Bug 21121 - APD - 14/03/2012
         -- deletes de las tablas temporales
         DELETE      preguncar
               WHERE sseguro = psseguro
                 AND sproces = psproces;

         vtraza := 350;

         DELETE      pregungarancar
               WHERE sseguro = psseguro
                 AND sproces = psproces;

         vtraza := 360;

         DELETE      pregunpolcar
               WHERE sseguro = psseguro
                 AND sproces = psproces;

         vtraza := 370;

         -- Bug 21121 - APD - 14/03/2012
         DELETE      tmp_detprimas
               WHERE sseguro = psseguro
                 AND sproces = psproces;

         --BUG 0026638: FAC LCOL - TEC - Cartera para Autos. (id 176-19)
         vtraza := 380;

         -- BUG 0026638: FAC LCOL - TEC - Cartera para Autos. (id 176-19)
         DELETE FROM autdisriesgoscar
               WHERE sseguro = psseguro
                 AND sproces = psproces;

         vtraza := 390;

         DELETE FROM autdetriesgoscar
               WHERE sseguro = psseguro
                 AND sproces = psproces;

         vtraza := 400;

         DELETE FROM autconductorescar
               WHERE sseguro = psseguro
                 AND sproces = psproces;

         vtraza := 410;

         DELETE FROM autriesgoscar
               WHERE sseguro = psseguro
                 AND sproces = psproces;

         -- Bug 26638/161264 - 09/04/2014 - AMC
         vtraza := 411;

         DELETE FROM bf_bonfransegcar
               WHERE sseguro = psseguro
                 AND sproces = psproces;

--

         -- fin Bug 21121 - APD - 14/03/2012
         -- Bug 23183/126831 - 23/10/2012 - AMC
         -- Duplicamos el cuadro de coaseguro
         BEGIN
            INSERT INTO coacuadro
                        (sseguro, ncuacoa, finicoa, ffincoa, ploccoa, fcuacoa, ccompan,
                         npoliza)
               SELECT sseguro, pnmovimi, finicoa, ffincoa, ploccoa, fcuacoa, ccompan, npoliza
                 FROM coacuadro
                WHERE sseguro = psseguro
                  AND ncuacoa = v_nmovlast;
         EXCEPTION
            WHEN OTHERS THEN
               RETURN 9904400;   -- Error al insertar en coacuadro
         END;

         vtraza := 390;

         BEGIN
            INSERT INTO coacedido
                        (sseguro, ncuacoa, ccompan, pcescoa, pcomcoa, pcomcon, pcomgas,
                         pcesion)
               SELECT sseguro, pnmovimi, ccompan, pcescoa, pcomcoa, pcomcon, pcomgas, pcesion
                 FROM coacedido
                WHERE sseguro = psseguro
                  AND ncuacoa = v_nmovlast;
         EXCEPTION
            WHEN OTHERS THEN
               RETURN 9904401;   -- Error al insertar en coacedido
         END;

         vtraza := 400;

         UPDATE seguros
            SET ncuacoa = pnmovimi
          WHERE sseguro = psseguro;

         -- Fi Bug 23183/126831 - 23/10/2012 - AMC

         -- BUG24929:DRA:04/12/2012:Inici
         vtraza := 410;

         INSERT INTO age_corretaje
                     (sseguro, cagente, nmovimi, nordage, pcomisi, ppartici, islider)
            SELECT sseguro, cagente, pnmovimi, nordage, pcomisi, ppartici, islider
              FROM age_corretaje
             WHERE sseguro = psseguro
               AND nmovimi = v_nmovlast;

         -- BUG24929:DRA:04/12/2012:Fi
            --A¿adir retorno
         INSERT INTO rtn_convenio
                     (sseguro, sperson, nmovimi, pretorno, idconvenio)
            SELECT sseguro, sperson, pnmovimi, pretorno, idconvenio
              FROM rtn_convenio
             WHERE sseguro = psseguro
               AND nmovimi = v_nmovlast;
      END IF;   -- Bug 23940 - APD - 01/11/2012

      RETURN 0;
   EXCEPTION
      WHEN OTHERS THEN
         p_tab_error(f_sysdate, f_user, 'PAC_DINCARTERA.f_traspasgar', vtraza,
                     f_axis_literales(105419), SQLERRM);
         RETURN 105419;
   END f_traspasgar;

------------------------------------------------------------------------------------
   FUNCTION f_excepcionsegu(psseguro IN NUMBER, pcconcep IN NUMBER, pcvalor OUT NUMBER)
      RETURN NUMBER IS
   BEGIN
      -- Obtenim el valor per el concepte
      SELECT cvalor
        INTO pcvalor
        FROM excepcionsegu
       WHERE sseguro = psseguro
         AND cconcep = pcconcep;

      RETURN 0;
   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         pcvalor := NULL;
         RETURN 0;
      WHEN OTHERS THEN
         RETURN 110536;
   END f_excepcionsegu;

   PROCEDURE proceso_batch_cierre(
      pmodo IN NUMBER,
      pcempres IN NUMBER,
      pmoneda IN NUMBER,
      pcidioma IN NUMBER,
      pfperini IN DATE,
      pfperfin IN DATE,
      pfcierre IN DATE,
      pcerror OUT NUMBER,
      psproces OUT NUMBER,
      pfproces OUT DATE) IS
      --
      --    Proceso que lanzar¿ el proceso de cartera
      --
      vparam         VARCHAR2(200)
         := 'pmodo=' || pmodo || ' pcempres=' || pcempres || ' pmoneda=' || pmoneda
            || ' pcidioma=' || pcidioma || ' pfperini=' || pfperini || ' pfperfin='
            || pfperfin || ' pfcierre=' || pfcierre;
      vobject        VARCHAR2(200) := 'PAC_DINCARTERA.PROCESO_BATCH_CIERRE';
      num_err        NUMBER := 0;
      text_error     VARCHAR2(500) := 0;
      pnnumlin       NUMBER;
      ptexto         VARCHAR2(200);
      conta_err      NUMBER := 0;
      conta_be       NUMBER;
      v_titulo       VARCHAR2(50);
      ntraza         NUMBER;
   BEGIN
      /* BUG 8339 :
                                                                    PROC PROCESO_BATCH_CIERRE
       --Se debe modificar este proceso para que para inicializar la cartera llame a la f_inicializar_cartera,
        substituyendo el c¿digo .
       'El else +endif ?correspondiente al if_num_err=0   se debe eliminar
       En el caso de que el modo sea 1 no debe llamar al proceso de la cartera.
      IF pmodo = 1 THEN
                v_titulo := 'Previo de Cartera de '||pfperini;
             ELSE
                v_titulo := 'Cartera de '||pfperini;
             END IF;
               ntraza := 2;
             --Insertamos en la tabla PROCESOSCAB el registro identificativo de proceso -----
             num_err := F_Procesini(F_User,pcempres,'CIERRE_CARTERA', v_titulo, psproces);
             COMMIT;
             IF num_err <> 0 THEN
                pcerror := 1;
                conta_err := conta_err + 1;
                P_Literal2(num_err,pcidioma,texto);
                pnnumlin := NULL;
                num_err := F_Proceslin(psproces,SUBSTR('Cartera: '||texto||' '||text_error,1,120),0,pnnumlin);
                COMMIT;
      END IF
      */
      -- bug 8339 Inicializar los parametros de salida
      pcerror := 0;
      psproces := NULL;
      pfproces := f_sysdate;

      --

      -- Control parametros entrada
      IF pmodo IS NULL
         OR pcempres IS NULL
         OR pmoneda IS NULL
         OR pcidioma IS NULL
         OR pfperini IS NULL
         OR pfperfin IS NULL
         OR pfcierre IS NULL THEN
         p_tab_error(f_sysdate, f_user, vobject, ntraza,
                     ' Faltan parametros por informar: ' || vparam, SQLERRM);
         pcerror := 140974;   --Faltan parametros por informar
      END IF;

      IF pcerror = 0 THEN
         ntraza := 1;

         -- bug 8339 : En el caso de que el modo sea 1 no debe llamar al proceso de la cartera.
         IF pmodo = 1 THEN
            v_titulo := 'Previo de Cartera de ' || pfperini;
            ntraza := 2;
            -- BUG 8339
            ptexto := 'CIERRE_PREVIO_CARTERA';
            num_err := pac_dincartera.f_inicializa_cartera(pmodo, pfperini, pcempres, ptexto,
                                                           pcidioma, psproces);
            ntraza := 3;
            pcerror := 0;

            BEGIN
               -- JLB - 17/10/2013 -- bloqueo de la cartera
               -- hace commit, no llama al pac_dincartera.f_inserta_carteraaux
               INSERT INTO carteraaux
                           (sproces, cramo, cmodali, ctipseg, ccolect, cbloqueo, fcartera)
                  (SELECT psproces, p.cramo, p.cmodali, p.ctipseg, p.ccolect, 0, f_sysdate
                     FROM productos p, codiram c
                    WHERE c.cempres = pcempres
                      AND p.cramo = c.cramo);

               COMMIT;
            EXCEPTION
               WHEN OTHERS THEN
                  p_tab_error(f_sysdate, f_user, vobject, ntraza,
                              'when others del insert =' || pfperini, SQLERRM);
            END;

            ntraza := 4;
            pac_dincartera.previ_cartera_tar(pcempres, TO_CHAR(pfperini, 'mm'),
                                             TO_CHAR(pfperini, 'yyyy'), NULL, NULL, pcidioma,
                                             psproces, conta_be, conta_err);
            ntraza := 6;
            num_err := f_procesfin(psproces, conta_err);
            pfproces := f_sysdate;
            COMMIT;
         ELSE
            --*** v_titulo := 'Cartera de '||pfperini;
            ntraza := 2;
            -- BUG 8339
            ptexto := 'CIERRE_CARTERA';
            num_err := pac_dincartera.f_inicializa_cartera(pmodo, pfperini, pcempres, ptexto,
                                                           pcidioma, psproces);
            ntraza := 3;
            pcerror := 0;

            BEGIN
               -- JLB - 17/10/2013 -- bloqueo de la cartera
               -- hace commit, no llama al pac_dincartera.f_inserta_carteraaux
               INSERT INTO carteraaux
                           (sproces, cramo, cmodali, ctipseg, ccolect, cbloqueo, fcartera)
                  (SELECT psproces, p.cramo, p.cmodali, p.ctipseg, p.ccolect, 1, f_sysdate
                     FROM productos p, codiram c
                    WHERE c.cempres = pcempres
                      AND p.cramo = c.cramo);

               COMMIT;
            EXCEPTION
               WHEN OTHERS THEN
                  p_tab_error(f_sysdate, f_user, vobject, ntraza,
                              'when others del insert =' || pfperini, SQLERRM);
            END;

            -- JLB - 17/10/2013 -- reviso si la cartera se puede llamar
            FOR reg IN (SELECT cramo, cmodali, ctipseg, ccolect, cactivi, npoliza, ncertif
                          FROM carteraaux
                         WHERE sproces = psproces
                           AND cbloqueo = 1) LOOP
               num_err := f_cartera_bloqueada(psproces, reg.cramo, reg.cmodali, reg.ctipseg,
                                              reg.ccolect, reg.cactivi, reg.npoliza,
                                              reg.ncertif);

               IF num_err <> 0 THEN   -- si existen carteras bloqueadas
                  conta_err := conta_err + 1;
                  pnnumlin := NULL;
                  num_err := f_proceslin(psproces,
                                         SUBSTR('Cartera: Cartera bloqueada ' || reg.cramo
                                                || '-' || reg.cmodali || '-' || reg.ctipseg
                                                || '-' || reg.ccolect || '-' || reg.cactivi
                                                || '-' || reg.npoliza || '-' || reg.ncertif,
                                                1, 120),
                                         0, pnnumlin);
                  EXIT;
               END IF;
            END LOOP;

            IF conta_err = 0 THEN
               -- si ha habido algun error al verificar  la cartera no la ejeuto
                 -- JLB - 17/10/2013-- reviso si la cartera se pi
               ntraza := 4;
               num_err := pac_dincartera.cartera_producte(pcempres, psproces, psproces,
                                                          TO_CHAR(pfperini, 'mm'),
                                                          TO_CHAR(pfperini, 'yyyy'), pcidioma,
                                                          pmoneda, pfperini, conta_be,
                                                          conta_err, NULL, NULL, NULL);
               ntraza := 5;

               IF num_err <> 0 THEN
                  conta_err := conta_err + 1;
                  pnnumlin := NULL;
                  num_err :=
                     f_proceslin(psproces,
                                 SUBSTR('Cartera: Proceso no finalizado correctamente', 1,
                                        120),
                                 0, pnnumlin);
               END IF;
            -- JLB - I - 17/10/2013 -- bloqueo cartera
            END IF;   -- si ha pasado la validaci¿n de bloqueo de cartera

            -- JLB - F - 17/10/2013 --bloqueo cartera
               -- END IF;
            ntraza := 6;
            num_err := f_procesfin(psproces, conta_err);
            pfproces := f_sysdate;
            COMMIT;
         END IF;
      END IF;   --pcerror <>0

      -- JLB - I - 17/10/2013 -- bloqueo cartera
       --delete carteraaux where sproces = psproces;
      num_err := pac_dincartera.f_delete_carteraaux(psproces);
   --- JLB - I - 17/10/2013 -- bloqueo cartera
   EXCEPTION
      WHEN OTHERS THEN
         -- JLB - I - 17/10/2013 -- bloqueo cartera
         num_err := pac_dincartera.f_delete_carteraaux(psproces);
         --- JLB - I - 17/10/2013 -- bloqueo cartera
            --***ROLLBACK;
         p_tab_error(f_sysdate, f_user, vobject, ntraza, vparam, SQLERRM);
         pcerror := 1;
   END proceso_batch_cierre;

   /******************************************************************************
                                                                                               BUG 8339 :  03/12/2008
     0008339: IAX - Desarrollo PL Renovaci¿n de Cartera
     Se ha desarrollar la parte PL del an¿lisis de Renovaci¿n de Cartera
   *******************************************************************************/

   /*******************************************************************************
                                 FUNCION F_INSERT_TMP_CARTERAUX
   Funci¿n que insertar¿ en la tabla temporal los productos seleccionados para el
   proceso de cartera/previo de cartera.
   Par¿metros:
    Entrada :
       Pcempres  NUMBER
       Psprocar  NUMBER
       Psproduc  NUMBER
       Pseleccio NUMBER
    Retorna: un NUMBER con el id del error.
   ********************************************************************************/
   FUNCTION f_insert_tmp_carteraux(
      pcempres IN NUMBER,
      psprocar IN NUMBER,
      psproduc IN NUMBER,
      pseleccio IN NUMBER)
      RETURN NUMBER IS
      vpasexec       NUMBER(8) := 1;
      vparam         VARCHAR2(200)
         := 'Pcempres=' || pcempres || ' Psprocar=' || psprocar || ' Psproduc=' || psproduc
            || ' Pseleccio=' || pseleccio;
      vobject        VARCHAR2(200) := 'PAC_DINCARTERA.F_INSERT_TMP_CARTERAUX';
   BEGIN
      -- Control parametros entrada
      IF pcempres IS NULL
         OR psprocar IS NULL
         OR psproduc IS NULL
         OR pseleccio IS NULL THEN
         RETURN 140974;   --Faltan parametros por informar
      END IF;

      -- Funci¿n que debe realizar un insert en la tabla tmp_carteraux, con la informaci¿n recibida.
      INSERT INTO tmp_carteraux
                  (sprocar, sproduc, cestado)
           VALUES (psprocar, psproduc, pseleccio);

      vpasexec := 2;
      RETURN 0;
   EXCEPTION
      --En el caso de existir el registro debe actualizar  el campo selecci¿n.
      WHEN DUP_VAL_ON_INDEX THEN
         BEGIN
            UPDATE tmp_carteraux
               SET cestado = pseleccio
             WHERE sprocar = psprocar
               AND sproduc = psproduc;

            vpasexec := 3;
            RETURN 0;
         EXCEPTION
            WHEN OTHERS THEN
               p_tab_error(f_sysdate, f_user, vobject, vpasexec, vparam, SQLERRM);
               RETURN 9000691;
         END;
      WHEN OTHERS THEN
         p_tab_error(f_sysdate, f_user, vobject, vpasexec, vparam, SQLERRM);
         RETURN 9000690;
   END f_insert_tmp_carteraux;

   /*******************************************************************************
                                                               FUNTION F_GET_PRODCARTERA
    Funci¿n que retornar¿ los productos que cumplen las condiciones de b¿squeda seg¿n los par¿metros informados.
    Par¿metros:
     Entrada :
     Pcempres  NUMBER  : Empresa
     Pcramo    NUMBER  : Ramo
     Psproduc  NUMBER  :  ID. Producto
   Esta  funci¿n deber¿ seleccionar aquellos productos que pasan cartera, para ello se debe hacer una select en prodcartera
     para la empresa y el ramo seleccionado.
   Con los registros llenar¿ un ref_cursor con las siguientes columnas.
   ? Cempres: c¿digo de la empresa
   ? Sproduc : c¿digo del producto
   ? Tproduc : descripci¿n del producto, que se obtendr¿ mediante el la funci¿n f_desproducto.
    Retorna : ref_cursor.
   ********************************************************************************/
   FUNCTION f_get_prodcartera(
      pcempres IN NUMBER,
      pcramo IN NUMBER,
      psproduc IN NUMBER,
      psprocar IN NUMBER,
      --Ini Bug 27539 --ECP--04/07/2013
      pmodo IN VARCHAR,
      --Fin Bug 27539 --ECP--04/07/2013
      pcidioma NUMBER,
      psquery OUT VARCHAR2)
      RETURN NUMBER IS
      vumerr         NUMBER;
      vpasexec       NUMBER(8) := 1;
      vparam         VARCHAR2(200)
                := 'Pcempres=' || pcempres || ' Pcramo=' || pcramo || ' Psproduc=' || psproduc;
      vobject        VARCHAR2(200) := 'PAC_DINCARTERA.F_GET_PRODCARTERA';
      vctipage       NUMBER;
   BEGIN
      -- Control parametros entrada
      IF pcempres IS NULL THEN
         --OR pcramo IS NULL THEN
         RETURN 9000505;   --Faltan parametros por informar
      END IF;

      BEGIN
         SELECT ctipage
           INTO vctipage
           FROM agentes
          WHERE cagente = ff_agente_usuario(f_user);
      EXCEPTION
         WHEN OTHERS THEN
            vctipage := NULL;
      END;

      vpasexec := 2;

      --Ini Bug 27539 --ECP--04/07/2013
      -- Bug 30393/168070 - 05/05/2014 - AMC
      -- Si no somos central solo mostramos los produtos descentralizados
      IF pmodo = 'PREVI_CARTERA' THEN
         psquery :=
            'SELECT distinct p.cempres,p.sproduc,f_desproducto_t(p.cramo,p.cmodali,p.ctipseg,p.ccolect,1,'
            || pcidioma || ') TTITULO,'
            || ' nvl((select cestado from TMP_CARTERAUX where sproduc = p.sproduc and sprocar='
            || psprocar || '),0) MARCAT ' || ' FROM PRODCARTERA p,prodagecartera age'
            || ' WHERE p.cempres = ' || pcempres || ' AND p.cramo= nvl(''' || pcramo
            || ''',p.cramo) AND p.sproduc= NVL(''' || psproduc || ''',p.sproduc)'
            || ' AND p.cempres = age.cempres(+)' || ' AND p.sproduc = age.sproduc (+)'
            || ' AND age.cagente(+) = FF_AGENTE_USUARIO(f_user)'
            || ' AND (nvl( pac_parametros.f_parempresa_n( ' || pcempres
            || ' , ''ECARTERA_DESCENTRAL''),0) = 0 '
            || ' or     ( nvl( pac_parametros.f_parempresa_n( ' || pcempres
            || ' , ''ECARTERA_DESCENTRAL''),0) = 1 '
            || ' AND ( (  NVL(pac_parametros.f_parproducto_n(P.SPRODUC, ''CARTERA_DESCENTRAL''), 0) = 1 AND  '
            || vctipage || ' != 0) or ' || vctipage || ' = 0))
                     )'
            || ' AND PAC_PRODUCTOS.F_PRODAGENTE( P.SPRODUC, ff_agente_usuario(f_user), 3) =1 '
            || ' order by p.sproduc';
      ELSE
         --Bug 29765/164894 - 31/01/2014 - AMC-- Si no somos central solo mostramos los produtos descentralizados-- Para central mostramos todos los productos aunque sean descentralizados
         psquery :=
            'SELECT distinct p.cempres,p.sproduc,f_desproducto_t(p.cramo,p.cmodali,p.ctipseg,p.ccolect,1,'
            || pcidioma || ') TTITULO,'
            || ' nvl((select cestado from TMP_CARTERAUX where sproduc = p.sproduc and sprocar='
            || psprocar || '),0) MARCAT,' || ' NVL'
            || ' ((SELECT MAX (fcarpro) FROM prodagecartera age'
            || ' WHERE age.sproduc = p.sproduc and (age.cagente = ff_agente_usuario(f_user)'
            || '  OR age.cagente = (SELECT cagente FROM redcomercial'
            || ' WHERE ctipage = 0 AND cempres = 12 AND fmovfin IS NULL))),p.fcarpro) fcarpro'
            || ' FROM PRODCARTERA p' || ' WHERE p.cempres = ' || pcempres
            || ' AND p.cramo= nvl(''' || pcramo || ''',p.cramo)' || ' AND p.sproduc= NVL('''
            || psproduc || ''',p.sproduc) AND p.autmanual IS NULL '
            || ' AND PAC_PRODUCTOS.F_PRODAGENTE( P.SPRODUC, ff_agente_usuario(f_user), 3) =1 '
            || ' and ( (nvl( pac_parametros.f_parempresa_n( ' || pcempres
            || ' , ''ECARTERA_DESCENTRAL''),0) = 0  ) or
                  ( nvl( pac_parametros.f_parempresa_n( '
            || pcempres || ' , ''ECARTERA_DESCENTRAL''),0) = 1 '
            || ' AND ((NVL(pac_parametros.f_parproducto_n(p.sproduc,''CARTERA_DESCENTRAL''),0) = 1'
            || ' AND ' || vctipage || ' != 0) OR ' || vctipage || ' = 0) ' || ' ))'
            || ' order by p.sproduc';
      --Fi Bug 29765/164894 - 31/01/2014 - AMC
      END IF;

      vumerr := pac_log.f_log_consultas(psquery, vobject, 1);
      -- Fi Bug 30393/168070 - 05/05/2014 - AMC

      --Fin Bug 27539 --ECP--04/07/2013
      RETURN 0;
   EXCEPTION
      WHEN OTHERS THEN
         p_tab_error(f_sysdate, f_user, vobject, vpasexec, vparam, SQLERRM);
         RETURN 9000689;
   END f_get_prodcartera;

   /*******************************************************************************
                                                                                                                                                                                                                                                   FUNCION F_INICIALIZA_CARTERA
    Esta funci¿n devuelve el sproces con el que se realizar¿ el proceso de cartera,
    para ello llamar¿ a la funci¿n de f_procesini.
   Par¿metros
    Entrada :
       Pmodo     NUMBER   : Modo
       Pfperini  DATE     : Fecha
       Pcempres  NUMBER   : Empresa
       Ptexto    VARCHAR2 :
    Salida :
       Psproces  NUMBER  : Numero proceso de cartera.
   Retorna :NUMBER con el n¿mero de proceso
   *********************************************************************************/
   FUNCTION f_inicializa_cartera(
      pmodo IN VARCHAR2,
      pfperini IN DATE,
      pcempres IN NUMBER,
      ptexto IN VARCHAR2,
      pcidioma IN NUMBER,
      psproces OUT NUMBER)
      RETURN NUMBER IS
      vpasexec       NUMBER(8) := 1;
      vparam         VARCHAR2(200)
                  := 'Pmodo=' || pmodo || ' Pfperini=' || pfperini || ' Pcempres=' || pcempres;
      vobject        VARCHAR2(200) := 'PAC_DINCARTERA.F_INICIALIZA_CARTERA';
      v_titulo       VARCHAR2(200);
      num_err        NUMBER;
      pnnumlin       NUMBER;
      pcerror        NUMBER;
      conta_err      NUMBER;
      vtexto         VARCHAR2(2000);
   BEGIN
      -- Control parametros entrada
      IF pmodo IS NULL
         OR pfperini IS NULL
         OR pcempres IS NULL
         OR pcidioma IS NULL THEN
         p_tab_error(f_sysdate, f_user, vobject, vpasexec,
                     ' Faltan parametros por informar: ' || vparam, SQLERRM);
         RETURN 140974;   --Faltan parametros por informar
      END IF;

      --
      IF pmodo = 'PREVI_CARTERA' THEN
         v_titulo := 'Previo de Cartera de ' || pfperini;
      ELSE
         v_titulo := 'Cartera de ' || pfperini;
      END IF;

      --Insertamos en la tabla PROCESOSCAB el registro identificativo de proceso -----
      num_err := f_procesini(f_user, pcempres, ptexto, v_titulo, psproces);

      IF num_err <> 0 THEN
         pcerror := 1;
         conta_err := conta_err + 1;
         vtexto := f_axis_literales(num_err, pcidioma);
         pnnumlin := NULL;
         num_err := f_proceslin(psproces, SUBSTR('Cartera: ' || vtexto, 1, 120), 0, pnnumlin);
      END IF;

      RETURN num_err;
   EXCEPTION
      WHEN OTHERS THEN
         p_tab_error(f_sysdate, f_user, vobject, vpasexec, vparam, SQLERRM);
         RETURN 112608;
   END f_inicializa_cartera;

   /*******************************************************************************
                                                               FUNTION F_GET_MES_CARTERA
   Deber¿ devolver tres meses , el mes de la fecha de pr¿xima cartera de la empresa, (fcarpro), el anterior y el siguiente.
   Si el par¿metro npoliza est¿ informado se deber¿ seleccionar la fcarpro de la p¿liza en lugar de la empresa.
   Par¿metros:
    Entrada :
      Pnpoliza  NUMBER : Numero de poliza
   Retorna: un ref_cursor.
   ********************************************************************************/
   FUNCTION f_get_mes_cartera(
      pnpoliza IN NUMBER,
      pcidioma IN NUMBER,
      pcempres IN NUMBER,
      pcmodo IN VARCHAR2,
      psquery OUT VARCHAR2,
      psprocar IN NUMBER   -- Bug 29952/169064 - 11/03/2014 - AMC
                        )
      RETURN NUMBER IS
      vpasexec       NUMBER(8) := 1;
      vparam         VARCHAR2(200) := 'Pnpoliza=' || pnpoliza;
      vobject        VARCHAR2(200) := 'PAC_DINCARTERA.F_GET_MES_CARTERA';
      consulta       VARCHAR2(1000);
      v_cempres      procesoscab.cempres%TYPE;
      --       v_cempres      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      v_sproduc      NUMBER;
      v_fcarpro      DATE;
      v_crespue4084  NUMBER;
      v_sseguro      NUMBER;
      v_fcarpro_2num NUMBER;
      mensajes       t_iax_mensajes;
      vfcarpro_aux   DATE;
      vcount         NUMBER;
      vumerr         NUMBER;
   BEGIN
      IF pnpoliza IS NOT NULL THEN
         --INI BUG 28821#c157894 --
         SELECT sproduc
           INTO v_sproduc
           FROM seguros
          WHERE npoliza = pnpoliza
            AND ncertif = 0;

         IF NVL(pac_md_param.f_get_parproducto_n(v_sproduc, 'CARTERA_FCARPRO', mensajes), 0) =
                                                                                              1 THEN
            --- Obtener el fcarpro de la p¿liza
            SELECT fcarpro, sseguro
              INTO vfcarpro_aux, v_sseguro
              FROM seguros
             WHERE npoliza = pnpoliza
               AND ncertif = 0;

            --Obtener la modalidad de cobro de la p¿liza
            BEGIN
               SELECT crespue
                 INTO v_crespue4084
                 FROM pregunpolseg
                WHERE cpregun = 4084
                  AND sseguro = v_sseguro
                  AND nmovimi = (SELECT MAX(nmovimi)
                                   FROM pregunpolseg
                                  WHERE sseguro = v_sseguro
                                    AND cpregun = 4084);
            EXCEPTION
               WHEN NO_DATA_FOUND THEN
                  v_crespue4084 := 2;   -- por defecto
            END;

            --Inici BUG 28821/172422 - RCL - 10/04/2014
            FOR c IN (SELECT DISTINCT fcarpro
                                 FROM seguros
                                WHERE npoliza = pnpoliza
                                  AND csituac IN(0, 5)) LOOP
               --- Si es cobro anticipado solo quier que me muestre el mes de la fcarpro.
               IF v_crespue4084 = 2 THEN   -- Anticipado
                  IF LENGTH(psquery) > 1 THEN
                     psquery := psquery || ' UNION ';
                  END IF;

                  psquery :=
                     psquery
                     || ' select catribu nmes, tatribu tmes from detvalores where cvalor = 54'
                     || ' and cidioma = ' || pcidioma || ' and catribu = '
                     || TO_NUMBER(TO_CHAR(c.fcarpro, 'MM'));
               ELSIF v_crespue4084 = 1 THEN   -- Vencido
                  SELECT DECODE(TO_NUMBER(TO_CHAR(c.fcarpro, 'MM')) + 1, 12, 13, 12)
                    INTO v_fcarpro_2num
                    FROM DUAL;

                  IF LENGTH(psquery) > 1 THEN
                     psquery := psquery || ' UNION ';
                  END IF;

                  psquery :=
                     psquery
                     || ' select catribu nmes, tatribu tmes from detvalores where cvalor = 54'
                     || ' and cidioma = ' || pcidioma || ' and catribu = '
                     ||(MOD(TO_NUMBER(TO_CHAR(c.fcarpro, 'MM')) + 1, v_fcarpro_2num));
               END IF;
            END LOOP;

            IF v_crespue4084 = 1 THEN
               SELECT DECODE(TO_NUMBER(TO_CHAR(vfcarpro_aux, 'MM')) + 1, 12, 13, 12)
                 INTO v_fcarpro_2num
                 FROM DUAL;

               IF MOD(TO_NUMBER(TO_CHAR(vfcarpro_aux, 'MM')) + 1, v_fcarpro_2num) = 1 THEN
                  psquery := psquery || ' order by nmes desc';
               ELSE
                  psquery := psquery || ' order by nmes';
               END IF;
            --Fi BUG 28821/172422 - RCL - 10/04/2014
            ELSE
               IF TO_NUMBER(TO_CHAR(vfcarpro_aux, 'MM')) = 1 THEN
                  psquery := psquery || ' order by nmes desc';
               ELSE
                  psquery := psquery || ' order by nmes';
               END IF;
            END IF;
         ELSE
            psquery :=
               'select catribu nmes, tatribu tmes from detvalores where cvalor = 54'
               || ' and cidioma = ' || pcidioma || ' order by catribu';
         END IF;
      ELSIF pcmodo = 'PREVI_CARTERA'
            AND NVL(pac_parametros.f_parempresa_n(pcempres, 'PREVIO_MESESCARTERA'), 0) = 1 THEN
         psquery := 'select catribu nmes, tatribu tmes from detvalores where cvalor = 54'
                    || ' and cidioma = ' || pcidioma || ' order by catribu';
      --FIN BUG 28821#c157894 --
      ELSE
         -- Bug 29952/169064 - 11/03/2014 - AMC
         IF NVL(pac_parametros.f_parempresa_n(pac_md_common.f_get_cxtempresa,
                                              'MESES_PRODCARTERA'),
                0) = 1 THEN
            -- Bug 30393/168070 - 05/05/2014 - AMC
            SELECT COUNT(fcarpro)
              INTO vcount
              FROM prodagecartera
             WHERE cempres = pcempres
               AND(cagente = ff_agente_usuario(f_user)
                   OR cagente = (SELECT cagente
                                   FROM redcomercial
                                  WHERE cempres = pac_md_common.f_get_cxtempresa
                                    AND ctipage = 0
                                    AND fmovfin IS NULL))
               AND sproduc IN(SELECT sproduc
                                FROM tmp_carteraux
                               WHERE sprocar = psprocar
                                 AND cestado = 1);

            IF vcount = 0 THEN
               psquery :=
                  ' select NMES,TMES from('
                  || ' select to_number(to_char(fecha,''mm'')) NMES,ff_desvalorfijo(54,'
                  || pcidioma || ',to_number(to_char(fecha,''mm''))) TMES,'
                  || ' to_number(to_char(fecha,''yyyy'')) ANYO' || ' from('
                  || ' select max(fcarpro) fecha from prodcartera' || ' where cempres = '
                  || pcempres
                  || ' and sproduc in ( select sproduc from tmp_carteraux where sprocar = '
                  || psprocar || ' and cestado = 1))' || ' union'
                  || ' select decode(to_char(fecha,''mm'')+1,13,1,to_char(fecha,''mm'')+1) NMES,'
                  || ' ff_desvalorfijo(54,' || pcidioma
                  || ',decode(to_char(fecha,''mm'')+1,13,1,to_char(fecha,''mm'')+1)) TMES,'
                  || ' decode(to_char(fecha,''mm'')+1,13,to_char(fecha,''yyyy'')+1,to_char(fecha,''yyyy'')) ANYO'
                  || ' from(' || ' select max(fcarpro) fecha from prodcartera'
                  || ' where cempres = ' || pcempres
                  || ' and sproduc in ( select sproduc from tmp_carteraux where sprocar =  '
                  || psprocar || ' and cestado = 1))' || ' union'
                  || ' select decode(to_char(fecha,''mm'')-1,0,12,to_char(fecha,''mm'')-1) NMES,'
                  || ' ff_desvalorfijo(54,' || pcidioma
                  || ',decode(to_char(fecha,''mm'')-1,0,12,to_char(fecha,''mm'')-1)) TMES,'
                  || ' decode(to_char(fecha,''yyyy'')-1,0,12,to_char(fecha,''yyyy'')-1) ANYO'
                  || ' from(' || ' select max(fcarpro) fecha from prodcartera'
                  || ' where cempres = ' || pcempres
                  || ' and sproduc in ( select sproduc from tmp_carteraux where sprocar = '
                  || psprocar || ' and cestado = 1))'
                  || ' ) where ANYO||NMES is not null order by ANYO||NMES';
            ELSE
               psquery :=
                  ' select NMES,TMES from('
                  || ' select to_number(to_char(fecha,''mm'')) NMES,ff_desvalorfijo(54,'
                  || pcidioma || ',to_number(to_char(fecha,''mm''))) TMES,'
                  || ' to_number(to_char(fecha,''yyyy'')) ANYO' || ' from('
                  || ' select max(fcarpro) fecha from prodagecartera' || ' where cempres = '
                  || pcempres || ' and cagente = FF_AGENTE_USUARIO(f_user)'
                  || ' and sproduc in ( select sproduc from tmp_carteraux where sprocar = '
                  || psprocar || ' and cestado = 1))' || ' union'
                  || ' select decode(to_char(fecha,''mm'')+1,13,1,to_char(fecha,''mm'')+1) NMES,'
                  || ' ff_desvalorfijo(54,' || pcidioma
                  || ',decode(to_char(fecha,''mm'')+1,13,1,to_char(fecha,''mm'')+1)) TMES,'
                  || ' decode(to_char(fecha,''mm'')+1,13,to_char(fecha,''yyyy'')+1,to_char(fecha,''yyyy'')) ANYO'
                  || ' from(' || ' select max(fcarpro) fecha from prodagecartera'
                  || ' where cempres = ' || pcempres
                  || ' and cagente = FF_AGENTE_USUARIO(f_user)'
                  || ' and sproduc in ( select sproduc from tmp_carteraux where sprocar = '
                  || psprocar || ' and cestado = 1))' || ' union'
                  || ' select decode(to_char(fecha,''mm'')-1,0,12,to_char(fecha,''mm'')-1) NMES,'
                  || ' ff_desvalorfijo(54,' || pcidioma
                  || ',decode(to_char(fecha,''mm'')-1,0,12,to_char(fecha,''mm'')-1)) TMES,'
                  || ' decode(to_char(fecha,''yyyy'')-1,0,12,to_char(fecha,''yyyy'')-1) ANYO'
                  || ' from(' || ' select max(fcarpro) fecha from prodagecartera'
                  || ' where cempres = ' || pcempres
                  || ' and cagente = FF_AGENTE_USUARIO(f_user)'
                  || ' and sproduc in ( select sproduc from tmp_carteraux where sprocar = '
                  || psprocar || ' and cestado = 1))'
                  || ' ) where ANYO||NMES is not null  order by ANYO||NMES';
            END IF;
         -- Fi Bug 30393/168070 - 05/05/2014 - AMC
         ELSE
            psquery :=
               'select  to_number(to_char(fcarpro,''mm'')) NMES,ff_desvalorfijo(54,'
               || pcidioma
               || ',to_char(fcarpro,''mm'')) TMES
                           from empresas
                           where cempres ='
               || pcempres
               || '
                           UNION
                           select  decode(to_char(fcarpro,''mm'')+1,13,1,to_char(fcarpro,''mm'')+1) NMES,
                           ff_desvalorfijo(54,'
               || pcidioma
               || ',decode(to_char(fcarpro,''mm'')+1,13,1,to_char(fcarpro,''mm'')+1)) TMES
                           from empresas
                           where cempres ='
               || pcempres
               || '
                           UNION
                           select  decode(to_char(fcarpro,''mm'')-1,0,12,to_char(fcarpro,''mm'')-1) NMES,
                           ff_desvalorfijo(54,'
               || pcidioma
               || ',decode(to_char(fcarpro,''mm'')-1,0,12,to_char(fcarpro,''mm'')-1)) TMES
                           from empresas
                           where cempres ='
               || pcempres;
         END IF;

         vumerr := pac_log.f_log_consultas(psquery, vobject, 1);
      -- Fi Bug 29952/169064 - 11/03/2014 - AMC
      END IF;

      vpasexec := 2;
      RETURN 0;
   EXCEPTION
      WHEN OTHERS THEN
         p_tab_error(f_sysdate, f_user, vobject, vpasexec, vparam,
                     SQLERRM || '  -- psquery = ' || psquery);
         RETURN 101919;
   END f_get_mes_cartera;

   /*******************************************************************************
                                 FUNCION F_GET_ANYO_CARTERA
   Esta funci¿n deber¿ calcular el a¿o de la cartera, por norma ser¿ el del campo fcarpro de la empresa, en los casos en que
   el recibido por par¿metro y el de la fcarpro sea diferente, se debe controlar que no exista un cambio de a¿o.
   En el caso que el par¿metro p¿liza venga informado se debe trabajar  con la fcarpro de la p¿liza.
   Par¿metros
    Entrada :
       Pnpoliza  NUMBER : Numero de poliza
       Pnmes     NUMBER : Mes
       Pcempres  NUMBER : EMPRESA
    Retorna  NUMBER
   ********************************************************************************/
   FUNCTION f_get_anyo_cartera(
      pcempres IN NUMBER,
      pnpoliza IN NUMBER,
      pnmes IN NUMBER,
      pnanyo OUT NUMBER,
      psprocar IN NUMBER   -- Bug 29952/169064 - 11/03/2014 - AMC
                        )
      RETURN NUMBER IS
      vpasexec       NUMBER(8) := 1;
      vparam         VARCHAR2(200) := 'Pnpoliza=' || pnpoliza || ' Pnmes=' || pnmes;
      vobject        VARCHAR2(200) := 'PAC_DINCARTERA.F_GET_ANYO_CARTERA';
      v_anyo         NUMBER;
      vnumerr        NUMBER := 0;
      v_crespue4084  NUMBER;
      v_sproduc      NUMBER;
      v_sseguro      NUMBER;
      mensajes       t_iax_mensajes;
      vfecha         DATE;   -- Bug 30393/168070 - 21/05/2014 - AMC
   BEGIN
      -- Control parametros entrada
      IF pnmes IS NULL THEN
         RETURN 140974;   --Faltan parametros por informar
      END IF;

      --Ini Bug.: 0012911 - ICV - 02/02/2010
      IF pnpoliza IS NOT NULL THEN
         --ini bug 28821#c157894
         SELECT sproduc, sseguro
           INTO v_sproduc, v_sseguro
           FROM seguros
          WHERE npoliza = pnpoliza
            AND ncertif = 0;

         IF NVL(pac_md_param.f_get_parproducto_n(v_sproduc, 'CARTERA_FCARPRO', mensajes), 0) =
                                                                                              1 THEN
            -- Obtener la modalidad de cobro
            BEGIN
               SELECT crespue
                 INTO v_crespue4084
                 FROM pregunpolseg
                WHERE cpregun = 4084
                  AND sseguro = v_sseguro
                  AND nmovimi = (SELECT MAX(nmovimi)
                                   FROM pregunpolseg
                                  WHERE sseguro = v_sseguro
                                    AND cpregun = 4084);
            EXCEPTION
               WHEN NO_DATA_FOUND THEN
                  v_crespue4084 := 2;   -- por defecto
            END;

            -- Si es cobro anticipado direcamente el a¿o de la fcarpro, si es cobro vencido y el mes de la fcarpro es Diciembre, entonces el a¿o debe ser el a¿o pr¿ximo de la fcarpro:
            IF v_crespue4084 = 2 THEN   -- Anticipado
               --BUG 28821/172422 - RCL - 10/04/2014
               SELECT TO_NUMBER(TO_CHAR(fcarpro, 'yyyy'))
                 INTO pnanyo
                 FROM seguros
                WHERE npoliza = pnpoliza
                  AND ncertif = 0;
            /*SELECT DISTINCT TO_NUMBER(TO_CHAR(fcarpro, 'yyyy'))
                       INTO pnanyo
                       FROM seguros
                      WHERE npoliza = pnpoliza
                        AND TO_NUMBER(TO_CHAR(fcarpro, 'mm')) =
                                               NVL(pnmes, TO_NUMBER(TO_CHAR(fcarpro, 'mm')));*/
            ELSIF v_crespue4084 = 1 THEN   -- Vencido
               --BUG 28821/172422 - RCL - 10/04/2014
               IF pnmes = 1 THEN
                  SELECT (CASE
                             WHEN(TO_CHAR(fcarpro, 'mm') = 12) THEN TO_NUMBER
                                                                             (TO_CHAR(fcarpro,
                                                                                      'yyyy'))
                                                                    + 1
                             ELSE TO_NUMBER(TO_CHAR(fcarpro, 'yyyy'))
                          END)
                    INTO pnanyo
                    FROM seguros
                   WHERE npoliza = pnpoliza
                     AND ncertif = 0;
               ELSE
                  SELECT TO_NUMBER(TO_CHAR(fcarpro, 'yyyy'))
                    INTO pnanyo
                    FROM seguros
                   WHERE npoliza = pnpoliza
                     AND ncertif = 0;
               END IF;
            /*SELECT DISTINCT (CASE
                                WHEN(TO_CHAR(fcarpro, 'mm') = 12) THEN TO_NUMBER
                                                                          (TO_CHAR(fcarpro,
                                                                                   'yyyy'))
                                                                       + 1
                                ELSE TO_NUMBER(TO_CHAR(fcarpro, 'yyyy'))
                             END)
                       INTO pnanyo
                       FROM seguros
                      WHERE npoliza = pnpoliza
                        AND TO_NUMBER(TO_CHAR(fcarpro, 'mm')) =
                                               NVL(pnmes, TO_NUMBER(TO_CHAR(fcarpro, 'mm')));*/
            END IF;
         ELSE
            SELECT (CASE
                       WHEN(pnmes = 1
                            AND TO_CHAR(fcarpro, 'mm') = 12) THEN TO_NUMBER(TO_CHAR(fcarpro,
                                                                                    'yyyy'))
                                                                  + 1
                       ELSE TO_NUMBER(TO_CHAR(fcarpro, 'yyyy'))
                    END)
              INTO pnanyo
              FROM seguros
             WHERE npoliza = pnpoliza
               AND ncertif = 0;
         END IF;
      --fi bug 28821#c157894
      /*
                                                                  SELECT (CASE
                 WHEN pnmes = 1 THEN TO_NUMBER(TO_CHAR(fcarpro, 'yyyy')) + 1
                 ELSE TO_NUMBER(TO_CHAR(fcarpro, 'yyyy'))
              END)
        INTO pnanyo
        FROM seguros
       WHERE npoliza = pnpoliza;
       */
      ELSE
         -- Bug 29952/169064 - 11/03/2014 - AMC
         IF NVL(pac_parametros.f_parempresa_n(pac_md_common.f_get_cxtempresa,
                                              'MESES_PRODCARTERA'),
                0) = 1 THEN
            -- Bug 30393/168070 - 05/05/2014 - AMC
            SELECT MAX(fecha)
              INTO vfecha
              FROM (SELECT MAX(fcarpro) fecha
                      FROM prodagecartera
                     WHERE cempres = pcempres
                       AND cagente = ff_agente_usuario(f_user)
                       AND sproduc IN(SELECT sproduc
                                        FROM tmp_carteraux
                                       WHERE sprocar = psprocar
                                         AND cestado = 1)
                    UNION
                    SELECT MAX(fcarpro) fecha
                      FROM prodagecartera
                     WHERE cempres = pcempres
                       AND cagente = (SELECT cagente
                                        FROM redcomercial
                                       WHERE cempres = pcempres
                                         AND ctipage = 0
                                         AND fmovfin IS NULL)
                       AND sproduc IN(SELECT sproduc
                                        FROM tmp_carteraux
                                       WHERE sprocar = psprocar
                                         AND cestado = 1)
                    UNION
                    SELECT MAX(fcarpro) fecha
                      FROM prodcartera
                     WHERE cempres = pcempres
                       AND sproduc IN(SELECT sproduc
                                        FROM tmp_carteraux
                                       WHERE sprocar = psprocar
                                         AND cestado = 1));

            SELECT anyo
              INTO pnanyo
              FROM (SELECT TO_NUMBER(TO_CHAR(vfecha, 'yyyy')) anyo
                      FROM DUAL
                     WHERE TO_NUMBER(TO_CHAR(vfecha, 'mm')) = pnmes
                    UNION
                    SELECT DECODE(TO_CHAR(vfecha, 'mm') + 1,
                                  13, TO_CHAR(vfecha, 'yyyy') + 1,
                                  TO_CHAR(vfecha, 'yyyy')) anyo
                      FROM DUAL
                     WHERE DECODE(TO_CHAR(vfecha, 'mm') + 1, 13, 1, TO_CHAR(vfecha, 'mm') + 1) =
                                                                                          pnmes
                    UNION
                    SELECT DECODE(TO_CHAR(vfecha, 'mm') - 1,
                                  0, TO_CHAR(vfecha, 'yyyy') - 1,
                                  TO_CHAR(vfecha, 'yyyy')) anyo
                      FROM DUAL
                     WHERE DECODE(TO_CHAR(vfecha, 'mm') - 1, 0, 12, TO_CHAR(vfecha, 'mm') - 1) =
                                                                                          pnmes);
         -- Fi Bug 30393/168070 - 05/05/2014 - AMC
         ELSE
            SELECT (CASE
                       WHEN(pnmes = 1
                            AND TO_CHAR(fcarpro, 'mm') = 12) THEN TO_NUMBER(TO_CHAR(fcarpro,
                                                                                    'yyyy'))
                                                                  + 1
                       ELSE TO_NUMBER(TO_CHAR(fcarpro, 'yyyy'))
                    END)
              INTO pnanyo
              FROM empresas
             WHERE cempres = pcempres;
         /*   SELECT (CASE
                                                                                   WHEN pnmes = 1 THEN TO_NUMBER(TO_CHAR(fcarpro, 'yyyy')) + 1
                       ELSE TO_NUMBER(TO_CHAR(fcarpro, 'yyyy'))
                    END)
              INTO pnanyo
              FROM empresas
             WHERE cempres = pcempres;*/
         END IF;
      -- Fi Bug 29952/169064 - 11/03/2014 - AMC
      END IF;

      --Fin Bug.: 0012911
      vpasexec := 2;
      RETURN 0;
   EXCEPTION
      WHEN OTHERS THEN
         p_tab_error(f_sysdate, f_user, vobject, vpasexec, vparam, SQLERRM);
         RETURN 103290;
   END f_get_anyo_cartera;

   /*******************************************************************************
                                                               FUNCION F_EJECUTAR_CARTERA
   Par¿metros
    Entrada :
     psproces     NUMBER  : Id. del proceso
     pmodo        NUMBER  : Modo de ejecuciom
     pcempres     NUMBER  : Empresa
     pnpoliza     NUMBER  : Numero de poliza
     pfperini     DATE    : Fecha inicio
     pncertif     NUMBER  : Numero de certificado
    Entrada/Salida :
     pconta_error NUMBER
    Retorna : Number
   ********************************************************************************/
   FUNCTION f_ejecutar_cartera(
      psproces IN NUMBER,
      pmodo IN VARCHAR2,
      pcempres IN NUMBER,
      pnpoliza IN NUMBER,
      pfperini IN DATE,
      pfcartera IN DATE,
      pncertif IN NUMBER,
      pmoneda IN NUMBER,
      pcidioma IN NUMBER,
      psprocar IN NUMBER,
      prenuevan IN NUMBER,
      pmens OUT VARCHAR2,
      prenovcero IN NUMBER DEFAULT 0)
      RETURN NUMBER IS
      vpasexec       NUMBER(8) := 1;
      vparam         VARCHAR2(200)
         := 'psproces=' || psproces || ' pmodo=' || pmodo || ' pcempres=' || pcempres
            || ' pnpoliza=' || pnpoliza || ' pfperini=' || pfperini || ' pncertif='
            || pncertif || ' pfcartera=' || pfcartera || ' prenovcero=' || prenovcero;
      vobject        VARCHAR2(200) := 'PAC_DINCARTERA.F_EJECUTAR_CARTERA';
      num_err        NUMBER;
      pnnumlin       NUMBER;
      conta_be       NUMBER;
      indice         NUMBER;
      indice_error   NUMBER := 0;
      vsseguro       seguros.sseguro%TYPE;
      --       vsseguro       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      vnumerr        NUMBER;
      v_sproduc      seguros.sproduc%TYPE;
      v_npoliza      seguros.npoliza%TYPE;
      v_ncertif      seguros.ncertif%TYPE;
   BEGIN
      /*
                                    No se deber¿ incializar el proceso ya que este habr¿ sido previamente incializado.
      Se deber¿ traspasar la informaci¿n de la tabla tmp_carteraux a la tabla carteraux(solo aquellos productos marcados),
      y para el proceso indicado. Deber¿ llamar al proceso de cartera o previo de cartera seg¿n el modo en que se haya entrado,
      registrando los errores.
      En el caso del previo de cartera se debe pasar como par¿metro el mes y el a¿o que se debe obtener del par¿metro pfperini.
      Una vez hecho este deber¿ finalizar el proceso , mediante una llamada al f_procesfin, y deber¿ limpiar la tabla tmp_carteraux
      para el proceso actual.
      */
      -- Control parametros entrada

      --FPERINI y FCARTERA no pueden ser null a la vez.
      --Si vamor por FPERINI es que estamos mirando la cartera por mes y a¿o, es decir desde el primer dia del mes
      --Si vamos por fcartera, ignoraremos FPERINI. En este caso estamos mirando la cartera a partir del dia exacto de FCARTERA
      IF pfperini IS NULL
         AND pfcartera IS NULL THEN
         p_tab_error(f_sysdate, f_user, vobject, vpasexec,
                     ' Faltan parametros por informar: ' || vparam, SQLERRM);
         RETURN 140974;   --Faltan parametros por informar
      END IF;

      IF psproces IS NULL
         OR pmodo IS NULL
         OR pcempres IS NULL THEN   --OR pnpoliza IS NULL OR pncertif IS NULL THEN
         p_tab_error(f_sysdate, f_user, vobject, vpasexec,
                     ' Faltan parametros por informar: ' || vparam, SQLERRM);
         RETURN 140974;   --Faltan parametros por informar
      END IF;

      --
      BEGIN
         IF pnpoliza IS NULL THEN
              -- JLB - I - 17/10/2013 --bloqueo de cartera
            /*  INSERT INTO carteraaux
                          (sproces, cramo, cmodali, ctipseg, ccolect, cactivi, npoliza, ncertif,  CBLOQUEO, fcartera)
                 SELECT psproces, p.cramo, p.cmodali, p.ctipseg, p.ccolect, NULL, pnpoliza,  NVL(pncertif, 0),  decode(pmodo, 'PREVI', 0 ,1), f_sysdate
                   FROM productos p, tmp_carteraux t
                  WHERE p.sproduc = t.sproduc
                    AND t.sprocar = psprocar
                    AND t.cestado = 1; */
            FOR reg IN (SELECT psproces psproces, p.cramo cramo, p.cmodali cmodali,
                               p.ctipseg ctipseg, p.ccolect ccolect, NULL cactivi,
                               pnpoliza npoliza, NVL(pncertif, 0) ncertif,
                               DECODE(pmodo, 'PREVI', 0, 1) cbloqueo, f_sysdate fcartera
                          FROM productos p, tmp_carteraux t
                         WHERE p.sproduc = t.sproduc
                           AND t.sprocar = psprocar
                           AND t.cestado = 1) LOOP
               vnumerr := f_insert_carteraaux(reg.psproces, reg.cramo, reg.cmodali,
                                              reg.ctipseg, reg.ccolect, reg.cactivi,
                                              reg.npoliza, reg.ncertif, reg.cbloqueo,
                                              reg.fcartera);
            END LOOP;

            -- F - jlb - 17/10/2013 - Bloqueo de carera
            DELETE      tmp_carteraux
                  WHERE sprocar = psprocar;

            vsseguro := NULL;
         ELSE
            SELECT sseguro
              INTO vsseguro
              FROM seguros
             WHERE npoliza = pnpoliza
               AND ncertif = NVL(pncertif, 0);

            -- BUG 17153 - 31/12/2010 - JMP - Permitir pasar la cartera a un colectivo entero o a un certificado
            v_npoliza := pnpoliza;
            v_ncertif := NVL(pncertif, 0);

            SELECT MAX(sproduc)
              INTO v_sproduc
              FROM seguros
             WHERE npoliza = pnpoliza;

            IF (NVL(f_parproductos_v(v_sproduc, 'ADMITE_CERTIFICADOS'), 0) = 1
                AND NVL(pncertif, 0) = 0) THEN
               vsseguro := NULL;
               v_ncertif := NULL;
            END IF;

-- JLB - I - 17/10/2013 --bloque de cartera
      /*     INSERT INTO carteraaux
                        (sproces, cramo, cmodali, ctipseg, ccolect, cactivi, npoliza, ncertif, CBLOQUEO, fcartera)
               SELECT psproces, p.cramo, p.cmodali, p.ctipseg, p.ccolect, NULL, pnpoliza, v_ncertif, decode(pmodo, 'PREVI', 0 ,1), f_sysdate
                 FROM productos p
                WHERE p.sproduc = v_sproduc; */

            -- I - jlb - 17/10/2013 - Bloqueo de cartera
            FOR reg IN (SELECT psproces sproces, p.cramo cramo, p.cmodali cmodali,
                               p.ctipseg ctipseg, p.ccolect ccolect, NULL cactivi,
                               pnpoliza npoliza, v_ncertif ncertif,
                               DECODE(pmodo, 'PREVI', 0, 1) cbloqueo, f_sysdate fcartera
                          FROM productos p
                         WHERE p.sproduc = v_sproduc) LOOP
               vnumerr := f_insert_carteraaux(reg.sproces, reg.cramo, reg.cmodali,
                                              reg.ctipseg, reg.ccolect, reg.cactivi,
                                              reg.npoliza, reg.ncertif, reg.cbloqueo,
                                              reg.fcartera);
            END LOOP;
         -- F - jlb - 17/10/2013 - Bloqueo de carera

         -- FI BUG 17153 - 31/12/2010 - JMP
         END IF;
      EXCEPTION
         WHEN OTHERS THEN
            p_tab_error(f_sysdate, f_user, vobject, vpasexec, vparam, SQLERRM);
            RETURN 112608;
      END;

      --
      vpasexec := 2;

      IF pmodo = 'PREVI' THEN
         pac_dincartera.previ_cartera_tar(pcempres, TO_CHAR(pfperini, 'mm'),   --pmes,
                                          TO_CHAR(pfperini, 'yyyy'),
                                          -- panyo,
                                          v_npoliza, v_ncertif, pcidioma, psproces, indice,
                                          indice_error, prenuevan, pfcartera);
         vpasexec := 3;
         num_err := 0;
      ELSE
         -- JLB - I - 17/10/2013 -- bloqueo de la cartera
         FOR reg IN (SELECT cramo, cmodali, ctipseg, ccolect, cactivi, npoliza, ncertif
                       FROM carteraaux
                      WHERE sproces = psproces
                        AND cbloqueo = 1) LOOP
            num_err := f_cartera_bloqueada(psproces, reg.cramo, reg.cmodali, reg.ctipseg,
                                           reg.ccolect, reg.cactivi, reg.npoliza, reg.ncertif);

            IF num_err <> 0 THEN   -- si existen carteras bloqueadas
               indice_error := 1;   -- marcamos error
               pnnumlin := NULL;
               vnumerr := f_proceslin(psproces,
                                      SUBSTR('Cartera: Cartera bloqueada ' || reg.cramo || '-'
                                             || reg.cmodali || '-' || reg.ctipseg || '-'
                                             || reg.ccolect || '-' || reg.cactivi || '-'
                                             || reg.npoliza || '-' || reg.ncertif,
                                             1, 120),
                                      0, pnnumlin);
               vnumerr := f_procesfin(psproces, num_err);
               vnumerr := pac_dincartera.f_delete_carteraaux(psproces);
               RETURN num_err;
            END IF;
         END LOOP;

         -- JLB - F 17/10/2013 -- bloqueo de la cartera
         num_err := pac_dincartera.cartera_producte(pcempres, psproces, psproces,
                                                    TO_CHAR(pfperini, 'mm'),
                                                    TO_CHAR(pfperini, 'yyyy'), pcidioma,
                                                    pmoneda, pfperini, indice, indice_error,
                                                    vsseguro, v_npoliza, v_ncertif, NULL,
                                                    prenovcero, pfcartera);

         IF num_err <> 0 THEN
            pnnumlin := NULL;
            vnumerr := f_proceslin(psproces,
                                   SUBSTR('Cartera: Proceso no finalizado correctamente', 1,
                                          120),
                                   0, pnnumlin);
         END IF;

         -- JLB - 17/10/2013 -- bloqueo de la cartera
         vpasexec := 4;
      END IF;

      pnnumlin := NULL;
      pmens := f_axis_literales(103148, pcidioma) || TO_CHAR(indice - indice_error) || ' | '
               || f_axis_literales(103149, pcidioma) || indice_error;
      vnumerr := f_proceslin(psproces, pmens, 0, pnnumlin, 2);
      -- Bug 26209  FAC - FIN 27/02/2013 - Soluci¿n definitiva ejecuci¿n de cartera desde pantalla
      vnumerr := pac_correo.f_envia_correo(pcidioma, psproces, 14, pmens);
      -- Bug 26209  FAC - FIN 27/02/2013 - Soluci¿n definitiva ejecuci¿n de cartera desde pantalla
      vpasexec := 5;
      vnumerr := f_procesfin(psproces, num_err);
      -- JLB - I - 17/10/2013 -- bloqueo de la cartera
      vnumerr := pac_dincartera.f_delete_carteraaux(psproces);
      -- JLB - F - 17/10/2013 -- bloqueo de la cartera
      RETURN num_err;
   EXCEPTION
      WHEN OTHERS THEN
         p_tab_error(f_sysdate, f_user, vobject, vpasexec, vparam, SQLERRM);
         -- JLB - I - 17/10/2013 -- bloqueo de la cartera
         vnumerr := pac_dincartera.f_delete_carteraaux(psproces);
         -- JLB - F - 17/10/2013 -- bloqueo de la cartera
         RETURN 112608;
   END f_ejecutar_cartera;

   -- Bug 23940 - APD - 18/10/2012 - se crea la funcion
   FUNCTION p_previ_cartera_psu(
      reg IN OUT seguros%ROWTYPE,
      pcempres IN NUMBER,
      psproces IN NUMBER,
      pmes IN NUMBER,
      panyo IN NUMBER,
      pcidioma IN NUMBER,
      lsproduc_ant IN OUT NUMBER,
      indice IN OUT NUMBER,
      indice_error IN OUT NUMBER)
      RETURN NUMBER IS
      algun_error    NUMBER := 0;
      num_err        NUMBER := 0;
      pnmovimi       notibajagar.nmovimb%TYPE;
      --       pnmovimi       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      lcprimin       NUMBER;
      liprimin       NUMBER;
      lcclapri       NUMBER;
      lcgarant_regu  NUMBER;
      lnorden        NUMBER;
      v_ctipcob      seguroscol.ctipcob%TYPE;
      --       v_ctipcob      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      v_fcartera     DATE;
      n_retafrac     NUMBER(1);
      vcreteni       seguros.creteni%TYPE;
      --       vcreteni       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      v_cursor       NUMBER;
      ss             VARCHAR2(3000);
      funcion        VARCHAR2(40);
      v_filas        NUMBER;
      num_risc       NUMBER;
      lcumple        NUMBER;
      lcactivi       NUMBER;
      lbonifica      NUMBER;
      laplica_bonifica NUMBER;
      v_frevisio     seguros_aho.frevisio%TYPE;
      --       v_frevisio     DATE; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      v_crealiza     cfg_accion.crealiza%TYPE;
      pcsubpro       productos.csubpro%TYPE;
      --       pcsubpro       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      pcobjase       productos.cobjase%TYPE;
      --       pcobjase       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      pcagrpro       productos.cagrpro%TYPE;
      --       pcagrpro       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      pcmoneda       NUMBER;
      pnedamar       productos.nedamar%TYPE;
      --       pnedamar       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      pciedmar       productos.ciedmar%TYPE;
      --       pciedmar       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      tipo           codiram.cgtarif%TYPE;
      --       tipo           NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      lmov           NUMBER;
      -- No serveix per r¿s, ¿s un par. de sortida per la cartera
      lanu           NUMBER;
      -- No serveix per r¿s, ¿s un par. de sortida per la cartera
      parms_transitorios pac_parm_tarifas.parms_transitorios_tabtyb;
      -- Bug 21167 - RSC - 03/02/2012 - LCOL_T001-LCOL - UAT - TEC: Incidencias del proceso de Cartera
      v_fcaranu_x    seguros.fcaranu%TYPE;
      v_fcarpro_x    seguros.fcarpro%TYPE;
                                             --Bug 28832 -- JMG -- 03/12/2013
      -- Fin Bug 21167
      pcmovimi       NUMBER;
      pfemisio       DATE;
      recibosi       NUMBER;
      prestacion     NUMBER;
      recpendi       NUMBER;
      vpersona       NUMBER;
      vnriesgo       NUMBER;   -- Bug 10053 - APD - 08/05/2009

      TYPE assoc_array_person IS TABLE OF NUMBER
         INDEX BY PLS_INTEGER;   --- Table para PIAS

      vhpersonpias   assoc_array_person;
      vhpersonppa    assoc_array_person;
      prima          garanseg.icapital%TYPE;
      --       prima          NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      texto          VARCHAR2(100);
      num_lin        NUMBER;
      psseguro       garanseggas.sseguro%TYPE;
      --       psseguro       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      v_cmodcom      comisionprod.cmodcom%TYPE;
      pnimport2      NUMBER;
      modcom         NUMBER;
      -- BUG 18423 - 21/12/2011 - JMP - LCOL705 - Multimoneda
      v_cmonpol      parempresas.nvalpar%TYPE;
      v_max_fcambio  DATE;
      v_nrecibo      reciboscar.nrecibo%TYPE;
      v_itasa        eco_tipocambio.itasa%TYPE;
      v_fcambio      DATE;
      -- FIN BUG 18423 - 21/12/2011 - JMP - LCOL705 - Multimoneda
      v_cbloqueocol  seguros.cbloqueocol%TYPE;

      -- Bug 23940 - APD - 31/12/2012
      FUNCTION validar_regulariza(psseguro IN NUMBER)
         RETURN NUMBER IS
         --Declaraci¿n de variables:
         xcpregun       pregunseg.cpregun%TYPE;
--          xcpregun       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
         xcrespue       pregunseg.crespue%TYPE;
--          xcrespue       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
         xsregula       regularizaciones.sregula%TYPE;
--          xsregula       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      BEGIN
         BEGIN
            SELECT cpregun, crespue
              INTO xcpregun, xcrespue
              FROM pregunseg
             WHERE sseguro = psseguro
               AND cpregun = 80
               AND crespue = 1;
         EXCEPTION
            WHEN NO_DATA_FOUND THEN
               RETURN 1000;
            WHEN TOO_MANY_ROWS THEN
               NULL;
            WHEN OTHERS THEN
               RETURN 107649;
         END;

         BEGIN
            SELECT sregula
              INTO xsregula
              FROM regularizaciones
             WHERE sseguro = psseguro
               AND fregula IS NULL;
         EXCEPTION
            WHEN OTHERS THEN
               RETURN 107649;
         END;

         RETURN 0;
      END;
   BEGIN
      IF reg.fcarpro IS NOT NULL THEN
         indice := indice + 1;
         algun_error := 0;
         num_err := 0;
         pnmovimi := NULL;

         IF reg.sproduc <> lsproduc_ant THEN
            lsproduc_ant := reg.sproduc;
---------------------------------------------------------
-------------------------------------------------
-- Mirem si el producte contempla la prima m¿nima
-------------------------------------------------
-- Si s'ha de comprovar la prima m¿nima, cal veure si hi ha garantia
-- de regularitzaci¿.
            pac_dincartera.garantia_regularitzacio(reg.cramo, reg.cmodali, reg.ctipseg,
                                                   reg.ccolect, lcprimin, liprimin, lcclapri,
                                                   lcgarant_regu, lnorden);
---------------------------------------------------------
         END IF;

         -- Bug 23428 - RSC - 07/09/2012 - EMISI¿N ¿ CARTERA - COBRO VENCIDO / ANTICIPADO
         BEGIN
            SELECT ctipcob
              INTO v_ctipcob
              FROM seguroscol
             WHERE sseguro = reg.sseguro;
         EXCEPTION
            WHEN NO_DATA_FOUND THEN
               v_ctipcob := 2;
            WHEN OTHERS THEN
               v_ctipcob := 2;
         END;

         SELECT DECODE(v_ctipcob,
                       1, ADD_MONTHS((LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo, 'mmyyyy'))
                                      + 1),
                                     -1),
                       (LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo, 'mmyyyy')) + 1))
           INTO v_fcartera
           FROM DUAL;

         -- Fin Bug 23428
         WHILE reg.fcarpro < v_fcartera
          AND algun_error = 0
          AND(reg.fcarpro < reg.fvencim
              OR reg.fvencim IS NULL) LOOP
            -- BUG 9153 - 04-05-09 - RSC - Suplementos autom¿ticos
            n_retafrac := NULL;

            -- Bug 23940 - APD - 31/12/2012 - si la poliza est¿ bloqueada en renovacion no permitir renovar
            IF (reg.fcarpro = reg.fcaranu
                AND reg.csituac <> 5
                AND n_retafrac IS NULL)
               OR(n_retafrac = 1) THEN
               SELECT cbloqueocol
                 INTO v_cbloqueocol
                 FROM seguros
                WHERE sseguro = reg.sseguro;

               IF v_cbloqueocol = 2 THEN
                  num_err := 152212;   -- Poliza bloqueada.
                  algun_error := 1;
               END IF;
            END IF;

            -- fin Bug 23940 - APD - 31/12/2012
            IF algun_error = 0 THEN
               -- Bug 23940 - APD - 18/10/2012 -- se validan las PSU PRE de Cartera Previo
/*
               num_err := pac_dincartera.f_genera_psu('P', 3, reg.sseguro, reg.fcarpro,
                                                      psproces, pcidioma, indice,
                                                      indice_error, vcreteni);

               IF num_err <> 0 THEN
                  -- Hay error de controles de PSU --> si se debe parar el PREVIO de CARTERA.
                  -- Pero si ha saltado la PSU ser¿a num_err =0 y vcreteni <> 0
                  -- y en este caso no se debe parar el PREVIO de CARTERA
                  algun_error := 1;
               END IF;
*/
               -- fin Bug 23940 - APD - 18/10/2012
               IF NVL(f_parproductos_v(reg.sproduc, 'FRACCIONARIO'), 0) = 1 THEN
                  SELECT MAX(tvalpar)
                    INTO funcion
                    FROM detparpro
                   WHERE cparpro = 'F_PRFRACCIONARIAS'
                     AND cidioma = 2
                     AND cvalpar = (SELECT cvalpar
                                      FROM parproductos
                                     WHERE sproduc = reg.sproduc
                                       AND cparpro = 'F_PRFRACCIONARIAS');

                  IF funcion IS NOT NULL THEN
                     ss := 'begin :n_retafrac := ' || funcion || '; end;';

                     IF DBMS_SQL.is_open(v_cursor) THEN
                        DBMS_SQL.close_cursor(v_cursor);
                     END IF;

                     v_cursor := DBMS_SQL.open_cursor;
                     DBMS_SQL.parse(v_cursor, ss, DBMS_SQL.native);

                     IF INSTR(ss, ':psseguro') > 0 THEN
                        DBMS_SQL.bind_variable(v_cursor, ':psseguro', reg.sseguro);
                     END IF;

                     IF INSTR(ss, ':pfecha') > 0 THEN
                        DBMS_SQL.bind_variable(v_cursor, ':pfecha', reg.fcarpro);
                     END IF;

                     IF INSTR(ss, ':n_retafrac') > 0 THEN
                        DBMS_SQL.bind_variable(v_cursor, ':n_retafrac', num_err);
                     END IF;

                     v_filas := DBMS_SQL.EXECUTE(v_cursor);
                     DBMS_SQL.variable_value(v_cursor, 'n_retafrac', n_retafrac);

                     IF DBMS_SQL.is_open(v_cursor) THEN
                        DBMS_SQL.close_cursor(v_cursor);
                     END IF;
                  END IF;
               END IF;
            -- Fin Bug 9153
            END IF;

            IF algun_error = 0 THEN
               --SMF Como ahora los de propuesta de suplementos entra por la
               --select a¿adimos a la condici¿n reg.csituac <> 5 para que no
               --entren por el IF.
               -- BUG 9153 - 04-05-09 - RSC - Suplementos autom¿ticos
               -- A¿adimos renovaci¿n si le toca renovar o si cumpla a¿os (n_retafrac = 1)
               IF (reg.fcarpro = reg.fcaranu
                   AND reg.csituac <> 5
                   AND n_retafrac IS NULL)
                  OR(n_retafrac = 1) THEN
                  -- Bug 27048/155371 - APD - 17/12/2013 - se cambia de posicion la validacion
                  -- de la PSU ya que de momento solo se ejecutaran las PSU en Cartera de Renovacion
                  -- Bug 23940 - APD - 18/10/2012 -- se validan las PSU PRE de Cartera Previo
                  num_err := pac_dincartera.f_genera_psu('P', 3, reg.sseguro, reg.fcarpro,
                                                         psproces, pcidioma, indice,
                                                         indice_error, vcreteni);

                  IF num_err <> 0 THEN
                     -- Hay error de controles de PSU --> si se debe parar el PREVIO de CARTERA.
                     -- Pero si ha saltado la PSU ser¿a num_err =0 y vcreteni <> 0
                     -- y en este caso no se debe parar el PREVIO de CARTERA
                     algun_error := 1;
                  END IF;

                  -- fin Bug 23940 - APD - 18/10/2012
                  -- fin Bug 27048/155371 - APD - 17/12/2013
                  IF algun_error = 0 THEN   -- Bug 27048/155371 - APD - 17/12/2013
                     --Bug 9685 - APD - 17/04/2009 - Se busca el par¿metro num_risc riesgos personales
                     BEGIN
                        SELECT COUNT(*)
                          INTO num_risc
                          FROM riesgos
                         WHERE sperson IS NOT NULL
                           AND sseguro = reg.sseguro;
                     EXCEPTION
                        WHEN OTHERS THEN
                           num_risc := 0;
                     END;

                     --Bug 9685 - APD - 17/04/2009 - Fin
                     -- Bug 9685 - APD - 17/04/2009 - en lugar de coger la acticad de la tabla seguros, llamar a la funci¿n pac_seguros.ff_get_actividad
                     -- Veure si s'ha de fer algun canvi a la p¿lissa abans de renovar
                     -- ( ara nom¿s implementat canvi d'activitat)
                     lcumple := 0;
                     num_err :=
                        pac_cambiocartera.cambiocartera
                                                   ('P', reg.sproduc,
                                                    pac_seguros.ff_get_actividad(reg.sseguro,
                                                                                 num_risc),
                                                    reg.sseguro, reg.cramo, reg.cmodali,
                                                    reg.ctipseg, reg.ccolect, reg.fcaranu,
                                                    reg.nsuplem, lcumple, lcactivi);

                     -- Bug 9685 - APD - 17/04/2009 - Fin
                     IF lcumple = 1 THEN
                        -- La p¿lissa ser¿ modificada en la cartera. En el previ nom¿s avisem
                        --                        num_err := 110406;
                        -- Canviem l'activitat per que tarifi amb la nova
                        reg.cactivi := lcactivi;
                     -- Bug 9685 - APD - 17/04/2009 - en lugar de coger la actividad de la tabla seguros, llamar a la funci¿n pac_seguros.ff_get_actividad
                     ELSE
                        reg.cactivi := pac_seguros.ff_get_actividad(reg.sseguro, num_risc);
                     -- Bug 9685 - APD - 17/04/2009 - Fin
                     END IF;

                     IF num_err = 0 THEN
                        -- La p¿lissa renova , cal comprovar si te bonificaci¿
                        -- per no sinistralitat
                        num_err := pac_bonifica.f_bonifica_poliza(reg.cramo, reg.cmodali,
                                                                  reg.ctipseg, reg.ccolect,
                                                                  reg.sseguro, reg.fcaranu,
                                                                  reg.fefecto, lbonifica,
                                                                  laplica_bonifica);
                     END IF;

                     IF num_err = 0 THEN
                        -- BUG 16903 - JMP - 09/12/2010 - No renovamos si fecha de revisi¿n anterior
                        --                                a la de renovaci¿n
                        BEGIN
                           SELECT frevisio
                             INTO v_frevisio
                             FROM seguros_aho
                            WHERE sseguro = reg.sseguro;

                           num_err := pac_cfg.f_get_user_accion_permitida(f_user,
                                                                          'CARTERA_NO_REVISA',
                                                                          reg.sproduc,
                                                                          reg.cempres,
                                                                          v_crealiza);

                           IF num_err <> 1 THEN
                              IF v_frevisio < reg.fcaranu THEN
                                 num_err := 9901723;
                              -- La fecha de revisi¿n es anterior a la renovaci¿n de la p¿liza
                              ELSE
                                 num_err := 0;
                              END IF;
                           ELSE
                              num_err := 0;
                           END IF;
                        EXCEPTION
                           WHEN NO_DATA_FOUND THEN
                              NULL;
                        END;
                     END IF;

                     IF num_err <> 0 THEN
                        algun_error := 1;
                        indice_error := indice_error + 1;
                     ELSE
                        --
                        -- FGG, 14/02/2000,. Para ver si est¿ informado
                        -- el % de regularizaci¿n.
                        num_err := validar_regulariza(reg.sseguro);

                        IF num_err <> 0
                           AND num_err <> 1000 THEN
                           algun_error := 1;
                           indice_error := indice_error + 1;
                        ELSE
                           num_err := 0;

                           BEGIN
                              SELECT csubpro, cobjase, cagrpro,
-- JLB - I - BUG 18423 COjo la moneda del producto
                                          -- DECODE(cdivisa, 3, 1, 2),
                                     pac_monedas.f_moneda_producto(sproduc),
-- JLB - F - BUG 18423 COjo la moneda del producto
                                                                            nedamar, ciedmar
                                INTO pcsubpro, pcobjase, pcagrpro,
                                     pcmoneda, pnedamar, pciedmar
                                FROM productos
                               WHERE cramo = reg.cramo
                                 AND ctipseg = reg.ctipseg
                                 AND ccolect = reg.ccolect
                                 AND cmodali = reg.cmodali;
                           EXCEPTION
                              WHEN OTHERS THEN
                                 algun_error := 1;
                           END;

                           --21/9/98: YIL. Se buscan los datos necesarios
                           -- para calcular las tarifas.
                           BEGIN
                              SELECT cgtarif
                                INTO tipo
                                FROM codiram
                               WHERE cramo = reg.cramo;
                           EXCEPTION
                              WHEN NO_DATA_FOUND THEN
                                 num_err := 101904;
                           END;

                           --25/11/98 YIL. Se busca el par¿metro num_risc
                           -- riesgos personales
                           BEGIN
                              SELECT COUNT(*)
                                INTO num_risc
                                FROM riesgos
                               WHERE sperson IS NOT NULL
                                 AND sseguro = reg.sseguro;
                           EXCEPTION
                              WHEN OTHERS THEN
                                 num_risc := 0;
                           END;

                           --DBMS_OUTPUT.put_line( 'abans de tarifar '|| reg.fefecto);
                           IF NVL(f_parproductos_v(reg.sproduc, 'DETALLE_GARANT'), 0) IN(1, 2) THEN
                              num_err :=
                                 pac_dincartera.f_garantarifa_sgt_det('P', reg.sseguro,
                                                                      reg.cramo, reg.cmodali,
                                                                      NVL(reg.cobjase,
                                                                          pcobjase),
                                                                      reg.ctipseg,
                                                                      reg.ccolect, tipo,
                                                                      reg.nduraci, psproces,
                                                                      reg.ndurcob,
                                                                      reg.fcarpro, pmes,
                                                                      panyo, tipo, pcagrpro,
                                                                      reg.ctarman,
                                                                      reg.cactivi, num_risc,
                                                                      NULL, reg.fefecto, lmov,
                                                                      lanu, pcmoneda,
                                                                      parms_transitorios,
                                                                      lbonifica,
                                                                      laplica_bonifica,
                                                                      reg.sproduc,
                                                                      reg.cforpag, pcidioma,
                                                                      lcgarant_regu, lnorden,
                                                                      lcprimin, liprimin,
                                                                      lcclapri, pnedamar,
                                                                      pciedmar, reg.fcaranu);
                           ELSE
                              num_err := pac_dincartera.f_garantarifa_sgt('P', reg.sseguro,
                                                                          reg.cramo,
                                                                          reg.cmodali,
                                                                          NVL(reg.cobjase,
                                                                              pcobjase),
                                                                          reg.ctipseg,
                                                                          reg.ccolect, tipo,
                                                                          reg.nduraci,
                                                                          psproces,
                                                                          reg.ndurcob,
                                                                          reg.fcarpro, pmes,
                                                                          panyo, tipo,
                                                                          pcagrpro,
                                                                          reg.ctarman,
                                                                          reg.cactivi,
                                                                          num_risc, NULL,
                                                                          reg.fefecto, lmov,
                                                                          lanu, pcmoneda,
                                                                          parms_transitorios,
                                                                          lbonifica,
                                                                          laplica_bonifica,
                                                                          reg.sproduc,
                                                                          reg.cforpag,
                                                                          pcidioma,
                                                                          lcgarant_regu,
                                                                          lnorden, lcprimin,
                                                                          liprimin, lcclapri,
                                                                          pnedamar, pciedmar,
                                                                          reg.fcaranu);
                           END IF;

                           IF num_err = 0 THEN
                              --Bug 23940 - APD - 02/11/2012 - el borrado de las tablas
                              -- temporales se traspasa despu¿s de la llamada a PSU POST
                              -- ya que se necesita para su informacion a las tablas EST
                              -- para que se puedan realizar las validaciones de la PSU POST
                              num_err := pac_dincartera.f_genera_psu('P', 4, reg.sseguro,
                                                                     reg.fcarpro, psproces,
                                                                     pcidioma, indice,
                                                                     indice_error, vcreteni);

                              IF num_err <> 0 THEN
                                 -- Hay error de controles de PSU --> si se debe parar el PREVIO de CARTERA.
                                 -- Pero si ha saltado la PSU ser¿a num_err =0 y vcreteni <> 0
                                 -- y en este caso no se debe parar el PREVIO de CARTERA
                                 algun_error := 1;
                              END IF;

                              -- fin Bug 23940 - APD - 02/11/2012

                              -- SMF borramos las tablas temporales para agilizar el previo
                              DELETE      tmp_garancar
                                    WHERE sseguro = reg.sseguro
                                      AND sproces = psproces;

                              DELETE      pregungarancar
                                    WHERE sseguro = reg.sseguro
                                      AND sproces = psproces;

                              DELETE      preguncar
                                    WHERE sseguro = reg.sseguro
                                      AND sproces = psproces;

                              DELETE      pregunpolcar
                                    WHERE sseguro = reg.sseguro
                                      AND sproces = psproces;

                              --BUG 0026638: FAC LCOL - TEC - Cartera para Autos. (id 176-19)
                              DELETE      autdetriesgoscar
                                    WHERE sseguro = reg.sseguro
                                      AND sproces = psproces;

                              DELETE      autdisriesgoscar
                                    WHERE sseguro = reg.sseguro
                                      AND sproces = psproces;

                              DELETE      autconductorescar
                                    WHERE sseguro = reg.sseguro
                                      AND sproces = psproces;

                              DELETE      autriesgoscar
                                    WHERE sseguro = reg.sseguro
                                      AND sproces = psproces;

                              --FIN BUG 0026638: FAC LCOL - TEC - Cartera para Autos. (id 176-19)

                              ----DBMS_OUTPUT.put_line(
                              --  'pac_tarifas.f_garantarifa_sgt '|| num_err);

                              --message('2el ch_cartas es ' || :busqueda.ch_cartas);pause;
                              IF num_err = 0 THEN
                                 -- Bug 21167 - RSC - 03/02/2012 - LCOL_T001-LCOL - UAT - TEC: Incidencias del proceso de Cartera
                                 v_fcaranu_x := reg.fcaranu;
                                 -- Fin bug 21167

                                 --Ya est¿n todas las garant¿as de GARANSEG tarificadas---
                                 --Llamamos la funci¿n que actualiza datos de la pr¿xima cartera-----
                                 num_err := f_acproxcar(reg.sseguro, reg.fcarant, reg.fcarpro,
                                                        reg.fcaranu, reg.nanuali, reg.nfracci,
                                                        reg.frenova);

                                 ----DBMS_OUTPUT.put_line('acproxcar '|| num_err);
                                 IF num_err <> 0 THEN
                                    algun_error := 1;
                                    indice_error := indice_error + 1;
                                 ELSE
                                    --15/1/99 YIL. Se controlan las p¿lizas de ahorro
                                    IF pcagrpro = 2 THEN   ---es una p¿liza de ahorro
                                       pcmovimi := 2;
                                    -- indica aportaci¿n peri¿dica
                                    ELSE
                                       pcmovimi := NULL;
                                    END IF;

                                    --2/10/98 YIL. Se utiliza la funci¿n f_recries para calcular el recibo
                                    --24/3/1999 YIL. Si la forma de pago es ¿nica no se calcula recibo
                                    IF reg.cforpag <> 0 THEN
                                       --Llamamos la funci¿n de calcular recibos
                                       IF NVL
                                             (pac_parametros.f_parempresa_n
                                                                         (reg.cempres,
                                                                          'FEMISIO_IS_SYSDATE'),
                                              0) = 1 THEN
                                          pfemisio := f_sysdate;
                                       ELSE
                                          pfemisio :=
                                             TO_DATE('1/' || TO_CHAR(TO_NUMBER(pmes)) || '/'
                                                     || TO_CHAR(panyo),
                                                     'dd/mm/yyyy');
                                       END IF;

                                       ----DBMS_OUTPUT.PUT_LINE ( '>>>>>>> RENOVAMOS');
                                       -- Vamos a calcular si podemos hacer el recibo y no superamos
                                       -- el l¿mite de aportaciones maximas solo en pp.
                                       ----DBMS_OUTPUT.put_line ( 'prima m¿nima: ' || liprimin ) ;
                                       recibosi := 1;
                                       -- Si tieneparte de prestaciones en PP NO GENERAMOS RECIBO
                                       prestacion := 0;

                                       IF reg.cagrpro = 11 THEN
                                          SELECT COUNT(1)
                                            INTO prestacion
                                            FROM prestaplan
                                           WHERE prestaplan.sseguro = reg.sseguro;
                                       END IF;

                                       -- Bug 0017382 - 26/01/2011 - RSC
                                       -- S¿ el producto es de ahorro, se busca el n¿mero de recibos pendientes que tiene la p¿liza
                                       --IF f_prod_ahorro(reg.sproduc) = 1 THEN
                                       --   SELECT f_recpen_pp(reg.sseguro, 1)
                                       --     INTO recpendi
                                       --     FROM DUAL;
                                       --ELSE
                                       --   recpendi := 0;
                                       --END IF;
                                       recpendi := 0;

                                       IF prestacion > 0
                                          OR recpendi > 1 THEN
                                          recibosi := 0;
                                       ELSIF (NVL(f_parproductos_v(reg.sproduc, 'APORTMAXIMAS'),
                                                  0) = 1
                                              OR NVL(f_parproductos_v(reg.sproduc,
                                                                      'TIPO_LIMITE'),
                                                     0) <> 0)
                                             AND prestacion = 0
                                             AND recpendi < 2 THEN
                                          -- Planes de Pensiones y PIAS (RSC 01/02/2008)
                                          DECLARE
                                             pendiente      garancar.ipritar%TYPE;
--                                           pendiente      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
                                          BEGIN
                                             SELECT riesgos.sperson, riesgos.nriesgo
                                               INTO vpersona, vnriesgo
                                               FROM riesgos
                                              WHERE riesgos.sseguro = reg.sseguro
                                                AND riesgos.fanulac IS NULL;

                                             IF NVL(f_parproductos_v(reg.sproduc,
                                                                     'APORTMAXIMAS'),
                                                    0) = 1 THEN   -- PPA
                                                IF vhpersonppa.EXISTS(vpersona) THEN
                                                   pendiente := vhpersonppa(vpersona);
                                                ELSE
                                                   -- Bug 10053 - APD - 08/05/2009 - se sustituye la funcion f_maxapor_pp por
                                                   -- pac_ppa_planes.ff_importe_por_aportar_persona
                                                   pendiente :=
                                                      pac_ppa_planes.ff_importe_por_aportar_persona
                                                                                 (panyo,
                                                                                  reg.sseguro,
                                                                                  vnriesgo,
                                                                                  vpersona);
                                                   -- Bug 10053 - APD - 08/05/2009 - fin
                                                   vhpersonppa(vpersona) := pendiente;
                                                END IF;
                                             ELSIF NVL(f_parproductos_v(reg.sproduc,
                                                                        'TIPO_LIMITE'),
                                                       0) <> 0 THEN   -- PIAS
                                                IF vhpersonpias.EXISTS(vpersona) THEN
                                                   pendiente := vhpersonpias(vpersona);
                                                ELSE
                                                   SELECT pac_limites_ahorro.ff_importe_por_aportar_persona
                                                              (panyo,
                                                               f_parproductos_v(reg.sproduc,
                                                                                'TIPO_LIMITE'),
                                                               vpersona, reg.fcarpro)
                                                     INTO pendiente
                                                     FROM DUAL;

                                                   vhpersonpias(vpersona) := pendiente;
                                                END IF;
                                             END IF;

                                             IF pendiente <= 0 THEN
                                                ---> HA superado el l¿mite de aportaciones
                                                recibosi := 0;
                                             ELSIF pendiente > 0 THEN
                                                -- En este caso el importe es el de la prima o la diferencia entre lo pendeinte y la prima.
                                                SELECT icapital
                                                  INTO prima
                                                  FROM garancar
                                                 WHERE garancar.sseguro = reg.sseguro
                                                   AND garancar.cgarant = 48
                                                   AND garancar.ffinefe IS NULL
                                                   AND sproces = psproces;

                                                ----DBMS_OUTPUT.put_line ( 'prima ' || prima || ' pendiente ' || pendiente );
                                                IF prima > pendiente THEN
                                                   UPDATE garancar
                                                      SET ipritar = pendiente,
                                                          icaptot = pendiente,
                                                          iprianu = pendiente * reg.cforpag,
                                                          ipritot = pendiente * reg.cforpag
                                                    WHERE cgarant = 48
                                                      AND sseguro = reg.sseguro
                                                      AND garancar.ffinefe IS NULL
                                                      AND sproces = psproces;

                                                   NULL;
                                                END IF;

                                                recibosi := 2;
                                             END IF;
                                          EXCEPTION
                                             WHEN NO_DATA_FOUND THEN
                                                recibosi := 0;
                                          END;
                                       END IF;

                                       --> Fin de planes de pensiones o PIAS
                                       IF NVL(pac_parametros.f_parempresa_n(reg.cempres,
                                                                            'REASEGURO_EST'),
                                              0) = 1 THEN
                                          /** se hace el reaseguro del previo**/--JRB
                                          -- qt 17260
                                          IF pac_cesionesrea.producte_reassegurable
                                                                                  (reg.sproduc) =
                                                                                             1
                                             AND NVL(f_parproductos_v(reg.sproduc,
                                                                      'CARTERA_PSU'),
                                                     0) = 0 THEN
                                             --      REASEGURO
                                             -- Bug: 11623 AVT 28-10-2009 control del reaseguro abans de cridar a les funcions
                                             -- s'haur¿ d'acabar substituint per la crida a PAC_CESIONESREA.PRODUCTE_REASEGURABLE
                                             /*BEGIN
                                                                                                                                                                                                                                                                                                                                                                                                                                          SELECT creaseg
                                                  INTO w_creaseg
                                                  FROM productos
                                                 WHERE sproduc = p_sproduc;
                                             EXCEPTION
                                                WHEN NO_DATA_FOUND THEN
                                                   error := 104347;
                                                WHEN OTHERS THEN
                                                   error := 102705;
                                             END;
                                             IF w_creaseg = 1 THEN*/
                                             -- Bug: 11623 AVT 28-10-2009 fi
                                             IF algun_error = 0 THEN
                                                -- REASEGURO
                                                -- Bug 10782 - RSC - 24/07/2009 - CRE - Incid¿ncia Reaseguro Cr¿dit Salut
                                                IF n_retafrac = 1
                                                   --JRB p_fcarpro <> p_fcaranu
                                                   AND(reg.fcarpro <> reg.fcaranu) THEN   -- Motivo: 821
                                                   num_err :=
                                                      pac_cesionesrea.f_buscactrrea_est
                                                                                 (reg.sseguro,
                                                                                  pnmovimi,
                                                                                  psproces, 4,
                                                                                  pcmoneda, 1,
                                                                                  NULL, NULL,
                                                                                  'CAR');
                                                ELSE
                                                   -- Fin Bug 10782
                                                   num_err :=
                                                      pac_cesionesrea.f_buscactrrea_est
                                                                                 (reg.sseguro,
                                                                                  pnmovimi,
                                                                                  psproces, 5,
                                                                                  pcmoneda, 1,
                                                                                  NULL, NULL,
                                                                                  'CAR');
                                                END IF;

                                                IF num_err <> 0
                                                   AND num_err <> 99 THEN
                                                   algun_error := 1;
                                                   indice_error := indice_error + 1;
                                                ELSIF num_err = 99 THEN   -- Error controlado
                                                   --NULL; Per coher¿ncia amb el P_EMITIR_PROPUESTA.
                                                   num_err := 0;
                                                ELSE
                                                   -- Bug 10782 - RSC - 24/07/2009 - CRE - Incid¿ncia Reaseguro Cr¿dit Salut
                                                   IF n_retafrac = 1
                                                      --JRB p_fcarpro <> p_fcaranu
                                                      AND(reg.fcarpro <> reg.fcaranu) THEN   -- Motivo: 821
                                                      num_err :=
                                                         pac_cesionesrea.f_cessio_est
                                                                                   (psproces,
                                                                                    4,
                                                                                    pcmoneda,
                                                                                    f_sysdate,
                                                                                    0, 'CAR');
                                                   ELSE
                                                      -- Fin Bug 10782
                                                      num_err :=
                                                         pac_cesionesrea.f_cessio_est
                                                                                   (psproces,
                                                                                    5,
                                                                                    pcmoneda,
                                                                                    f_sysdate,
                                                                                    0, 'CAR');
                                                   END IF;

                                                   IF num_err <> 0
                                                      AND num_err <> 99 THEN
                                                      algun_error := 1;
                                                      indice_error := indice_error + 1;
                                                   ELSIF num_err = 99 THEN   -- Falta facultativo
                                                      -- Aturem la cartera si falta facultatiu i gravem l'error que ho indica
                                                      algun_error := 1;
                                                      indice_error := indice_error + 1;
                                                      texto :=
                                                            f_axis_literales(105382, pcidioma);
                                                      num_lin := NULL;
                                                      num_err :=
                                                         f_proceslin(psproces, texto,
                                                                     psseguro, num_lin);
                                                   -- Mantis 10251/10809.#6.01/06/2009.Ini.0010251: CRE - Incidencia Cartera con Facultativo.NMM.
                                                   -- FAL - 10/05/2011 - Bug 0018514: MSGV003 - Modificacions en la retenci¿ per facultatiu
                                                   -- Recupera el riesgo de facpendientes para insertar motivo retencion por riesgo

                                                   -- Bug 21167 - RSC - 03/02/2012 - LCOL_T001-LCOL - UAT - TEC: Incidencias del proceso de Cartera
                                                   -- Comentados todo esto ya que en el previo no debe retener ni modificar movseguro !!!
                                                   /*FOR reg IN
                                                      (SELECT DISTINCT (NVL(nriesgo, 1))
                                                                                   nriesgo
                                                                  FROM facpendientes
                                                                 WHERE sseguro = psseguro
                                                                   AND nmovimi = pnmovimi
                                                                   AND sproces = psproces) LOOP
                                                      num_err :=
                                                         pac_emision_mv.f_retener_poliza
                                                            (NULL, psseguro, reg.nriesgo,   -- num_risc
                                                             pnmovimi,
                                                             10   -- MOTIU RETENCIO ( Pendent quadre facultatiu)
                                                               ,
                                                             1   -- CODI RETENCIO
                                                              ,
                                                             pfemisio);
                                                   END LOOP;

                                                   UPDATE seguros
                                                   SET csituac = 5
                                                   WHERE sseguro = psseguro;

                                                   UPDATE movseguro
                                                   SET femisio = NULL
                                                   WHERE sseguro = psseguro
                                                     AND nmovimi = pnmovimi;
                                                   */
                                                   -- Mantis 10251/10809.#6.06/2009.Fi.
                                                   END IF;
                                                END IF;
                                             END IF;
                                          END IF;
                                       -- Bug: 11623 AVT Fi del IF...
                                       END IF;

                                       IF recibosi IN(1, 2) THEN
                                          num_err :=
                                             pac_propio.f_graba_com_adq(reg.sseguro, 0, 'P',
                                                                        psproces);

                                          -- Bug13607 ASN - 11/03/2010

                                          -- Bug 19777/95194 - 26/10/2011 -AMC

                                          -- ini Bug 0022583 - 24/08/2012 - JMF
                                          IF (NVL
                                                 (pac_parametros.f_parproducto_n
                                                                            (reg.sproduc,
                                                                             'PER_REV_NO_ANUAL'),
                                                  0) <> 0) THEN
                                             --IF f_es_renovacion(reg.sseguro) = 0 THEN   -- es cartera
                                             IF (f_renovacion_anual(reg.sseguro, v_fcaranu_x,
                                                                    reg.sproduc) = 404
                                                 OR f_es_renovacion(reg.sseguro) = 0) THEN
                                                v_cmodcom := 2;
                                             ELSE
                                                -- si es 1 es nueva produccion
                                                v_cmodcom := 1;
                                             END IF;
                                          ELSE
                                             IF f_es_renovacion(reg.sseguro) = 0 THEN   -- es cartera
                                                v_cmodcom := 2;
                                             ELSE
                                                -- si es 1 es nueva produccion
                                                v_cmodcom := 1;

                                                -- ini Bug 0022583 - 05/10/2012 - JMF
                                                -- Si la nueva fecha anual calculada, supera la fecha solicitada, es cartera.
                                                IF TO_CHAR(reg.fcaranu, 'yyyymm') >
                                                                   panyo || LPAD(pmes, 2, '0') THEN
                                                   v_cmodcom := 2;
                                                END IF;
                                             -- fin Bug 0022583 - 05/10/2012 - JMF
                                             END IF;
                                          END IF;

                                          -- fin Bug 0022583 - 24/08/2012 - JMF

                                          --BUG9028-XVM-01102009 inici
                                          IF NVL
                                                (pac_parametros.f_parinstalacion_n
                                                                              ('CALCULO_RECIBO'),
                                                 1) = 0 THEN
                                             IF (NVL(f_parproductos_v(reg.sproduc,
                                                                      'SEPARA_RIESGO_AHORRO'),
                                                     0) = 1
                                                 AND pac_seguros.f_tiene_garanahorro
                                                                                  (NULL,
                                                                                   reg.sseguro,
                                                                                   reg.fcarpro) =
                                                                                              1)
                                                OR NVL
                                                     (f_parproductos_v(reg.sproduc,
                                                                       'SEPARA_RIESGO_AHORRO'),
                                                      0) = 0 THEN
                                                num_err :=
                                                   pac_adm.f_recries(reg.ctipreb, reg.sseguro,
                                                                     NULL, pfemisio,
                                                                     reg.fcarant, reg.fcarpro,
                                                                     3, reg.nanuali,
                                                                     reg.nfracci, NULL, NULL,
                                                                     psproces, 21, 'P',
                                                                     v_cmodcom, reg.fcaranu,
                                                                     NULL, pcmovimi, pcempres,
                                                                     pnmovimi, 1, pnimport2);
                                             END IF;
                                          ELSE
                                             IF (NVL(f_parproductos_v(reg.sproduc,
                                                                      'SEPARA_RIESGO_AHORRO'),
                                                     0) = 1
                                                 AND pac_seguros.f_tiene_garanahorro
                                                                                  (NULL,
                                                                                   reg.sseguro,
                                                                                   reg.fcarpro) =
                                                                                              1)
                                                OR NVL
                                                     (f_parproductos_v(reg.sproduc,
                                                                       'SEPARA_RIESGO_AHORRO'),
                                                      0) = 0 THEN
                                                num_err :=
                                                   f_recries(reg.ctipreb, reg.sseguro, NULL,
                                                             pfemisio, reg.fcarant,
                                                             reg.fcarpro, 3, reg.nanuali,
                                                             reg.nfracci, NULL, NULL,
                                                             psproces, 21, 'P', v_cmodcom,
                                                             reg.fcaranu, NULL, pcmovimi,
                                                             pcempres, pnmovimi, 1, pnimport2);
                                             END IF;
                                          END IF;

                                          -- Fi Bug 19777/95194 - 26/10/2011 -AMC

                                          --BUG9028-XVM-01102009 fi

                                          -- RSC 06/02/2008 Actualizamos lo que le queda pendiente a esta persona
                                          -- para que al intentar generar otro recibo en la cartera de esta persona
                                          -- tenga en cuenta los l¿mites de pendiente que tiene actualmente una vez
                                          -- generado ya algun recibo previo en la cartera.
                                          IF NVL(f_parproductos_v(reg.sproduc, 'APORTMAXIMAS'),
                                                 0) = 1 THEN
                                             vhpersonppa(vpersona) :=
                                                                  vhpersonppa(vpersona)
                                                                  - prima;
                                          ELSIF NVL(f_parproductos_v(reg.sproduc,
                                                                     'TIPO_LIMITE'),
                                                    0) <> 0 THEN
                                             vhpersonpias(vpersona) :=
                                                                 vhpersonpias(vpersona)
                                                                 - prima;
                                          END IF;
                                       ELSE
                                          num_err := 0;
                                       END IF;

                                       ----DBMS_OUTPUT.put_line(pnimport2 || 'alberto f_recries '|| num_err);
                                       IF num_err <> 0 THEN
                                          algun_error := 1;
                                          indice_error := indice_error + 1;
                                       ELSE
                                          -- Bug 19096 - RSC - 03/08/2011 - LCOL - Parametrizaci¿n b¿sica producto Vida Individual Pagos Permanentes (Afegim 'RRIE')
                                          IF NVL(f_parproductos_v(reg.sproduc,
                                                                  'SEPARA_RIESGO_AHORRO'),
                                                 0) = 1 THEN
                                             -- Obtenemos el recibo de ahorro generado
                                             -- Bug 19777/95194 - 26/10/2011 -AMC

                                             -- ini Bug 0022583 - 24/08/2012 - JMF
                                             IF (NVL
                                                    (pac_parametros.f_parproducto_n
                                                                            (reg.sproduc,
                                                                             'PER_REV_NO_ANUAL'),
                                                     0) <> 0) THEN
                                                --IF f_es_renovacion(reg.sseguro) = 0 THEN   -- es cartera
                                                IF (f_renovacion_anual(reg.sseguro,
                                                                       v_fcaranu_x,
                                                                       reg.sproduc) = 404
                                                    OR f_es_renovacion(reg.sseguro) = 0) THEN
                                                   v_cmodcom := 2;
                                                ELSE
                                                   -- si es 1 es nueva produccion
                                                   v_cmodcom := 1;
                                                END IF;
                                             ELSE
                                                IF f_es_renovacion(reg.sseguro) = 0 THEN   -- es cartera
                                                   v_cmodcom := 2;
                                                ELSE
                                                   -- si es 1 es nueva produccion
                                                   v_cmodcom := 1;

                                                   -- ini Bug 0022583 - 05/10/2012 - JMF
                                                   -- Si la nueva fecha anual calculada, supera la fecha solicitada, es cartera.
                                                   IF TO_CHAR(reg.fcaranu, 'yyyymm') >
                                                                   panyo || LPAD(pmes, 2, '0') THEN
                                                      v_cmodcom := 2;
                                                   END IF;
                                                -- fin Bug 0022583 - 05/10/2012 - JMF
                                                END IF;
                                             END IF;

                                             -- fin Bug 0022583 - 24/08/2012 - JMF
                                             IF NVL
                                                   (pac_parametros.f_parinstalacion_n
                                                                              ('CALCULO_RECIBO'),
                                                    1) = 0 THEN
                                                num_err :=
                                                   pac_adm.f_recries(reg.ctipreb, reg.sseguro,
                                                                     NULL, pfemisio,
                                                                     reg.fcarant, reg.fcarpro,
                                                                     3, reg.nanuali,
                                                                     reg.nfracci, NULL, NULL,
                                                                     psproces, 21, 'PRIE',
                                                                     v_cmodcom, reg.fcaranu,
                                                                     NULL, pcmovimi, pcempres,
                                                                     pnmovimi, 1, pnimport2);
                                             ELSE
                                                num_err :=
                                                   f_recries(reg.ctipreb, reg.sseguro, NULL,
                                                             pfemisio, reg.fcarant,
                                                             reg.fcarpro, 3, reg.nanuali,
                                                             reg.nfracci, NULL, NULL,
                                                             psproces, 21, 'PRIE', v_cmodcom,
                                                             reg.fcaranu, NULL, pcmovimi,
                                                             pcempres, pnmovimi, 1, pnimport2);
                                             END IF;

                                             -- Fi Bug 19777/95194 - 26/10/2011 -AMC
                                             IF num_err <> 0 THEN
                                                algun_error := 1;
                                                indice_error := indice_error + 1;
                                             ELSE
                                                NULL;
                                             END IF;
                                          END IF;
                                       -- Fin Bug 19096
                                       END IF;
                                    END IF;
                                 -- De si la forma de pago no es ¿nica.
                                 END IF;   -- De sin error en f_acproxcar
                              ELSE   -- De error en f_garantarifa
                                 algun_error := 1;
                                 indice_error := indice_error + 1;
                              --                              EXIT;
                              END IF;
                           ELSE
                              algun_error := 1;
                              indice_error := indice_error + 1;
                           END IF;
                        -- Bug 23940 - APD - 29/10/2012 - de algun_error en PSU POST
                        END IF;   -- Validar regulariza
                     END IF;   -- Bonificacio
                  END IF;   -- fin Bug 27048/155371 - APD - 17/12/2013
               ELSE   --  fcarpro <> fcaranu
                  v_fcarpro_x := reg.fcarpro;
                                             --Bug 28832 -- JMG -- 03/12/2013
                  --Llamamos la funci¿n que actualiza datos de la pr¿xima cartera-----
                  num_err := f_acproxcar(reg.sseguro, reg.fcarant, reg.fcarpro, reg.fcaranu,
                                         reg.nanuali, reg.nfracci, reg.frenova);

                  IF num_err <> 0 THEN
                     algun_error := 1;
                     indice_error := indice_error + 1;
                  ELSE
                     --15/1/99 YIL. Se controlan las p¿lizas de ahorro
                     IF pcagrpro = 2 THEN   ---es una p¿liza de ahorro
                        pcmovimi := 2;   -- indica aportaci¿n peri¿dica
                     ELSE
                        pcmovimi := NULL;
                     END IF;

                     --Llamamos la funci¿n de calcular recibos
                     IF NVL(pac_parametros.f_parempresa_n(reg.cempres, 'FEMISIO_IS_SYSDATE'),
                            0) = 1 THEN
                        pfemisio := f_sysdate;
                     ELSE
                        pfemisio := TO_DATE('1/' || TO_CHAR(TO_NUMBER(pmes)) || '/'
                                            || TO_CHAR(panyo),
                                            'dd/mm/yyyy');
                     END IF;

                     -- 17/6/99 YIL. Se mira si es nueva producci¿n o cartera para
                     -- aplicar como modo de comision un 1 o un 2
                     IF f_es_renovacion(reg.sseguro) = 0 THEN   -- es cartera
                        modcom := 2;
                     ELSE   -- si es 1 es nueva produccion
                        modcom := 1;
                     END IF;

                     -- Bug 22583 - XVM - 26/03/2013
                     -- ini Bug 0022583 - 22/11/2012 - JMF
                     -- Si la nueva fecha anual calculada, supera la fecha solicitada, es cartera.
                     /*IF TO_CHAR(reg.fcaranu, 'yyyymm') > panyo || LPAD(pmes, 2, '0') THEN
                        modcom := 2;
                     END IF;*/

                     -- Ini Bug 28832 -- ECP -- 13/11/2016
                      -- Bug 28832 -- JMG -- 03/12/2013 -- Se modifica v_fcaranu_x por v_fcarpro_x
                     IF (NVL(pac_parametros.f_parproducto_n(reg.sproduc, 'PER_REV_NO_ANUAL'),
                             0) <> 0) THEN
                        IF (f_renovacion_anual(reg.sseguro, v_fcarpro_x, reg.sproduc) = 404
                            OR f_es_renovacion(reg.sseguro) = 0) THEN
                           modcom := 2;
                        ELSE   -- si es 1 es nueva produccion
                           modcom := 1;
                        END IF;
                     ELSE
                        IF f_es_renovacion(reg.sseguro) = 0 THEN   -- es cartera
                           modcom := 2;
                        ELSE   -- si es 1 es nueva produccion
                           modcom := 1;

                           IF TO_CHAR(reg.fcaranu, 'yyyymm') > panyo || LPAD(pmes, 2, '0') THEN
                              modcom := 2;
                           END IF;
                        -- fin Bug 0022583 - 05/10/2012 - JMF
                        END IF;
                     END IF;

                     -- Fin Bug 28832 -- ECP -- 13/11/2016
                     -- fin Bug 0022583 - 22/11/2012 - JMF
                     -- Bug 22583 - XVM - 26/03/2013

                     --Averiguamos el nmovimi
                     num_err := f_buscanmovimi(reg.sseguro, 1, 1, pnmovimi);

                     ----DBMS_OUTPUT.put_line('f_busca '|| num_err);
                     IF num_err <> 0 THEN
                        algun_error := 1;
                        indice_error := indice_error + 1;
                     ELSE
                        --********** PLANES DE PENSIONES **********
                        -- Vamos a calcular si podemos hacer el recibo y no superamos
                        -- el l¿mite de aportaciones maximas solo en pp.
                        --DBMS_OUTPUT.put_line ( pnimport2 || 'nO ES RENOVACION prima m¿nima: ' || liprimin ) ;
                        recibosi := 1;
                        -- Si tieneparte de prestaciones en PP NO GENERAMOS RECIBO
                        prestacion := 0;

                        IF reg.cagrpro = 11 THEN
                           SELECT COUNT(1)
                             INTO prestacion
                             FROM prestaplan
                            WHERE prestaplan.sseguro = reg.sseguro;
                        END IF;

                        -- Bug 0017382 - 26/01/2011 - RSC
                        -- S¿ el producto es de ahorro, se busca el n¿mero de recibos pendientes que tiene la p¿liza
                        --IF f_prod_ahorro(reg.sproduc) = 1 THEN
                        --   SELECT f_recpen_pp(reg.sseguro, 1)
                        --     INTO recpendi
                        --     FROM DUAL;
                        --ELSE
                        --   recpendi := 0;
                        --END IF;
                        recpendi := 0;

                        IF prestacion > 0
                           OR recpendi > 1 THEN
                           recibosi := 0;
                        ELSIF (NVL(f_parproductos_v(reg.sproduc, 'APORTMAXIMAS'), 0) = 1
                               OR NVL(f_parproductos_v(reg.sproduc, 'TIPO_LIMITE'), 0) <> 0)
                              AND prestacion = 0 THEN
                           DECLARE
                              pendiente      garancar.ipritar%TYPE;
--                               pendiente      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
                           BEGIN
                              --DBMS_OUTPUT.PUT_LINE ( 'ENTRAMOS A BUSCAR EL RIESGO' || REG.SSEGURO);
                              SELECT riesgos.sperson, riesgos.nriesgo
                                INTO vpersona, vnriesgo
                                FROM riesgos
                               WHERE riesgos.sseguro = reg.sseguro
                                 AND riesgos.fanulac IS NULL;

                              IF NVL(f_parproductos_v(reg.sproduc, 'APORTMAXIMAS'), 0) = 1 THEN
                                 IF vhpersonppa.EXISTS(vpersona) THEN
                                    pendiente := vhpersonppa(vpersona);
                                 ELSE
                                    -- Bug 10053 - APD - 08/05/2009 - se sustituye la funcion f_maxapor_pp por
                                    -- pac_ppa_planes.ff_importe_por_aportar_persona
                                    pendiente :=
                                       pac_ppa_planes.ff_importe_por_aportar_persona
                                                                                 (panyo,
                                                                                  reg.sseguro,
                                                                                  vnriesgo,
                                                                                  vpersona);
                                    -- Bug 10053 - APD - 08/05/2009 - fin
                                    vhpersonppa(vpersona) := pendiente;
                                 END IF;
                              ELSIF NVL(f_parproductos_v(reg.sproduc, 'TIPO_LIMITE'), 0) <> 0 THEN
                                 IF vhpersonpias.EXISTS(vpersona) THEN
                                    pendiente := vhpersonpias(vpersona);
                                 ELSE
                                    SELECT pac_limites_ahorro.ff_importe_por_aportar_persona
                                                              (panyo,
                                                               f_parproductos_v(reg.sproduc,
                                                                                'TIPO_LIMITE'),
                                                               vpersona, reg.fcarpro)
                                      INTO pendiente
                                      FROM DUAL;

                                    vhpersonpias(vpersona) := pendiente;
                                 END IF;
                              END IF;

                              IF pendiente < 0 THEN   ---> HA superado el l¿mite de aportaciones
                                 recibosi := 0;
                              ELSIF pendiente >= 0 THEN   --AND PENDIENTE >=  liprimin THEN
                                 -- En este caso el importe es el de la prima o la diferencia entre lo pendiente y la prima.
                                 BEGIN
                                    SELECT icapital
                                      INTO prima
                                      FROM garanseg
                                     WHERE garanseg.sseguro = reg.sseguro
                                       AND garanseg.cgarant = 48
                                       AND garanseg.ffinefe IS NULL;
                                 EXCEPTION
                                    WHEN OTHERS THEN
                                       NULL;
                                 END;

                                 IF prima > pendiente THEN
                                    prima := pendiente;
                                 END IF;

                                 recibosi := 2;
                              END IF;
                           EXCEPTION
                              WHEN OTHERS THEN
                                 recibosi := 0;
                           END;
                        END IF;   --> Fin de planes de pensiones o PIAS

                        IF recibosi IN(1, 2) THEN
                           --BUG9028-XVM-01102009 inici
                           IF NVL(pac_parametros.f_parinstalacion_n('CALCULO_RECIBO'), 1) = 0 THEN
                              num_err := pac_adm.f_recries(reg.ctipreb, reg.sseguro, NULL,
                                                           pfemisio, reg.fcarant, reg.fcarpro,
                                                           3, reg.nanuali, reg.nfracci, NULL,
                                                           NULL, psproces, 22, 'P', modcom,
                                                           reg.fcaranu, NULL, pcmovimi,
                                                           pcempres, pnmovimi, 1, pnimport2);
                           ELSE
                              num_err := f_recries(reg.ctipreb, reg.sseguro, NULL, pfemisio,
                                                   reg.fcarant, reg.fcarpro, 3, reg.nanuali,
                                                   reg.nfracci, NULL, NULL, psproces, 22, 'P',
                                                   modcom, reg.fcaranu, NULL, pcmovimi,
                                                   pcempres, pnmovimi, 1, pnimport2);
                           END IF;

                           --BUG9028-XVM-01102009 fi

                           -- RSC 06/02/2008 Actualizamos lo que le queda pendiente a esta persona
                           -- para que al intentar generar otro recibo en la cartera de esta persona
                           -- tenga en cuenta los l¿mites de pendiente que tiene actualmente una vez
                           -- generado ya algun recibo previo en la cartera.
                           IF NVL(f_parproductos_v(reg.sproduc, 'APORTMAXIMAS'), 0) = 1 THEN
                              vhpersonppa(vpersona) := vhpersonppa(vpersona) - prima;
                           ELSIF NVL(f_parproductos_v(reg.sproduc, 'TIPO_LIMITE'), 0) <> 0 THEN
                              vhpersonpias(vpersona) := vhpersonpias(vpersona) - prima;
                           END IF;

                           -- Si el recibo es de planes de pensiones puede que revalorize
                           -- con lo que modificamos el informe revalorizado para que se visualice
                           -- en el listado.
                           IF NVL(f_parproductos_v(reg.sproduc, 'APORTMAXIMAS'), 0) = 1
                              OR NVL(f_parproductos_v(reg.sproduc, 'TIPO_LIMITE'), 0) <> 0 THEN
                              UPDATE vdetreciboscar
                                 SET iprinet = prima,
                                     itotpri = prima,
                                     itotalr = prima
                               WHERE nrecibo = (SELECT MAX(nrecibo)
                                                  FROM reciboscar
                                                 WHERE sseguro = reg.sseguro
                                                   AND vdetreciboscar.nrecibo =
                                                                             reciboscar.nrecibo);

                              -- BUG 18423 - 21/12/2011 - JMP - LCOL705 - Multimoneda
                              IF NVL(pac_parametros.f_parempresa_n(reg.cempres, 'MULTIMONEDA'),
                                     0) = 1 THEN
                                 v_cmonpol := pac_oper_monedas.f_monpol(reg.sseguro);

                                 SELECT MAX(fcambio), MAX(nrecibo)
                                   INTO v_max_fcambio, v_nrecibo
                                   FROM detreciboscar
                                  WHERE nrecibo =
                                           (SELECT MAX(r.nrecibo)
                                              FROM vdetreciboscar_monpol v, reciboscar r
                                             WHERE r.sseguro = reg.sseguro
                                               AND v.nrecibo = r.nrecibo);

                                 IF v_max_fcambio IS NOT NULL THEN
                                    num_err :=
                                       pac_oper_monedas.f_datos_contraval(reg.sseguro, NULL,
                                                                          NULL, v_max_fcambio,
                                                                          1, v_itasa,
                                                                          v_fcambio);

                                    UPDATE vdetreciboscar_monpol v
                                       SET iprinet = f_round(prima * v_itasa, v_cmonpol),
                                           itotpri = f_round(prima * v_itasa, v_cmonpol),
                                           itotalr = f_round(prima * v_itasa, v_cmonpol)
                                     WHERE nrecibo = v_nrecibo;
                                 END IF;
                              END IF;
                           -- FIN BUG 18423 - 21/12/2011 - JMP - LCOL705 - Multimoneda
                           END IF;
                        END IF;

                        IF num_err <> 0 THEN
                           algun_error := 1;
                           indice_error := indice_error + 1;
                        ELSE
                           -- Bug 19096 - RSC - 03/08/2011 - LCOL - Parametrizaci¿n b¿sica producto Vida Individual Pagos Permanentes (Afegim 'RRIE')
                           IF NVL(f_parproductos_v(reg.sproduc, 'SEPARA_RIESGO_AHORRO'), 0) =
                                                                                             1 THEN
                              -- Obtenemos el recibo de ahorro generado
                              /*
                              BEGIN
                                  SELECT r.nrecibo
                                  INTO v_recibo_ahorro
                                  FROM reciboscar r, seguros s
                                  WHERE r.sseguro = reg.sseguro
                                    AND r.sseguro = s.sseguro
                                    AND 3 = (SELECT DISTINCT NVL(f_pargaranpro_v(s.cramo,
                                                                                 s.cmodali,
                                                                                 s.ctipseg,
                                                                                 s.ccolect,
                                                                                 NVL(s.cactivi, 0),
                                                                                 d.cgarant,'TIPO'), 0)
                                             FROM detreciboscar d
                                             WHERE nrecibo = r.nrecibo)
                                    AND r.fefecto = reg.fcarant
                                    AND r.fvencim = reg.fcarpro
                                    AND r.ctiprec = 3;
                              EXCEPTION
                                 WHEN NO_DATA_FOUND THEN
                                     NULL;
                              END;
                              */
                              IF NVL(pac_parametros.f_parinstalacion_n('CALCULO_RECIBO'), 1) =
                                                                                             0 THEN
                                 num_err := pac_adm.f_recries(reg.ctipreb, reg.sseguro, NULL,
                                                              pfemisio, reg.fcarant,
                                                              reg.fcarpro, 3, reg.nanuali,
                                                              reg.nfracci, NULL, NULL,
                                                              psproces, 22, 'PRIE', modcom,
                                                              reg.fcaranu, NULL, pcmovimi,
                                                              pcempres, pnmovimi, 1,
                                                              pnimport2);
                              ELSE
                                 num_err := f_recries(reg.ctipreb, reg.sseguro, NULL,
                                                      pfemisio, reg.fcarant, reg.fcarpro, 3,
                                                      reg.nanuali, reg.nfracci, NULL, NULL,
                                                      psproces, 22, 'PRIE', modcom,
                                                      reg.fcaranu, NULL, pcmovimi, pcempres,
                                                      pnmovimi, 1, pnimport2);
                              END IF;

                              IF num_err <> 0 THEN
                                 algun_error := 1;
                                 indice_error := indice_error + 1;
                              ELSE
-------------------------------------------------------------------
-- De momento en modo previo no vamos a fusionar recibos.        --
-- (Ver c¿digo comentado. Se deber¿a modificar la f_agruparecibo --
--  para permitir la creaci¿n de recibos en las tablas CAR sin   --
--  insertar en ADM_RECUNIF).                                    --
-------------------------------------------------------------------
                                 NULL;
                              /*
                              -- Aqui tenemos que fusionar los dos recibos (si es que hay dos)
                              -- Obtenemos el recibo de riesgo generado
                              BEGIN
                                  SELECT r.nrecibo
                                  INTO v_recibo_riesgo
                                  FROM recibos r, seguros s
                                  WHERE r.sseguro = reg.sseguro
                                    AND r.sseguro = s.sseguro
                                    AND 6 = (SELECT DISTINCT NVL(f_pargaranpro_v(s.cramo,
                                                                                 s.cmodali,
                                                                                 s.ctipseg,
                                                                                 s.ccolect,
                                                                                 NVL(s.cactivi, 0),
                                                                                 d.cgarant,'TIPO'), 0)
                                             FROM detrecibos d
                                             WHERE nrecibo = r.nrecibo)
                                    AND r.fefecto = reg.fcarant
                                    AND r.fvencim = reg.fcarpro
                                    AND r.ctiprec = 3;
                              EXCEPTION
                                 WHEN NO_DATA_FOUND THEN
                                     NULL;
                              END;


                              IF v_recibo_ahorro IS NOT NULL AND v_recibo_riesgo IS NOT NULL THEN

                                 -- Necesario para la agrupacion
                                 UPDATE recibos
                                 SET cestaux = 2
                                 WHERE nrecibo IN (v_recibo_ahorro, v_recibo_riesgo);

                                 v_listarec := t_lista_id();
                                 v_obrec := ob_lista_id();
                                 v_obrec.idd := v_recibo_ahorro;
                                 v_listarec.EXTEND;
                                 v_listarec(v_listarec.LAST) := v_obrec;

                                 v_obrec := ob_lista_id();
                                 v_obrec.idd := v_recibo_riesgo;
                                 v_listarec.EXTEND;
                                 v_listarec(v_listarec.LAST) := v_obrec;

                                 num_err := pac_gestion_rec.f_agruparecibo(NULL, NULL, NULL, NULL, v_listarec, lctiprec, 'P');

                                 IF num_err <> 0 THEN
                                     algun_error := 1;
                                     indice_error := indice_error + 1;
                                 END IF;
                              END IF;*/
                              END IF;
                           END IF;
                        -- Fin Bug 19096
                        END IF;
                     END IF;
                  END IF;   -- f_acproxcar
               END IF;   -- fcaranu=fcarpro
            ELSE   -- if anlgun error
               EXIT;
            END IF;   -- if algun error

            IF algun_error = 0 THEN
               --22/10/98 YIL. Se borran los registros de GARANCAR
               COMMIT;
            ELSE
               ROLLBACK;
               texto := f_axis_literales(num_err, pcidioma);
               ----DBMS_OUTPUT.put_line(
               --    ' rollback '|| num_err || texto || psproces);
               texto := texto || '.' || reg.sseguro;
               num_lin := NULL;
               num_err := f_proceslin(psproces, texto, reg.sseguro, num_lin);

               IF num_err = 0 THEN
                  COMMIT;
               END IF;
            END IF;
         END LOOP;
      END IF;

      RETURN 0;
   END p_previ_cartera_psu;

   /******************************************************************************
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    NOMBRE:       PREVI_CARTERA_TAR
       PROP¿SITO:    Realizar el previo de cartera.
       REVISIONES:
       Ver        Fecha        Autor             Descripci¿n
       ---------  ----------  ---------------  ------------------------------------
        1.0       -            -               1. Creaci¿n de funci¿n
        8.0        14/05/2009  APD             10. Bug 10053: Se modifica la funcion f_maxapor_pp por pac_ppa_planes.ff_importe_por_aportar_persona
        9.0        28/05/2009  RSC             11. Se incluye ajuste de suplementos autom¿ticos (fraccionarios)
        10.0       09/12/2010  JMP             12. (CEM) No renovamos si fecha de revisi¿n anterior a la de renovaci¿n
    ******************************************************************************/

   /******************************************************************************
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    NOMBRE:       PREVI_CARTERA_TAR
       PROP¿SITO:    Realizar el previo de cartera.
       REVISIONES:
       Ver        Fecha        Autor             Descripci¿n
       ---------  ----------  ---------------  ------------------------------------
        1.0       -            -               1. Creaci¿n de funci¿n
        8.0        14/05/2009  APD             10. Bug 10053: Se modifica la funcion f_maxapor_pp por pac_ppa_planes.ff_importe_por_aportar_persona
        9.0        28/05/2009  RSC             11. Se incluye ajuste de suplementos autom¿ticos (fraccionarios)
        10.0       09/12/2010  JMP             12. (CEM) No renovamos si fecha de revisi¿n anterior a la de renovaci¿n
    ******************************************************************************/
   PROCEDURE previ_cartera_tar(
      pcempres IN NUMBER,
      pmes IN NUMBER,
      panyo IN NUMBER,
      pnpoliza IN NUMBER,
      pncertif IN NUMBER,
      -- BUG 8339 --pcramo IN NUMBER, pcmodali IN NUMBER, pctipseg IN NUMBER,
      -- BUG 8339 --pccolect IN NUMBER, pcactivi IN NUMBER,
      pcidioma IN NUMBER,
      psproces IN NUMBER,
      indice OUT NUMBER,
      indice_error OUT NUMBER,
      prenuevan IN NUMBER DEFAULT 0,
      pfcartera IN DATE DEFAULT NULL) IS
      parms_transitorios pac_parm_tarifas.parms_transitorios_tabtyb;
      num_lin        NUMBER;
      lfcartera      VARCHAR2(10);
      lfcartera2     VARCHAR2(10);
      pnrecibo       recibos.nrecibo%TYPE;
      recibosi       NUMBER;
      prima          garanseg.icapital%TYPE;
      --       prima          NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      pcsubpro       productos.csubpro%TYPE;
      --       pcsubpro       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      num_err        NUMBER := 0;
      num_err2       NUMBER := 0;
      prestacion     NUMBER;
      recpendi       NUMBER;
      texto          VARCHAR2(100);
      algun_error    NUMBER := 0;
      fcarpronueva   DATE;   --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      fcarantnueva   DATE;   --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      fcaranunueva   DATE;   --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      nanualinueva   NUMBER;
      --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      nfraccinueva   NUMBER;
      --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      frenovanueva   DATE;
      tipo           codiram.cgtarif%TYPE;
      --       tipo           NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      pcobjase       productos.cobjase%TYPE;
      --       pcobjase       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      fec            DATE;
      pnmovimi       notibajagar.nmovimb%TYPE;
      --       pnmovimi       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      pfemisio       DATE;
      texto2         VARCHAR2(60);
      pcagrpro       productos.cagrpro%TYPE;
      --       pcagrpro       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      num            NUMBER;
      piregula       NUMBER;
      v_factor       NUMBER;
      num_risc       NUMBER;
      pcmovimi       NUMBER;
      pnimport2      NUMBER;
      modcom         NUMBER;
      lbonifica      NUMBER;
      laplica_bonifica NUMBER;
      lcumple        NUMBER;
      lcactivi       NUMBER;
      lmov           NUMBER;
      -- No serveix per r¿s, ¿s un par. de sortida per la cartera
      lanu           NUMBER;
      -- No serveix per r¿s, ¿s un par. de sortida per la cartera
      lsproduc_ant   NUMBER;
      lcprimin       NUMBER;
      liprimin       NUMBER;
      lcclapri       NUMBER;
      lcgarant_regu  NUMBER;
      lnorden        NUMBER;
      pcmoneda       NUMBER;
      pnedamar       productos.nedamar%TYPE;
      --       pnedamar       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      pciedmar       productos.ciedmar%TYPE;
      --       pciedmar       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      psseguro       garanseggas.sseguro%TYPE;
      --       psseguro       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      v_ctipo        cfg_plantillas_tipos.ctipo%TYPE;
      vdescrip       cfg_plantillas_tipos.tdescrip%TYPE;
      v_diasnoti     medcobpro.diasnoti%TYPE;
      v_conta_noti   NUMBER;
      v_sperson_tom  tomadores.sperson%TYPE;
      v_per_notif_prefe per_parpersonas.nvalpar%TYPE;
      v_email        per_contactos.tvalcon%TYPE;
      -- ozea -- BUG:0035712 Tarea: 0202997
      v_asunto       axis_literales.tlitera%TYPE;

      -- ozea -- BUG:0035712 Tarea: 0202997
      TYPE t_cursor IS REF CURSOR;

      c_seguro       t_cursor;
      v_sel          VARCHAR2(4000);
      v_mensa        VARCHAR2(100);

      CURSOR c_motextra IS
         SELECT DISTINCT (sseguro) sseguro
                    FROM extrarec
                   WHERE nrecibo IS NULL
                     AND ADD_MONTHS(falta, f_parinstalacion_n('CEXTRNMES')) <= f_sysdate;

      CURSOR c_prod IS
         SELECT *
           FROM carteraaux
          WHERE sproces = psproces;

      CURSOR c_seg(wram NUMBER, wmod NUMBER, wtip NUMBER, wcol NUMBER) IS
         SELECT   s.*
             FROM seguros s, seguroscol sc
            WHERE s.cramo = wram
              AND s.cmodali = wmod
              AND s.ctipseg = wtip
              AND s.ccolect = wcol
              AND s.npoliza = NVL(pnpoliza, s.npoliza)
              AND s.ncertif = NVL(pncertif, s.ncertif)
              AND s.sseguro = sc.sseguro(+)
              AND((s.csituac = 5)
                  OR(s.creteni = 0
                     AND s.csituac NOT IN(7, 8, 9, 10)))
              AND s.fcarpro <
                    DECODE(pfcartera,
                           NULL, DECODE(sc.ctipcob,
                                        1, ADD_MONTHS((LAST_DAY(TO_DATE(LPAD(pmes, 2, '0')
                                                                        || panyo,
                                                                        'mmyyyy'))
                                                       + 1),
                                                      -1),
                                        (LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo,
                                                          'mmyyyy'))
                                         + 1)),
                           DECODE(sc.ctipcob, 1, ADD_MONTHS(pfcartera + 1, -1), pfcartera + 1))
              AND(s.fvencim > DECODE(pfcartera,
                                     NULL, DECODE
                                              (sc.ctipcob,
                                               1, ADD_MONTHS
                                                           ((LAST_DAY(TO_DATE(LPAD(pmes, 2,
                                                                                   '0')
                                                                              || panyo,
                                                                              'mmyyyy'))),
                                                            -1),
                                               (LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo,
                                                                 'mmyyyy')))),
                                     DECODE(sc.ctipcob,
                                            1, ADD_MONTHS(pfcartera, -1),
                                            pfcartera))
                  OR(s.fvencim <=
                        DECODE(pfcartera,
                               NULL, DECODE(sc.ctipcob,
                                            1, ADD_MONTHS((LAST_DAY(TO_DATE(LPAD(pmes, 2, '0')
                                                                            || panyo,
                                                                            'mmyyyy'))),
                                                          -1),
                                            (LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo,
                                                              'mmyyyy')))),
                               DECODE(sc.ctipcob, 1, ADD_MONTHS(pfcartera, -1), pfcartera))
                     AND TO_CHAR(s.fvencim, 'mmyyyy') =
                           DECODE(pfcartera,
                                  NULL, DECODE(sc.ctipcob,
                                               1, TO_CHAR
                                                         (ADD_MONTHS(TO_DATE('01'
                                                                             || LPAD(pmes, 2,
                                                                                     '0')
                                                                             || panyo,
                                                                             'ddmmyyyy'),
                                                                     -1),
                                                          'mmyyyy'),
                                               LPAD(pmes, 2, '0') || panyo),
                                  DECODE(sc.ctipcob,
                                         1, TO_CHAR(ADD_MONTHS(pfcartera, -1), 'mmyyyy'),
                                         TO_CHAR(pfcartera, 'mmyyyy')))
                     AND s.fvencim > s.fcarpro
                     AND NVL(f_parproductos_v(s.sproduc, 'RECMESVENCI'), 1) = 1)
                  OR s.fvencim IS NULL)
              AND(EXISTS(
                     SELECT sseguro
                       FROM movseguro m
                      WHERE nmovimi =
                               (SELECT MAX(nmovimi)
                                  FROM movseguro m3
                                 WHERE m3.sseguro = m.sseguro
                                   AND TRUNC(m3.fefecto) <=
                                         DECODE
                                            (pfcartera,
                                             NULL, DECODE
                                                (sc.ctipcob,
                                                 1, ADD_MONTHS
                                                            (LAST_DAY(TO_DATE(LPAD(pmes, 2,
                                                                                   '0')
                                                                              || panyo,
                                                                              'mmyyyy')),
                                                             -1),
                                                 LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo,
                                                                  'mmyyyy'))),
                                             DECODE(sc.ctipcob,
                                                    1, ADD_MONTHS(pfcartera, -1),
                                                    pfcartera))
                                   AND m3.cmovseg NOT IN(6, 52))
                        -- Bug 29665/177284 - 12/06/2014 - AMC
                        AND cmovseg <> 3
                        AND femisio IS NOT NULL
                        AND sseguro = s.sseguro)
                  OR(s.csituac = 5
                     AND s.ccartera = 1))
              AND NVL(f_ultima_cartera(s.sseguro, s.fcarpro), s.fcarpro) >= s.fcarpro
              -- Bug 23940 - APD - 13/11/2012 - la poliza no puede estar bloqueada para cartera
              AND NVL(s.cbloqueocol, 0) <> 1
         ORDER BY s.npoliza;

      -- RSC 06/02/2008 -----------------------------------------------------------
      /*
                                                                   Se debe tener en cuenta que para cada l¿mite que se a¿ada en este funci¿n como
       tratamiento para los c¿mulos se deber¿ crear una tabla de este tipo. La raz¿n es
       que utilizamos un hash de este tipo para ir almacenando los valores de "aportaciones
       pendientes" que se permiten seg¿n el l¿mite que estemos tratando para cada persona.
       Ejemplo: Al tratar la primera p¿liza de la persona X de un producto PIAS se le permiten 200 ¿.
                Si el previo de cartera dice que generar¿ un recibo de 200¿ como aportaci¿n
                periodica entonces esta persona X tendr¿ 0¿ pendientes para el resto de p¿lizas
                del mismo tipo. Es decir en iteraciones posteriores ya no tendr¿ 200¿ pendientes
                sino 0.
                Este asunto lo solucionamos con estos hash.
                Hemos de crear un TABLE de este tipo para cada tipo de l¿mite que tratemos.
                Ahora mismo se trata de la siguiente manera:
                IF NVL(f_parproductos_v(reg.sproduc, 'APORTMAXIMAS'),0) = 1 THEN        ----> PPA
                  vhpersonppa(vpersona) := vhpersonppa(vpersona) - prima;
                ELSIF NVL(f_parproductos_v(reg.sproduc, 'TIPO_LIMITE'),0) <> 0 THEN     ----> Pias
                  vhpersonpias(vpersona) := vhpersonpias(vpersona) - prima;
                END IF;
                Si se a¿aden m¿s se deber¿ modificar la condici¿n
                NVL(f_parproductos_v(reg.sproduc, 'TIPO_LIMITE'),0) <> 0  (PIAS)
                por NVL(f_parproductos_v(reg.sproduc, 'TIPO_LIMITE'),0) = 1 y el resto
                de l¿mites con el numero que le toque.
      */
      TYPE assoc_array_person IS TABLE OF NUMBER
         INDEX BY PLS_INTEGER;   --- Table para PIAS

      vhpersonpias   assoc_array_person;
      vhpersonppa    assoc_array_person;
      vpersona       NUMBER;
      -- BUG 9153 - 04-05-09 - RSC - Suplementos autom¿ticos
      n_retafrac     NUMBER(1);
      v_cursor       NUMBER;
      ss             VARCHAR2(3000);
      funcion        VARCHAR2(40);
      v_filas        NUMBER;
      -- Fin Bug 9153
      vnriesgo       NUMBER;   -- Bug 10053 - APD - 08/05/2009
      v_frevisio     seguros_aho.frevisio%TYPE;
      --       v_frevisio     DATE; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      v_crealiza     cfg_accion.crealiza%TYPE;
      v_cmodcom      comisionprod.cmodcom%TYPE;
      -- BUG 18423 - 21/12/2011 - JMP - LCOL705 - Multimoneda
      v_cmonpol      parempresas.nvalpar%TYPE;
      v_max_fcambio  DATE;
      v_nrecibo      reciboscar.nrecibo%TYPE;
      v_itasa        eco_tipocambio.itasa%TYPE;
      v_fcambio      DATE;
      -- FIN BUG 18423 - 21/12/2011 - JMP - LCOL705 - Multimoneda

      -- Bug 21167 - RSC - 03/02/2012 - LCOL_T001-LCOL - UAT - TEC: Incidencias del proceso de Cartera
      v_fcaranu_x    seguros.fcaranu%TYPE;
      v_fcarpro_x    seguros.fcarpro%TYPE;
                                              --Bug 28832 -- JMG -- 03/12/2013
      -- Fin Bug 21167

      -- Bug 23428 - RSC - 07/09/2012 - EMISI¿N ¿ CARTERA - COBRO VENCIDO / ANTICIPADO
      v_ctipcob      seguroscol.ctipcob%TYPE;
      --       v_ctipcob      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      v_fcartera     DATE;
      -- FIn bug 23428
      v_sproduc      productos.sproduc%TYPE;
      -- Bug 23940 - APD - 12/11/2012
      v_es_col_admin NUMBER;   -- Bug 23940 - APD - 06/11/2012
      v_es_col_agrup NUMBER;   -- Bug 23940 - APD - 06/11/2012
      v_cbloqueocol  seguros.cbloqueocol%TYPE;
      -- Bug 23940 - APD - 31/12/2012
      vrecunif       NUMBER;   -- Bug 28640/160626 - AMC - 25/03/2014
      v_fcarpro_pb   seguros.fcarpro%TYPE;
      v_fcarpro_y    seguros.fcarpro%TYPE;
      ventra         BOOLEAN;
      --INI BUG CONF-186  Fecha (22/08/2016) - HRE - proceso de marcas
      cur_marcas     sys_refcursor;
      v_sperson        per_agr_marcas.sperson%TYPE;
      v_area           VARCHAR2(500);
      v_cmarca         per_agr_marcas.cmarca%TYPE;
      v_descripcion    VARCHAR2(500);
      v_tipo           VARCHAR2(50);
      v_caacion        agr_marcas.caacion%TYPE;
      v_accion         VARCHAR2(50);
      v_persona        VARCHAR2(500);
      v_rol            VARCHAR2(50);
      v_validaMarca    BOOLEAN := FALSE;
      mensajes         T_IAX_MENSAJES;
      v_seguir       BOOLEAN := TRUE;
      --FIN BUG CONF-186  - Fecha (22/08/2016) - HRE
-----------------------------------------------------------------------------
      FUNCTION validar_regulariza(psseguro IN NUMBER)
         RETURN NUMBER IS
         --Declaraci¿n de variables:
         xcpregun       pregunseg.cpregun%TYPE;
--          xcpregun       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
         xcrespue       pregunseg.crespue%TYPE;
--          xcrespue       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
         xsregula       regularizaciones.sregula%TYPE;
--          xsregula       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      BEGIN
         BEGIN
            SELECT cpregun, crespue
              INTO xcpregun, xcrespue
              FROM pregunseg
             WHERE sseguro = psseguro
               AND cpregun = 80
               AND crespue = 1;
         EXCEPTION
            WHEN NO_DATA_FOUND THEN
               RETURN 1000;
            WHEN TOO_MANY_ROWS THEN
               NULL;
            WHEN OTHERS THEN
               RETURN 107649;
         END;

         BEGIN
            SELECT sregula
              INTO xsregula
              FROM regularizaciones
             WHERE sseguro = psseguro
               AND fregula IS NULL;
         EXCEPTION
            WHEN OTHERS THEN
               RETURN 107649;
         END;

         RETURN 0;
      END;
   BEGIN
      -- SMF llamamos a los suplementos por cartera,llenamos las tablas de
      -- carteraaux para saber que polizas, o productos estan pasando el
      -- previo.
      indice := 0;
      indice_error := 0;
      lfcartera := TO_CHAR(LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo, 'mmyyyy')),
                           'dd/mm/yyyy');
      -- No controlamos el posible error de suplem_car ya que el proceso solo
      -- sirve para generar un listado informativo de las polizas que se
      -- ver¿an modificadas por la cartera real.
      -- Bug 9153 - 08/05/2009 - RSC -  Suplementos autom¿ticos
      -- Este suplemento ya no tiene sentido. Comentado aqui y comentado
      -- en PAC_DINCARTERA
      /*
                                                                 num_err := pac_suplem.f_suplem_car(psproces, indice_error,
                                        TO_DATE('01' || LPAD(pmes, 2, '0') || panyo,
                                                'dd/mm/yyyy'),
                                        TO_DATE('01' || LPAD(pmes, 2, '0') || panyo,
                                                'dd/mm/yyyy'),
                                        1);
      */
      indice := indice_error;
      -- Construim la select din¿micament
      lfcartera2 := TO_CHAR(LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo, 'mmyyyy')) + 1,
                            'dd/mm/yyyy');

      FOR vprod IN c_prod LOOP
         lsproduc_ant := 0;

         SELECT sproduc
           INTO v_sproduc
           FROM productos
          WHERE cramo = vprod.cramo
            AND cmodali = vprod.cmodali
            AND ctipseg = vprod.ctipseg
            AND ccolect = vprod.ccolect;

         -- Bug 23940 - APD - 12/11/2012
         IF NVL(f_parproductos_v(v_sproduc, 'CARTERA_PSU'), 0) = 1 THEN
-------------------------------------
-- Se realiza la cartera CON PSU's --
-------------------------------------

            -- Bug 28640/160626 - AMC - 25/03/2014
            vrecunif := f_parproductos_v(v_sproduc, 'RECUNIF');

            FOR reg IN c_seg_psu(vprod.cramo, vprod.cmodali, vprod.ctipseg, vprod.ccolect,
                                 NULL, pnpoliza, pncertif, pmes, panyo, pfcartera, NULL,
                                 vrecunif   -- Bug 28640/160626 - AMC - 25/03/2014
                                         ) LOOP

              v_seguir := TRUE;--BUG CONF-186  Fecha (22/08/2016) - HRE - proceso de marcas
               --INI BUG CONF-186  Fecha (22/08/2016) - HRE - proceso de marcas
               IF (reg.sseguro IS NOT NULL) THEN
                  cur_marcas := pac_md_marcas.f_get_marcas_poliza(pcempres, reg.sseguro, 'POL', mensajes);
                  FETCH cur_marcas
                     INTO v_sperson, v_area, v_cmarca, v_descripcion, v_tipo, v_caacion, v_accion, v_persona, v_rol;
                  WHILE cur_marcas%FOUND LOOP
                     IF v_caacion != 0 THEN
                        v_validaMarca := TRUE;
                        num_err := pac_marcas.f_ins_log_marcaspoliza(pcempres, psproces, v_sperson, v_cmarca, psseguro);
                     END IF;

                  FETCH cur_marcas
                    INTO v_sperson, v_area, v_cmarca, v_descripcion, v_tipo, v_caacion, v_accion, v_persona, v_rol;
                  END LOOP;

                  IF (v_validaMarca) THEN
                     v_seguir := FALSE;
                     num_err := 9909325;
                     -- Tiene marcas y no se permite generar la cartera
                     texto := f_axis_literales(num_err, pac_md_common.f_get_cxtidioma);
                     texto := texto || '.' || reg.sseguro || ' (' || reg.npoliza
                                 || '-' || reg.ncertif || ')';
                     num_lin := NULL;
                     num_err2 := f_proceslin(psproces, texto, pnpoliza, num_lin);
                     IF num_err2 = 0 THEN
                        COMMIT;
                     END IF;

                  END IF;
               END IF;
               --FIN BUG CONF-186  - Fecha (22/08/2016) - HRE

            IF (v_seguir) THEN --BUG CONF-186  - Fecha (22/08/2016) - HRE
               v_es_col_admin := pac_seguros.f_es_col_admin(reg.sseguro, 'POL');
               v_es_col_agrup := pac_seguros.f_es_col_agrup(reg.sseguro, 'POL');
               num_err := 0;

-- DRA:25597:07/11/2013: Se inicializa o al encontrar una bloqueada o con error ya no sigue con el resto

               ------------------------------
-- Renovacion de colectivos administrados/agrupados
 -------------------------------
               IF (v_es_col_admin = 1
                   OR v_es_col_agrup = 1)
                  AND reg.ncertif = 0 THEN
                  -- si el certificado 0 est¿ bloqueado para cartera no se puede pasar cartera
                  IF NVL(reg.cbloqueocol, 0) = 1 THEN
                     num_err := 152212;   -- Poliza bloqueada.
                     texto := f_axis_literales(num_err, pcidioma) || '. '
                              || f_axis_literales(112522, pcidioma);
                     texto := texto || '.' || reg.sseguro || ' (' || reg.npoliza || '-'
                              || reg.ncertif || ')';
                     num_lin := NULL;
                     num_err2 := f_proceslin(psproces, texto, reg.sseguro, num_lin);

                     IF num_err2 = 0 THEN
                        COMMIT;
                     END IF;
                  END IF;

                  IF (num_err = 0
                      AND pnpoliza IS NOT NULL)
                     OR pnpoliza IS NULL THEN
                     IF v_es_col_admin = 1 THEN
                        --se valida si se pueden renovar los certificados X del certificado 0
                        num_err := f_permite_renovar(vprod.cramo, vprod.cmodali,
                                                     vprod.ctipseg, vprod.ccolect,
                                                     reg.npoliza, pmes, panyo);

                        IF num_err <> 0 THEN
                           IF num_err <> 0 THEN
                              ROLLBACK;
                              texto := f_axis_literales(num_err, pcidioma);
                              texto := texto || '.' || reg.sseguro || ' (' || reg.npoliza
                                       || '-' || reg.ncertif || ')';
                              num_lin := NULL;
                              num_err2 := f_proceslin(psproces, texto, reg.sseguro, num_lin);

                              IF num_err2 = 0 THEN
                                 COMMIT;
                              END IF;
                           END IF;
                        END IF;
                     END IF;

                     IF num_err = 0 THEN
                        --se renueva el certificado 0
                        -- la funcion f_genera_cartera ya realiza el COMMIT o ROLLBACK
                        v_fcarpro_pb := reg.fcarpro;
                        num_err := p_previ_cartera_psu(reg, pcempres, psproces, pmes, panyo,
                                                       pcidioma, lsproduc_ant, indice,
                                                       indice_error);

                        -- si la cartera del certificado 0 ha ido bien, se puede realizar la
                        -- cartera de sus certificados
                           -- se renuevan los certificados X del certificado 0
                        FOR reg_col IN c_seg_col_psu(vprod.cramo, vprod.cmodali,
                                                     vprod.ctipseg, vprod.ccolect,
                                                     reg.npoliza, pmes, panyo) LOOP
                           -- la funcion f_genera_cartera ya realiza el COMMIT o ROLLBACK
                           num_err := p_previ_cartera_psu(reg_col, pcempres, psproces, pmes,
                                                          panyo, pcidioma, lsproduc_ant,
                                                          indice, indice_error);
                        END LOOP;

                        -- 29943 - 30/04/2014 - JTT
                        num_err := pac_dincartera.f_tratamiento_pb(pcempres, reg.sproduc,
                                                                   reg.sseguro, v_fcarpro_pb,
                                                                   NULL, 'P', NULL, psproces);

                        IF num_err <> 0 THEN
                           indice_error := indice_error + 1;
                           texto := f_axis_literales(9906703, pcidioma);
                           texto := texto || '.' || reg.sseguro || ' (' || reg.npoliza || '-'
                                    || reg.ncertif || ')';
                           num_lin := NULL;
                           num_err := f_proceslin(psproces, texto, reg.sseguro, num_lin);
                           COMMIT;
                        END IF;
                     -- Fi 29943
                     END IF;
                  END IF;
               ELSE
------------------------------
  --Renovacion de polizas individuales
 --------------------------------
                      -- si el certificado 0 est¿ bloqueado no se puede pasar cartera
                  IF NVL(reg.cbloqueocol, 0) = 1 THEN
                     num_err := 152212;   -- Poliza bloqueada.
                     texto := f_axis_literales(num_err, pcidioma) || '. '
                              || f_axis_literales(112522, pcidioma);
                     texto := texto || '.' || reg.sseguro || ' (' || reg.npoliza || '-'
                              || reg.ncertif || ')';
                     num_lin := NULL;
                     num_err2 := f_proceslin(psproces, texto, reg.sseguro, num_lin);

                     IF num_err2 = 0 THEN
                        COMMIT;
                     END IF;
                  END IF;

                  IF num_err = 0 THEN
                     -- la funcion f_genera_cartera ya realiza el COMMIT o ROLLBACK
                     v_fcarpro_pb := reg.fcarpro;
                     num_err := p_previ_cartera_psu(reg, pcempres, psproces, pmes, panyo,
                                                    pcidioma, lsproduc_ant, indice,
                                                    indice_error);

                     IF num_err <> 0 THEN
                        texto := f_axis_literales(num_err, pcidioma) || '. '
                                 || f_axis_literales(112522, pcidioma);
                        texto := texto || '.' || reg.sseguro || ' (' || reg.npoliza || '-'
                                 || reg.ncertif || ')';
                        num_lin := NULL;
                        num_err2 := f_proceslin(psproces, texto, reg.sseguro, num_lin);

                        IF num_err2 = 0 THEN
                           COMMIT;
                        END IF;
                     END IF;

                     -- 29943 - 30/04/2014 - JTT
                     IF num_err = 0 THEN
                        num_err := pac_dincartera.f_tratamiento_pb(pcempres, reg.sproduc,
                                                                   reg.sseguro, v_fcarpro_pb,
                                                                   NULL, 'P', NULL, psproces);

                        IF num_err <> 0 THEN
                           indice_error := indice_error + 1;
                           texto := f_axis_literales(9906703, pcidioma);
                           texto := texto || '.' || reg.sseguro || ' (' || reg.npoliza || '-'
                                    || reg.ncertif || ')';
                           num_lin := NULL;
                           num_err := f_proceslin(psproces, texto, reg.sseguro, num_lin);
                           COMMIT;
                        END IF;
                     END IF;
                  -- Fi 29943
                  END IF;
               END IF;
            END IF;----BUG CONF-186  Fecha (22/08/2016) - HRE - proceso de marcas
            END LOOP;
         ELSE
-------------------------------------
-- Se realiza la cartera SIN PSU's --
-------------------------------------
            -- fin Bug 23940 - APD - 12/11/2012
            FOR reg IN c_seg(vprod.cramo, vprod.cmodali, vprod.ctipseg, vprod.ccolect) LOOP
               --INI BUG CONF-186  Fecha (22/08/2016) - HRE - proceso de marcas
               v_seguir := TRUE;
               IF (reg.sseguro IS NOT NULL) THEN
                  cur_marcas := pac_md_marcas.f_get_marcas_poliza(pcempres, reg.sseguro, 'POL', mensajes);
                  FETCH cur_marcas
                     INTO v_sperson, v_area, v_cmarca, v_descripcion, v_tipo, v_caacion, v_accion, v_persona, v_rol;
                  WHILE cur_marcas%FOUND LOOP
                     IF v_caacion != 0 THEN
                        v_validaMarca := TRUE;
                        num_err := pac_marcas.f_ins_log_marcaspoliza(pcempres, psproces, v_sperson, v_cmarca, psseguro);
                     END IF;

                  FETCH cur_marcas
                    INTO v_sperson, v_area, v_cmarca, v_descripcion, v_tipo, v_caacion, v_accion, v_persona, v_rol;
                  END LOOP;

                  IF (v_validaMarca) THEN
                     v_seguir := FALSE;
                     num_err := 9909325;
                     -- Tiene marcas y no se permite generar la cartera
                     texto := f_axis_literales(num_err, pac_md_common.f_get_cxtidioma);
                     texto := texto || '.' || reg.sseguro || ' (' || reg.npoliza
                                 || '-' || reg.ncertif || ')';
                     num_lin := NULL;
                     num_err2 := f_proceslin(psproces, texto, pnpoliza, num_lin);
                     IF num_err2 = 0 THEN
                        COMMIT;
                     END IF;

                  END IF;
               END IF;
               --FIN BUG CONF-186  - Fecha (22/08/2016) - HRE

               IF (v_seguir) THEN --BUG CONF-186  - Fecha (22/08/2016) - HRE

                 IF reg.fcarpro IS NOT NULL THEN
                  v_fcarpro_pb := reg.fcarpro;
                  indice := indice + 1;
                  algun_error := 0;
                  num_err := 0;
                  pnmovimi := NULL;

                  IF reg.sproduc <> lsproduc_ant THEN
                     lsproduc_ant := reg.sproduc;
---------------------------------------------------------
-------------------------------------------------
-- Mirem si el producte contempla la prima m¿nima
-------------------------------------------------
-- Si s'ha de comprovar la prima m¿nima, cal veure si hi ha garantia
-- de regularitzaci¿.
                     pac_dincartera.garantia_regularitzacio(reg.cramo, reg.cmodali,
                                                            reg.ctipseg, reg.ccolect,
                                                            lcprimin, liprimin, lcclapri,
                                                            lcgarant_regu, lnorden);
---------------------------------------------------------
                  END IF;

                  -- Bug 23428 - RSC - 07/09/2012 - EMISI¿N ¿ CARTERA - COBRO VENCIDO / ANTICIPADO
                  BEGIN
                     SELECT ctipcob
                       INTO v_ctipcob
                       FROM seguroscol
                      WHERE sseguro = reg.sseguro;
                  EXCEPTION
                     WHEN NO_DATA_FOUND THEN
                        v_ctipcob := 2;
                     WHEN OTHERS THEN
                        v_ctipcob := 2;
                  END;

                  SELECT DECODE(v_ctipcob,
                                1, ADD_MONTHS((LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo,
                                                                'mmyyyy'))
                                               + 1),
                                              -1),
                                (LAST_DAY(TO_DATE(LPAD(pmes, 2, '0') || panyo, 'mmyyyy')) + 1))
                    INTO v_fcartera
                    FROM DUAL;

                  IF pfcartera IS NOT NULL THEN   --JRH MSV-3 Error , genera m¿s recibos de la cuenta cuando hay carteras pendientes.
                     SELECT DECODE(v_ctipcob, 1, ADD_MONTHS(pfcartera + 1, -1), pfcartera + 1)
                       INTO v_fcartera
                       FROM DUAL;
                  END IF;

                  --JRH

                  -- Fin Bug 23428
                  WHILE reg.fcarpro < v_fcartera
                   AND algun_error = 0
                   AND(reg.fcarpro < reg.fvencim
                       OR reg.fvencim IS NULL) LOOP
                     -- BUG 9153 - 04-05-09 - RSC - Suplementos autom¿ticos
                     n_retafrac := NULL;

                     -- Bug 23940 - APD - 31/12/2012 - si la poliza est¿ bloqueada en renovacion no permitir renovar
                     IF (reg.fcarpro = reg.fcaranu
                         AND reg.csituac <> 5
                         AND n_retafrac IS NULL)
                        OR(n_retafrac = 1) THEN
                        SELECT cbloqueocol
                          INTO v_cbloqueocol
                          FROM seguros
                         WHERE sseguro = reg.sseguro;

                        IF v_cbloqueocol = 2 THEN
                           num_err := 152212;   -- Poliza bloqueada.
                           algun_error := 1;
                        END IF;
                     END IF;

                     IF pac_seguros.f_suspendida(reg.sseguro, reg.fcarpro) = 1 THEN
                        num_err := 9904518;   -- P¿liza suspendida
                        algun_error := 1;
                     END IF;

                     -- fin Bug 23940 - APD - 31/12/2012
                     IF NVL(f_parproductos_v(reg.sproduc, 'FRACCIONARIO'), 0) = 1 THEN
                        SELECT MAX(tvalpar)
                          INTO funcion
                          FROM detparpro
                         WHERE cparpro = 'F_PRFRACCIONARIAS'
                           AND cidioma = 2
                           AND cvalpar = (SELECT cvalpar
                                            FROM parproductos
                                           WHERE sproduc = reg.sproduc
                                             AND cparpro = 'F_PRFRACCIONARIAS');

                        IF funcion IS NOT NULL THEN
                           ss := 'begin :n_retafrac := ' || funcion || '; end;';

                           IF DBMS_SQL.is_open(v_cursor) THEN
                              DBMS_SQL.close_cursor(v_cursor);
                           END IF;

                           v_cursor := DBMS_SQL.open_cursor;
                           DBMS_SQL.parse(v_cursor, ss, DBMS_SQL.native);

                           IF INSTR(ss, ':psseguro') > 0 THEN
                              DBMS_SQL.bind_variable(v_cursor, ':psseguro', reg.sseguro);
                           END IF;

                           IF INSTR(ss, ':pfecha') > 0 THEN
                              DBMS_SQL.bind_variable(v_cursor, ':pfecha', reg.fcarpro);
                           END IF;

                           IF INSTR(ss, ':n_retafrac') > 0 THEN
                              DBMS_SQL.bind_variable(v_cursor, ':n_retafrac', num_err);
                           END IF;

                           v_filas := DBMS_SQL.EXECUTE(v_cursor);
                           DBMS_SQL.variable_value(v_cursor, 'n_retafrac', n_retafrac);

                           IF DBMS_SQL.is_open(v_cursor) THEN
                              DBMS_SQL.close_cursor(v_cursor);
                           END IF;
                        END IF;
                     END IF;

                     -- Fin Bug 9153
                     IF algun_error = 0 THEN
                        --SMF Como ahora los de propuesta de suplementos entra por la
                        --select a¿adimos a la condici¿n reg.csituac <> 5 para que no
                        --entren por el IF.
                        -- BUG 9153 - 04-05-09 - RSC - Suplementos autom¿ticos
                        -- A¿adimos renovaci¿n si le toca renovar o si cumpla a¿os (n_retafrac = 1)
                        IF (reg.fcarpro = reg.fcaranu
                            AND reg.csituac <> 5
                            AND n_retafrac IS NULL)
                           OR(n_retafrac = 1) THEN
                           --Bug 9685 - APD - 17/04/2009 - Se busca el par¿metro num_risc riesgos personales
                           BEGIN
                              SELECT COUNT(*)
                                INTO num_risc
                                FROM riesgos
                               WHERE sperson IS NOT NULL
                                 AND sseguro = reg.sseguro;
                           EXCEPTION
                              WHEN OTHERS THEN
                                 num_risc := 0;
                           END;

                           --Bug 9685 - APD - 17/04/2009 - Fin
                           -- Bug 9685 - APD - 17/04/2009 - en lugar de coger la acticad de la tabla seguros, llamar a la funci¿n pac_seguros.ff_get_actividad
                           -- Veure si s'ha de fer algun canvi a la p¿lissa abans de renovar
                           -- ( ara nom¿s implementat canvi d'activitat)
                           lcumple := 0;
                           num_err :=
                              pac_cambiocartera.cambiocartera
                                                   ('P', reg.sproduc,
                                                    pac_seguros.ff_get_actividad(reg.sseguro,
                                                                                 num_risc),
                                                    reg.sseguro, reg.cramo, reg.cmodali,
                                                    reg.ctipseg, reg.ccolect, reg.fcaranu,
                                                    reg.nsuplem, lcumple, lcactivi);

                           -- Bug 9685 - APD - 17/04/2009 - Fin
                           IF lcumple = 1 THEN
                              -- La p¿lissa ser¿ modificada en la cartera. En el previ nom¿s avisem
                              --                        num_err := 110406;
                              -- Canviem l'activitat per que tarifi amb la nova
                              reg.cactivi := lcactivi;
                           -- Bug 9685 - APD - 17/04/2009 - en lugar de coger la actividad de la tabla seguros, llamar a la funci¿n pac_seguros.ff_get_actividad
                           ELSE
                              reg.cactivi := pac_seguros.ff_get_actividad(reg.sseguro,
                                                                          num_risc);
                           -- Bug 9685 - APD - 17/04/2009 - Fin
                           END IF;

                           IF num_err = 0 THEN
                              -- La p¿lissa renova , cal comprovar si te bonificaci¿
                              -- per no sinistralitat
                              num_err := pac_bonifica.f_bonifica_poliza(reg.cramo,
                                                                        reg.cmodali,
                                                                        reg.ctipseg,
                                                                        reg.ccolect,
                                                                        reg.sseguro,
                                                                        reg.fcaranu,
                                                                        reg.fefecto,
                                                                        lbonifica,
                                                                        laplica_bonifica);
                           END IF;

                           IF num_err = 0 THEN
                              -- BUG 16903 - JMP - 09/12/2010 - No renovamos si fecha de revisi¿n anterior
                              --                                a la de renovaci¿n
                              BEGIN
                                 SELECT frevisio
                                   INTO v_frevisio
                                   FROM seguros_aho
                                  WHERE sseguro = reg.sseguro;

                                 num_err :=
                                    pac_cfg.f_get_user_accion_permitida(f_user,
                                                                        'CARTERA_NO_REVISA',
                                                                        reg.sproduc,
                                                                        reg.cempres,
                                                                        v_crealiza);

                                 IF num_err <> 1 THEN
                                    IF v_frevisio < reg.fcaranu THEN
                                       num_err := 9901723;
                                    -- La fecha de revisi¿n es anterior a la renovaci¿n de la p¿liza
                                    ELSE
                                       num_err := 0;
                                    END IF;
                                 ELSE
                                    num_err := 0;
                                 END IF;
                              EXCEPTION
                                 WHEN NO_DATA_FOUND THEN
                                    NULL;
                              END;
                           END IF;

                           IF num_err <> 0 THEN
                              algun_error := 1;
                              indice_error := indice_error + 1;
                           ELSE
                              --
                              -- FGG, 14/02/2000,. Para ver si est¿ informado
                              -- el % de regularizaci¿n.
                              num_err := validar_regulariza(reg.sseguro);

                              IF num_err <> 0
                                 AND num_err <> 1000 THEN
                                 algun_error := 1;
                                 indice_error := indice_error + 1;
                              ELSE
                                 num_err := 0;

                                 BEGIN
                                    SELECT csubpro, cobjase, cagrpro,
-- JLB - I - BUG 18423 COjo la moneda del producto
                                          -- DECODE(cdivisa, 3, 1, 2),
                                           pac_monedas.f_moneda_producto(sproduc),
-- JLB - F - BUG 18423 COjo la moneda del producto
                                                                                  nedamar,
                                           ciedmar
                                      INTO pcsubpro, pcobjase, pcagrpro,
                                           pcmoneda, pnedamar,
                                           pciedmar
                                      FROM productos
                                     WHERE cramo = reg.cramo
                                       AND ctipseg = reg.ctipseg
                                       AND ccolect = reg.ccolect
                                       AND cmodali = reg.cmodali;
                                 EXCEPTION
                                    WHEN OTHERS THEN
                                       algun_error := 1;
                                 END;

                                 --21/9/98: YIL. Se buscan los datos necesarios
                                 -- para calcular las tarifas.
                                 BEGIN
                                    SELECT cgtarif
                                      INTO tipo
                                      FROM codiram
                                     WHERE cramo = reg.cramo;
                                 EXCEPTION
                                    WHEN NO_DATA_FOUND THEN
                                       num_err := 101904;
                                 END;

                                 --25/11/98 YIL. Se busca el par¿metro num_risc
                                 -- riesgos personales
                                 BEGIN
                                    SELECT COUNT(*)
                                      INTO num_risc
                                      FROM riesgos
                                     WHERE sperson IS NOT NULL
                                       AND sseguro = reg.sseguro;
                                 EXCEPTION
                                    WHEN OTHERS THEN
                                       num_risc := 0;
                                 END;

                                 --DBMS_OUTPUT.put_line( 'abans de tarifar '|| reg.fefecto);
                                 IF NVL(f_parproductos_v(reg.sproduc, 'DETALLE_GARANT'), 0) IN
                                                                                         (1, 2) THEN
                                    num_err :=
                                       pac_dincartera.f_garantarifa_sgt_det
                                                                          ('P', reg.sseguro,
                                                                           reg.cramo,
                                                                           reg.cmodali,
                                                                           pcobjase,
                                                                           reg.ctipseg,
                                                                           reg.ccolect, tipo,
                                                                           reg.nduraci,
                                                                           psproces,
                                                                           reg.ndurcob,
                                                                           reg.fcarpro, pmes,
                                                                           panyo, tipo,
                                                                           pcagrpro,
                                                                           reg.ctarman,
                                                                           reg.cactivi,
                                                                           num_risc, NULL,
                                                                           reg.fefecto, lmov,
                                                                           lanu, pcmoneda,
                                                                           parms_transitorios,
                                                                           lbonifica,
                                                                           laplica_bonifica,
                                                                           reg.sproduc,
                                                                           reg.cforpag,
                                                                           pcidioma,
                                                                           lcgarant_regu,
                                                                           lnorden, lcprimin,
                                                                           liprimin, lcclapri,
                                                                           pnedamar, pciedmar,
                                                                           reg.fcaranu);
                                 ELSE
                                    num_err :=
                                       pac_dincartera.f_garantarifa_sgt('P', reg.sseguro,
                                                                        reg.cramo,
                                                                        reg.cmodali, pcobjase,
                                                                        reg.ctipseg,
                                                                        reg.ccolect, tipo,
                                                                        reg.nduraci, psproces,
                                                                        reg.ndurcob,
                                                                        reg.fcarpro, pmes,
                                                                        panyo, tipo, pcagrpro,
                                                                        reg.ctarman,
                                                                        reg.cactivi, num_risc,
                                                                        NULL, reg.fefecto,
                                                                        lmov, lanu, pcmoneda,
                                                                        parms_transitorios,
                                                                        lbonifica,
                                                                        laplica_bonifica,
                                                                        reg.sproduc,
                                                                        reg.cforpag, pcidioma,
                                                                        lcgarant_regu,
                                                                        lnorden, lcprimin,
                                                                        liprimin, lcclapri,
                                                                        pnedamar, pciedmar,
                                                                        reg.fcaranu);
                                 END IF;

                                 -- SMF borramos las tablas temporales para agilizar el previo
                                 DELETE      tmp_garancar
                                       WHERE sseguro = reg.sseguro
                                         AND sproces = psproces;

                                 DELETE      pregungarancar
                                       WHERE sseguro = reg.sseguro
                                         AND sproces = psproces;

                                 DELETE      preguncar
                                       WHERE sseguro = reg.sseguro
                                         AND sproces = psproces;

                                 DELETE      pregunpolcar
                                       WHERE sseguro = reg.sseguro
                                         AND sproces = psproces;

                                 --BUG 0026638: FAC LCOL - TEC - Cartera para Autos. (id 176-19)
                                 DELETE      autdetriesgoscar
                                       WHERE sseguro = reg.sseguro
                                         AND sproces = psproces;

                                 DELETE      autdisriesgoscar
                                       WHERE sseguro = reg.sseguro
                                         AND sproces = psproces;

                                 DELETE      autconductorescar
                                       WHERE sseguro = reg.sseguro
                                         AND sproces = psproces;

                                 DELETE      autriesgoscar
                                       WHERE sseguro = reg.sseguro
                                         AND sproces = psproces;

                                 --FIN BUG 0026638: FAC LCOL - TEC - Cartera para Autos. (id 176-19)

                                 ----DBMS_OUTPUT.put_line(
                                 --  'pac_tarifas.f_garantarifa_sgt '|| num_err);

                                 --message('2el ch_cartas es ' || :busqueda.ch_cartas);pause;
                                 IF num_err = 0 THEN
                                    -- Bug 21167 - RSC - 03/02/2012 - LCOL_T001-LCOL - UAT - TEC: Incidencias del proceso de Cartera
                                    v_fcaranu_x := reg.fcaranu;
                                    v_fcarpro_y := reg.fcarpro;
                                    -- Fin bug 21167

                                    --Ya est¿n todas las garant¿as de GARANSEG tarificadas---
                                    --Llamamos la funci¿n que actualiza datos de la pr¿xima cartera-----
                                    num_err := f_acproxcar(reg.sseguro, reg.fcarant,
                                                           reg.fcarpro, reg.fcaranu,
                                                           reg.nanuali, reg.nfracci,
                                                           reg.frenova);

                                    ----DBMS_OUTPUT.put_line('acproxcar '|| num_err);
                                    IF num_err <> 0 THEN
                                       algun_error := 1;
                                       indice_error := indice_error + 1;
                                    ELSE
                                       --15/1/99 YIL. Se controlan las p¿lizas de ahorro
                                       IF pcagrpro = 2 THEN   ---es una p¿liza de ahorro
                                          pcmovimi := 2;
                                       -- indica aportaci¿n peri¿dica
                                       ELSE
                                          pcmovimi := NULL;
                                       END IF;

                                       --2/10/98 YIL. Se utiliza la funci¿n f_recries para calcular el recibo
                                       --24/3/1999 YIL. Si la forma de pago es ¿nica no se calcula recibo
                                       IF reg.cforpag <> 0 THEN
                                          --Llamamos la funci¿n de calcular recibos
                                          IF NVL
                                                (pac_parametros.f_parempresa_n
                                                                         (reg.cempres,
                                                                          'FEMISIO_IS_SYSDATE'),
                                                 0) = 1 THEN
                                             pfemisio := f_sysdate;
                                          ELSE
                                             pfemisio :=
                                                NVL(pfcartera,
                                                    TO_DATE('1/' || TO_CHAR(TO_NUMBER(pmes))
                                                            || '/' || TO_CHAR(panyo),
                                                            'dd/mm/yyyy'));
                                          --Decode ctipcob, restar 1 mes quan tipo de cobro vencido
                                          END IF;

                                          ----DBMS_OUTPUT.PUT_LINE ( '>>>>>>> RENOVAMOS');
                                          -- Vamos a calcular si podemos hacer el recibo y no superamos
                                          -- el l¿mite de aportaciones maximas solo en pp.
                                          ----DBMS_OUTPUT.put_line ( 'prima m¿nima: ' || liprimin ) ;
                                          recibosi := 1;
                                          -- Si tieneparte de prestaciones en PP NO GENERAMOS RECIBO
                                          prestacion := 0;

                                          IF reg.cagrpro = 11 THEN
                                             SELECT COUNT(1)
                                               INTO prestacion
                                               FROM prestaplan
                                              WHERE prestaplan.sseguro = reg.sseguro;
                                          END IF;

                                          -- Bug 0017382 - 26/01/2011 - RSC
                                          -- S¿ el producto es de ahorro, se busca el n¿mero de recibos pendientes que tiene la p¿liza
                                          --IF f_prod_ahorro(reg.sproduc) = 1 THEN
                                          --   SELECT f_recpen_pp(reg.sseguro, 1)
                                          --     INTO recpendi
                                          --     FROM DUAL;
                                          --ELSE
                                          --   recpendi := 0;
                                          --END IF;
                                          recpendi := 0;

                                          IF prestacion > 0
                                             OR recpendi > 1 THEN
                                             recibosi := 0;
                                          ELSIF (NVL(f_parproductos_v(reg.sproduc,
                                                                      'APORTMAXIMAS'),
                                                     0) = 1
                                                 OR NVL(f_parproductos_v(reg.sproduc,
                                                                         'TIPO_LIMITE'),
                                                        0) <> 0)
                                                AND prestacion = 0
                                                AND recpendi < 2 THEN
                                             -- Planes de Pensiones y PIAS (RSC 01/02/2008)
                                             DECLARE
                                                pendiente      garancar.ipritar%TYPE;
--                                                 pendiente      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
                                             BEGIN
                                                SELECT riesgos.sperson, riesgos.nriesgo
                                                  INTO vpersona, vnriesgo
                                                  FROM riesgos
                                                 WHERE riesgos.sseguro = reg.sseguro
                                                   AND riesgos.fanulac IS NULL;

                                                IF NVL(f_parproductos_v(reg.sproduc,
                                                                        'APORTMAXIMAS'),
                                                       0) = 1 THEN   -- PPA
                                                   IF vhpersonppa.EXISTS(vpersona) THEN
                                                      pendiente := vhpersonppa(vpersona);
                                                   ELSE
                                                      -- Bug 10053 - APD - 08/05/2009 - se sustituye la funcion f_maxapor_pp por
                                                      -- pac_ppa_planes.ff_importe_por_aportar_persona
                                                      pendiente :=
                                                         pac_ppa_planes.ff_importe_por_aportar_persona
                                                                                 (panyo,
                                                                                  reg.sseguro,
                                                                                  vnriesgo,
                                                                                  vpersona);
                                                      -- Bug 10053 - APD - 08/05/2009 - fin
                                                      vhpersonppa(vpersona) := pendiente;
                                                   END IF;
                                                ELSIF NVL(f_parproductos_v(reg.sproduc,
                                                                           'TIPO_LIMITE'),
                                                          0) <> 0 THEN   -- PIAS
                                                   IF vhpersonpias.EXISTS(vpersona) THEN
                                                      pendiente := vhpersonpias(vpersona);
                                                   ELSE
                                                      SELECT pac_limites_ahorro.ff_importe_por_aportar_persona
                                                                (panyo,
                                                                 f_parproductos_v
                                                                                 (reg.sproduc,
                                                                                  'TIPO_LIMITE'),
                                                                 vpersona, reg.fcarpro)
                                                        INTO pendiente
                                                        FROM DUAL;

                                                      vhpersonpias(vpersona) := pendiente;
                                                   END IF;
                                                END IF;

                                                IF pendiente <= 0 THEN
                                                   ---> HA superado el l¿mite de aportaciones
                                                   recibosi := 0;
                                                ELSIF pendiente > 0 THEN
                                                   -- En este caso el importe es el de la prima o la diferencia entre lo pendeinte y la prima.
                                                   SELECT icapital
                                                     INTO prima
                                                     FROM garancar
                                                    WHERE garancar.sseguro = reg.sseguro
                                                      AND garancar.cgarant = 48
                                                      AND garancar.ffinefe IS NULL
                                                      AND sproces = psproces;

                                                   ----DBMS_OUTPUT.put_line ( 'prima ' || prima || ' pendiente ' || pendiente );
                                                   IF prima > pendiente THEN
                                                      UPDATE garancar
                                                         SET ipritar = pendiente,
                                                             icaptot = pendiente,
                                                             iprianu = pendiente * reg.cforpag,
                                                             ipritot = pendiente * reg.cforpag
                                                       WHERE cgarant = 48
                                                         AND sseguro = reg.sseguro
                                                         AND garancar.ffinefe IS NULL
                                                         AND sproces = psproces;

                                                      NULL;
                                                   END IF;

                                                   recibosi := 2;
                                                END IF;
                                             EXCEPTION
                                                WHEN NO_DATA_FOUND THEN
                                                   recibosi := 0;
                                             END;
                                          END IF;

                                          --> Fin de planes de pensiones o PIAS
                                          IF NVL
                                                (pac_parametros.f_parempresa_n(reg.cempres,
                                                                               'REASEGURO_EST'),
                                                 0) = 1 THEN
                                             /** se hace el reaseguro del previo**/--JRB
                                             IF pac_cesionesrea.producte_reassegurable
                                                                                  (reg.sproduc) =
                                                                                             1 THEN
                                                --      REASEGURO
                                                -- Bug: 11623 AVT 28-10-2009 control del reaseguro abans de cridar a les funcions
                                                -- s'haur¿ d'acabar substituint per la crida a PAC_CESIONESREA.PRODUCTE_REASEGURABLE
                                                /*BEGIN
                                                                                                                                                                                                                                                                                                                                                                                                                                             SELECT creaseg
                                                     INTO w_creaseg
                                                     FROM productos
                                                    WHERE sproduc = p_sproduc;
                                                EXCEPTION
                                                   WHEN NO_DATA_FOUND THEN
                                                      error := 104347;
                                                   WHEN OTHERS THEN
                                                      error := 102705;
                                                END;
                                                IF w_creaseg = 1 THEN*/
                                                -- Bug: 11623 AVT 28-10-2009 fi
                                                IF algun_error = 0 THEN
                                                   -- REASEGURO
                                                   -- Bug 10782 - RSC - 24/07/2009 - CRE - Incid¿ncia Reaseguro Cr¿dit Salut
                                                   IF n_retafrac = 1
                                                      --JRB p_fcarpro <> p_fcaranu
                                                      AND(reg.fcarpro <> reg.fcaranu) THEN   -- Motivo: 821
                                                      num_err :=
                                                         pac_cesionesrea.f_buscactrrea_est
                                                                                 (reg.sseguro,
                                                                                  pnmovimi,
                                                                                  psproces, 4,
                                                                                  pcmoneda, 1,
                                                                                  NULL, NULL,
                                                                                  'CAR');
                                                   ELSE
                                                      -- Fin Bug 10782
                                                      num_err :=
                                                         pac_cesionesrea.f_buscactrrea_est
                                                                                 (reg.sseguro,
                                                                                  pnmovimi,
                                                                                  psproces, 5,
                                                                                  pcmoneda, 1,
                                                                                  NULL, NULL,
                                                                                  'CAR');
                                                   END IF;

                                                   IF num_err <> 0
                                                      AND num_err <> 99 THEN
                                                      algun_error := 1;
                                                      indice_error := indice_error + 1;
                                                   ELSIF num_err = 99 THEN   -- Error controlado
                                                      --NULL; Per coher¿ncia amb el P_EMITIR_PROPUESTA.
                                                      num_err := 0;
                                                   ELSE
                                                      -- Bug 10782 - RSC - 24/07/2009 - CRE - Incid¿ncia Reaseguro Cr¿dit Salut
                                                      IF n_retafrac = 1
                                                         --JRB p_fcarpro <> p_fcaranu
                                                         AND(reg.fcarpro <> reg.fcaranu) THEN   -- Motivo: 821
                                                         num_err :=
                                                            pac_cesionesrea.f_cessio_est
                                                                                   (psproces,
                                                                                    4,
                                                                                    pcmoneda,
                                                                                    f_sysdate,
                                                                                    0, 'CAR');
                                                      ELSE
                                                         -- Fin Bug 10782
                                                         num_err :=
                                                            pac_cesionesrea.f_cessio_est
                                                                                   (psproces,
                                                                                    5,
                                                                                    pcmoneda,
                                                                                    f_sysdate,
                                                                                    0, 'CAR');
                                                      END IF;

                                                      IF num_err <> 0
                                                         AND num_err <> 99 THEN
                                                         algun_error := 1;
                                                         indice_error := indice_error + 1;
                                                      ELSIF num_err = 99 THEN
                                                          -- Falta facultativo
                                                         -- Aturem la cartera si falta facultatiu i gravem l'error que ho indica
                                                         algun_error := 1;
                                                         indice_error := indice_error + 1;
                                                         texto :=
                                                            f_axis_literales(105382, pcidioma);
                                                         num_lin := NULL;
                                                         num_err :=
                                                            f_proceslin(psproces, texto,
                                                                        psseguro, num_lin);
                                                      -- Mantis 10251/10809.#6.01/06/2009.Ini.0010251: CRE - Incidencia Cartera con Facultativo.NMM.
                                                      -- FAL - 10/05/2011 - Bug 0018514: MSGV003 - Modificacions en la retenci¿ per facultatiu
                                                      -- Recupera el riesgo de facpendientes para insertar motivo retencion por riesgo

                                                      -- Bug 21167 - RSC - 03/02/2012 - LCOL_T001-LCOL - UAT - TEC: Incidencias del proceso de Cartera
                                                      -- Comentados todo esto ya que en el previo no debe retener ni modificar movseguro !!!
                                                      /*FOR reg IN
                                                         (SELECT DISTINCT (NVL(nriesgo, 1))
                                                                                      nriesgo
                                                                     FROM facpendientes
                                                                    WHERE sseguro = psseguro
                                                                      AND nmovimi = pnmovimi
                                                                      AND sproces = psproces) LOOP
                                                         num_err :=
                                                            pac_emision_mv.f_retener_poliza
                                                               (NULL, psseguro, reg.nriesgo,   -- num_risc
                                                                pnmovimi,
                                                                10   -- MOTIU RETENCIO ( Pendent quadre facultatiu)
                                                                  ,
                                                                1   -- CODI RETENCIO
                                                                 ,
                                                                pfemisio);
                                                      END LOOP;

                                                      UPDATE seguros
                                                      SET csituac = 5
                                                      WHERE sseguro = psseguro;

                                                      UPDATE movseguro
                                                      SET femisio = NULL
                                                      WHERE sseguro = psseguro
                                                        AND nmovimi = pnmovimi;
                                                      */
                                                      -- Mantis 10251/10809.#6.06/2009.Fi.
                                                      END IF;
                                                   END IF;
                                                END IF;
                                             END IF;
                                          -- Bug: 11623 AVT Fi del IF...
                                          END IF;

                                          IF recibosi IN(1, 2) THEN
                                             num_err :=
                                                pac_propio.f_graba_com_adq(reg.sseguro, 0,
                                                                           'P', psproces);

                                             -- Bug13607 ASN - 11/03/2010

                                             -- Bug 19777/95194 - 26/10/2011 -AMC

                                             -- ini Bug 0022583 - 24/08/2012 - JMF
                                             IF (NVL
                                                    (pac_parametros.f_parproducto_n
                                                                            (reg.sproduc,
                                                                             'PER_REV_NO_ANUAL'),
                                                     0) <> 0) THEN
                                                --IF f_es_renovacion(reg.sseguro) = 0 THEN   -- es cartera
                                                IF (f_renovacion_anual(reg.sseguro,
                                                                       v_fcaranu_x,
                                                                       reg.sproduc) = 404
                                                    OR f_es_renovacion(reg.sseguro) = 0) THEN
                                                   v_cmodcom := 2;
                                                ELSE
                                                   -- si es 1 es nueva produccion
                                                   v_cmodcom := 1;
                                                END IF;
                                             ELSE
                                                IF f_es_renovacion(reg.sseguro) = 0 THEN   -- es cartera
                                                   v_cmodcom := 2;
                                                ELSE
                                                   -- si es 1 es nueva produccion
                                                   v_cmodcom := 1;

                                                   -- ini Bug 0022583 - 05/10/2012 - JMF
                                                   -- Si la nueva fecha anual calculada, supera la fecha solicitada, es cartera.
                                                   IF TO_CHAR(reg.fcaranu, 'yyyymm') >
                                                                   panyo || LPAD(pmes, 2, '0') THEN
                                                      v_cmodcom := 2;
                                                   END IF;
                                                -- fin Bug 0022583 - 05/10/2012 - JMF
                                                END IF;
                                             END IF;

                                             -- fin Bug 0022583 - 24/08/2012 - JMF

                                             --BUG9028-XVM-01102009 inici
                                             IF NVL
                                                   (pac_parametros.f_parinstalacion_n
                                                                              ('CALCULO_RECIBO'),
                                                    1) = 0 THEN
                                                IF (NVL
                                                       (f_parproductos_v
                                                                        (reg.sproduc,
                                                                         'SEPARA_RIESGO_AHORRO'),
                                                        0) = 1
                                                    AND pac_seguros.f_tiene_garanahorro
                                                                                  (NULL,
                                                                                   reg.sseguro,
                                                                                   reg.fcarpro) =
                                                                                              1)
                                                   OR NVL
                                                        (f_parproductos_v
                                                                        (reg.sproduc,
                                                                         'SEPARA_RIESGO_AHORRO'),
                                                         0) = 0 THEN
                                                   num_err :=
                                                      pac_adm.f_recries(reg.ctipreb,
                                                                        reg.sseguro, NULL,
                                                                        pfemisio, reg.fcarant,
                                                                        reg.fcarpro, 3,
                                                                        reg.nanuali,
                                                                        reg.nfracci, NULL,
                                                                        NULL, psproces, 21,
                                                                        'P', v_cmodcom,
                                                                        reg.fcaranu, NULL,
                                                                        pcmovimi, pcempres,
                                                                        pnmovimi, 1,
                                                                        pnimport2);
                                                END IF;
                                             ELSE
                                                IF (NVL
                                                       (f_parproductos_v
                                                                        (reg.sproduc,
                                                                         'SEPARA_RIESGO_AHORRO'),
                                                        0) = 1
                                                    AND pac_seguros.f_tiene_garanahorro
                                                                                  (NULL,
                                                                                   reg.sseguro,
                                                                                   reg.fcarpro) =
                                                                                              1)
                                                   OR NVL
                                                        (f_parproductos_v
                                                                        (reg.sproduc,
                                                                         'SEPARA_RIESGO_AHORRO'),
                                                         0) = 0 THEN
                                                   num_err :=
                                                      f_recries(reg.ctipreb, reg.sseguro,
                                                                NULL, pfemisio, reg.fcarant,
                                                                reg.fcarpro, 3, reg.nanuali,
                                                                reg.nfracci, NULL, NULL,
                                                                psproces, 21, 'P', v_cmodcom,
                                                                reg.fcaranu, NULL, pcmovimi,
                                                                pcempres, pnmovimi, 1,
                                                                pnimport2);
                                                END IF;
                                             END IF;

                                             -- Fi Bug 19777/95194 - 26/10/2011 -AMC

                                             --BUG9028-XVM-01102009 fi

                                             -- RSC 06/02/2008 Actualizamos lo que le queda pendiente a esta persona
                                             -- para que al intentar generar otro recibo en la cartera de esta persona
                                             -- tenga en cuenta los l¿mites de pendiente que tiene actualmente una vez
                                             -- generado ya algun recibo previo en la cartera.
                                             IF NVL(f_parproductos_v(reg.sproduc,
                                                                     'APORTMAXIMAS'),
                                                    0) = 1 THEN
                                                vhpersonppa(vpersona) :=
                                                                  vhpersonppa(vpersona)
                                                                  - prima;
                                             ELSIF NVL(f_parproductos_v(reg.sproduc,
                                                                        'TIPO_LIMITE'),
                                                       0) <> 0 THEN
                                                vhpersonpias(vpersona) :=
                                                                 vhpersonpias(vpersona)
                                                                 - prima;
                                             END IF;
                                          ELSE
                                             num_err := 0;
                                          END IF;

                                          ----DBMS_OUTPUT.put_line(pnimport2 || 'alberto f_recries '|| num_err);
                                          IF num_err <> 0 THEN
                                             algun_error := 1;
                                             indice_error := indice_error + 1;
                                          ELSE
                                             -- Bug 19096 - RSC - 03/08/2011 - LCOL - Parametrizaci¿n b¿sica producto Vida Individual Pagos Permanentes (Afegim 'RRIE')
                                             IF NVL(f_parproductos_v(reg.sproduc,
                                                                     'SEPARA_RIESGO_AHORRO'),
                                                    0) = 1 THEN
                                                -- Obtenemos el recibo de ahorro generado
                                                -- Bug 19777/95194 - 26/10/2011 -AMC

                                                -- ini Bug 0022583 - 24/08/2012 - JMF
                                                IF (NVL
                                                       (pac_parametros.f_parproducto_n
                                                                            (reg.sproduc,
                                                                             'PER_REV_NO_ANUAL'),
                                                        0) <> 0) THEN
                                                   --IF f_es_renovacion(reg.sseguro) = 0 THEN   -- es cartera
                                                   IF (f_renovacion_anual(reg.sseguro,
                                                                          v_fcaranu_x,
                                                                          reg.sproduc) = 404
                                                       OR f_es_renovacion(reg.sseguro) = 0) THEN
                                                      v_cmodcom := 2;
                                                   ELSE
                                                      -- si es 1 es nueva produccion
                                                      v_cmodcom := 1;
                                                   END IF;
                                                ELSE
                                                   IF f_es_renovacion(reg.sseguro) = 0 THEN   -- es cartera
                                                      v_cmodcom := 2;
                                                   ELSE
                                                      -- si es 1 es nueva produccion
                                                      v_cmodcom := 1;

                                                      -- ini Bug 0022583 - 05/10/2012 - JMF
                                                      -- Si la nueva fecha anual calculada, supera la fecha solicitada, es cartera.
                                                      IF TO_CHAR(reg.fcaranu, 'yyyymm') >
                                                                   panyo || LPAD(pmes, 2, '0') THEN
                                                         v_cmodcom := 2;
                                                      END IF;
                                                   -- fin Bug 0022583 - 05/10/2012 - JMF
                                                   END IF;
                                                END IF;

                                                -- fin Bug 0022583 - 24/08/2012 - JMF
                                                IF NVL
                                                      (pac_parametros.f_parinstalacion_n
                                                                              ('CALCULO_RECIBO'),
                                                       1) = 0 THEN
                                                   num_err :=
                                                      pac_adm.f_recries(reg.ctipreb,
                                                                        reg.sseguro, NULL,
                                                                        pfemisio, reg.fcarant,
                                                                        reg.fcarpro, 3,
                                                                        reg.nanuali,
                                                                        reg.nfracci, NULL,
                                                                        NULL, psproces, 21,
                                                                        'PRIE', v_cmodcom,
                                                                        reg.fcaranu, NULL,
                                                                        pcmovimi, pcempres,
                                                                        pnmovimi, 1,
                                                                        pnimport2);
                                                ELSE
                                                   num_err :=
                                                      f_recries(reg.ctipreb, reg.sseguro,
                                                                NULL, pfemisio, reg.fcarant,
                                                                reg.fcarpro, 3, reg.nanuali,
                                                                reg.nfracci, NULL, NULL,
                                                                psproces, 21, 'PRIE',
                                                                v_cmodcom, reg.fcaranu, NULL,
                                                                pcmovimi, pcempres, pnmovimi,
                                                                1, pnimport2);
                                                END IF;

                                                -- Fi Bug 19777/95194 - 26/10/2011 -AMC
                                                IF num_err <> 0 THEN
                                                   algun_error := 1;
                                                   indice_error := indice_error + 1;
                                                ELSE
                                                   NULL;
                                                END IF;
                                             END IF;
                                          -- Fin Bug 19096
                                          END IF;
                                       END IF;
                                    -- De si la forma de pago no es ¿nica.
                                    END IF;   -- De sin error en f_acproxcar
                                 ELSE   -- De error en f_garantarifa
                                    algun_error := 1;
                                    indice_error := indice_error + 1;
                                 --                              EXIT;
                                 END IF;
                              END IF;   -- Validar regulariza
                           END IF;   -- Bonificacio
                        ELSE   --  fcarpro <> fcaranu
                           v_fcarpro_x := reg.fcarpro;
                           v_fcarpro_y := reg.fcarpro;
                                             --Bug 28832 -- JMG -- 03/12/2013
                           --Llamamos la funci¿n que actualiza datos de la pr¿xima cartera-----
                           num_err := f_acproxcar(reg.sseguro, reg.fcarant, reg.fcarpro,
                                                  reg.fcaranu, reg.nanuali, reg.nfracci,
                                                  reg.frenova);

                           IF num_err <> 0 THEN
                              algun_error := 1;
                              indice_error := indice_error + 1;
                           ELSE
                              --15/1/99 YIL. Se controlan las p¿lizas de ahorro
                              IF pcagrpro = 2 THEN   ---es una p¿liza de ahorro
                                 pcmovimi := 2;
                              -- indica aportaci¿n peri¿dica
                              ELSE
                                 pcmovimi := NULL;
                              END IF;

                              --Llamamos la funci¿n de calcular recibos
                              IF NVL(pac_parametros.f_parempresa_n(reg.cempres,
                                                                   'FEMISIO_IS_SYSDATE'),
                                     0) = 1 THEN
                                 pfemisio := f_sysdate;
                              ELSE
                                 pfemisio := NVL(pfcartera,
                                                 TO_DATE('1/' || TO_CHAR(TO_NUMBER(pmes))
                                                         || '/' || TO_CHAR(panyo),
                                                         'dd/mm/yyyy'));
                              END IF;

                              -- 17/6/99 YIL. Se mira si es nueva producci¿n o cartera para
                              -- aplicar como modo de comision un 1 o un 2
                              IF f_es_renovacion(reg.sseguro) = 0 THEN   -- es cartera
                                 modcom := 2;
                              ELSE   -- si es 1 es nueva produccion
                                 modcom := 1;
                              END IF;

                              -- Bug 22583 - XVM - 26/03/2013
                              -- ini Bug 0022583 - 22/11/2012 - JMF
                              -- Si la nueva fecha anual calculada, supera la fecha solicitada, es cartera.

                              /*IF TO_CHAR(reg.fcaranu, 'yyyymm') > panyo || LPAD(pmes, 2, '0') THEN
                                 modcom := 2;
                              END IF;*/

                              -- Ini Bug 28832 -- ECP -- 13/11/2016
                              -- Bug 28832 -- JMG -- 03/12/2013 -- Se modifica v_fcaranu_x por v_fcarpro_x
                              IF (NVL(pac_parametros.f_parproducto_n(reg.sproduc,
                                                                     'PER_REV_NO_ANUAL'),
                                      0) <> 0) THEN
                                 IF (f_renovacion_anual(reg.sseguro, v_fcarpro_x, reg.sproduc) =
                                                                                            404
                                     OR f_es_renovacion(reg.sseguro) = 0) THEN
                                    modcom := 2;
                                 ELSE   -- si es 1 es nueva produccion
                                    modcom := 1;
                                 END IF;
                              ELSE
                                 IF f_es_renovacion(reg.sseguro) = 0 THEN   -- es cartera
                                    modcom := 2;
                                 ELSE   -- si es 1 es nueva produccion
                                    modcom := 1;

                                    IF TO_CHAR(reg.fcaranu, 'yyyymm') >
                                                                   panyo || LPAD(pmes, 2, '0') THEN
                                       modcom := 2;
                                    END IF;
                                 -- fin Bug 0022583 - 05/10/2012 - JMF
                                 END IF;
                              END IF;

                              -- Fin Bug 28832 -- ECP -- 13/11/2016

                              -- fin Bug 0022583 - 22/11/2012 - JMF
                              -- Bug 22583 - XVM - 26/03/2013

                              --Averiguamos el nmovimi
                              num_err := f_buscanmovimi(reg.sseguro, 1, 1, pnmovimi);

                              ----DBMS_OUTPUT.put_line('f_busca '|| num_err);
                              IF num_err <> 0 THEN
                                 algun_error := 1;
                                 indice_error := indice_error + 1;
                              ELSE
                                 --********** PLANES DE PENSIONES **********
                                 -- Vamos a calcular si podemos hacer el recibo y no superamos
                                 -- el l¿mite de aportaciones maximas solo en pp.
                                 --DBMS_OUTPUT.put_line ( pnimport2 || 'nO ES RENOVACION prima m¿nima: ' || liprimin ) ;
                                 recibosi := 1;
                                 -- Si tieneparte de prestaciones en PP NO GENERAMOS RECIBO
                                 prestacion := 0;

                                 IF reg.cagrpro = 11 THEN
                                    SELECT COUNT(1)
                                      INTO prestacion
                                      FROM prestaplan
                                     WHERE prestaplan.sseguro = reg.sseguro;
                                 END IF;

                                 -- Bug 0017382 - 26/01/2011 - RSC
                                 -- S¿ el producto es de ahorro, se busca el n¿mero de recibos pendientes que tiene la p¿liza
                                 --IF f_prod_ahorro(reg.sproduc) = 1 THEN
                                 --   SELECT f_recpen_pp(reg.sseguro, 1)
                                 --     INTO recpendi
                                 --     FROM DUAL;
                                 --ELSE
                                 --   recpendi := 0;
                                 --END IF;
                                 recpendi := 0;

                                 IF prestacion > 0
                                    OR recpendi > 1 THEN
                                    recibosi := 0;
                                 ELSIF (NVL(f_parproductos_v(reg.sproduc, 'APORTMAXIMAS'), 0) =
                                                                                              1
                                        OR NVL(f_parproductos_v(reg.sproduc, 'TIPO_LIMITE'), 0) <>
                                                                                              0)
                                       AND prestacion = 0 THEN
                                    DECLARE
                                       pendiente      garancar.ipritar%TYPE;
--                                        pendiente      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
                                    BEGIN
                                       --DBMS_OUTPUT.PUT_LINE ( 'ENTRAMOS A BUSCAR EL RIESGO' || REG.SSEGURO);
                                       SELECT riesgos.sperson, riesgos.nriesgo
                                         INTO vpersona, vnriesgo
                                         FROM riesgos
                                        WHERE riesgos.sseguro = reg.sseguro
                                          AND riesgos.fanulac IS NULL;

                                       IF NVL(f_parproductos_v(reg.sproduc, 'APORTMAXIMAS'), 0) =
                                                                                              1 THEN
                                          IF vhpersonppa.EXISTS(vpersona) THEN
                                             pendiente := vhpersonppa(vpersona);
                                          ELSE
                                             -- Bug 10053 - APD - 08/05/2009 - se sustituye la funcion f_maxapor_pp por
                                             -- pac_ppa_planes.ff_importe_por_aportar_persona
                                             pendiente :=
                                                pac_ppa_planes.ff_importe_por_aportar_persona
                                                                                 (panyo,
                                                                                  reg.sseguro,
                                                                                  vnriesgo,
                                                                                  vpersona);
                                             -- Bug 10053 - APD - 08/05/2009 - fin
                                             vhpersonppa(vpersona) := pendiente;
                                          END IF;
                                       ELSIF NVL(f_parproductos_v(reg.sproduc, 'TIPO_LIMITE'),
                                                 0) <> 0 THEN
                                          IF vhpersonpias.EXISTS(vpersona) THEN
                                             pendiente := vhpersonpias(vpersona);
                                          ELSE
                                             SELECT pac_limites_ahorro.ff_importe_por_aportar_persona
                                                              (panyo,
                                                               f_parproductos_v(reg.sproduc,
                                                                                'TIPO_LIMITE'),
                                                               vpersona, reg.fcarpro)
                                               INTO pendiente
                                               FROM DUAL;

                                             vhpersonpias(vpersona) := pendiente;
                                          END IF;
                                       END IF;

                                       IF pendiente < 0 THEN
                                          ---> HA superado el l¿mite de aportaciones
                                          recibosi := 0;
                                       ELSIF pendiente >= 0 THEN   --AND PENDIENTE >=  liprimin THEN
                                          -- En este caso el importe es el de la prima o la diferencia entre lo pendiente y la prima.
                                          BEGIN
                                             SELECT icapital
                                               INTO prima
                                               FROM garanseg
                                              WHERE garanseg.sseguro = reg.sseguro
                                                AND garanseg.cgarant = 48
                                                AND garanseg.ffinefe IS NULL;
                                          EXCEPTION
                                             WHEN OTHERS THEN
                                                NULL;
                                          END;

                                          IF prima > pendiente THEN
                                             prima := pendiente;
                                          END IF;

                                          recibosi := 2;
                                       END IF;
                                    EXCEPTION
                                       WHEN OTHERS THEN
                                          recibosi := 0;
                                    END;
                                 END IF;   --> Fin de planes de pensiones o PIAS

                                 IF recibosi IN(1, 2) THEN
                                    --BUG9028-XVM-01102009 inici
                                    IF NVL
                                          (pac_parametros.f_parinstalacion_n('CALCULO_RECIBO'),
                                           1) = 0 THEN
                                       num_err :=
                                          pac_adm.f_recries(reg.ctipreb, reg.sseguro, NULL,
                                                            pfemisio, reg.fcarant,
                                                            reg.fcarpro, 3, reg.nanuali,
                                                            reg.nfracci, NULL, NULL, psproces,
                                                            22, 'P', modcom, reg.fcaranu,
                                                            NULL, pcmovimi, pcempres,
                                                            pnmovimi, 1, pnimport2);
                                    ELSE
                                       num_err :=
                                          f_recries(reg.ctipreb, reg.sseguro, NULL, pfemisio,
                                                    reg.fcarant, reg.fcarpro, 3, reg.nanuali,
                                                    reg.nfracci, NULL, NULL, psproces, 22,
                                                    'P', modcom, reg.fcaranu, NULL, pcmovimi,
                                                    pcempres, pnmovimi, 1, pnimport2);
                                    END IF;

                                    --BUG9028-XVM-01102009 fi

                                    -- RSC 06/02/2008 Actualizamos lo que le queda pendiente a esta persona
                                    -- para que al intentar generar otro recibo en la cartera de esta persona
                                    -- tenga en cuenta los l¿mites de pendiente que tiene actualmente una vez
                                    -- generado ya algun recibo previo en la cartera.
                                    IF NVL(f_parproductos_v(reg.sproduc, 'APORTMAXIMAS'), 0) =
                                                                                              1 THEN
                                       vhpersonppa(vpersona) := vhpersonppa(vpersona) - prima;
                                    ELSIF NVL(f_parproductos_v(reg.sproduc, 'TIPO_LIMITE'), 0) <>
                                                                                              0 THEN
                                       vhpersonpias(vpersona) := vhpersonpias(vpersona)
                                                                 - prima;
                                    END IF;

                                    -- Si el recibo es de planes de pensiones puede que revalorize
                                    -- con lo que modificamos el informe revalorizado para que se visualice
                                    -- en el listado.
                                    IF NVL(f_parproductos_v(reg.sproduc, 'APORTMAXIMAS'), 0) =
                                                                                              1
                                       OR NVL(f_parproductos_v(reg.sproduc, 'TIPO_LIMITE'), 0) <>
                                                                                              0 THEN
                                       UPDATE vdetreciboscar
                                          SET iprinet = prima,
                                              itotpri = prima,
                                              itotalr = prima
                                        WHERE nrecibo =
                                                 (SELECT MAX(nrecibo)
                                                    FROM reciboscar
                                                   WHERE sseguro = reg.sseguro
                                                     AND vdetreciboscar.nrecibo =
                                                                             reciboscar.nrecibo);

                                       -- BUG 18423 - 21/12/2011 - JMP - LCOL705 - Multimoneda
                                       IF NVL(pac_parametros.f_parempresa_n(reg.cempres,
                                                                            'MULTIMONEDA'),
                                              0) = 1 THEN
                                          v_cmonpol := pac_oper_monedas.f_monpol(reg.sseguro);

                                          SELECT MAX(fcambio), MAX(nrecibo)
                                            INTO v_max_fcambio, v_nrecibo
                                            FROM detreciboscar
                                           WHERE nrecibo =
                                                    (SELECT MAX(r.nrecibo)
                                                       FROM vdetreciboscar_monpol v,
                                                            reciboscar r
                                                      WHERE r.sseguro = reg.sseguro
                                                        AND v.nrecibo = r.nrecibo);

                                          IF v_max_fcambio IS NOT NULL THEN
                                             num_err :=
                                                pac_oper_monedas.f_datos_contraval
                                                                               (reg.sseguro,
                                                                                NULL, NULL,
                                                                                v_max_fcambio,
                                                                                1, v_itasa,
                                                                                v_fcambio);

                                             UPDATE vdetreciboscar_monpol v
                                                SET iprinet =
                                                            f_round(prima * v_itasa, v_cmonpol),
                                                    itotpri =
                                                            f_round(prima * v_itasa, v_cmonpol),
                                                    itotalr =
                                                            f_round(prima * v_itasa, v_cmonpol)
                                              WHERE nrecibo = v_nrecibo;
                                          END IF;
                                       END IF;
                                    -- FIN BUG 18423 - 21/12/2011 - JMP - LCOL705 - Multimoneda
                                    END IF;
                                 END IF;

                                 IF num_err <> 0 THEN
                                    algun_error := 1;
                                    indice_error := indice_error + 1;
                                 ELSE
                                    -- Bug 19096 - RSC - 03/08/2011 - LCOL - Parametrizaci¿n b¿sica producto Vida Individual Pagos Permanentes (Afegim 'RRIE')
                                    IF NVL(f_parproductos_v(reg.sproduc,
                                                            'SEPARA_RIESGO_AHORRO'),
                                           0) = 1 THEN
                                       -- Obtenemos el recibo de ahorro generado
                                       /*
                                       BEGIN
                                           SELECT r.nrecibo
                                           INTO v_recibo_ahorro
                                           FROM reciboscar r, seguros s
                                           WHERE r.sseguro = reg.sseguro
                                             AND r.sseguro = s.sseguro
                                             AND 3 = (SELECT DISTINCT NVL(f_pargaranpro_v(s.cramo,
                                                                                          s.cmodali,
                                                                                          s.ctipseg,
                                                                                          s.ccolect,
                                                                                          NVL(s.cactivi, 0),
                                                                                          d.cgarant,'TIPO'), 0)
                                                      FROM detreciboscar d
                                                      WHERE nrecibo = r.nrecibo)
                                             AND r.fefecto = reg.fcarant
                                             AND r.fvencim = reg.fcarpro
                                             AND r.ctiprec = 3;
                                       EXCEPTION
                                          WHEN NO_DATA_FOUND THEN
                                              NULL;
                                       END;
                                       */
                                       IF NVL
                                             (pac_parametros.f_parinstalacion_n
                                                                             ('CALCULO_RECIBO'),
                                              1) = 0 THEN
                                          num_err :=
                                             pac_adm.f_recries(reg.ctipreb, reg.sseguro, NULL,
                                                               pfemisio, reg.fcarant,
                                                               reg.fcarpro, 3, reg.nanuali,
                                                               reg.nfracci, NULL, NULL,
                                                               psproces, 22, 'PRIE', modcom,
                                                               reg.fcaranu, NULL, pcmovimi,
                                                               pcempres, pnmovimi, 1,
                                                               pnimport2);
                                       ELSE
                                          num_err :=
                                             f_recries(reg.ctipreb, reg.sseguro, NULL,
                                                       pfemisio, reg.fcarant, reg.fcarpro, 3,
                                                       reg.nanuali, reg.nfracci, NULL, NULL,
                                                       psproces, 22, 'PRIE', modcom,
                                                       reg.fcaranu, NULL, pcmovimi, pcempres,
                                                       pnmovimi, 1, pnimport2);
                                       END IF;

                                       IF num_err <> 0 THEN
                                          algun_error := 1;
                                          indice_error := indice_error + 1;
                                       ELSE
-------------------------------------------------------------------
-- De momento en modo previo no vamos a fusionar recibos.        --
-- (Ver c¿digo comentado. Se deber¿a modificar la f_agruparecibo --
--  para permitir la creaci¿n de recibos en las tablas CAR sin   --
--  insertar en ADM_RECUNIF).                                    --
-------------------------------------------------------------------
                                          NULL;
                                       /*
                                       -- Aqui tenemos que fusionar los dos recibos (si es que hay dos)
                                       -- Obtenemos el recibo de riesgo generado
                                       BEGIN
                                           SELECT r.nrecibo
                                           INTO v_recibo_riesgo
                                           FROM recibos r, seguros s
                                           WHERE r.sseguro = reg.sseguro
                                             AND r.sseguro = s.sseguro
                                             AND 6 = (SELECT DISTINCT NVL(f_pargaranpro_v(s.cramo,
                                                                                          s.cmodali,
                                                                                          s.ctipseg,
                                                                                          s.ccolect,
                                                                                          NVL(s.cactivi, 0),
                                                                                          d.cgarant,'TIPO'), 0)
                                                      FROM detrecibos d
                                                      WHERE nrecibo = r.nrecibo)
                                             AND r.fefecto = reg.fcarant
                                             AND r.fvencim = reg.fcarpro
                                             AND r.ctiprec = 3;
                                       EXCEPTION
                                          WHEN NO_DATA_FOUND THEN
                                              NULL;
                                       END;


                                       IF v_recibo_ahorro IS NOT NULL AND v_recibo_riesgo IS NOT NULL THEN

                                          -- Necesario para la agrupacion
                                          UPDATE recibos
                                          SET cestaux = 2
                                          WHERE nrecibo IN (v_recibo_ahorro, v_recibo_riesgo);

                                          v_listarec := t_lista_id();
                                          v_obrec := ob_lista_id();
                                          v_obrec.idd := v_recibo_ahorro;
                                          v_listarec.EXTEND;
                                          v_listarec(v_listarec.LAST) := v_obrec;

                                          v_obrec := ob_lista_id();
                                          v_obrec.idd := v_recibo_riesgo;
                                          v_listarec.EXTEND;
                                          v_listarec(v_listarec.LAST) := v_obrec;

                                          num_err := pac_gestion_rec.f_agruparecibo(NULL, NULL, NULL, NULL, v_listarec, lctiprec, 'P');

                                          IF num_err <> 0 THEN
                                              algun_error := 1;
                                              indice_error := indice_error + 1;
                                          END IF;
                                       END IF;*/
                                       END IF;
                                    END IF;
                                 -- Fin Bug 19096
                                 END IF;
                              END IF;
                           END IF;   -- f_acproxcar
                        END IF;   -- fcaranu=fcarpro

                         /*****************************************************************
                         Bug 0035712 -  Tarea 0202997 - 07/05/2015 - Ozea
                        ******************************************************************/
                        /*******************************************************************

                        OJO: Esto se hizo inicialmente para la renovaci¿n de p¿lizas. Meses despues nos
                        dimos cuenta que MSV le llama renovaci¿n a los recibos fraccionados y a la renovaci¿n le
                        llama aniversario. Ellos quieren notificaci¿n para cada recibo fraccionado.

                        ********************************************************************/
                        IF reg.ctipcob NOT IN(2, 19) THEN
                           BEGIN
                              SELECT ctipo, tdescrip
                                INTO v_ctipo, vdescrip
                                FROM cfg_plantillas_tipos
                               WHERE ttipo = 'RENOVACION';

                              BEGIN
                                 SELECT NVL(diasnoti, 0)
                                   INTO v_diasnoti
                                   FROM medcobpro
                                  WHERE cramo = reg.cramo
                                    AND cmodali = reg.cmodali
                                    AND ctipseg = reg.ctipseg
                                    AND ccolect = reg.ccolect
                                    AND ctipcob = reg.ctipcob;
                              EXCEPTION
                                 WHEN NO_DATA_FOUND THEN
                                    v_diasnoti := 0;
                              END;

                              ventra := TRUE;

                              IF pac_seguros.f_suspendida(reg.sseguro, v_fcarpro_y) = 1 THEN
                                 ventra := FALSE;
                              END IF;

                              IF ventra THEN
                                 IF v_diasnoti <> 0 THEN
                                    IF (v_fcarpro_y <= f_sysdate + v_diasnoti) THEN
                                       SELECT COUNT(1)
                                         INTO v_conta_noti
                                         FROM notificaseg
                                        WHERE sseguro = reg.sseguro
                                          AND ctipo = v_ctipo
                                          AND fecha = v_fcarpro_y;

                                       IF v_conta_noti = 0 THEN
                                          SELECT sperson
                                            INTO v_sperson_tom
                                            FROM tomadores
                                           WHERE sseguro = reg.sseguro
                                             AND nordtom = 1;

                                          BEGIN
                                             SELECT nvalpar
                                               INTO v_per_notif_prefe
                                               FROM per_parpersonas
                                              WHERE cparam = 'PER_NOTIF_PREFE'
                                                AND sperson = v_sperson_tom;
                                          EXCEPTION
                                             WHEN NO_DATA_FOUND THEN
                                                v_per_notif_prefe := 0;
                                          END;

                                          -- v_per_notif_prefe = 0 --> Por correo postal
                                          -- v_per_notif_prefe = 1 --> Por email
                                          --IF v_per_notif_prefe = 0 THEN   -- Por correo postal
                                          pac_isql.p_docs_renovacion(psproces, reg.sseguro,
                                                                     NULL, NULL);
                                       /*ELSIF v_per_notif_prefe = 1 THEN   -- Por correo electronico
                                          -- 1.- Recuperar el email de la persona:
                                          SELECT MAX(tvalcon)
                                            INTO v_email
                                            FROM per_contactos p1
                                           WHERE p1.sperson = v_sperson_tom
                                             AND p1.ctipcon = 3
                                             AND p1.cmodcon IN(
                                                   SELECT MIN(cmodcon)
                                                     FROM per_contactos p2
                                                    WHERE p2.sperson = p1.sperson
                                                      AND p2.ctipcon = p1.ctipcon);

                                          IF v_email IS NOT NULL THEN
                                             v_asunto := vdescrip;
                                             pac_isql.p_docs_renovacion(psproces, reg.sseguro,
                                                                        v_email, v_asunto);
                                          END IF;
                                       END IF;*/
                                       END IF;
                                    END IF;
                                 END IF;
                              END IF;
                           EXCEPTION
                              WHEN NO_DATA_FOUND THEN
                                 NULL;
                           END;
                        END IF;
                     ELSE   -- if anlgun error
                        EXIT;
                     END IF;   -- if algun error

                     IF algun_error = 0 THEN
                        --22/10/98 YIL. Se borran los registros de GARANCAR
                        COMMIT;
                        -- 29943 - 30/04/2014 - JTT
                        num_err := pac_dincartera.f_tratamiento_pb(pcempres, reg.sproduc,
                                                                   reg.sseguro, v_fcarpro_pb,
                                                                   NULL, 'P', NULL, psproces);

                        IF num_err <> 0 THEN
                           indice_error := indice_error + 1;
                           texto := f_axis_literales(9906703, pcidioma);
                           texto := texto || '.' || reg.sseguro || ' (' || reg.npoliza || '-'
                                    || reg.ncertif || ')';
                           num_lin := NULL;
                           num_err := f_proceslin(psproces, texto, reg.sseguro, num_lin);
                           COMMIT;
                        END IF;
                     -- Fi 29943
                     ELSE
                        ROLLBACK;
                        texto := f_axis_literales(num_err, pcidioma);
                        ----DBMS_OUTPUT.put_line(
                        --    ' rollback '|| num_err || texto || psproces);
                        texto := texto || '.' || reg.sseguro;
                        num_lin := NULL;
                        num_err := f_proceslin(psproces, texto, reg.sseguro, num_lin);

                        IF num_err = 0 THEN
                           COMMIT;
                        END IF;
                     END IF;
                  END LOOP;
               END IF;
               END IF;--BUG CONF-186  Fecha (22/08/2016) - HRE - proceso de marcas
            END LOOP;
         END IF;   -- fin Bug 23940 - APD - 12/11/2012 'CARTERA_PSU'
      END LOOP;

      --
      -- Por ultimo, trataremos los recibos extraordinarios
      --
      FOR r_dat IN c_motextra LOOP
         num_err := f_prevrecriesextra(r_dat.sseguro, pcempres, psproces, 'P', pnrecibo);
      END LOOP;
   EXCEPTION
      WHEN OTHERS THEN
         p_tab_error(f_sysdate, f_user, 'previ_cartera_tar', 99,
                     'Error When others,sqlcode=' || SQLCODE, SQLERRM);
   END previ_cartera_tar;

   FUNCTION f_garantarifa_sgt_det(
      pmodo IN VARCHAR2,
      psseguro IN NUMBER,
      pcramo IN NUMBER,
      pcmodali IN NUMBER,
      pcobjase IN NUMBER,
      pctipseg IN NUMBER,
      pccolect IN NUMBER,
      pctipo IN NUMBER,
      pnduraci IN NUMBER,
      conta_proces IN NUMBER,
      pcdurcob IN NUMBER,
      pfcarpro IN DATE,
      pmes IN VARCHAR2,
      panyo IN NUMBER,
      tipo IN NUMBER,
      pcagrpro IN NUMBER,
      pcmanual IN NUMBER,
      pcactivi IN NUMBER,
      num_risc IN NUMBER,
      pfemisio IN DATE,
      pfefecto IN DATE,
      movimiento OUT NUMBER,
      anulado OUT NUMBER,
      pmoneda IN NUMBER,
      parms_transitorios IN OUT pac_parm_tarifas.parms_transitorios_tabtyb,
      pbonifica IN NUMBER,
      paplica_bonifica IN NUMBER,
      psproduc IN NUMBER,
      pcforpag IN NUMBER,
      pidioma IN NUMBER,
      pcgarant_regu IN NUMBER,
      pnorden IN NUMBER,
      pcprimin IN NUMBER,
      piprimin IN NUMBER,
      pcclapri IN NUMBER,
      pnedamar IN NUMBER,
      pciedmar IN NUMBER,
      pfcaranu IN DATE)
      RETURN NUMBER IS
      /***********************************************************************************************
                                                                         F_GARANTARIFA_SGT: 1.- Revaloriza el seguro
                          2.- Tarifica
                          3.- Grabamos en GARANCAR
      ************************************************************************************************/
      num_err        NUMBER := 0;
      prevcap        NUMBER;
      piprima        NUMBER;
      cont           tmp_garancar.contador%TYPE := 0;
--       cont           NUMBER := 0; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      texto          VARCHAR2(80);
      registros      NUMBER;
      estat_garan    VARCHAR2(20);
      tecnico        NUMBER;   -- Si hay descuento tecnico
      porcen         NUMBER;   -- Porcentaje del coaseguro
      old_riesgo     NUMBER := 0;
      total_prima    NUMBER;
      wsperson       NUMBER;
      wedad          NUMBER;
      wcsexper       NUMBER;
      wfnacimi       DATE;
      mensa          VARCHAR2(100);
      lprima_bonif   NUMBER;
      laplica_actual NUMBER;
      lcanvia_tarifa NUMBER;
      lcanvia_tarifa_pro NUMBER;   -- aquesta mant¿ la del producte
      lcanvia_tarifa_gar NUMBER;   -- aquesta la de la garantia
      aux            NUMBER;
      -- Ini Bug 21907 - MDS - 03/05/2012
      pidtotec       garancar.idtotec%TYPE := 0;
--       pidtotec       NUMBER := 0; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      pireccom       garancar.ireccom%TYPE := 0;
--       pireccom       NUMBER := 0; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      -- Fin Bug 21907 - MDS - 03/05/2012
      vapldtosenform NUMBER;   --bfp bug 22212

      ------
--      CURSOR tmp(wses NUMBER) IS
--         SELECT *
--           FROM sgt_parms_transitorios
--          WHERE sesion = wses;

      -------
      CURSOR cur_risc IS
         SELECT DISTINCT sseguro, nriesgo
                    FROM garanseg
                   WHERE sseguro = psseguro
                     AND ffinefe IS NULL;

      -- Bug 9794 - YIL - 21/04/2009 -- Se modifica el order by del cursor de garant¿as para
      --                                dejarlo igual que el cursor de pac_tarifas (seg¿n el par¿metro 'ORDEN_TARIF')
      -- Bug 9524 - YIL - 30/04/2009 -- Se modifica el order by de los cursores de garant¿as
      --                                para que tenga en cuenta el par¿metro ORDEN_TARIF_CARTERA en lugar del ORDEN_TARIF
      -- Bug 7926 - RSC - 28/05/2009 -- Se modifica la select del cursor  para que tenga en
      --                                cuenta si la garant¿a ha vencido ya (solo para el previo, ya que en la cartera
      --                                real ya se da de baja la garant¿a antes y por tanto la garant¿a ya no entra en el cursor.
      -- Bug 10350 - RSC - 04/06/2009 - Detalle de garant¿as (tarificaci¿n)

      --Bug 26638/160974 - 03/04/2014 - AMC   - Se a¿ade la tabla garanseg_aux a la select
      CURSOR c_garanseg_risc(wnriesgo IN NUMBER) IS
         SELECT   NVL(dg.ndetgar, 0) ndetgar, NVL(g.sseguro, gg.sseguro) sseguro,
                  NVL(g.cgarant, gg.cgarant) cgarant, NVL(g.nriesgo, gg.nriesgo) nriesgo,
                  NVL(g.nmovimi, gg.nmovimi) nmovimi, NVL(g.finiefe, gg.finiefe) finiefe,
                  NVL(g.norden, gg.norden) norden,
                  NVL(dg.ctarifa, NVL(g.ctarifa, gg.ctarifa)) ctarifa,
                  NVL(dg.icapital, NVL(g.icaptot, gg.icaptot)) icapital,
                  NVL(g.precarg, gg.precarg) precarg,
                  NVL(dg.iprianu, NVL(g.ipritot, gg.ipritot)) iprianu,
                  NVL(g.ffinefe, gg.ffinefe), NVL(g.cformul, gg.cformul) cformul,
                  NVL(g.iextrap, gg.iextrap) iextrap, NVL(g.ctipfra, gg.ctipfra) ctipfra,
                  NVL(g.ifranqu, gg.ifranqu) ifranqu, NVL(g.irecarg, gg.irecarg) irecarg,
                  NVL(g.idtocom, gg.idtocom) idtocom,
                  NVL(dg.pdtocom, NVL(g.pdtocom, gg.pdtocom)) pdtocom,
                  NVL(dg.ipritar, NVL(g.ipritar, gg.ipritar)) ipritar,
                  NVL(dg.crevali, NVL(g.crevali, gg.crevali)) crevali,
                  NVL(dg.prevali, NVL(g.prevali, gg.prevali)) prevali,
                  NVL(dg.irevali, NVL(g.irevali, gg.irevali)) irevali,
                  NVL(g.itarifa, gg.itarifa) itarifa, NVL(g.itarrea, gg.itarrea) itarrea,
                  NVL(dg.ftarifa, NVL(g.ftarifa, gg.ftarifa)) ftarifa,
                  NVL(g.crevalcar, gg.crevalcar) crevalcar, NVL(g.cderreg, gg.cderreg) cderreg,
                  NVL(g.feprev, gg.feprev) feprev, NVL(g.fpprev, gg.fpprev) fpprev,
                  NVL(g.percre, gg.percre) percre, NVL(g.cref, gg.cref) cref,
                  NVL(g.cintref, gg.cintref) cintref, NVL(g.pdif, gg.pdif) pdif,
                  NVL(dg.pinttec, NVL(g.pinttec, gg.pinttec)) pinttec,
                  NVL(g.nparben, gg.nparben) nparben, NVL(g.nbns, gg.nbns) nbns,
                  NVL(g.tmgaran, gg.tmgaran) tmgaran, NVL(g.cmatch, gg.cmatch) cmatch,
                  NVL(g.tdesmat, gg.tdesmat) tdesmat, NVL(g.pintfin, gg.pintfin) pintfin,
                  NVL(g.nfactor, gg.nfactor) nfactor, NVL(g.nmovima, gg.nmovima) nmovima,
                  dg.cunica
             FROM garanseg g, detgaranseg dg, garanseg_aux gg
            WHERE g.sseguro = psseguro
              AND gg.sseguro(+) = g.sseguro
              AND g.nriesgo = wnriesgo
              AND gg.nriesgo(+) = g.nriesgo
              AND gg.nmovimi(+) = g.nmovimi
              AND g.ffinefe IS NULL
              AND pfcarpro < DECODE(pmodo,
                                    'P', NVL(pac_seguros.f_vto_garantia(g.sseguro, g.nriesgo,
                                                                        g.cgarant, g.nmovimi),
                                             pfcarpro + 1),
                                    pfcarpro + 1)
              AND g.sseguro = dg.sseguro(+)
              AND g.nriesgo = dg.nriesgo(+)
              AND g.cgarant = dg.cgarant(+)
              AND g.finiefe = dg.finiefe(+)
              AND g.nmovimi = dg.nmovimi(+)
         ORDER BY g.nriesgo,
                  DECODE(NVL(pac_parametros.f_pargaranpro_n(psproduc, pcactivi, g.cgarant,
                                                            'ORDEN_TARIF_CARTERA'),
                             0),
                         0, g.cgarant,
                         pac_parametros.f_pargaranpro_n(psproduc, pcactivi, g.cgarant,
                                                        'ORDEN_TARIF_CARTERA'));

      --ORDER BY nriesgo;
      -- Bug 9794 - YIL - 21/04/2009 -- Fin
      -- Bug 9524 - YIL - 30/04/2009 -- Fin
      -- Bug 7926 - RSC - 28/05/2009 -- Fin

      -- Bug 9794 - YIL - 21/04/2009 -- Se modifica el order by del cursor de garant¿as para dejarlo igual que el cursor de pac_tarifas (seg¿n el par¿metro 'ORDEN_TARIF')
      -- Bug 9524 - YIL - 30/04/2009 -- Se modifica el order by de los cursores de garant¿as para que tenga en cuenta el par¿metro ORDEN_TARIF_CARTERA
      --en lugar del ORDEN_TARIF
      -- Bug 7926 - RSC - 28/05/2009 -- Se modifica la select del cursor  para que tenga en
      --                                cuenta si la garant¿a ha vencido ya (solo para el previo, ya que en la cartera
      --                                real ya se da de baja la garant¿a antes y por tanto la garant¿a ya no entra en el cursor.
      CURSOR c_garancar(wnriesgo IN NUMBER) IS
         SELECT   sseguro, cgarant, nriesgo, finiefe, norden, ctarifa, icapital, precarg,
                  iprianu, ffinefe, cformul, iextrap, sproces, ctipfra, ifranqu, irecarg,
                  ipritar, idtocom, pdtocom, crevali, prevali, irevali, itarifa, itarrea,
                  ftarifa, cderreg, feprev, fpprev, percre, cref, cintref, pdif, pinttec,
                  nparben, nbns, tmgaran, cmatch, tdesmat, pintfin, nmovi_ant, nmovima,
                  ndetgar,
                          -- Ini Bug 21907 - MDS - 03/05/2012
                          pdtotec, preccom, idtotec, ireccom
             -- FIN Bug 21907 - MDS - 03/05/2012
         FROM     garancar
            WHERE sseguro = psseguro
              AND nriesgo = wnriesgo
              AND sproces = conta_proces
              AND pfcarpro < DECODE(pmodo,
                                    'P', NVL(pac_seguros.f_vto_garantia(sseguro, nriesgo,
                                                                        cgarant, nmovi_ant),
                                             pfcarpro + 1),
                                    pfcarpro + 1)
         ORDER BY DECODE(NVL(pac_parametros.f_pargaranpro_n(psproduc, pcactivi, cgarant,
                                                            'ORDEN_TARIF_CARTERA'),
                             0),
                         0, cgarant,
                         pac_parametros.f_pargaranpro_n(psproduc, pcactivi, cgarant,
                                                        'ORDEN_TARIF_CARTERA'));

      --ORDER BY nriesgo;
      -- Bug 9794 - YIL - 21/04/2009 -- Fin
      -- Bug 9524 - YIL - 30/04/2009 -- Fin
      -- Bug 7926 - RSC - 28/05/2009 -- Fin
      ppsproces      garancar.sproces%TYPE := conta_proces;
--       ppsproces      NUMBER := conta_proces; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      piprianu       NUMBER := 0;
      pipritar       NUMBER := 0;
      pirecarg       garancar.irecarg%TYPE := 0;
--       pirecarg       NUMBER := 0; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      pidtocom       garancar.idtocom%TYPE := 0;
--       pidtocom       NUMBER := 0; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      prima          garanseg.icapital%TYPE := 0;
--       prima          NUMBER := 0; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      prevprima      NUMBER;
      pnnumlin       NUMBER;
      garantia       NUMBER;
      wprima         NUMBER;
      -- psesion        sgt_parms_transitorios.sesion%TYPE;   --       psesion        NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      psesion        PLS_INTEGER;
      --       psesion        NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      tasa           NUMBER := 0;
      lnmovimi       NUMBER;
      lcte           NUMBER := 0;
      lcdo           NUMBER := 0;
      lprima_minima  NUMBER;
      formula        sgt_formulas.formula%TYPE;
--       formula        VARCHAR2(2000); --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      lprima_regu    garancar.iprianu%TYPE;
      --       lprima_regu    NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      lcvalpar       NUMBER;
      laplicaprmin   NUMBER;
      vctarman       garanpro.ctarman%TYPE;
      --       vctarman       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      v_factor       NUMBER;   --factor multiplicador.
      --
      v_resp         NUMBER;
      v_nmovimi      NUMBER;
      xdecprev       NUMBER;
      xtmgaran       NUMBER;
      xctabla        NUMBER;
      xltabla        NUMBER;
      xfefecto       DATE;
      --
      vmovgar        NUMBER;
      num_err2       NUMBER;
      pmensa         VARCHAR2(100);
      -- Bug 10350 - RSC - 04/06/2009 - Detalle de garant¿as (tarificaci¿n)
      v_nou_ndetgar  NUMBER;
      v_act_agente   seguros.cagente%TYPE;
      v_irevali_f    NUMBER;
      v_icapital_f   NUMBER;
      v_iprianu_f    NUMBER;
      v_irecarg_f    NUMBER;
      v_ipritar_f    NUMBER;
      v_idtocom_f    NUMBER;
      v_itarrea_f    NUMBER;
      v_pinttec      intertecseg.pinttec%TYPE;
      v_ndurcob_orig detgaranseg.ndurcob%TYPE;
      v_incremento   NUMBER;
      v_nou_ndurcob  detgaranseg.ndurcob%TYPE;
      -- Fin Bug 10350
      v_extraprima   NUMBER;   -- BUG19532:DRA:26/09/2011

      -- Bug 13727 - 05/05/2010 - APR - An¿lisis/Implementaci¿n de nuevas combinaciones de tarificaci¿n Flexilife Nueva Emisi¿n
      TYPE assoc_array_gars IS TABLE OF NUMBER
         INDEX BY PLS_INTEGER;

      vtarif_acrib   assoc_array_gars;
      -- Fin Bug 13727

      -- BUG 20666-  01/2012 - JRH  -  20666:  Buscar en las CAR
      vcapital_ini   NUMBER;
      vcapital_def   NUMBER;
      vcrespuesta    NUMBER;
      -- Fi BUG 20666-  01/2012 - JRH
      v_tregconcep   pac_parm_tarifas.tregconcep_tabtyp;
      -- Bug 21121 - APD - 23/02/2012
      v_cversion     aut_versiones.cversion%TYPE;
      vcont          NUMBER;
      vfrenova       DATE;
      vnmovimi       NUMBER;
      vnsiniestros   NUMBER;
      v_crespue_4942 pregungaranseg.crespue%TYPE;
      v_crespue_4945 pregungaranseg.crespue%TYPE;
      vcempres       NUMBER;   --Bug 26638/161264 - 14/04/2014 - AMC
      vactfranqbonus NUMBER;
      vaplicaplanben NUMBER;
   BEGIN
      parms_transitorios.DELETE;

      -- Inicializo la matriz de parms_transitorios

      -- Seleccionamos el n¿mero de sesi¿n del proceso.
      SELECT sgt_sesiones.NEXTVAL
        INTO psesion
        FROM DUAL;

-- I - JLB - OPTIMIZA
  --    BEGIN
      -- I - JLB - OPTIMIZA
         -- INSERT INTO sgt_parms_transitorios
         --            (sesion, parametro, valor)
          --    VALUES (psesion, 'SESION', psesion);
      num_err := pac_sgt.put(psesion, 'SESION', psesion);

      IF num_err <> 0 THEN
         RETURN 108438;
      END IF;

  --   EXCEPTION
 --        WHEN OTHERS THEN
--            RETURN 108438;
  --    END;
  -- F - JLB - OpTIMIZA
      -- Cal veure si el producte aplica canvi de tarifa al renovar
      num_err := f_parproductos(psproduc, 'NOVATARIFA', lcanvia_tarifa_pro);

      IF num_err <> 0 THEN
         RETURN num_err;
      END IF;

      -- Cal veure si per aquesta p¿lissa en concret existeix l'excepci¿ de no
      -- aplicar la prima m¿nima (Valor fixe 820, concepte = 1), etc.
      num_err := pac_dincartera.f_excepcionsegu(psseguro, 1, laplicaprmin);

      IF num_err <> 0 THEN
         RETURN num_err;
      END IF;

-------------------
-- Cursor de riscos
-------------------
      FOR v_risc IN cur_risc LOOP
         -- Inicialitzar parms
         parms_transitorios.DELETE;
         --
         -- I - JLB - OPTIMIZA
         --DELETE FROM sgt_parms_transitorios
         --      WHERE sesion = psesion
         --        AND parametro <> 'SESION';
         num_err := pac_sgt.del(psesion);
         num_err := pac_sgt.put(psesion, 'SESION', psesion);

        -- F - JLB - OPTIMIZA
------------------------------------------------------------------------
-- Pasamos garanseg a tmp_garancar
------------------------------------------------------------------------
         BEGIN
            SELECT MAX(nmovimi)
              INTO vmovgar
              FROM garanseg
             WHERE sseguro = psseguro
               AND ffinefe IS NULL;

            IF vmovgar IS NULL THEN
               RETURN 10000000000;
            END IF;
         END;

         num_err := pac_tarifas.f_tmpgarancar(NULL, conta_proces, psseguro, v_risc.nriesgo,
                                              vmovgar);

         IF num_err <> 0 THEN
            --DBMS_OUTPUT.put_line ('traspaso garantias ' || num_err);
            RETURN num_err;
         END IF;

         --BUG 0026638: FAC LCOL - TEC - Cartera para Autos. (id 176-19)
         SELECT COUNT(1)
           INTO vcont
           FROM autriesgoscar
          WHERE sproces = conta_proces
            AND sseguro = psseguro
            AND nriesgo = v_risc.nriesgo;

         IF vcont <> 0 THEN
            SELECT cversion
              INTO v_cversion
              FROM autriesgoscar
             WHERE sproces = conta_proces
               AND sseguro = psseguro
               AND nriesgo = v_risc.nriesgo;

            num_err := f_act_homologo_valores(conta_proces, psseguro, v_risc.nriesgo,
                                              v_cversion, psproduc);

            IF num_err <> 0 THEN
               RETURN num_err;
            END IF;

            num_err := f_act_antiguedad(conta_proces, psseguro, v_risc.nriesgo);

            IF num_err <> 0 THEN
               RETURN num_err;
            END IF;

            IF num_err <> 0 THEN
               RETURN num_err;
            END IF;

            vnsiniestros := pac_planbenef.f_autos_siniestros('CAR', psseguro, v_risc.nriesgo,
                                                             vfrenova, vnmovimi, NULL, NULL,
                                                             NULL, NULL, 4926);
            num_err := f_act_num_siniestros(conta_proces, psseguro, v_risc.nriesgo,
                                            vnsiniestros);

            IF num_err <> 0 THEN
               RETURN num_err;
            END IF;

            -- Bug 26638/160974 - 19/12/2013 - AMC
            num_err := f_parproductos(psproduc, 'APLICAPLANBEN', vaplicaplanben);

            IF NVL(vaplicaplanben, 0) = 1 THEN
               num_err := pac_planbenef.f_set_planbeneficios(psseguro, v_risc.nriesgo,
                                                             vnmovimi, conta_proces, 'CAR');

               IF num_err <> 0 THEN
                  RETURN num_err;
               END IF;
            END IF;

            -- Bug 26638/161264 - 14/04/2013 - AMC
            num_err := f_parproductos(psproduc, 'ACTFRANQBONUS', vactfranqbonus);

            IF NVL(vactfranqbonus, 0) = 1 THEN
               SELECT cempres
                 INTO vcempres
                 FROM seguros
                WHERE sseguro = psseguro;

               num_err := pac_dincartera.f_actualizar_franq(conta_proces, psproduc, pcactivi,
                                                            v_risc.nriesgo, psseguro, vmovgar,
                                                            pfefecto, psseguro, NULL, NULL,
                                                            NULL, NULL, NULL, NULL, NULL, NULL,
                                                            NULL, NULL, NULL, NULL, FALSE,
                                                            FALSE, vcempres, pidioma);

               IF num_err <> 0 THEN
                  RETURN num_err;
               END IF;

               -- Bug 26638/161275 - 14/04/2013 - AMC
               num_err := pac_dincartera.f_set_bonus_malus(conta_proces, psseguro,
                                                           v_risc.nriesgo, vmovgar + 1,
                                                           psproduc, pfefecto, vcempres);

               IF num_err <> 0 THEN
                  RETURN num_err;
               END IF;
            END IF;
         END IF;

         --FIN BUG 0026638: FAC LCOL - TEC - Cartera para Autos. (id 176-19)

         --COMMIT;
         --RETURN 111721;

         -------------------------------------------------------------------------
-- Es comprova l'anul.laci¿ per edat
-- las inicializaciones se hacen dentro
-- las preguntas se insertan a dentro de la funcion que tarifa ya
-- que para tarifar se necesitan las respuestas.
-------------------------------------------------------------------------
         cont := 0;
         -- Bug 13727 - 05/05/2010 - APR - An¿lisis/Implementaci¿n de nuevas combinaciones de tarificaci¿n Flexilife Nueva Emisi¿n
         vtarif_acrib.DELETE;

         -- Fin Bug 13727
         FOR v_gar IN c_garanseg_risc(v_risc.nriesgo) LOOP
            --SMF ara mirem que la nova data de tarifa a nivell de garantia
            num_err := f_pargaranpro(pcramo, pcmodali, pctipseg, pccolect, pcactivi,
                                     v_gar.cgarant, 'NOVATARIFAGAR', lcanvia_tarifa_gar);

            IF num_err <> 0 THEN
               RETURN num_err;
            END IF;

            lcanvia_tarifa := NVL(lcanvia_tarifa_gar, lcanvia_tarifa_pro);
            cont := cont + 1;

            IF NVL(lcanvia_tarifa, 0) = 1 THEN
               v_gar.ftarifa := pfcarpro;
            END IF;

            -- Modifiquem la bonificacio
            IF paplica_bonifica = 1 THEN
               -- La bonificaci¿ la posem al descompte.
               v_gar.pdtocom := pbonifica;
            END IF;

            -- Miramos si se tiene que anular la garant¿a por la edad.
            -- Si fuera as¿ en la funci¿n anuledad ya se anula
            num_err := f_anuledad(psseguro, v_gar.nriesgo, v_gar.cgarant, v_gar.nmovimi,
                                  v_gar.finiefe, pfcarpro, pcramo, pcmodali, pctipseg,
                                  pccolect, pcobjase, pmodo, NULL   --ptablas
                                                                 , pnedamar, pciedmar,
                                  estat_garan);

            IF num_err <> 0 THEN
               RETURN num_err;
            END IF;

            IF estat_garan = 'NO_CAMBIADA' THEN   -- si la garant¿a no se anula por la edad
-----------------------------------------------------------
--BUSQUEDA DEL ctarman de la garantia. Si el de la poliza=5
----------------------------------------------------------
               IF (pcmanual = 5) THEN
                  BEGIN
                     SELECT ctarman
                       INTO vctarman
                       FROM garanpro
                      WHERE cgarant = v_gar.cgarant
                        AND cramo = pcramo
                        AND cmodali = pcmodali
                        AND ctipseg = pctipseg
                        AND ccolect = pccolect
                        AND cactivi = pcactivi;
                  EXCEPTION
                     WHEN NO_DATA_FOUND THEN
                        --si no la encontramos, buscamos la actividad 0
                        BEGIN
                           SELECT ctarman
                             INTO vctarman
                             FROM garanpro
                            WHERE cgarant = v_gar.cgarant
                              AND cramo = pcramo
                              AND cmodali = pcmodali
                              AND ctipseg = pctipseg
                              AND ccolect = pccolect
                              AND cactivi = 0;
                        EXCEPTION
                           WHEN OTHERS THEN
                              p_literal2(111832, pidioma, texto);
                              texto := texto || v_gar.cgarant;
                              aux := NULL;
                              num_err := f_proceslin(conta_proces, texto, psseguro, aux);
                              RETURN 111832;
                        --Error al cercar el ctarman per la garantia :
                        END;
                     WHEN OTHERS THEN
                        p_literal2(111832, pidioma, texto);
                        texto := texto || v_gar.cgarant;
                        aux := NULL;
                        num_err := f_proceslin(conta_proces, texto, psseguro, aux);
                        RETURN 111832;   --error al leer de garanpro
                  END;

                  --comprobaci¿n que ctarman encontrado es correcto.
                  IF vctarman IS NULL THEN
                     p_literal2(111456, pidioma, texto);
                     aux := NULL;
                     num_err := f_proceslin(conta_proces, texto, psseguro, aux);
                     RETURN 111456;
                  --El campo CTARMAN esta a nulo en GARANPRO
                  END IF;
               END IF;   --fin --pcmanual=5

-----------------------------------------------------------
-- inicializamos las variables, con el codigo de garantia
-- de riesgo y la forma de tarificaci¿n.
-----------------------------------------------------------
               piprianu := NULL;
               pipritar := NULL;
               prevcap := NULL;
               prevprima := NULL;
               parms_transitorios(cont).cgarant := v_gar.cgarant;
               parms_transitorios(cont).nriesgo := v_gar.nriesgo;
               parms_transitorios(cont).ctarman := NVL(vctarman, pcmanual);
               parms_transitorios(cont).nfactor := v_gar.nfactor;

               --revalorizamos aqui..
               IF pcforpag <> 0
                  OR NVL(f_parproductos_v(psproduc, 'REVALORIZA_CAPITAL'), 0) = 1 THEN   -- BUG24804:DRA:01/03/2013
                  --
                  IF NVL(v_gar.crevalcar, 1) = 1 THEN
                     IF NVL(f_parproductos_v(psproduc, 'DETALLE_GARANT'), 0) = 1 THEN
                        IF v_gar.ipritar = 0
                           OR v_gar.ipritar IS NULL THEN
                           wprima := v_gar.iprianu;
                        ELSE
                           wprima := v_gar.ipritar;
                        END IF;
                     ELSE
                        IF v_gar.ipritar = 0 THEN
                           wprima := v_gar.iprianu;
                        ELSE
                           wprima := v_gar.ipritar;
                        END IF;
                     END IF;

                     -- Bug 10828 - RSC - 08/09/2009 - CRE - Revisi¿n de los productos PPJ din¿mico y Pla Estudiant (ajustes)
                     IF (NVL(f_parproductos_v(psproduc, 'SOLO_TARIFA_CARTERA'), 0) <> 1)
                        OR(NVL(f_parproductos_v(psproduc, 'SOLO_TARIFA_CARTERA'), 0) = 1
                           AND pfcarpro = pfcaranu) THEN
                        -- Bug 9794 - YIL - 21/04/2009 - Se le pasa el nuevo par¿metro a f_revalgar: v_gar.nriesgo
                        IF NVL(f_parproductos_v(psproduc, 'DETALLE_GARANT'), 0) = 1 THEN
                           -- Bug 10350 - RSC - 19/06/2009 - Detalle de garant¿as
                           -- Si tiene detalle de garant¿a la parte de prima revalorizada se generar¿
                           -- con otro movimiento detalle (NDETGAR) y la parte de prima sin revalorizar
                           -- se debe dejar en TMP_GARANCAR con los valores de capital, prima, etc
                           -- que ya ten¿a. Por tanto aqui grabamos parms_transitorios con los valores
                           -- antes de revalorizar.
                           parms_transitorios(cont).icapital := v_gar.icapital;
                           parms_transitorios(cont).iprianu := v_gar.iprianu;
                           parms_transitorios(cont).ipritar := v_gar.ipritar;

                           -- Bug 13727 - 18/03/2010 - APR - An¿lisis/Implementaci¿n de nuevas combinaciones de tarificaci¿n Flexilife Nueva Emisi¿n
                           IF v_gar.cgarant IN(2116) THEN
                              parms_transitorios(cont).sitarifa := 1;
                           ELSE
                              parms_transitorios(cont).sitarifa := 0;
                                          -- Marcamos para que esta no tarife
                           -- (campo nuievo en PAC_PARMS_TARIFAS)
                           END IF;

                           -- Fin Bug 13727
                           UPDATE tmp_garancar
                              SET contador = cont,
                                  sitarifa = parms_transitorios(cont).sitarifa
                            WHERE sseguro = psseguro
                              AND sproces = conta_proces
                              AND cgarant = v_gar.cgarant
                              AND nriesgo = v_gar.nriesgo
                              AND ndetgar = v_gar.ndetgar;

                           num_err := f_revalgar_det(psseguro, NVL(vctarman, pcmanual),
                                                     v_gar.cgarant, pcactivi, pcramo, pcmodali,
                                                     pctipseg, pccolect, v_gar.icapital,
                                                     wprima, v_gar.crevali, v_gar.irevali,
                                                     v_gar.prevali, TO_NUMBER(pmes), panyo,
                                                     prevcap, prevprima, v_factor,
                                                     v_gar.nriesgo, v_gar.ndetgar);
                        ELSE
                           IF NVL(f_parproductos_v(psproduc, 'DETALLE_GARANT'), 0) = 2 THEN
                              -- Bug 29943 - 03/06/2014 - JTT: Como se realiza para DETALLE_GARANT=1 actualizamos
                                 -- el campo contador con el indice para que la funcion f_revalgar pueda actualizar los
                                 -- registros correctamente.
                              UPDATE tmp_garancar
                                 SET contador = cont
                               WHERE sseguro = psseguro
                                 AND sproces = conta_proces
                                 AND cgarant = v_gar.cgarant
                                 AND nriesgo = v_gar.nriesgo
                                 AND ndetgar = v_gar.ndetgar;

                              -- Fi Bug 29943
                              IF v_gar.cunica = 0 THEN
                                 parms_transitorios(cont).sitarifa := 1;
                                 num_err := f_revalgar(psseguro, NVL(vctarman, pcmanual),
                                                       v_gar.cgarant, pcactivi, pcramo,
                                                       pcmodali, pctipseg, pccolect,
                                                       v_gar.icapital, wprima, v_gar.crevali,
                                                       v_gar.irevali, v_gar.prevali,
                                                       TO_NUMBER(pmes), panyo, prevcap,
                                                       prevprima, v_factor, v_gar.nriesgo);
                              ELSE
                                 parms_transitorios(cont).sitarifa := 0;
                              -- Marcamos para que esta no tarife
                              END IF;
                           ELSE
                              num_err := f_revalgar(psseguro, NVL(vctarman, pcmanual),
                                                    v_gar.cgarant, pcactivi, pcramo, pcmodali,
                                                    pctipseg, pccolect, v_gar.icapital,
                                                    wprima, v_gar.crevali, v_gar.irevali,
                                                    v_gar.prevali, TO_NUMBER(pmes), panyo,
                                                    prevcap, prevprima, v_factor,
                                                    v_gar.nriesgo);
                           END IF;

                           -- Bug 9794 - YIL - 21/04/2009 - Fin
                           parms_transitorios(cont).nfactor :=
                                                           v_gar.nfactor
                                                           *(1 +(v_factor / 100));
                           parms_transitorios(cont).nfactor :=
                                                           v_gar.nfactor
                                                           *(1 +(v_factor / 100));
                        END IF;

                        IF num_err <> 0 THEN
                           p_literal2(num_err, pidioma, texto);
                           aux := NULL;
                           num_err2 := f_proceslin(conta_proces, texto, psseguro, aux);
                           RETURN num_err;
                        END IF;
                     END IF;
                  ELSE
                     prevcap := v_gar.icapital;
                  END IF;
               ELSE
                  prevcap := v_gar.icapital;
               END IF;   -- De si revaloriza o no

               -- Bug 9794 - YIL - 21/04/2009 - se a¿ade  ELSIF NVL(vctarman, pcmanual) IN (0) then
               IF NVL(vctarman, pcmanual) IN(1, 3) THEN   -- Manual
                  piprianu := prevprima;
                  pipritar := prevprima;
               ELSIF NVL(vctarman, pcmanual) IN(0) THEN
                  piprianu := prevprima;
                  pipritar := prevprima;
               ELSE   -- Revaloritza prima
                  IF NVL(vctarman, pcmanual) IN(2, 4) THEN   --Automatico.
                     pipritar := prevprima;
                     piprianu := prevprima;
                  --ELSE
                  -- pipritar := NULL;
                  -- piprianu := NULL;
                  END IF;
               END IF;

               -- Bug 9794 - YIL - 21/04/2009 - Fin

               ---------------------------------------------------
-- copiamos los k y primas que hemos econtrado.
---------------------------------------------------
               IF NVL(f_parproductos_v(psproduc, 'DETALLE_GARANT'), 0) <> 1 THEN
                  IF NVL(f_parproductos_v(psproduc, 'DETALLE_GARANT'), 0) = 2 THEN
                     IF v_gar.cunica = 0 THEN
                        parms_transitorios(cont).icapital := NVL(prevcap, v_gar.icapital);
                        parms_transitorios(cont).iprianu := NVL(piprianu, v_gar.iprianu);
                        parms_transitorios(cont).ipritar := NVL(pipritar, v_gar.ipritar);

                        -- actualizamos la tabla tmp_garancar para que coja, las primas
                        -- y capitales revalorizadas
                        -- Bug 10350 - 04/06/2009 - RSC - Detalle garant¿as (tarificaci¿n)
                        -- Updateamos cada detalle si es que tiene detalle
                        UPDATE tmp_garancar
                           SET icapital = parms_transitorios(cont).icapital,
                               iprianu = parms_transitorios(cont).iprianu,
                               ipritar = parms_transitorios(cont).ipritar,
                               nfactor = parms_transitorios(cont).nfactor,
                               ftarifa = v_gar.ftarifa
                         WHERE sseguro = psseguro
                           AND sproces = conta_proces
                           AND cgarant = v_gar.cgarant
                           AND nriesgo = v_gar.nriesgo
                           AND ndetgar = v_gar.ndetgar;
                     END IF;
                  ELSE
                     parms_transitorios(cont).icapital := NVL(prevcap, v_gar.icapital);
                     parms_transitorios(cont).iprianu := NVL(piprianu, v_gar.iprianu);
                     parms_transitorios(cont).ipritar := NVL(pipritar, v_gar.ipritar);

                     -- actualizamos la tabla tmp_garancar para que coja, las primas
                     -- y capitales revalorizadas
                     -- Bug 10350 - 04/06/2009 - RSC - Detalle garant¿as (tarificaci¿n)
                     -- Updateamos cada detalle si es que tiene detalle
                     UPDATE tmp_garancar
                        SET icapital = parms_transitorios(cont).icapital,
                            iprianu = parms_transitorios(cont).iprianu,
                            ipritar = parms_transitorios(cont).ipritar,
                            nfactor = parms_transitorios(cont).nfactor,
                            ftarifa = v_gar.ftarifa
                      WHERE sseguro = psseguro
                        AND sproces = conta_proces
                        AND cgarant = v_gar.cgarant
                        AND nriesgo = v_gar.nriesgo
                        -- Bug 10350 - 04/06/2009 - RSC - Detalle garant¿as (tarificaci¿n)
                        AND ndetgar = v_gar.ndetgar;
                  END IF;
               ELSE
                  -- Bug 10350 - RSC - 05/08/2009 - Detalle de garant¿as (Tarificaci¿n)
                  SELECT GREATEST(MONTHS_BETWEEN(ffincob, pfcarpro), 0)
                    INTO v_nou_ndurcob
                    FROM tmp_garancar
                   WHERE sseguro = psseguro
                     AND cgarant = v_gar.cgarant
                     AND finiefe = v_gar.finiefe
                     AND nriesgo = v_gar.nriesgo
                     AND sproces = conta_proces
                     AND ndetgar = v_gar.ndetgar;

                  -- Si tiene duraci¿n de pagos todav¿a se genera nueva detalle
                  IF v_nou_ndurcob > 0 THEN
                     -- Fin Bug 10350 - RSC - 05/08/2009
                     IF v_gar.crevali <> 0
                        AND pac_propio.f_garan_reducida(psseguro, v_gar.cgarant, v_gar.ndetgar) =
                                                                                              0
                        AND v_factor > 0 THEN
                        -- Bug 13727 - 05/05/2010 - APR - An¿lisis/Implementaci¿n de nuevas combinaciones de tarificaci¿n Flexilife Nueva Emisi¿n
                        IF v_gar.cgarant IN(2113, 2115)
                           AND vtarif_acrib.EXISTS(v_gar.cgarant) THEN
                           -- Si ya hemos creado un nuevo detalle para la 2113 no vamos a crear m¿s.
                           -- El nuevo detalle recoger¿ la tarificaci¿n del resto. El problema
                           -- es que la garant¿a 2113 se calcula en funci¿n a la prima de otras garant¿as
                           -- como la 2101 o la 2108. Si 2101 o 2108 revalorizan y crean nuevos detalles
                           -- la 2113 debe crear nuevo detalle, pero solo uno, este ya recoger¿ las revalorizaciones
                           -- del resto de garant¿as.
                           NULL;
                        ELSE
                           vtarif_acrib(v_gar.cgarant) := 0;
                           -- Fin Bug 13727

                           -- Incrementamos contador para grabar una nueva linea de
                           -- tarificaci¿n
                           cont := cont + 1;
                           parms_transitorios(cont).cgarant := v_gar.cgarant;
                           parms_transitorios(cont).nriesgo := v_gar.nriesgo;
                           parms_transitorios(cont).ctarman := NVL(vctarman, pcmanual);
                           parms_transitorios(cont).nfactor :=
                                                          v_gar.nfactor
                                                          *(1 +(v_factor / 100));
                           -- Guardamos el incremento o revalorizaci¿n
                           parms_transitorios(cont).icapital := prevcap;
                           parms_transitorios(cont).iprianu := piprianu;
                           parms_transitorios(cont).ipritar := pipritar;
                           -- Marcamos para que esta SI tarife
                           parms_transitorios(cont).sitarifa := 1;

                           SELECT MAX(ndetgar) + 1
                             INTO v_nou_ndetgar
                             FROM tmp_garancar
                            WHERE sseguro = psseguro
                              AND cgarant = v_gar.cgarant
                              AND finiefe = v_gar.finiefe
                              AND nriesgo = v_gar.nriesgo
                              AND sproces = conta_proces;

                           -- Obtenemos el agente actual para el nuevo detalle
                           SELECT cagente
                             INTO v_act_agente
                             FROM seguros
                            WHERE sseguro = psseguro;

                           -- FBL. 25/06/2014 MSV Bug 0028974
                           INSERT INTO tmp_garancar
                                       (sseguro, cgarant, nriesgo, finiefe, norden, ctarifa,
                                        icapital, precarg, iprianu, ffinefe, cformul, iextrap,
                                        ctipfra, ifranqu, sproces, irecarg, ipritar, pdtocom,
                                        idtocom, crevali, prevali, irevali, itarifa, itarrea,
                                        ipritot, icaptot, ftarifa, cderreg, feprev, fpprev,
                                        percre, cref, cintref, pdif, pinttec, nparben, nbns,
                                        tmgaran, cmatch, tdesmat, pintfin, nmovima, nfactor,
                                        nmovi_ant, idtoint, ccampanya, nversio, cageven,
                                        nlinea, ctarman, ndetgar, fefecto, fvencim, ndurcob,
                                        cparben, cprepost, ffincob, provmat0, fprovmat0,
                                        provmat1, fprovmat1, pintmin, ipripur, ipriinv, cunica,
                                        ipricom)
                              SELECT sseguro, cgarant, nriesgo, finiefe, norden, ctarifa,
                                     icapital, precarg, iprianu, ffinefe, cformul, iextrap,
                                     ctipfra, ifranqu, sproces, irecarg, ipritar, pdtocom,
                                     idtocom, crevali, prevali, irevali, itarifa, itarrea,
                                     ipritot, icaptot, ftarifa, cderreg, feprev, fpprev,
                                     percre, cref, cintref, pdif, pinttec, nparben, nbns,
                                     tmgaran, cmatch, tdesmat, pintfin, nmovima, nfactor,
                                     nmovi_ant, idtoint, ccampanya, nversio, v_act_agente,
                                     nlinea, ctarman, v_nou_ndetgar, fefecto, fvencim, ndurcob,
                                     cparben, cprepost, ffincob, provmat0, fprovmat0, provmat1,
                                     fprovmat1, pintmin, NULL, NULL, cunica, ipricom
                                -- IPRIPUR y IPRIINV grabamos NULL de momento
                              FROM   tmp_garancar
                               WHERE sseguro = psseguro
                                 AND cgarant = v_gar.cgarant
                                 AND finiefe = v_gar.finiefe
                                 AND nriesgo = v_gar.nriesgo
                                 AND sproces = conta_proces
                                 AND ndetgar = v_gar.ndetgar;

                           -- Fin FBL. 25/06/2014 MSV Bug 0028974
                           -- Inter¿s vigente asociado a la 'tarifa' vigente
                           IF v_gar.ctarifa = NVL(f_parproductos_v(psproduc, 'CTARIFA_VIGENTE'),
                                                  v_gar.ctarifa) THEN
                              v_pinttec := v_gar.pinttec;
                           ELSE
                              v_pinttec := pac_inttec.ff_int_gar_seg(NULL, psseguro,
                                                                     v_gar.cgarant, pfcarpro);
                           END IF;

                           -- Obtenemos el NDURCOB del detalle origen
                           UPDATE tmp_garancar
                              SET icapital = parms_transitorios(cont).icapital,
                                  iprianu = parms_transitorios(cont).iprianu,
                                  ipritar = parms_transitorios(cont).ipritar,
                                  nfactor = parms_transitorios(cont).nfactor,
                                  ftarifa = pfcarpro,
                                  ctarifa = NVL(f_parproductos_v(psproduc, 'CTARIFA_VIGENTE'),
                                                v_gar.ctarifa),
                                  contador = cont,
                                  pinttec = v_pinttec,
                                  fefecto = pfcarpro,
                                  ndurcob = GREATEST(MONTHS_BETWEEN(ffincob, pfcarpro), 0)
--(v_ndurcob_orig - v_incremento) --LEAST(months_between(fvencim, pfcarpro), v_ndurcob_orig)
                           WHERE  sseguro = psseguro
                              AND sproces = conta_proces
                              AND cgarant = v_gar.cgarant
                              AND nriesgo = v_gar.nriesgo
                              AND finiefe = v_gar.finiefe
                              AND ndetgar = v_nou_ndetgar;

                           -- Establecemos el nuevo NDURCOB al detalle origen
                           -- para poder agrupar posteriormente por NDURCOB.
                           -- Siempre y cuando la tarifa sea la misma. Si no tienen
                           -- la misma tarifa ese detalle se quedar¿ como est¿ (con su NDURCOB)
                           --IF v_gar.ctarifa = NVL(f_parproductos_v(psproduc, 'CTARIFA_VIGENTE'), v_gar.ctarifa) THEN
                           UPDATE tmp_garancar
                              SET ndurcob = GREATEST(MONTHS_BETWEEN(ffincob, pfcarpro), 0)
--(v_ndurcob_orig - v_incremento) -- LEAST(months_between(fvencim, pfcarpro), v_ndurcob_orig)
                           WHERE  sseguro = psseguro
                              AND sproces = conta_proces
                              AND cgarant = v_gar.cgarant
                              AND nriesgo = v_gar.nriesgo
                              AND finiefe = v_gar.finiefe
                              AND ndetgar = v_gar.ndetgar;
                        END IF;
                     END IF;
                  ELSE
                     -- Bug 10350 - RSC - 05/08/2009 - Detalle de garant¿as (Tarificaci¿n)
                     -- Hay que 'reducir' la garant¿a.
                     parms_transitorios(cont).iprianu := 0;

                     UPDATE tmp_garancar
                        SET ndurcob = 0,
                            iprianu = 0
                      WHERE sseguro = psseguro
                        AND sproces = conta_proces
                        AND cgarant = v_gar.cgarant
                        AND nriesgo = v_gar.nriesgo
                        AND finiefe = v_gar.finiefe
                        AND ndetgar = v_gar.ndetgar;
                  END IF;
               -- Al fusionar detalles guardaremos en DETGARANSEG la m¿nima fefecto
               END IF;
            --   return 0;
            -- Revalorizaci¿n
            --num_err := Pac_cartera.F_Reval_Par (v_gar.crevali,v_gar.prevali,v_gar.irevali,v_gar.finiefe,
            --              v_gar.icapital,pcramo,pcmodali,pctipseg,pccolect,pcactivi,
            --              v_gar.cgarant,cont,parms_transitorios);
            --IF num_err <> 0 THEN
            --  RETURN num_err;
            --END IF;
            ELSE
               -- Bug 10350 - 04/06/2009 - RSC - Detalle garant¿as (tarificaci¿n)
               -- Anulamos cada detalle uno por uno
               UPDATE tmp_garancar
                  SET canulado = 1
                WHERE sproces = conta_proces
                  AND cgarant = v_gar.cgarant
                  AND nriesgo = v_risc.nriesgo
                  AND sseguro = psseguro
                  -- Bug 10350 - 04/06/2009 - RSC - Detalle garant¿as (tarificaci¿n)
                  AND ndetgar = v_gar.ndetgar;
            -- Fin Bug 10350
            END IF;   -- si no_cambiada
         END LOOP;

         -- Bug 7926 - 28/05/2009 - RSC - Fecha de vencimiento a nivel de garant¿a
         -- PAC_TARIFAS.f_tmpgarancar inserta todas las garant¿as en TMP_GARANCAR
         -- aunque estas est¿n vencidas para la cartera
         IF pmodo = 'P' THEN   -- PREVI CARTERA TAR
            FOR regs IN (SELECT sseguro, cgarant, nriesgo
                           FROM garanseg
                          WHERE sseguro = psseguro
                            AND nriesgo = v_risc.nriesgo
                            AND ffinefe IS NULL
                            AND pfcarpro >= NVL(pac_seguros.f_vto_garantia(sseguro, nriesgo,
                                                                           cgarant, nmovimi),
                                                pfcarpro + 1)) LOOP
               --MINUS
               --SELECT sseguro, cgarant, nriesgo
               --  FROM garanseg
               -- WHERE sseguro = psseguro
               --   AND nriesgo = v_risc.nriesgo
               --   AND ffinefe IS NULL
               --   AND pfcarpro < NVL(pac_seguros.f_vto_garantia(sseguro, nriesgo,
               --                                                   cgarant, nmovimi),
               --                      pfcarpro + 1)) LOOP
               -- La garant¿a vence y por tanto la anulamos en TMP_GARANCAR
               -- Al anularla aqu¿ la tarificaci¿n ya no la tendr¿ en cuenta
               UPDATE tmp_garancar
                  SET canulado = 1
                WHERE sproces = conta_proces
                  AND cgarant = regs.cgarant
                  AND nriesgo = regs.nriesgo
                  AND sseguro = psseguro;
            -- Bug 10350 - 04/06/2009 - RSC - Detalle garant¿as (tarificaci¿n)
            -- Nota: En caso de tener Detalle de garant¿as anulamos todos los
            -- detalles directamente (no utilizamos NDETGAR) en caso de que
            -- a la garant¿a le toque vencer.
            END LOOP;
         END IF;

         -- Fin Bug 7926
         SELECT COUNT(1)
           INTO num_err
           FROM tmp_garancar
          WHERE sproces = conta_proces
            AND nriesgo = v_risc.nriesgo
            AND sseguro = psseguro
            AND NVL(canulado, 0) <> 1;

         --Tarifem totes les garanties de la polissa i risc
         --(tant anul¿lades com no anul¿lades).
         IF num_err <> 0 THEN   --miro si hay garantias vigentes.
            --DBMS_OUTPUT.put_line ('---- efefcte a tarifar risc ' || pfefecto);
            num_err := pac_tarifas.f_tarifar_risc(ppsproces, NULL, 'CAR', pmodo, pcramo,
                                                  pcmodali, pctipseg, pccolect, psproduc,
                                                  pcactivi, paplica_bonifica, pbonifica,
                                                  psseguro, v_risc.nriesgo, pfcarpro,   --pfemisio, nununu
                                                  pfefecto, pcmanual, pcobjase, pcforpag,
                                                  pidioma, pmes, panyo, pmoneda,
                                                  parms_transitorios, total_prima, pmensa,
                                                  'CAR');

            IF num_err <> 0 THEN
               RETURN num_err;
            END IF;
         END IF;

         -- Despr¿s de tarifar traspassem a garancar.

         -- Bug 10350 - 22/06/2009 - RSC - Detalle garant¿as (tarificaci¿n)
         IF NVL(f_parproductos_v(psproduc, 'DETALLE_GARANT'), 0) = 1 THEN
            -- FBL. 25/06/2014 MSV Bug 0028974
            INSERT INTO garancar
                        (sseguro, cgarant, nriesgo, finiefe, norden, ctarifa, icapital,
                         precarg, iprianu, iextrap, ctipfra, ifranqu, sproces, irecarg,
                         ipritar, pdtocom, idtocom, crevali, prevali, irevali, itarifa,
                         itarrea, ipritot, icaptot, ftarifa, cderreg, feprev, fpprev, percre,
                         cref, cintref, pdif, pinttec, nparben, nbns, tmgaran, cmatch,
                         tdesmat, pintfin, canulado, nfactor, nmovi_ant, idtoint, ccampanya,
                         nversio, cageven, nmovima, ndetgar, fefecto, fvencim, ndurcob,
                         ffincob, cparben, ipripur, ipriinv, cunica, ipricom)
               SELECT   MIN(sseguro), MIN(cgarant), MIN(nriesgo), pfcarpro, MIN(norden),
                        ctarifa, SUM(icapital), MIN(precarg), SUM(iprianu), MIN(iextrap),
                        MIN(ctipfra), MIN(ifranqu), MIN(sproces), SUM(irecarg), SUM(ipritar),
                        MIN(pdtocom), SUM(idtocom), MIN(crevali), MIN(prevali), SUM(irevali),
                        SUM(itarifa), SUM(itarrea), SUM(ipritot), SUM(icaptot), MIN(ftarifa),
                        MIN(cderreg), MIN(feprev), MIN(fpprev), MIN(percre), MIN(cref),
                        MIN(cintref), MIN(pdif), MIN(pinttec), MIN(nparben), MIN(nbns),
                        MIN(tmgaran), MIN(cmatch), MIN(tdesmat), MIN(pintfin), MIN(canulado),
                        MIN(nfactor), MIN(nmovi_ant), MIN(idtoint), MIN(ccampanya),
                        MIN(nversio), MIN(cageven), MIN(nmovima), MIN(ndetgar) ndetgar,
                        MIN(fefecto) fefecto, MAX(fvencim) fvencim, ndurcob,
                        MAX(ffincob) ffincob, MIN(cparben) cparben, SUM(ipripur),
                        SUM(ipriinv), 0, ipricom
                   FROM tmp_garancar
                  WHERE sproces = ppsproces
                    AND sseguro = psseguro
                    AND nriesgo = v_risc.nriesgo
                    AND cunica = 0
               GROUP BY cgarant, ctarifa, ndurcob
               ORDER BY cgarant, ctarifa, ndurcob;

            -- Fin FBL. 25/06/2014 MSV Bug 0028974

            -- Las linea de detalle que tienen CUNICA = 1 no se tarifan ni generan nuevo detalle.
            -- Por tanto, tras tarifar, se debe insertar tal cual en garancar

            -- FBL. 25/06/2014 MSV Bug 0028974
            INSERT INTO garancar
                        (sseguro, cgarant, nriesgo, finiefe, norden, ctarifa, icapital,
                         precarg, iprianu, iextrap, ctipfra, ifranqu, sproces, irecarg,
                         ipritar, pdtocom, idtocom, crevali, prevali, irevali, itarifa,
                         itarrea, ipritot, icaptot, ftarifa, cderreg, feprev, fpprev, percre,
                         cref, cintref, pdif, pinttec, nparben, nbns, tmgaran, cmatch, tdesmat,
                         pintfin, canulado, nfactor, nmovi_ant, idtoint, ccampanya, nversio,
                         cageven, nmovima, ndetgar, fefecto, fvencim, ndurcob, ffincob,
                         cparben, ipripur, ipriinv, cunica, ipricom)
               SELECT sseguro, cgarant, nriesgo, pfcarpro, norden, ctarifa, icapital, precarg,
                      iprianu, iextrap, ctipfra, ifranqu, sproces, irecarg, ipritar, pdtocom,
                      idtocom, crevali, prevali, irevali, itarifa, itarrea, ipritot, icaptot,
                      ftarifa, cderreg, feprev, fpprev, percre, cref, cintref, pdif, pinttec,
                      nparben, nbns, tmgaran, cmatch, tdesmat, pintfin, canulado, nfactor,
                      nmovi_ant, idtoint, ccampanya, nversio, cageven, nmovima, ndetgar,
                      fefecto, fvencim, ndurcob, ffincob, cparben, ipripur, ipriinv, 1,
                      ipricom
                 FROM tmp_garancar
                WHERE sproces = ppsproces
                  AND sseguro = psseguro
                  AND nriesgo = v_risc.nriesgo
                  AND cunica <> 0;   -- = 1
         -- Fin FBL. 25/06/2014 MSV Bug 0028974
-- PRUEBA !!!! -------------------------------------------
--COMMIT;
--RETURN 111721;
----------------------------------------------------------
         ELSE
            IF NVL(f_parproductos_v(psproduc, 'DETALLE_GARANT'), 0) = 2 THEN
               -- FBL. 25/06/2014 MSV Bug 0028974
               INSERT INTO garancar
                           (sseguro, cgarant, nriesgo, finiefe, norden, ctarifa, icapital,
                            precarg, iprianu, iextrap, ctipfra, ifranqu, sproces, irecarg,
                            ipritar, pdtocom, idtocom, crevali, prevali, irevali, itarifa,
                            itarrea, ipritot, icaptot, ftarifa, cderreg, feprev, fpprev,
                            percre, cref, cintref, pdif, pinttec, nparben, nbns, tmgaran,
                            cmatch, tdesmat, pintfin, canulado, nfactor, nmovi_ant, idtoint,
                            ccampanya, nversio, cageven, nmovima, ndetgar, fefecto, fvencim,
                            ndurcob, ffincob, cparben, ipripur, ipriinv, cunica, pintmin,
                            ipricom)
                  SELECT sseguro, cgarant, nriesgo, pfcarpro, norden, ctarifa, icapital,
                         precarg, iprianu, iextrap, ctipfra, ifranqu, sproces, irecarg,
                         ipritar, pdtocom, idtocom, crevali, prevali, irevali, itarifa,
                         itarrea, ipritot, icaptot, ftarifa, cderreg, feprev, fpprev, percre,
                         cref, cintref, pdif, pinttec, nparben, nbns, tmgaran, cmatch,
                         tdesmat, pintfin, canulado, nfactor, nmovi_ant, idtoint, ccampanya,
                         nversio, cageven, nmovima, ndetgar, fefecto, fvencim, ndurcob,
                         ffincob, cparben, ipripur, ipriinv, cunica, pintmin, ipricom
                    FROM tmp_garancar
                   WHERE sproces = ppsproces
                     AND sseguro = psseguro
                     AND nriesgo = v_risc.nriesgo;
            -- Fin FBL. 25/06/2014 MSV Bug 0028974
            ELSE
               -- Bug 10350 - 04/06/2009 - RSC - Detalle garant¿as (tarificaci¿n)
               -- Grabamos NDETGAR igual a 0.
               -- FBL. 25/06/2014 MSV Bug 0028974
               INSERT INTO garancar
                           (sseguro, cgarant, nriesgo, finiefe, norden, ctarifa, icapital,
                            precarg, iprianu, ffinefe, cformul, iextrap, ctipfra, ifranqu,
                            sproces, irecarg, ipritar, pdtocom, idtocom, crevali, prevali,
                            irevali, itarifa, itarrea, ipritot, icaptot, ftarifa, cderreg,
                            feprev, fpprev, percre, cref, cintref, pdif, pinttec, nparben,
                            nbns, tmgaran, cmatch, tdesmat, pintfin, canulado, nfactor,
                            nmovi_ant, idtoint, ccampanya, nversio, cageven, nlinea, nmovima,
                            ndetgar, ipricom)
                  SELECT sseguro, cgarant, nriesgo, pfcarpro, norden, ctarifa, icapital,
                         precarg, iprianu, ffinefe, cformul, iextrap, ctipfra, ifranqu,
                         sproces, irecarg, ipritar, pdtocom, idtocom, crevali, prevali,
                         irevali, itarifa, itarrea, ipritot, icaptot, ftarifa, cderreg,
                         feprev, fpprev, percre, cref, cintref, pdif, pinttec, nparben, nbns,
                         tmgaran, cmatch, tdesmat, pintfin, canulado, nfactor, nmovi_ant,
                         idtoint, ccampanya, nversio, cageven, nlinea, nmovima, 0, ipricom
                    FROM tmp_garancar
                   WHERE sproces = ppsproces
                     AND sseguro = psseguro
                     AND nriesgo = v_risc.nriesgo;
            -- Fin FBL. 25/06/2014 MSV Bug 0028974
            END IF;
         END IF;

         -- Fin Bug 10350
         DELETE FROM tmp_garancar
               WHERE sproces = ppsproces;

         --Bug 26638/160974 - 03/04/2014 - AMC
         DELETE FROM garanseg_aux
               WHERE sseguro = psseguro;

------------------------------------------------
         -- COMPROVACI¿ de prima m¿nima, cal regularitzar
------------------------------------------------
-- Si s'ha de comprovar la prima m¿nima, cal veure si hi ha garantia
-- de regularitzaci¿.
-- Si la prima m¿nima ¿s calculada, cal cridar al SGT
         lprima_minima := NULL;

         IF pcgarant_regu IS NOT NULL
            AND NVL(pcprimin, 0) = 1
            AND NVL(laplicaprmin, 1) = 1 THEN
            --DBMS_OUTPUT.put_line ('vaig a calcular pm       ');
            BEGIN
               SELECT formula
                 INTO formula
                 FROM sgt_formulas
                WHERE clave = pcclapri;

               -- Bug 21121 - APD - 23/02/2012 - se a¿ade el parametro v_tregconcep
               pac_parm_tarifas.inserta_parametro(psesion, pcclapri, 1, parms_transitorios,
                                                  num_err, NULL, v_tregconcep);

               -- fin Bug 21121 - APD - 232/02/2012
               IF num_err <> 0 THEN
                  mensa := pcgarant_regu || '.Regulariza';
                  RETURN(num_err);
               END IF;

               -- Insertem el par¿metre pfunci¿n per saber qu¿ estem fent
               -- desde SGT ( Cartera, Alta, suplement, Reasseg )
               -- JLB - I - OPTIMI
                         -- BEGIN
                             --INSERT INTO sgt_parms_transitorios
                             --            (sesion, parametro, valor)
                             --     VALUES (psesion, 'FUNCION', 3);
               num_err := pac_sgt.put(psesion, 'FUNCION', 3);

               IF num_err <> 0 THEN
                  RETURN 109843;
               END IF;

                 -- JLB - F - OPTIMIZA
               -- EXCEPTION
                 --  WHEN OTHERS THEN
                 --     RETURN 109843;
                --END;

               ---nunu

               --trobem el valor de la prima minima
               lprima_minima := pk_formulas.eval(formula, psesion);
            --DBMS_OUTPUT.put_line ('lprima_minima ' || lprima_minima);
            EXCEPTION
               WHEN OTHERS THEN
                  p_literal2(101150, pidioma, texto);
                  pnnumlin := NULL;
                  num_err := f_proceslin(ppsproces, texto, psseguro, pnnumlin);
                  RETURN 101150;
            END;
         ELSIF pcgarant_regu IS NOT NULL
               AND NVL(pcprimin, 1) = 0
               AND NVL(laplicaprmin, 1) = 1 THEN
            lprima_minima := piprimin;
         END IF;

         --DBMS_OUTPUT.put_line ('lprima_minima ' || lprima_minima);
         --DBMS_OUTPUT.put_line ('total prima ' || total_prima);
         IF total_prima < NVL(lprima_minima, 0)
            AND NVL(laplicaprmin, 1) = 1 THEN
            -- Insertem a garancar la garantia de regularitzaci¿
            BEGIN
               lprima_regu := lprima_minima - total_prima;

               --DBMS_OUTPUT.put_line ('lprima_regu ' || lprima_regu);
               INSERT INTO garancar
                           (sseguro, cgarant, nriesgo, finiefe, norden, ctarifa,
                            icapital, precarg, iprianu, ffinefe, cformul, iextrap, ctipfra,
                            ifranqu, sproces, irecarg, ipritar, pdtocom, idtocom, crevali,
                            prevali, irevali, itarifa, itarrea, ipritot, icaptot, ftarifa)
                    VALUES (psseguro, pcgarant_regu, v_risc.nriesgo, pfcarpro, pnorden, NULL,
                            NULL, NULL, lprima_regu, NULL, NULL, NULL, NULL,
                            NULL, ppsproces, NULL, NULL, NULL, NULL, 0,
                            NULL, NULL, NULL, NULL, lprima_regu, NULL, pfcarpro);
            EXCEPTION
               WHEN DUP_VAL_ON_INDEX THEN
                  UPDATE garancar
                     SET iprianu = lprima_regu
                   WHERE sproces = ppsproces
                     AND sseguro = psseguro
                     AND nriesgo = v_risc.nriesgo
                     AND cgarant = pcgarant_regu;
               WHEN OTHERS THEN
                  RETURN 101998;
            END;
         ELSE
            -- Esborrem la garantia de regularitzaci¿ si no n'ha de tenir, pq tenim la
            -- del moviment anterior
            DELETE FROM garancar
                  WHERE sproces = ppsproces
                    AND sseguro = psseguro
                    AND nriesgo = v_risc.nriesgo
                    AND cgarant = pcgarant_regu;
         END IF;

         pac_parm_tarifas.borra_parametro(psesion, pcclapri);
         -- I - JLB - OPTIMIZA
          --DELETE FROM sgt_parms_transitorios
           --     WHERE sesion = psesion;
         num_err := pac_sgt.del(psesion);
         -- F - JLB - OPTIMIZA
         parms_transitorios.DELETE;
         -- Inicializo la matriz de parms_transitorios
         --  Realitzem un bucle per calcular els descomptes
         --  (despres d'haver tingut en compte les respostes de les preguntes)
         -- Per la bonificaci¿, comprovem quina prima ¿s la menor entre la nova
         -- i l'anualitat anterior
         laplica_actual := NULL;

         IF NVL(paplica_bonifica, 0) = 1 THEN
            -- Retorna 1 si s'aplica el descompte a la prima actual
            -- Retorna 0 si s'aplica el descompte a la prima de l'anualitat anterior
            laplica_actual := pac_bonifica.calcul_bonificacio_actual(psseguro, conta_proces,
                                                                     NULL, lnmovimi);
         END IF;

-------------------------------------------------------------------------
-- 4art bucle de garanties (garancar ). Descomptes i rec¿rrecs
-------------------------------------------------------------------------
         FOR v_gar IN c_garancar(v_risc.nriesgo) LOOP   -- loop de descomptes i rec¿rrecs
            --         dbms_output.put_line(v_gar.cgarant||'  '||v_gar.iprianu );
            IF NVL(laplica_actual, 1) = 1 THEN
               lprima_bonif := v_gar.iprianu;
            ELSE
               lprima_bonif := pac_bonifica.calcul_prima_ant(psseguro, lnmovimi,
                                                             v_gar.nriesgo, v_gar.cgarant,
                                                             v_gar.ndetgar);

               IF lprima_bonif IS NULL THEN
                  lprima_bonif := 0;
               END IF;
            END IF;

            prima := v_gar.iprianu;
            p_tab_error(f_sysdate, f_user, 'pac_dincartera', 100, 'prima: ' || prima, NULL);

            -- Bug 14336 - RSC - 05/05/2010 - APR03 - Error en la renovaci¿n de polizas de portfolio con sobreprima
            -- Bug 13727 - RSC - 05/05/2010 - APR - An¿lisis/Implementaci¿n de nuevas
            --                                      combinaciones de tarificaci¿n Flexilife Nueva Emisi¿n
            IF NVL(f_parproductos_v(psproduc, 'DETALLE_GARANT'), 0) NOT IN(1, 2) THEN
               -- Fin Bug 14336 y 13727

               -- Veure si se li aplica el descompte amb el par¿metre APLICABONI
               num_err := f_pargaranpro(pcramo, pcmodali, pctipseg, pccolect, pcactivi,
                                        v_gar.cgarant, 'APLICABONI', lcvalpar);

               IF NVL(lcvalpar, 1) = 1 THEN
                  -- BUG 20666-  01/2012 - JRH  -  20666:  -- BUG 20666-  01/2012 - JRH  -  20666:  Buscar en las CAR Si tenemos el capitalo inicial informado la extraprima utiliza este capital
                  vcapital_ini := NULL;
                  vcapital_def := NULL;

                  --DCT 03/02/2014
                  --Si tenemos parametrizado el producto a 1 no obtendremos el capital Inicial sino el que toque(revalorizado)
                  IF NVL(f_parproductos_v(psproduc, 'CAPITAL_REVAL'), 0) <> 1 THEN
                     num_err := pac_preguntas.f_get_pregungaranseg(psseguro, v_gar.cgarant,
                                                                   v_gar.nriesgo, 4071, 'TMP',
                                                                   vcapital_ini, ppsproces);

                     IF num_err = 0 THEN
                        vcapital_def := vcapital_ini;
                     ELSIF num_err = 120135 THEN
                        vcapital_def := v_gar.icapital;
                     ELSE
                        p_tab_error(f_sysdate, f_user, 'pac_dincartera.f_garantarifa_sgt2', 1,
                                    'Error extraprima',
                                    num_err || ' - ' || 'Error buscando capital inicial');
                        RETURN num_err;
                     END IF;
                  ELSE
                     vcapital_def := v_gar.icapital;
                  END IF;

                  -- Bug 24704 - RSC - 17/12/2013
                  v_crespue_4942 := NVL(pac_preguntas.f_get_pregungaranseg_v(psseguro,
                                                                             v_gar.cgarant,
                                                                             v_gar.nriesgo,
                                                                             4942, 'CAR',
                                                                             ppsproces),
                                        0);
                  v_crespue_4945 := NVL(pac_preguntas.f_get_pregungaranseg_v(psseguro,
                                                                             v_gar.cgarant,
                                                                             v_gar.nriesgo,
                                                                             4945, 'CAR',
                                                                             ppsproces),
                                        0);
                  -- Fin bug 24704

                  --  FiBUG 20666-  01/2012 - JRH
                  --bfp bug 22212 ini
                  vapldtosenform := NVL(f_parproductos_v(psproduc, 'APLDTOSENFORM'), 0);

                  IF vapldtosenform <> 1 THEN
                        --bfp bug 22212 fi
                     -- a¿adir par¿metros nuevos : v_gar.pdtotec, v_gar.preccom, pidtotec, pireccom
                     num_err := f_recdto(v_gar.precarg, v_gar.pdtocom, pirecarg, pidtocom,
                                         v_gar.pdtotec, v_gar.preccom, pidtotec, pireccom,   -- Bug 21907 - MDS - 03/05/2012
                                         v_gar.iextrap, vcapital_def, v_extraprima,   -- BUG19532:DRA:26/09/2011
                                         prima, pmoneda, paplica_bonifica, lprima_bonif,
                                         v_crespue_4942, v_crespue_4945, psproduc);   --DCT -02/12/2014);

                     IF num_err <> 0 THEN
                        RETURN num_err;
                     END IF;
                  --bfp bug 22212 ini
                  END IF;

                  --bfp buf 22212 fi

                  -- Modificamos la tabla GARANCAR con las primas nuevas
                  -- Se redondea la prima en funcion de la forma de pago

                  -- Bug 10350 - 04/06/2009 - RSC - Detalle garant¿as (tarificaci¿n)
                  -- A¿adimos v_gar.netgar
                  BEGIN
                     UPDATE garancar
                        SET irecarg = pirecarg,
                            idtocom = pidtocom,
                            idtotec = pidtotec,
                            -- Bug 21907 - MDS - 03/05/2012
                            ireccom = pireccom,
                            -- Bug 21907 - MDS - 03/05/2012
                            iprianu = f_round_forpag(prima, pcforpag, pmoneda, psproduc)
                      WHERE sseguro = psseguro
                        AND cgarant = v_gar.cgarant
                        AND nriesgo = v_gar.nriesgo
                        AND finiefe = v_gar.finiefe
                        AND sproces = v_gar.sproces
                        AND nmovima = v_gar.nmovima
                        AND ndetgar = v_gar.ndetgar;
                  EXCEPTION
                     WHEN OTHERS THEN
                        RETURN 101998;
                  END;
               -- Fin Bug 10350
               END IF;
            ELSE
               --AGG 23/10/2014 para las garantias con detalle_Garant = 2 tambi¿n tiene que aplicar el valor del descuento comercial
               --al pasar la cartera
               vcapital_ini := NULL;
               vcapital_def := NULL;

               --DCT 03/02/2014
               --Si tenemos parametrizado el producto a 1 no obtendremos el capital Inicial sino el que toque(revalorizado)
               IF NVL(f_parproductos_v(psproduc, 'CAPITAL_REVAL'), 0) <> 1 THEN
                  num_err := pac_preguntas.f_get_pregungaranseg(psseguro, v_gar.cgarant,
                                                                v_gar.nriesgo, 4071, 'TMP',
                                                                vcapital_ini, ppsproces);

                  IF num_err = 0 THEN
                     vcapital_def := vcapital_ini;
                  ELSIF num_err = 120135 THEN
                     vcapital_def := v_gar.icapital;
                  ELSE
                     p_tab_error(f_sysdate, f_user, 'pac_dincartera.f_garantarifa_sgt2', 1,
                                 'Error extraprima',
                                 num_err || ' - ' || 'Erro buscando capital inicial');
                     RETURN num_err;
                  END IF;
               ELSE
                  vcapital_def := v_gar.icapital;
               END IF;

               v_crespue_4942 := NVL(pac_preguntas.f_get_pregungaranseg_v(psseguro,
                                                                          v_gar.cgarant,
                                                                          v_gar.nriesgo, 4942,
                                                                          'CAR', ppsproces),
                                     0);
               v_crespue_4945 := NVL(pac_preguntas.f_get_pregungaranseg_v(psseguro,
                                                                          v_gar.cgarant,
                                                                          v_gar.nriesgo, 4945,
                                                                          'CAR', ppsproces),
                                     0);
               vapldtosenform := NVL(f_parproductos_v(psproduc, 'APLDTOSENFORM'), 0);

               IF vapldtosenform <> 1 THEN
                  num_err := f_recdto(v_gar.precarg, v_gar.pdtocom, pirecarg, pidtocom,
                                      v_gar.pdtotec, v_gar.preccom, pidtotec, pireccom,   -- Bug 21907 - MDS - 03/05/2012
                                      v_gar.iextrap, vcapital_def, v_extraprima,   -- BUG19532:DRA:26/09/2011
                                      prima, pmoneda, paplica_bonifica, lprima_bonif,
                                      v_crespue_4942, v_crespue_4945, psproduc);   --DCT - 02/12/2014

                  IF num_err <> 0 THEN
                     RETURN num_err;
                  END IF;
               END IF;

               BEGIN
                  UPDATE garancar
                     SET irecarg = pirecarg,
                         idtocom = pidtocom,
                         idtotec = pidtotec,
                         ireccom = pireccom,
                         iprianu = f_round_forpag(prima, pcforpag, pmoneda, psproduc)
                   WHERE sseguro = psseguro
                     AND cgarant = v_gar.cgarant
                     AND nriesgo = v_gar.nriesgo
                     AND finiefe = v_gar.finiefe
                     AND sproces = v_gar.sproces
                     AND nmovima = v_gar.nmovima
                     AND ndetgar = v_gar.ndetgar;
               EXCEPTION
                  WHEN OTHERS THEN
                     RETURN 101998;
               END;
            END IF;
         END LOOP;   -- loop de descomptes i rec¿rrecs
      END LOOP;   --RIESGOS

      --COMMIT;
      --RETURN 111721;

      -- Mirem si s'ha d'anular la p¿lissa despr¿s de tarifar tots els riscos.
      -- S'ha canviat de posisci¿ pq abans s'estava fent dins del bucle de riscos
      -- i si s'anulava el primer anulava la pol sense haver mirat els altres
      /******************************************************
                                                                      Se verifican las anulaciones
      *******************************************************/
      anulado := 0;

      IF pmodo = 'P' THEN
         BEGIN
            SELECT COUNT(*)
              INTO registros
              FROM garancar
             WHERE sseguro = psseguro
               AND sproces = conta_proces
               AND NVL(canulado, 0) <> 1;
         EXCEPTION
            WHEN OTHERS THEN
               registros := 0;
         END;

         --Si no hay registros grabados en GARANCAR se
         --anula el seguro
         IF registros = 0 THEN
            -- Grabamos un registro en PROCESLIN para avisar
            -- que el seguro se va a anular.
            anulado := 1;
            p_literal2(105735, pidioma, texto);
            pnnumlin := NULL;
            num_err := f_proceslin(ppsproces, texto, psseguro, pnnumlin);
            RETURN num_err;
         END IF;
      ELSIF pmodo = 'R' THEN
         --Hemos grabado las garant¿as que no se anulan en GARANCAR.
         -- Ahora tenemos que mirar si se anula algun riesgo o el seguro
         num_err := f_anular(psseguro, pfcarpro, conta_proces, pfcarpro, pfemisio, movimiento,
                             anulado, pmoneda);

         IF num_err <> 0 THEN
            --DBMS_OUTPUT.put_line ('error en dincartera.f_anular');
            RETURN num_err;
         END IF;
      END IF;

           -- Bug 23183/126116 - 18/10/2012 - AMC
           /*
            IF anulado = 0 THEN
      --------------------------------------------------------------------------
      -- A¿adimos el COASEGURO!!!!!!!!!!!!!!!!!!!!!
      -- Se calcula el porcentaje tambi¿n para el coaseguro aceptado (ctipcoa <> 0)
               BEGIN
                  SELECT c.ploccoa
                    INTO porcen
                    FROM coacuadro c, seguros s
                   WHERE c.sseguro = s.sseguro
                     AND c.ncuacoa = s.ncuacoa
                     AND s.ctipcoa <> 0
                     AND s.sseguro = psseguro;
               EXCEPTION
                  WHEN OTHERS THEN
                     porcen := 100;   -- No hay coaseguro cedido
               END;

               num_err := f_garancoa('P', porcen, psseguro);

               IF num_err <> 0 THEN
                  RETURN num_err;
               END IF;
            END IF;
           */
      IF anulado = 0 THEN
         num_err := f_garancoa('P', 100, psseguro);

         IF num_err <> 0 THEN
            RETURN num_err;
         END IF;
      END IF;

      COMMIT;
      RETURN 0;
   EXCEPTION
      WHEN OTHERS THEN
         RETURN 111916;
   END f_garantarifa_sgt_det;

     /*******************************************************************************
                                                                                                                                                                                                                                                                                                        PROCEDIMIENTO P_EJECUTAR_CARTERA
       psproces     NUMBER  : Id. del proceso
       pmodo        NUMBER  : Modo de ejecuciom
       pcempres     NUMBER  : Empresa
       pnpoliza     NUMBER  : Numero de poliza
       pfperini     DATE    : Fecha inicio
       pncertif     NUMBER  : Numero de certificado
       pmoneda      NUMBER  : Moneda
       pcidioma     NUMBER  : Idioma
       psprocar     NUMBER
       prenueva     NUMBER
       Bug 11685 - 04/11/2009 - AMC - Se crea el procedimiento p_ejecutar_cartera
   ********************************************************************************/
   PROCEDURE p_ejecutar_cartera(
      psproces IN NUMBER,
      pmodo IN VARCHAR2,
      pcempres IN NUMBER,
      pnpoliza IN NUMBER,
      pfperini IN DATE,
      pncertif IN NUMBER,
      pmoneda IN NUMBER,
      pcidioma IN NUMBER,
      psprocar IN NUMBER,
      prenuevan IN NUMBER) IS
      vpasexec       NUMBER(8) := 1;
      vparam         VARCHAR2(200)
         := 'psproces=' || psproces || ' pmodo=' || pmodo || ' pcempres=' || pcempres
            || ' pnpoliza=' || pnpoliza || ' pfperini=' || pfperini || ' pncertif='
            || pncertif || ' psprocar:' || psprocar;
      vobject        VARCHAR2(200) := 'PAC_DINCARTERA.P_EJECUTAR_CARTERA';
      num_err        NUMBER;
      pnnumlin       NUMBER;
      conta_be       NUMBER;
      indice         NUMBER;
      indice_error   NUMBER;
      vsseguro       seguros.sseguro%TYPE;
      --       vsseguro       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      vnumerr        NUMBER;
      pmens          VARCHAR2(1000);
      salir          EXCEPTION;
      v_sproduc      seguros.sproduc%TYPE;
      v_npoliza      seguros.npoliza%TYPE;
      v_ncertif      seguros.ncertif%TYPE;
   BEGIN
      /*
                                    No se deber¿ incializar el proceso ya que este habr¿ sido previamente incializado.
      Se deber¿ traspasar la informaci¿n de la tabla tmp_carteraux a la tabla carteraux(solo aquellos productos marcados),
      y para el proceso indicado. Deber¿ llamar al proceso de cartera o previo de cartera seg¿n el modo en que se haya entrado,
      registrando los errores.
      En el caso del previo de cartera se debe pasar como par¿metro el mes y el a¿o que se debe obtener del par¿metro pfperini.
      Una vez hecho este deber¿ finalizar el proceso , mediante una llamada al f_procesfin, y deber¿ limpiar la tabla tmp_carteraux
      para el proceso actual.
      */

      -- Control parametros entrada
      IF psproces IS NULL
         OR pmodo IS NULL
         OR pcempres IS NULL
         OR pfperini IS NULL THEN   --OR pnpoliza IS NULL OR pncertif IS NULL THEN
         p_tab_error(f_sysdate, f_user, vobject, vpasexec,
                     ' Faltan parametros por informar: ' || vparam, SQLERRM);
         --RETURN 140974;   --Faltan parametros por informar
         vnumerr := f_proceslin(psproces,
                                SUBSTR('Cartera: Proceso no finalizado correctamente', 1, 120),
                                0, vpasexec);
         RAISE salir;
      END IF;

      --
      BEGIN
         IF pnpoliza IS NULL THEN
            -- I - jlb - 17/10/2013 - Bloqueo de carera
                /*INSERT INTO carteraaux
                            (sproces, cramo, cmodali, ctipseg, ccolect, cactivi, npoliza, ncertif, cbloqueo, fcartera)
                   SELECT psproces, p.cramo, p.cmodali, p.ctipseg, p.ccolect, NULL, pnpoliza, NVL(pncertif, 0), decode(pmodo, 'PREVI', 0 ,1), f_sysdate
                     FROM productos p, tmp_carteraux t
                    WHERE p.sproduc = t.sproduc
                      AND t.sprocar = psprocar
                      AND t.cestado = 1; */
            FOR reg IN (SELECT psproces psproces, p.cramo cramo, p.cmodali cmodali,
                               p.ctipseg ctipseg, p.ccolect ccolect, NULL cactivi,
                               pnpoliza npoliza, NVL(pncertif, 0) ncertif,
                               DECODE(pmodo, 'PREVI', 0, 1) cbloqueo, f_sysdate fcartera
                          FROM productos p, tmp_carteraux t
                         WHERE p.sproduc = t.sproduc
                           AND t.sprocar = psprocar
                           AND t.cestado = 1) LOOP
               vnumerr := f_insert_carteraaux(reg.psproces, reg.cramo, reg.cmodali,
                                              reg.ctipseg, reg.ccolect, reg.cactivi,
                                              reg.npoliza, reg.ncertif, reg.cbloqueo,
                                              reg.fcartera);
            END LOOP;

            -- F - jlb - 17/10/2013 - Bloqueo de carera
            DELETE      tmp_carteraux
                  WHERE sprocar = psprocar;

            vsseguro := NULL;
         ELSE
            SELECT sseguro
              INTO vsseguro
              FROM seguros
             WHERE npoliza = pnpoliza
               AND ncertif = NVL(pncertif, 0);

            -- BUG 17153 - 31/12/2010 - JMP - Permitir pasar la cartera a un colectivo entero o a un certificado
            v_npoliza := pnpoliza;
            v_ncertif := NVL(pncertif, 0);

            SELECT MAX(sproduc)
              INTO v_sproduc
              FROM seguros
             WHERE npoliza = pnpoliza;

            IF (NVL(f_parproductos_v(v_sproduc, 'ADMITE_CERTIFICADOS'), 0) = 1
                AND NVL(pncertif, 0) = 0) THEN
               vsseguro := NULL;
               v_ncertif := NULL;
            END IF;

-- I - jlb - 17/10/2013 - Bloqueo de cartera
   -- I - jlb - 17/10/2013 - Bloqueo de carera
         /*   INSERT INTO carteraaux
                        (sproces, cramo, cmodali, ctipseg, ccolect, cactivi, npoliza, ncertif, cbloqueo , fcartera)
               SELECT psproces, p.cramo, p.cmodali, p.ctipseg, p.ccolect, NULL, pnpoliza, v_ncertif, decode(pmodo, 'PREVI', 0 ,1) ,f_sysdate
                 FROM productos p, seguros s
                WHERE p.sproduc = s.sproduc
                  AND s.sseguro = NVL(vsseguro, s.sseguro)
                  AND s.npoliza = pnpoliza
                  AND s.ncertif = NVL(v_ncertif, s.ncertif); */
            FOR reg IN (SELECT psproces psproces, p.cramo cramo, p.cmodali cmodali,
                               p.ctipseg ctipseg, p.ccolect ccolect, NULL cactivi,
                               pnpoliza npoliza, v_ncertif ncertif,
                               DECODE(pmodo, 'PREVI', 0, 1) cbloqueo, f_sysdate fcartera
                          FROM productos p, seguros s
                         WHERE p.sproduc = s.sproduc
                           AND s.sseguro = NVL(vsseguro, s.sseguro)
                           AND s.npoliza = pnpoliza
                           AND s.ncertif = NVL(v_ncertif, s.ncertif)) LOOP
               vnumerr := f_insert_carteraaux(reg.psproces, reg.cramo, reg.cmodali,
                                              reg.ctipseg, reg.ccolect, reg.cactivi,
                                              reg.npoliza, reg.ncertif, reg.cbloqueo,
                                              reg.fcartera);
            END LOOP;
         -- F - jlb - 17/10/2013 - Bloqueo de carera

         -- F - jlb - 17/10/2013 - Bloqueo de cartera

         -- FI BUG 17153 - 31/12/2010 - JMP
         END IF;
      EXCEPTION
         WHEN OTHERS THEN
            p_tab_error(f_sysdate, f_user, vobject, vpasexec, vparam, SQLERRM);
            --  RETURN 112608;
            vnumerr := f_proceslin(psproces,
                                   SUBSTR('Cartera: Proceso no finalizado correctamente', 1,
                                          120),
                                   0, vpasexec);
            RAISE salir;
      END;

      --
      vpasexec := 2;

      IF pmodo = 'PREVI' THEN
         pac_dincartera.previ_cartera_tar(pcempres, TO_CHAR(pfperini, 'mm'),   --pmes,
                                          TO_CHAR(pfperini, 'yyyy'),
                                          -- panyo,
                                          v_npoliza, v_ncertif, pcidioma, psproces, indice,
                                          indice_error, prenuevan);
         vpasexec := 3;
         num_err := 0;
      ELSE
         -- JLB - I - 17/10/2013 -- bloqueo de la cartera
         FOR reg IN (SELECT cramo, cmodali, ctipseg, ccolect, cactivi, npoliza, ncertif
                       FROM carteraaux
                      WHERE sproces = psproces
                        AND cbloqueo = 1) LOOP
            --
            num_err := f_cartera_bloqueada(psproces, reg.cramo, reg.cmodali, reg.ctipseg,
                                           reg.ccolect, reg.cactivi, reg.npoliza, reg.ncertif);

            IF num_err <> 0 THEN   -- si existen carteras bloqueadas
               indice_error := 1;
               pnnumlin := NULL;
               vnumerr := f_proceslin(psproces,
                                      SUBSTR('Cartera: Cartera bloqueada ' || reg.cramo || '-'
                                             || reg.cmodali || '-' || reg.ctipseg || '-'
                                             || reg.ccolect || '-' || reg.cactivi || '-'
                                             || reg.npoliza || '-' || reg.ncertif,
                                             1, 120),
                                      0, pnnumlin);
               vnumerr := f_procesfin(psproces, num_err);
            END IF;
         END LOOP;

         -- JLB -F - 17/10/2013 -- bloqueo de la cartera
         IF num_err = 0 THEN
            num_err := pac_dincartera.cartera_producte(pcempres, psproces, psproces,
                                                       TO_CHAR(pfperini, 'mm'),
                                                       TO_CHAR(pfperini, 'yyyy'), pcidioma,
                                                       pmoneda, pfperini, indice,
                                                       indice_error, vsseguro, v_npoliza,
                                                       v_ncertif);

            IF num_err <> 0 THEN
               indice_error := indice_error + 1;
               pnnumlin := NULL;
               vnumerr :=
                  f_proceslin(psproces,
                              SUBSTR('Cartera: Proceso no finalizado correctamente', 1, 120),
                              0, pnnumlin);
            END IF;
         END IF;

         vpasexec := 4;
      -- num_err := 0;
      END IF;

      --- JLB -I  - 17/10/2013 -- bloqueo de la cartera
      vnumerr := pac_dincartera.f_delete_carteraaux(psproces);
      --- JLB - I - 17/10/2013 -- bloqueo cartera
      --
      pnnumlin := NULL;
      pmens := f_axis_literales(103148, pcidioma) || TO_CHAR(indice - indice_error) || ' | '
               || f_axis_literales(103149, pcidioma) || indice_error;
      vnumerr := f_proceslin(psproces, pmens, 0, pnnumlin, 2);
      vpasexec := 5;
      vnumerr := f_procesfin(psproces, num_err);
   EXCEPTION
      WHEN salir THEN
          --- JLB -I  - 17/10/2013 -- bloqueo de la cartera
         --delete carteraaux where sproces = psproces;
         num_err := pac_dincartera.f_delete_carteraaux(psproces);
         --- JLB - I - 17/10/2013 -- bloqueo cartera
         p_tab_error(f_sysdate, f_user, vobject, vpasexec, ' sale por salir', SQLERRM);
         NULL;
      WHEN OTHERS THEN
          --- JLB -I  - 17/10/2013 -- bloqueo de la cartera
         --delete carteraaux where sproces = psproces;
         vnumerr := pac_dincartera.f_delete_carteraaux(psproces);
         --- JLB - I - 17/10/2013 -- bloqueo cartera
         p_tab_error(f_sysdate, f_user, vobject, vpasexec, vparam, SQLERRM);
         --RETURN 112608;
         vnumerr := f_proceslin(psproces,
                                SUBSTR('Cartera: Proceso no finalizado correctamente', 1, 120),
                                0, vpasexec);
   END p_ejecutar_cartera;

   -- Bug 23940 - APD - 06/11/2012 - se crea la funcion
   FUNCTION f_act_cbloqueocol(psseguro IN NUMBER, pcbloqueocol IN NUMBER)
      RETURN NUMBER IS
      num_err        NUMBER := 0;
      vtraza         NUMBER;
      v_resp_9214    NUMBER;
   BEGIN
      vtraza := 1;
      -- I- bug 35150
      num_err := pac_preguntas.f_get_pregunpolseg(psseguro, 9214, 'SEG', v_resp_9214);

      IF v_resp_9214 = 1 THEN
         UPDATE seguros
            SET cbloqueocol = 0
          WHERE sseguro = psseguro;

         RETURN 0;
      END IF;

      -- F - bug 35150
      UPDATE seguros
         SET cbloqueocol = pcbloqueocol
       WHERE sseguro = psseguro;

      RETURN 0;
   EXCEPTION
      WHEN OTHERS THEN
         p_tab_error(f_sysdate, f_user, 'PAC_DINCARTERA.f_act_cbloqueocol', vtraza,
                     f_axis_literales(9904536), SQLERRM);
         RETURN 9904536;   -- Error al bloquear el colectivo
   END f_act_cbloqueocol;

   -- Bug 23940 - APD - 06/11/2012 - se crea la funcion
   -- Funci¿n que valida si para un Colectivo administrado se ha hecho un suplemento de
   -- renovaci¿n o no
   FUNCTION f_suplemento_renovacion(psseguro IN NUMBER, ohaysuplem OUT NUMBER)
      RETURN NUMBER IS
      num_err        NUMBER := 0;
      vtraza         NUMBER;
   BEGIN
      vtraza := 1;

      SELECT COUNT(1)
        INTO ohaysuplem
        FROM movseguro m
       WHERE m.sseguro = psseguro
         AND m.cmovseg = 1
         AND TRUNC(m.fefecto) = (SELECT TRUNC(s.fcaranu)
                                   FROM seguros s
                                  WHERE s.sseguro = m.sseguro);

      RETURN 0;
   EXCEPTION
      WHEN OTHERS THEN
         p_tab_error(f_sysdate, f_user, 'PAC_DINCARTERA.f_suplemento_renovacion', vtraza,
                     f_axis_literales(1000455), SQLERRM);
         RETURN 1000455;
   END f_suplemento_renovacion;

   -- Bug 23940 - APD - 06/11/2012 - se crea la funcion
   -- Funci¿n que indica si los botones en la pantalla de Gesti¿n de Renovaci¿n deben
   -- estar activados o desactivados
   FUNCTION f_botones_gestrenova(
      psseguro IN NUMBER,
      opermiteemitir OUT NUMBER,
      opermitepropret OUT NUMBER,
      opermitesuplemento OUT NUMBER,
      opermiterenovar OUT NUMBER)
      RETURN NUMBER IS
      num_err        NUMBER := 0;
      vtraza         NUMBER;
      vcsituac       seguros.csituac%TYPE;
      vcreteni       seguros.creteni%TYPE;
      vfcarpro       seguros.fcarpro%TYPE;
      vfcaranu       seguros.fcaranu%TYPE;
      vsproduc       seguros.sproduc%TYPE;
      --Bug 34371/196559 - 28/01/2015 - AMC
      vplantrenovcero VARCHAR2(200);
   BEGIN
      vtraza := 1;
      -- Se inicializan los parametros de salida a 0 (No permitir)
      opermiteemitir := 0;
      opermitepropret := 0;
      opermitesuplemento := 0;
      opermiterenovar := 0;

      --Bug 34371/196559 - 28/01/2015 - AMC
      SELECT csituac, creteni, fcarpro, fcaranu, sproduc
        INTO vcsituac, vcreteni, vfcarpro, vfcaranu, vsproduc
        FROM seguros
       WHERE sseguro = psseguro;

      vplantrenovcero := pac_parametros.f_parproducto_t(vsproduc, 'PLANT_RENOVCERO');

      IF vplantrenovcero IS NOT NULL THEN
         IF vfcarpro = vfcaranu
            AND(vcsituac = 0
                OR(vcsituac = 17
                   AND vcreteni = 0))
            AND vcreteni = 0 THEN
            opermiterenovar := 1;
         END IF;
      ELSE
         opermiterenovar := 0;
      END IF;

      --Fi Bug 34371/196559 - 28/01/2015 - AMC

      -- Vigente o Prop. Suplem
      IF (vcsituac = 0
          AND vcreteni = 0
          AND vfcarpro = vfcaranu) THEN
         opermitesuplemento := 1;
      END IF;

      -- Prop. Suplem. Pdte. Autor. o Prop. Cartera Pdte. Autor.
      SELECT DECODE(COUNT(1), 0, 0, 1)
        INTO opermitepropret
        FROM seguros s, movseguro m
       WHERE m.sseguro = s.sseguro
         AND m.nmovimi IN(SELECT MAX(nmovimi)
                            FROM movseguro m2
                           WHERE m2.sseguro = s.sseguro)
         AND s.csituac IN(4, 5, 12, 17)
         AND(s.creteni = 2
             OR s.creteni = 5
             OR(s.creteni = 1
                AND(EXISTS(SELECT mot.cmotret
                             FROM motretencion mot
                            WHERE mot.sseguro = s.sseguro
                              AND mot.nmovimi = m.nmovimi
                              AND mot.cmotret NOT IN(1, 20)))))
         AND s.npoliza IN(SELECT a.npoliza
                            FROM seguros a
                           WHERE a.sseguro = psseguro)
         AND(s.sseguro IN(SELECT mot.sseguro
                            FROM motretencion mot
                           WHERE mot.cmotret NOT IN(1))
             OR(s.sseguro IN(SELECT psu.sseguro
                               FROM psucontrolseg psu
                              WHERE psu.sseguro = s.sseguro)));

      -- Prop. Suplem. o Prop. Cartera
      SELECT DECODE(COUNT(1), 0, 0, 1)
        INTO opermiteemitir
        FROM seguros s, movseguro m
       WHERE m.sseguro = s.sseguro
         AND m.nmovimi IN(SELECT MAX(m2.nmovimi)
                            FROM movseguro m2
                           WHERE m2.sseguro = s.sseguro)
         AND s.csituac IN(4, 5, 12)
         AND(s.creteni IN(0, 2, 5)
             OR(s.creteni = 1
                AND((EXISTS(SELECT mot.cmotret
                              FROM motretencion mot
                             WHERE mot.sseguro = s.sseguro
                               AND mot.nmovimi = m.nmovimi
                               AND mot.cmotret IN(1, 4, 5, 6, 10, 20)))
                    OR(EXISTS(SELECT pp.cmotret
                                FROM psu_retenidas pp
                               WHERE pp.sseguro = s.sseguro
                                 AND pp.nmovimi = m.nmovimi)))))
         AND s.npoliza IN(SELECT npoliza
                            FROM seguros
                           WHERE sseguro = psseguro)
         AND((TRUNC(m.femisio) IS NULL
              AND pac_seguros.f_get_escertifcero(NULL, s.sseguro) = 1
              AND m.cmotmov <> 100
              AND NVL(m.cmotven, 0) <> 998)
             OR s.creteni = 1);

      RETURN 0;
   EXCEPTION
      WHEN OTHERS THEN
         p_tab_error(f_sysdate, f_user, 'PAC_DINCARTERA.f_botones_gestrenova', vtraza,
                     f_axis_literales(1000455), SQLERRM);
         RETURN 1000455;
   END f_botones_gestrenova;

-- JLB - I -  17/10/2013 -- bloqueo de cartera
/****************************************************************************
    f_cartera_bloqueada: Mira si para la cartera que si quiere ejecutar existe un proceso ya corriendo, total o parcial.
    Es decir si se lanza para una poliza, no se puede lanzar una cartera posteiormente para su ramo, y viceveresa.
    Return: 0 - no hay ningun proceso de cartera corriengo para la cartera que se quiere ejecutar
            1 - Existe alg¿n proceso de cartera que tiene conflicto con la cartera a ejecutar.
-- JLB -
*****************************************************************************/
   FUNCTION f_cartera_bloqueada(
      psproces IN NUMBER,
      pcramo IN NUMBER,
      pcmodali IN NUMBER,
      pctipseg IN NUMBER,
      pccolect IN NUMBER,
      pcactivi IN NUMBER,
      pnpoliza IN NUMBER,
      pncertif IN NUMBER)
      RETURN NUMBER IS
      vnumerr        NUMBER;
      v_count        NUMBER;
      v_bloq_poliza  NUMBER(1) := 0;
      v_bloq_activi  NUMBER(1) := 0;
      v_bloq_prod    NUMBER(1) := 0;
      v_bloq_ramo    NUMBER(1) := 0;
   BEGIN
      IF pnpoliza IS NOT NULL THEN   -- miro si la poliza esta bloqueada
         SELECT COUNT('x')
           INTO v_count
           FROM carteraaux
          WHERE sproces <> psproces
            AND npoliza = pnpoliza
            AND((NVL(pncertif, 0) <> 0
                 AND ncertif = pncertif)
                OR(NVL(pncertif, 0) = 0))
            AND cbloqueo = 1
            AND fcartera >= f_sysdate - 1;

         IF v_count > 0 THEN
            RETURN 9906169;   -- cartera bloqueada
         END IF;

         v_bloq_poliza := 1;   --pasado
      END IF;

      --
      IF pcramo IS NOT NULL
         AND pcmodali IS NOT NULL
         AND pctipseg IS NOT NULL
         AND pccolect IS NOT NULL
         AND pcactivi IS NOT NULL THEN
         SELECT COUNT('x')
           INTO v_count
           FROM carteraaux
          WHERE sproces <> psproces
            AND cramo = pcramo
            AND cmodali = pcmodali
            AND ctipseg = pctipseg
            AND ccolect = pccolect
            AND cactivi = pcactivi
            AND((v_bloq_poliza = 1
                 AND npoliza IS NULL)
                OR(v_bloq_poliza = 0))
            AND cbloqueo = 1
            AND fcartera >= f_sysdate - 1;

         IF v_count > 0 THEN
            RETURN 9906169;   -- cartera bloqueada
         END IF;

         v_bloq_activi := 1;
      END IF;

      --
      IF pcramo IS NOT NULL
         AND pcmodali IS NOT NULL
         AND pctipseg IS NOT NULL
         AND pccolect IS NOT NULL THEN
         SELECT COUNT('x')
           INTO v_count
           FROM carteraaux
          WHERE sproces <> psproces
            AND cramo = pcramo
            -- miro si el producto y actividad se esta lanzando
            AND cmodali = pcmodali
            AND ctipseg = pctipseg
            AND ccolect = pccolect
            AND((v_bloq_poliza = 1
                 AND npoliza IS NULL)
                OR(v_bloq_poliza = 0))
            AND((v_bloq_activi = 1
                 AND cactivi IS NULL)
                OR(v_bloq_activi = 0))
            AND cbloqueo = 1
            AND fcartera >= f_sysdate - 1;

         IF v_count > 0 THEN
            RETURN 9906169;   -- cartera bloqueada
         END IF;

         v_bloq_prod := 1;
      END IF;

      --
      IF pcramo IS NOT NULL THEN
         -- quiero pasar poliza a nivel de ramo
         SELECT COUNT('x')
           INTO v_count
           FROM carteraaux
          WHERE sproces <> psproces
            AND cramo = pcramo
            AND((v_bloq_poliza = 1
                 AND npoliza IS NULL)
                OR(v_bloq_poliza = 0))
            AND((v_bloq_activi = 1
                 AND cactivi IS NULL)
                OR(v_bloq_activi = 0))
            AND((v_bloq_prod = 1
                 AND cmodali IS NULL
                 AND cactivi IS NULL
                 AND ccolect IS NULL)
                OR(v_bloq_prod = 0))
            AND cbloqueo = 1
            AND fcartera >= f_sysdate - 1;

         IF v_count > 0 THEN
            RETURN 9906169;   -- cartera bloqueada
         END IF;

         v_bloq_ramo := 1;
      END IF;

      RETURN 0;   -- ok la cartera no esta bloqueada
   EXCEPTION
      WHEN OTHERS THEN
         RETURN 9906169;   --si hay algun otro error cartera bloqueada
   END f_cartera_bloqueada;

/****************************************************************************
   f_insert_carteraaux: Inserta un registro en carterauax y ejecuta commit,
*****************************************************************************/
   FUNCTION f_insert_carteraaux(
      psproces IN NUMBER,
      pcramo IN NUMBER,
      pcmodali IN NUMBER,
      pctipseg IN NUMBER,
      pccolect IN NUMBER,
      pcactivi IN NUMBER,
      pnpoliza IN NUMBER,
      pncertif IN NUMBER,
      pcbloqueo IN NUMBER,
      pfcartera IN DATE)
      RETURN NUMBER IS
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      INSERT INTO carteraaux
                  (sproces, cramo, cmodali, ctipseg, ccolect, cactivi, npoliza,
                   ncertif, cbloqueo, fcartera)
           VALUES (psproces, pcramo, pcmodali, pctipseg, pccolect, pcactivi, pnpoliza,
                   pncertif, pcbloqueo, pfcartera);

      COMMIT;
      RETURN 0;
   -- si falla que salga por excepci¿n
   END f_insert_carteraaux;

/****************************************************************************
   f_delete_carteraaux: Borra los registro en carterauax identificados por sproces y ejecuta commit,
*****************************************************************************/
   FUNCTION f_delete_carteraaux(psproces IN NUMBER)
      RETURN NUMBER IS
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      DELETE      carteraaux
            WHERE sproces = psproces;

      COMMIT;
      RETURN 0;
   -- si falla que salga por excepci¿n
   END f_delete_carteraaux;

-- JLB - F -  17/10/2013 -- bloqueo de cartera

   --psproces,pcempres,pproductos,pfperini,pmoneda,pcidioma,vmens
   FUNCTION f_lanza_cartera(
      psproces IN NUMBER,
      pmodo IN VARCHAR2,
      pcempres IN NUMBER,
      pproductos IN VARCHAR2,
      pnpoliza IN NUMBER,
      pncertif IN NUMBER,
      pfperini IN DATE,
      pfcartera IN DATE,
      pmoneda IN NUMBER,
      pcidioma IN NUMBER,
      psprocar IN NUMBER,
      pmens OUT VARCHAR2)
      RETURN NUMBER IS
      vpasexec       NUMBER(8) := 1;
      vparam         VARCHAR2(200)
         := 'psproces=' || psproces || ' pmodo=' || pmodo || ' pcempres=' || pcempres
            || ' pproductos=' || pproductos || ' pnpoliza=' || pnpoliza || ' pfperini='
            || pfperini || ' pfcartera=' || pfcartera || ' psprocar=' || psprocar;
      vobject        VARCHAR2(200) := 'PAC_DINCARTERA.F_LANZA_CARTERA';
      num_err        NUMBER;
      pnnumlin       NUMBER;
      conta_be       NUMBER;
      indice         NUMBER;
      indice_error   NUMBER := 0;
      vsseguro       seguros.sseguro%TYPE;
      --       vsseguro       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      vnumerr        NUMBER;
      v_npoliza      seguros.npoliza%TYPE;
      v_ncertif      seguros.ncertif%TYPE;
      v_sproduc      NUMBER;
      pos            NUMBER;
      plong          NUMBER;
      pos_prev       NUMBER := 0;
      loop_size      NUMBER := 1;
      long_param     NUMBER := 1;
      v_pproductos   VARCHAR2(300);
   BEGIN
      -- Control parametros entrada
      IF pfcartera IS NULL
         AND pfperini IS NULL THEN
         p_tab_error(f_sysdate, f_user, vobject, vpasexec,
                     ' Faltan parametros por informar: ' || vparam, SQLERRM);
         RETURN 140974;   --Faltan parametros por informar
      END IF;

      IF psproces IS NULL
         OR pmodo IS NULL
         OR psprocar IS NULL
         OR pcempres IS NULL
                            --OR pfperini IS NULL
      THEN   --OR pnpoliza IS NULL OR pncertif IS NULL THEN
         p_tab_error(f_sysdate, f_user, vobject, vpasexec,
                     ' Faltan parametros por informar: ' || vparam, SQLERRM);
         RETURN 140974;   --Faltan parametros por informar
      END IF;

      --
      BEGIN
         IF pnpoliza IS NULL THEN
            --A¿adir bucle para que haga esto para cada producto seleccionado
            v_pproductos := pproductos;

            ---Parseamos los parametros
            /*IF INSTR(v_pproductos, '##') > 0 THEN
                v_pproductos := REPLACE(v_pproductos, '##', '#');
            END IF;

            IF INSTR(v_pproductos, '#') = 1 THEN
                v_pproductos := SUBSTR(v_pproductos, 2, LENGTH(v_pproductos));
            END IF;*/
            IF REGEXP_REPLACE(v_pproductos, '[^#]', '') IS NOT NULL THEN
               loop_size := LENGTH(REGEXP_REPLACE(v_pproductos, '[^#]', '')) + 1;
            END IF;

            FOR i IN 1 .. loop_size LOOP
               pos := INSTR(v_pproductos, '#', 1, i);
               plong := pos - pos_prev - 1;

               IF pos = 0 THEN
                  pos := LENGTH(v_pproductos);
                  plong := pos - pos_prev;
               END IF;

               v_sproduc := TO_NUMBER(SUBSTR(v_pproductos, pos_prev + 1, plong));
               pos_prev := pos;

               FOR reg IN (SELECT psproces psproces, p.cramo cramo, p.cmodali cmodali,
                                  p.ctipseg ctipseg, p.ccolect ccolect, NULL cactivi,
                                  NULL npoliza, NULL ncertif,
                                  DECODE(pmodo, 'PREVI_CARTERA', 0, 1) cbloqueo,
                                  NVL(pfcartera, pfperini) fcartera
                             FROM productos p, tmp_carteraux t
                            WHERE p.sproduc = t.sproduc
                              AND t.sprocar = psprocar
                              AND p.sproduc = v_sproduc
                              AND t.cestado = 1) LOOP
                  vnumerr := f_insert_carteraaux(reg.psproces, reg.cramo, reg.cmodali,
                                                 reg.ctipseg, reg.ccolect, reg.cactivi,
                                                 reg.npoliza, reg.ncertif, reg.cbloqueo,
                                                 reg.fcartera);
               END LOOP;
            END LOOP;
         ELSE
            SELECT sseguro
              INTO vsseguro
              FROM seguros
             WHERE npoliza = pnpoliza
               AND ncertif = NVL(pncertif, 0);

            -- BUG 17153 - 31/12/2010 - JMP - Permitir pasar la cartera a un colectivo entero o a un certificado
            v_npoliza := pnpoliza;
            v_ncertif := NVL(pncertif, 0);

            SELECT MAX(sproduc)
              INTO v_sproduc
              FROM seguros
             WHERE npoliza = pnpoliza;

            IF (NVL(f_parproductos_v(v_sproduc, 'ADMITE_CERTIFICADOS'), 0) = 1
                AND NVL(pncertif, 0) = 0) THEN
               vsseguro := NULL;
               v_ncertif := NULL;
            END IF;

            FOR reg IN (SELECT psproces sproces, p.cramo cramo, p.cmodali cmodali,
                               p.ctipseg ctipseg, p.ccolect ccolect, NULL cactivi,
                               pnpoliza npoliza, v_ncertif ncertif,
                               DECODE(pmodo, 'PREVI_CARTERA', 0, 1) cbloqueo,
                               NVL(pfcartera, pfperini) fcartera
                          FROM productos p
                         WHERE p.sproduc = v_sproduc) LOOP
               vnumerr := f_insert_carteraaux(reg.sproces, reg.cramo, reg.cmodali,
                                              reg.ctipseg, reg.ccolect, reg.cactivi,
                                              reg.npoliza, reg.ncertif, reg.cbloqueo,
                                              reg.fcartera);
            END LOOP;
         END IF;

         -- F - jlb - 17/10/2013 - Bloqueo de carera
         DELETE      tmp_carteraux
               WHERE sprocar = psprocar;

         vsseguro := NULL;
      EXCEPTION
         WHEN OTHERS THEN
            p_tab_error(f_sysdate, f_user, vobject, vpasexec, vparam, SQLERRM);
            RETURN 112608;
      END;

      --
      vpasexec := 2;

      IF pmodo = 'PREVI_CARTERA' THEN
         pac_dincartera.previ_cartera_tar(pcempres, TO_CHAR(pfperini, 'mm'),
                                          TO_CHAR(pfperini, 'yyyy'), v_npoliza, v_ncertif,
                                          pcidioma, psproces, indice, indice_error, 0,
                                          pfcartera);
         vpasexec := 3;
         num_err := 0;
      ELSE
         FOR reg IN (SELECT cramo, cmodali, ctipseg, ccolect, cactivi, npoliza, ncertif
                       FROM carteraaux
                      WHERE sproces = psproces
                        AND cbloqueo = 1) LOOP
            num_err := f_cartera_bloqueada(psproces, reg.cramo, reg.cmodali, reg.ctipseg,
                                           reg.ccolect, reg.cactivi, reg.npoliza, reg.ncertif);

            IF num_err <> 0 THEN   -- si existen carteras bloqueadas
               indice_error := 1;   -- marcamos error
               pnnumlin := NULL;
               vnumerr := f_proceslin(psproces,
                                      SUBSTR('Cartera: Cartera bloqueada ' || reg.cramo || '-'
                                             || reg.cmodali || '-' || reg.ctipseg || '-'
                                             || reg.ccolect || '-' || reg.cactivi || '-'
                                             || reg.npoliza || '-' || reg.ncertif,
                                             1, 120),
                                      0, pnnumlin);
               vnumerr := f_procesfin(psproces, num_err);
               vnumerr := pac_dincartera.f_delete_carteraaux(psproces);
               RETURN num_err;
            END IF;
         END LOOP;

         num_err := pac_dincartera.cartera_producte(pcempres, psproces, psproces,
                                                    TO_CHAR(pfperini, 'mm'),
                                                    TO_CHAR(pfperini, 'yyyy'), pcidioma,
                                                    pmoneda, pfperini, indice, indice_error,
                                                    vsseguro, v_npoliza, v_ncertif, NULL, 0,
                                                    pfcartera);

         IF num_err <> 0 THEN
            pnnumlin := NULL;
            vnumerr := f_proceslin(psproces,
                                   SUBSTR('Cartera: Proceso no finalizado correctamente', 1,
                                          120),
                                   0, pnnumlin);
         END IF;

         vpasexec := 4;
      END IF;

      pnnumlin := NULL;
      pmens := f_axis_literales(103148, pcidioma) || TO_CHAR(indice - indice_error) || ' | '
               || f_axis_literales(103149, pcidioma) || indice_error;
      vnumerr := f_proceslin(psproces, pmens, 0, pnnumlin, 2);
      vnumerr := pac_correo.f_envia_correo(pcidioma, psproces, 14, pmens);
      vpasexec := 5;
      vnumerr := f_procesfin(psproces, num_err);
      vnumerr := pac_dincartera.f_delete_carteraaux(psproces);
      RETURN num_err;
   EXCEPTION
      WHEN OTHERS THEN
         p_tab_error(f_sysdate, f_user, vobject, vpasexec, vparam, SQLERRM);
         vnumerr := pac_dincartera.f_delete_carteraaux(psproces);
         RETURN 112608;
   END f_lanza_cartera;

/****************************************************************************
      f_tratamiento_pb: Realiza el tratamiento correspondiente segun el tipo de PB del producto.

       pcempres     : Empresa
       psseguro     : Sequencial del seguro
       pfefecto     : fecha de efecto
       pnmovimi     : Numero de movimiento de la poliza. Si es NULL la funcion busca el ultimo movimiento
       pmodo        : Modo de ejecuci¿n
             P - Previo
             R - Real
             A - Reproceso
       pnriesgo     : Numero de riesgo
       psprocpu     : Numero de proceso donde se calcula la primera PU

      Return :  0 - Ejecucion correcta
                1 - Se ha producido un error
   *****************************************************************************/
   FUNCTION f_tratamiento_pb(
      pcempres IN NUMBER,
      psproduc IN NUMBER,
      psseguro IN NUMBER,
      pfefecto IN DATE,
      pnmovimi IN NUMBER,
      pmodo IN VARCHAR2,
      pnriesgo IN NUMBER,
      psprocpu IN NUMBER)
      RETURN NUMBER IS
      v_ctipopu      NUMBER;
      v_sproduc      NUMBER;
      vobject        VARCHAR2(500) := 'PAC_DINCARTERA.f_tratamiento_pb';
      vpasexec       NUMBER := 1;
      vparam         VARCHAR2(500)
         := 'pcempres: ' || pcempres || ' psproduc:' || psproduc || ', psseguro: ' || psseguro
            || ', pfefecto: ' || pfefecto || ', pnmovimi: ' || pnmovimi || ', pmodo: '
            || pmodo || ' pnriesgo: ' || pnriesgo || ' psprocpu: ' || psprocpu;
      v_nmovimi      NUMBER;
      num_err        NUMBER;
      v_ipb          NUMBER;
      esalidaerror   EXCEPTION;
      v_cestado      adm_proceso_pu.cestado%TYPE;
      v_cerror       adm_proceso_pu.cerror%TYPE;
      v_terror       adm_proceso_pu.terror%TYPE;
      v_newpoliza    NUMBER;
      -- INI RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
      v_cmovseg      NUMBER;
      v_numpart      NUMBER;
      v_fefectomov   DATE;
   -- FIN RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
   BEGIN
      vpasexec := 2;
      -- Determinamos el tipo de PU del producto
      v_ctipopu := NVL(f_parproductos_v(psproduc, 'TIPO_PB'), 0);
      vpasexec := 3;

      IF v_ctipopu <> 0 THEN
         IF pnmovimi IS NULL THEN
            vpasexec := 4;
            num_err := f_buscanmovimi(psseguro, 1, 1, v_nmovimi);

            IF num_err <> 0 THEN
               RAISE esalidaerror;
            END IF;

            -- INI RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
            IF pmodo IN('P', 'R') THEN
               SELECT cmovseg, fefecto
                 INTO v_cmovseg, v_fefectomov
                 FROM movseguro
                WHERE sseguro = psseguro
                  AND nmovimi = v_nmovimi;

               IF (v_cmovseg != 2
                   OR v_fefectomov < pfefecto) THEN
                  RETURN 0;
               END IF;

               SELECT COUNT(*)
                 INTO v_numpart
                 FROM movseguro
                WHERE sseguro = psseguro
                  AND cmotmov = 556
                  AND fefecto = v_fefectomov
                  AND cmovseg <> 52;

               IF (v_numpart > 0) THEN
                  RETURN 0;
               END IF;
            END IF;
         -- FIN RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
         ELSE
            v_nmovimi := pnmovimi;
            -- INI RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
            v_fefectomov := pfefecto;
         -- FIN RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
         END IF;

         vpasexec := 5;

         -- Insertamos un registro por cada riesgo para los tipos de PU siguientes
         -- 0 Est¿ndar
         -- 1 MVA detalle por p¿liza en cartera
         -- 2 T1 (P¿liza nueva en cartera)
         -- 3 Resta Prima en cartera
         -- 4 Recibo en Cierre por certificado
         -- 5 Recibo en Cierre por p¿liza 0
         -- 6 MVA detalle por garant¿a en cartera
         IF v_ctipopu = 1 THEN
            --Consideraremos un unico riego para este caso
            vpasexec := 10;
            -- INI RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
             --v_ipb := pac_provmat_formul.f_calcul_formulas_provi(psseguro, pfefecto,
             --                                                    'IPARTBEN');
            v_ipb := pac_provmat_formul.f_calcul_formulas_provi(psseguro, v_fefectomov,
                                                                'IPARTBEN');

            -- FIN RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
            IF v_ipb IS NOT NULL THEN
               IF pmodo IN('A', 'R') THEN
                  vpasexec := 11;
                  -- INI RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
                  --num_err := pac_propio.f_alta_detalle_gar(psseguro, pfefecto, v_ipb,
                  --                                         pcempres);
                  num_err := pac_propio.f_alta_detalle_gar(psseguro, v_fefectomov, v_ipb,
                                                           pcempres);

                  -- FIN RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
                  IF num_err = 0 THEN
                     v_cestado := 1;   -- procesado
                     v_cerror := NULL;
                     v_terror := NULL;
                  ELSE
                     v_cestado := 0;   -- pdte de procesar para reprocesar)
                     v_cerror := num_err;
                     v_terror := SUBSTR(v_cerror || ' ' || f_axis_literales(v_cerror) || ' '
                                        || vobject || ' -> ' || vparam,
                                        1, 2000);
                  END IF;
               ELSE   -- 'P'
                  v_cestado := 1;   -- procesado
                  v_cerror := NULL;
                  v_terror := NULL;
               END IF;
            ELSE
               v_ipb := 0;
               v_cestado := 0;   -- pdte de procesar para reprocesar)
               v_cerror := 9000787;
               v_terror := SUBSTR(v_cerror || ' ' || f_axis_literales(v_cerror) || ' '
                                  || vobject || ' -> ' || vparam,
                                  1, 2000);
            END IF;

            IF pmodo = 'R' THEN
               vpasexec := 12;

               DELETE      adm_proceso_pu
                     WHERE sseguro = psseguro
                       AND nriesgo = pnriesgo
                       -- INI RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
                               --AND fefecto = pfefecto;
                       AND fefecto = v_fefectomov;

               -- FIN RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
               INSERT INTO adm_proceso_pu
                           (sproces, sseguro, nriesgo, nmovimi, fefecto,
                            fcalcul, cestado, ctipopu, importe, cerror, terror)
                    -- INI RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
                    --    VALUES (psprocpu, psseguro, NVL(pnriesgo, 1), v_nmovimi, pfefecto,
               VALUES      (psprocpu, psseguro, NVL(pnriesgo, 1), v_nmovimi, v_fefectomov,
                            -- FIN RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
                            f_sysdate, v_cestado, v_ctipopu, v_ipb, v_cerror, v_terror);
            ELSIF pmodo = 'P' THEN
               vpasexec := 13;

               DELETE      adm_proceso_pu_previo
                     WHERE sseguro = psseguro
                       AND nriesgo = pnriesgo
                       -- INI RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
                       --AND fefecto = pfefecto;
                       AND fefecto = v_fefectomov;

               -- FIN RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
               INSERT INTO adm_proceso_pu_previo
                           (sproces, sseguro, nriesgo, nmovimi, fefecto,
                            fcalcul, cestado, ctipopu, importe, cerror, terror)
                     -- INI RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
                    --VALUES (psprocpu, psseguro, NVL(pnriesgo, 1), v_nmovimi, pfefecto,
               VALUES      (psprocpu, psseguro, NVL(pnriesgo, 1), v_nmovimi, v_fefectomov,
                            -- FIN RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
                            f_sysdate, v_cestado, v_ctipopu, v_ipb, v_cerror, v_terror);
            ELSIF pmodo = 'A' THEN
               vpasexec := 14;

               UPDATE adm_proceso_pu
                  SET cestado = v_cestado,
                      importe = v_ipb,
                      fcalcul = f_sysdate,
                      freproc = f_sysdate,
                      cerror = v_cerror,
                      terror = v_terror
                WHERE sproces = psprocpu
                  AND sseguro = psseguro
                  AND nriesgo = pnriesgo
                   -- INI RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
                  --AND fefecto = pfefecto;
                  AND fefecto = v_fefectomov;
            -- FIN RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
            END IF;
---------------------------------------------------------------------------------------------------
         ELSIF v_ctipopu = 2 THEN
            --Consideraremos un unico riego para este caso
            vpasexec := 20;
            -- INI RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
            --v_ipb := pac_provmat_formul.f_calcul_formulas_provi(psseguro, pfefecto,
            v_ipb := pac_provmat_formul.f_calcul_formulas_provi(psseguro, v_fefectomov,

                                                                -- FIN RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
                                                                'IPARTBEN');

            IF v_ipb IS NOT NULL THEN
               IF pmodo IN('A', 'R') THEN
                  vpasexec := 21;
                  -- INI RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
                  --num_err := pac_propio.f_alta_poliza_pu(psseguro, pfefecto, v_ctipopu,
                  num_err := pac_propio.f_alta_poliza_pu(psseguro, v_fefectomov, v_ctipopu,

                                                         -- FIN RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
                                                         pcempres, v_newpoliza);

                  IF num_err = 0 THEN
                     v_cestado := 1;   -- procesado
                     v_cerror := NULL;
                     v_terror := NULL;
                  ELSE
                     v_cestado := 0;   -- pdte de procesar para reprocesar)
                     v_cerror := num_err;
                     v_terror := SUBSTR(v_cerror || ' ' || f_axis_literales(v_cerror) || ' '
                                        || vobject || ' -> ' || vparam,
                                        1, 2000);
                  END IF;
               ELSE   -- 'P'
                  v_cestado := 1;   -- procesado
                  v_cerror := NULL;
                  v_terror := NULL;
               END IF;
            ELSE
               v_ipb := 0;
               v_cestado := 0;   -- pdte de procesar para reprocesar)
               v_cerror := 9000787;
               v_terror := SUBSTR(v_cerror || ' ' || f_axis_literales(v_cerror) || ' '
                                  || ' IPARTBEN (7505) --> ' || vobject || ' vparam: '
                                  || vparam,
                                  1, 2000);
            END IF;

            IF pmodo = 'R' THEN
               vpasexec := 22;

               DELETE      adm_proceso_pu
                     WHERE sseguro = psseguro
                       AND nriesgo = pnriesgo
                       -- INI RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
                       --AND fefecto = pfefecto;
                       AND fefecto = v_fefectomov;

               -- FIN RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
               INSERT INTO adm_proceso_pu
                           (sproces, sseguro, nriesgo, nmovimi, fefecto,
                            fcalcul, cestado, ctipopu, importe, cerror, terror)
                    -- INI RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
                    --VALUES (psprocpu, psseguro, NVL(pnriesgo, 1), v_nmovimi, pfefecto,
               VALUES      (psprocpu, psseguro, NVL(pnriesgo, 1), v_nmovimi, v_fefectomov,
                            -- INI RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
                            f_sysdate, v_cestado, v_ctipopu, v_ipb, v_cerror, v_terror);
            ELSIF pmodo = 'P' THEN
               vpasexec := 23;

               DELETE      adm_proceso_pu_previo
                     WHERE sseguro = psseguro
                       AND nriesgo = pnriesgo
                       -- INI RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
                       --AND fefecto = pfefecto;
                       AND fefecto = pfefecto;

               -- FIN RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
               INSERT INTO adm_proceso_pu_previo
                           (sproces, sseguro, nriesgo, nmovimi, fefecto,
                            fcalcul, cestado, ctipopu, importe, cerror, terror)
                    -- INI RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
                    --VALUES (psprocpu, psseguro, NVL(pnriesgo, 1), v_nmovimi, pfefecto,
               VALUES      (psprocpu, psseguro, NVL(pnriesgo, 1), v_nmovimi, v_fefectomov,
                            -- FIN RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
                            f_sysdate, v_cestado, v_ctipopu, v_ipb, v_cerror, v_terror);
            ELSIF pmodo = 'A' THEN
               vpasexec := 24;

               UPDATE adm_proceso_pu
                  SET cestado = v_cestado,
                      importe = v_ipb,
                      fcalcul = f_sysdate,
                      freproc = f_sysdate,
                      cerror = v_cerror,
                      terror = v_terror
                WHERE sproces = psprocpu
                  AND sseguro = psseguro
                  AND nriesgo = pnriesgo
                  -- INI RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
                  --AND fefecto = pfefecto;
                  AND fefecto = v_fefectomov;
            -- FIN RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
            END IF;
---------------------------------------------------------------------------------------------------
         ELSIF v_ctipopu = 3 THEN   --PDTE de desarrrollo
            -- Para cada riesgo del seguro lo grabamos en la tabla ADM_PROCESO_PU para que se reprocese (cestado = 0)
            vpasexec := 30;

            FOR reg IN (SELECT nriesgo
                          FROM riesgos
                         WHERE sseguro = psseguro) LOOP
               IF pmodo = 'R' THEN
                  vpasexec := 31;

                  DELETE      adm_proceso_pu
                        WHERE sseguro = psseguro
                          AND nriesgo = pnriesgo
                          -- INI RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
                          --AND fefecto = pfefecto;
                          AND fefecto = v_fefectomov;

                  -- FIN RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
                  INSERT INTO adm_proceso_pu
                              (sproces, sseguro, nriesgo, nmovimi, fefecto,
                               fcalcul, cestado, ctipopu, importe)
                       -- INI RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
                       --VALUES (psprocpu, psseguro, reg.nriesgo, v_nmovimi, pfefecto,
                  VALUES      (psprocpu, psseguro, reg.nriesgo, v_nmovimi, v_fefectomov,
                               -- FIN RLLF 29/10/2015 0034026: POSTEC PV LARGO PLAZO INVERSI¿N ERROR EN CALCULO DE RESERVA DIARIA. Error en la generaci¿n para p¿lizas no anuales.
                               f_sysdate, 0, v_ctipopu, 0);
               END IF;
            END LOOP;
---------------------------------------------------------------------------------------------------
         ELSIF v_ctipopu = 4 THEN   -- Se trata desde cierres
            vpasexec := 40;
            NULL;
---------------------------------------------------------------------------------------------------
         ELSIF v_ctipopu = 5 THEN   -- Se trata desde cierres
            vpasexec := 50;
            NULL;
---------------------------------------------------------------------------------------------------
         ELSIF v_ctipopu = 6 THEN
--PU por garant¿a. Se tiene que dsarrollar una tabla detalle a la adm_proceso_pu con las garant¿as y un
-- nuevo pac_propio.f_alta_pb_gar que genere el movimiento de PB, y el detalle para cada garant¿a e inserte en adm_proceso_pu
-- y su detalle pro garant¿a.
            vpasexec := 60;
            NULL;
         END IF;
      END IF;

      -- Si todo ha ido bien hacemos COMMIT, confirmamos las tablas ADM_PROCESO_PU
      COMMIT;
      RETURN 0;
   EXCEPTION
      WHEN esalidaerror THEN
         p_tab_error(f_sysdate, f_user, vobject, vpasexec,
                     vparam || ' ' || ' num_error: ' || num_err || ' '
                     || f_axis_literales(num_err),
                     SQLERRM);
         RETURN 1;
      WHEN OTHERS THEN
         -- Si ha producido un error al actualizar las tablas ADM_PROCESO_PU retrocedemos las operaciones realizadas
         ROLLBACK;
         p_tab_error(f_sysdate, f_user, vobject, vpasexec, vparam, SQLERRM);
         RETURN 1;
   END f_tratamiento_pb;

/****************************************************************************
   f_actualizar_franq

   Bug 26638/161264 - 0/04/2014 - AMC
*****************************************************************************/
   FUNCTION f_actualizar_franq(
      psproces IN NUMBER,
      psproduc IN NUMBER,
      pcactivi IN NUMBER,
      pnriesgo IN NUMBER,
      psseguro IN NUMBER,
      pnmovimi IN NUMBER,
      pfefecto IN DATE,
      pssegpol IN NUMBER,
      pcgrup IN NUMBER,
      pcsubgrup IN NUMBER,
      pcversion IN NUMBER,
      pcnivel IN NUMBER,
      pcvalor1 IN NUMBER,
      pimpvalor1 IN NUMBER,
      pcvalor2 IN NUMBER,
      pimpvalor2 IN NUMBER,
      pcimpmin IN NUMBER,
      pimpmin IN NUMBER,
      pcimpmax IN NUMBER,
      pimpmax IN NUMBER,
      psuplem IN BOOLEAN,
      psimul IN BOOLEAN,
      pcempres IN NUMBER,
      pcidioma IN NUMBER)
      RETURN NUMBER IS
      TYPE vbf_progarangrup IS RECORD(
         cempres        NUMBER,
         tempres        VARCHAR2(200),
         sproduc        NUMBER,
         tproducto      VARCHAR2(200),
         cactivi        NUMBER,
         tactividad     VARCHAR2(200),
         cgarant        NUMBER,
         tgarant        VARCHAR2(200),
         cgarpadre      NUMBER,
         cvisible       NUMBER,
         cnivgar        NUMBER,
         cvisniv        NUMBER,
         ffecini        DATE,
         codgrup        NUMBER,
         tgrupo         VARCHAR2(200)
      );

      TYPE vbf_versiongrup IS RECORD(
         cempres        NUMBER,
         tempres        VARCHAR2(100),
         cgrup          NUMBER,
         cversion       NUMBER,
         tgrup          VARCHAR2(50),
         fdesde         DATE,
         fhasta         DATE
      );

      TYPE vbf_desnivel IS RECORD(
         cempres        NUMBER,
         tempres        VARCHAR2(200),
         cgrup          NUMBER,
         csubgrup       NUMBER,
         tgrup          VARCHAR2(200),
         tgrupsubgrup   VARCHAR2(200),
         cversion       NUMBER(15),
         cnivel         NUMBER,
         cidioma        NUMBER,
         tidioma        VARCHAR2(100),
         tnivel         VARCHAR2(200)
      );

      TYPE vbf_listlibre IS RECORD(
         cempres        NUMBER(6),
         id_listlibre   NUMBER(4),
         cvalor         NUMBER(8),
         tvalor         VARCHAR2(2000),
         catribu        NUMBER(3),
         tatribu        VARCHAR2(2000),
         idlistalibre2  NUMBER(4),
         id_listlibre_min NUMBER(4),
         id_listlibre_max NUMBER(4)
      );

      TYPE tbf_desnivel IS TABLE OF vbf_desnivel;

      TYPE tbf_listlibre IS TABLE OF vbf_listlibre;

      TYPE vbf_detnivel IS RECORD(
         cempres        NUMBER,
         tempres        VARCHAR2(200),
         cgrup          NUMBER,
         csubgrup       NUMBER,
         cversion       NUMBER,
         tgrup          VARCHAR2(200),
         tgrupsubgrup   VARCHAR2(200),
         cnivel         NUMBER,
         tnivel         VARCHAR2(200),
         norden         NUMBER,
         cdtorec        NUMBER,
         formulaselecc  NUMBER,
         tdtorec        VARCHAR2(200),
         tformulavalida VARCHAR2(200),
         formulasinies  NUMBER,
         tformulasinies VARCHAR2(200),
         ctipnivel      NUMBER,
         ttipnivel      VARCHAR2(200),
         cvalor1        NUMBER,
         tvalor1        VARCHAR2(200),
         impvalor1      NUMBER,
         cvalor2        NUMBER,
         tvalor2        VARCHAR2(200),
         impvalor2      NUMBER,
         cimpmin        NUMBER,
         timpmin        VARCHAR2(200),
         impmin         NUMBER,
         cimpmax        NUMBER,
         timpmax        VARCHAR2(200),
         impmax         NUMBER,
         cdefecto       VARCHAR2(1),
         ccontratable   VARCHAR2(1),
         tcontratable   VARCHAR2(200),
         cinterviene    VARCHAR2(1),
         tinterviene    VARCHAR2(100),
         lidioma        tbf_desnivel,
         id_listlibre   NUMBER,
         lvalor1        NUMBER,
         lvalor2        NUMBER,
         limpmin        NUMBER,
         limpmax        NUMBER,
         listacvalor1   tbf_listlibre,
         listacvalor2   tbf_listlibre,
         listacimpmin   tbf_listlibre,
         listacimpmax   tbf_listlibre
      );

      TYPE vbf_desgrupsubgrup IS RECORD(
         cempres        NUMBER,
         tempres        VARCHAR2(200),
         cgrup          NUMBER,
         csubgrup       NUMBER,
         cversion       NUMBER,
         cidioma        NUMBER,
         tidioma        VARCHAR2(200),
         tgrup          VARCHAR2(200),
         tgrupsubgrup   VARCHAR2(200)
      );

      TYPE tbf_detnivel IS TABLE OF vbf_detnivel;

      TYPE tbf_desgrupsubgrup IS TABLE OF vbf_desgrupsubgrup;

      TYPE vbf_grupsubgrup IS RECORD(
         cempres        NUMBER,
         tempres        VARCHAR2(200),
         cgrup          NUMBER,
         csubgrup       NUMBER,
         cversion       NUMBER,
         ctipgrupsubgrup NUMBER,
         tgrup          VARCHAR2(200),
         tgrupsubgrup   VARCHAR2(200),
         ttipgrupsubgrup VARCHAR2(200),
         obversion      vbf_versiongrup,
         lniveles       tbf_detnivel,
         ldescripciones tbf_desgrupsubgrup
      );

      TYPE vbf_desgrup IS RECORD(
         cempres        NUMBER,
         tempres        VARCHAR2(100),
         cgrup          NUMBER,
         cversion       NUMBER,
         cidioma        NUMBER,
         tidioma        VARCHAR2(200),
         tgrup          VARCHAR2(200)
      );

      TYPE tbf_grupsubgrup IS TABLE OF vbf_grupsubgrup;

      TYPE tbf_desgrup IS TABLE OF vbf_desgrup;

      TYPE vbf_codgrup IS RECORD(
         cempres        NUMBER,
         tempres        VARCHAR2(100),
         cgrup          NUMBER,
         cversion       NUMBER,
         tgrup          VARCHAR2(50),
         ctipgrup       NUMBER,
         ctipvisgrup    NUMBER,
         ttipvisgrup    VARCHAR2(100),
         lsubgrupos     tbf_grupsubgrup,
         lidiomas       tbf_desgrup
      );

      TYPE vbonfranseg IS RECORD(
         sseguro        NUMBER,
         nriesgo        NUMBER,
         cgrup          NUMBER,
         tgrup          VARCHAR2(200),
         csubgrup       NUMBER,
         cnivel         NUMBER,
         tnivel         VARCHAR2(200),
         cversion       NUMBER,
         nmovimi        NUMBER,
         finiefe        DATE,
         ctipgrup       VARCHAR2(1),
         cvalor1        NUMBER,
         tvalor1        VARCHAR2(200),
         impvalor1      NUMBER,
         cvalor2        VARCHAR2(2),
         tvalor2        VARCHAR2(200),
         impvalor2      NUMBER,
         cimpmin        VARCHAR2(2),
         timpmin        VARCHAR2(200),
         impmin         NUMBER,
         cimpmax        VARCHAR2(2),
         timpmax        VARCHAR2(200),
         impmax         NUMBER,
         ffinefe        DATE,
         cusualt        VARCHAR2(20),
         falta          DATE,
         cusumod        VARCHAR2(20),
         fmodifi        DATE,
         ctipvisgrup    NUMBER,
         ttipvisgrup    VARCHAR2(200),
         ctipgrupsubgrup NUMBER,
         cniveldefecto  NUMBER
      );

      TYPE tbf_progarangrup IS TABLE OF vbf_progarangrup;

      TYPE vbf_proactgrup IS RECORD(
         cempres        NUMBER,
         sproduc        NUMBER,
         cactivi        NUMBER,
         ffecini        DATE,
         cgrup          NUMBER,
         cobliga        VARCHAR2(1),
         cformulasub    NUMBER,
         csubgrupunic   NUMBER,
         norden         NUMBER,
         teccontra      VARCHAR2(1),
         ffecfin        DATE,
         formuladefecto NUMBER,
         garantias      tbf_progarangrup,
         grupo          vbf_codgrup,
         lniveles       tbf_detnivel,
         franqcontratada vbonfranseg
      );

      TYPE viaxpar_respuestas IS RECORD(
         crespue        NUMBER,
         cpregun        NUMBER(4),
         trespue        VARCHAR2(40)
      );

      TYPE tiaxpar_respuestas IS TABLE OF viaxpar_respuestas;

      TYPE tbf_proactgrup IS TABLE OF vbf_proactgrup;

      tprodfranq     tbf_proactgrup;
      resp           tiaxpar_respuestas;
      vpasexec       NUMBER(8) := 1;
      vparam         VARCHAR2(500)
         := 'psproduc=' || psproduc || ',pcactivi=' || pcactivi || ',pnriesgo=' || pnriesgo
            || ',psseguro=' || psseguro || ',pnmovimi=' || pnmovimi || ',pfefecto=' || pfefecto
            || ',pssegpol=' || pssegpol || ',pcgrup=' || pcgrup || ',pcsubgrup=' || pcsubgrup
            || ',pcversion=' || pcversion || ',pcnivel=' || pcnivel || ',pcvalor1=' || pcvalor1
            || ',pimpvalor1=' || pimpvalor1 || ',pcvalor2=' || pcvalor2 || ',pimpvalor2='
            || pimpvalor2 || ',pcimpmin=' || pcimpmin || ',pimpmin=' || pimpmin || ',pcimpmax='
            || pcimpmax || ',pimpmax=' || pimpmax || ',pcempres=' || pcempres || ',pcidioma='
            || pcidioma;
      vobject        VARCHAR2(200) := 'PAC_MDPAR_PRODUCTOS.F_Get_franquicias';
      cur            sys_refcursor;
      v_isaltacol    NUMBER;
      vindex         NUMBER;
      vindex2        NUMBER;
      vindex3        NUMBER;
      vindex4        NUMBER;
      tprodfranqgar  tbf_progarangrup;
      tgrupsubgrup   tbf_grupsubgrup;
      vsubgrup       NUMBER;
      tdetnivel      tbf_detnivel;

      CURSOR c_franq IS
         SELECT DISTINCT bfp.*
                    FROM bf_proactgrup bfp, bf_progarangrup bfpa, garanseg g
                   WHERE bfp.sproduc = psproduc
                     AND bfp.cactivi = pcactivi
                     AND bfp.cgrup = NVL(pcgrup, cgrup)
                     AND bfp.cempres = pcempres
                     AND bfp.cempres = bfpa.cempres
                     AND bfp.cactivi = bfpa.cactivi
                     AND bfp.sproduc = bfpa.sproduc
                     AND bfp.cgrup = bfpa.codgrup
                     AND bfp.ffecini = bfpa.ffecini
                     AND g.cgarant = bfpa.cgarant
                     AND g.sseguro = psseguro
                     AND g.nriesgo = pnriesgo
                     AND g.nmovimi = pnmovimi
         UNION
         SELECT DISTINCT bfp.*
                    FROM bf_proactgrup bfp, bf_progarangrup bfpa, garanseg_aux g
                   WHERE bfp.sproduc = psproduc
                     AND bfp.cactivi = pcactivi
                     AND bfp.cgrup = NVL(pcgrup, cgrup)
                     AND bfp.cempres = pcempres
                     AND bfp.cempres = bfpa.cempres
                     AND bfp.cactivi = bfpa.cactivi
                     AND bfp.sproduc = bfpa.sproduc
                     AND bfp.cgrup = bfpa.codgrup
                     AND bfp.ffecini = bfpa.ffecini
                     AND g.cgarant = bfpa.cgarant
                     AND g.sseguro = psseguro
                     AND g.nriesgo = pnriesgo
                     AND g.nmovimi = pnmovimi;

      vformula       NUMBER := 1;
      v_issuplem     NUMBER := 0;
      vcnivel        NUMBER;
      vcvalor1       NUMBER;
      vimpvalor1     NUMBER;
      vcvalor2       NUMBER;
      vimpvalor2     NUMBER;
      vcimpmin       NUMBER;
      vimpmin        NUMBER;
      vcimpmax       NUMBER;
      vimpmax        NUMBER;
      vnumerr        NUMBER;
      lvalor2        NUMBER;
      limpmin        NUMBER;
      limpmax        NUMBER;
      vvalor         NUMBER;
      vcmodali       NUMBER;
      vccolect       NUMBER;
      vctipseg       NUMBER;
      vcramo         NUMBER;
      v_crealiza     NUMBER;
      vdefectogrup   NUMBER;
      vcniveldefecto NUMBER;
      e_param_error  EXCEPTION;
      e_object_error EXCEPTION;
      vplan          NUMBER;
      vconta         NUMBER;
      pregpar        t_iaxpar_preguntas;
      v_crespue      NUMBER;
      v_trespue      VARCHAR2(2000);
      v_resp         NUMBER;
      vtprefor       VARCHAR2(100);
      v_cplan        NUMBER;
      v_cambio       BOOLEAN;
      franq          t_iax_bf_proactgrup;
      franqcontrat   t_iax_bf_proactgrup;
      marcar         BOOLEAN;
      trobat         BOOLEAN;
      vtbonfranseg   t_iax_bonfranseg;
      bon_sseguro    NUMBER;
      bon_nriesgo    NUMBER;
      bon_cgrup      NUMBER;
      bon_tgrup      VARCHAR2(200);
      bon_csubgrup   NUMBER;
      bon_tsubgrup   VARCHAR2(200);
      bon_cnivel     NUMBER;
      bon_tnivel     VARCHAR2(200);
      bon_cversion   NUMBER;
      bon_nmovimi    NUMBER;
      bon_finiefe    DATE;
      bon_ctipgrup   VARCHAR2(1);
      bon_cvalor1    NUMBER;
      bon_tvalor1    VARCHAR2(200);
      bon_impvalor1  NUMBER;
      bon_cvalor2    VARCHAR2(2);
      bon_tvalor2    VARCHAR2(200);
      bon_impvalor2  NUMBER;
      bon_cimpmin    VARCHAR2(2);
      bon_timpmin    VARCHAR2(200);
      bon_impmin     NUMBER;
      bon_cimpmax    VARCHAR2(2);
      bon_timpmax    VARCHAR2(200);
      bon_impmax     NUMBER;
      bon_ffinefe    DATE;
      bon_cusualt    VARCHAR2(20);
      bon_falta      DATE;
      bon_cusumod    VARCHAR2(20);
      bon_fmodifi    DATE;
      bon_ctipvisgrup NUMBER;
      bon_ttipvisgrup VARCHAR2(200);
      bon_ctipgrupsubgrup NUMBER;
      bon_cniveldefecto NUMBER;
      vctipgrup      NUMBER;

      FUNCTION f_get_bf_listalibre(pid_listlibre IN NUMBER)
         RETURN tbf_listlibre IS
         vpasexec       NUMBER(8) := 1;
         vparam         VARCHAR2(500) := 'pid_listlibre=' || pid_listlibre;
         vobject        VARCHAR2(200) := 'PAC_MDPAR_PRODUCTOS.f_get_bf_listalibre';
         cur            sys_refcursor;
         lista          tbf_listlibre;
         vindex4        NUMBER;
      BEGIN
         FOR i IN (SELECT DISTINCT (cvalor)
                              FROM bf_listlibre
                             WHERE cempres = pcempres
                               AND id_listlibre = pid_listlibre
                               AND ROWNUM = 1) LOOP
            FOR x IN (SELECT *
                        FROM bf_listlibre
                       WHERE cempres = pcempres
                         AND id_listlibre = pid_listlibre
                         AND cvalor = i.cvalor) LOOP
               vpasexec := 91;
               vindex4 := lista.LAST;
               vpasexec := 92;
               lista(vindex4).cempres := x.cempres;
               lista(vindex4).cvalor := x.cvalor;
               lista(vindex4).catribu := x.catribu;
               lista(vindex4).id_listlibre := x.id_listlibre;
               lista(vindex4).tatribu := ff_desvalorfijo(i.cvalor,
                                                         pac_md_common.f_get_cxtidioma,
                                                         x.catribu);
               lista(vindex4).idlistalibre2 := x.id_listlibre_2;
               lista(vindex4).id_listlibre_min := x.id_listlibre_min;
               lista(vindex4).id_listlibre_max := x.id_listlibre_max;
            END LOOP;
         END LOOP;

         RETURN lista;
      EXCEPTION
         WHEN OTHERS THEN
            IF cur%ISOPEN THEN
               CLOSE cur;
            END IF;

            p_tab_error(f_sysdate, f_user, 'pac_dincartera.f_get_bf_listalibre', 1,
                        'Error nocontrolado vparam:' || vparam,
                        'psqcode =>' || SQLCODE || ' psqerrm =>' || SQLERRM);
            RETURN NULL;
      END f_get_bf_listalibre;
   BEGIN
      --Inicialitzacions
      IF psproduc IS NULL
         OR pcactivi IS NULL THEN
         RAISE e_param_error;
      END IF;

      vpasexec := 2;

      FOR frq IN c_franq() LOOP
         BEGIN
            SELECT ctipgrup, cnivel, cniveldefecto
              INTO vctipgrup, vcnivel, vcniveldefecto
              FROM bf_bonfranseg
             WHERE sseguro = psseguro
               AND nriesgo = pnriesgo
               AND cgrup = frq.cgrup
               AND nmovimi = pnmovimi;
         EXCEPTION
            WHEN NO_DATA_FOUND THEN
               SELECT ctipgrup
                 INTO vctipgrup
                 FROM bf_codgrup
                WHERE cempres = pcempres
                  AND cgrup = frq.cgrup
                  AND cversion = (SELECT MAX(cversion)
                                    FROM bf_codgrup
                                   WHERE cempres = pcempres
                                     AND cgrup = frq.cgrup);
         END;

         IF vctipgrup = 1
            OR vcnivel <> vcniveldefecto THEN
            INSERT INTO bf_bonfransegcar
               SELECT psproces, psseguro, pnriesgo, cgrup, csubgrup, cnivel, cversion,
                      pnmovimi + 1, f_sysdate, ctipgrup, cvalor1, impvalor1, cvalor2,
                      impvalor2, cimpmin, impmin, cimpmax, impmax, ffinefe, cniveldefecto
                 FROM bf_bonfranseg
                WHERE sseguro = psseguro
                  AND nriesgo = pnriesgo
                  AND cgrup = frq.cgrup
                  AND nmovimi = pnmovimi;
         ELSE
            vdefectogrup := NULL;

            IF tprodfranq IS NULL THEN
               tprodfranq := tbf_proactgrup();
            END IF;

            vindex := tprodfranq.COUNT + 1;
            tprodfranq.EXTEND;
            tprodfranq(vindex).cempres := frq.cempres;
            tprodfranq(vindex).sproduc := frq.sproduc;
            tprodfranq(vindex).cactivi := frq.cactivi;
            tprodfranq(vindex).ffecini := frq.ffecini;
            tprodfranq(vindex).cgrup := frq.cgrup;
            tprodfranq(vindex).cobliga := frq.cobliga;
            tprodfranq(vindex).cformulasub := frq.cformulasub;
            tprodfranq(vindex).csubgrupunic := frq.csubgrupunic;
            tprodfranq(vindex).norden := frq.norden;
            tprodfranq(vindex).teccontra := frq.teccontra;
            tprodfranq(vindex).ffecfin := frq.ffecfin;

            IF pcnivel IS NULL THEN
               IF frq.formuladefecto IS NOT NULL THEN
                  vnumerr := pac_bonfran.f_resuelve_formula(3, psseguro, pcactivi, psproduc,
                                                            frq.cgrup, pfefecto, pnriesgo,
                                                            frq.formuladefecto, pnmovimi,
                                                            vdefectogrup);

                  IF vnumerr <> 0 THEN
                     RAISE e_object_error;
                  END IF;

                  tprodfranq(vindex).formuladefecto := vdefectogrup;
               --frq.formuladefecto;
               END IF;
            END IF;

            vpasexec := 3;

            SELECT cmodali, ccolect, ctipseg, cramo
              INTO vcmodali, vccolect, vctipseg, vcramo
              FROM productos
             WHERE sproduc = psproduc;

            FOR frqgar IN (SELECT   bfpa.cgarant, gp.cgarpadre, gp.cvisniv
                               FROM bf_proactgrup bfp, bf_progarangrup bfpa, garanpro gp
                              WHERE bfp.cempres = bfpa.cempres
                                AND bfp.cactivi = bfpa.cactivi
                                AND bfp.sproduc = bfpa.sproduc
                                AND bfp.cgrup = bfpa.codgrup
                                AND bfp.ffecini = bfpa.ffecini
                                AND bfp.sproduc = psproduc
                                AND bfp.cactivi = pcactivi
                                AND bfp.cgrup = frq.cgrup
                                AND bfp.ffecini = frq.ffecini
                                AND bfp.cempres = pcempres
                                AND gp.sproduc = bfp.sproduc
                                AND gp.cmodali = vcmodali
                                AND gp.ccolect = vccolect
                                AND gp.ctipseg = vctipseg
                                AND gp.cramo = vcramo
                                AND gp.cgarant = bfpa.cgarant
                           ORDER BY bfp.norden) LOOP
               IF tprodfranqgar IS NULL THEN
                  tprodfranqgar := tbf_progarangrup();
               END IF;

               vpasexec := 4;
               vindex2 := tprodfranqgar.COUNT + 1;
               tprodfranqgar.EXTEND;
               tprodfranqgar(vindex2).cgarant := frqgar.cgarant;
               tprodfranqgar(vindex2).tgarant := ff_desgarantia(frqgar.cgarant, pcidioma);
               tprodfranqgar(vindex2).cgarpadre := frqgar.cgarpadre;
               tprodfranqgar(vindex2).cvisniv := frqgar.cvisniv;

               BEGIN
                  SELECT DECODE(cgarant, g01, 1, g02, 2, g03, 3, NULL)
                    INTO tprodfranqgar(vindex2).cnivgar
                    FROM garanprored
                   WHERE sproduc = psproduc
                     AND cactivi = pcactivi
                     AND cgarant = frqgar.cgarant
                     AND fmovfin IS NULL;
               EXCEPTION
                  WHEN OTHERS THEN
                     tprodfranqgar(vindex2).cnivgar := NULL;
               END;

               vnumerr := pac_cfg.f_get_user_accion_permitida(f_user, 'NIVEL_VISIONGAR',
                                                              psproduc, pcempres, v_crealiza);

               IF NVL(frqgar.cvisniv, 1) > NVL(v_crealiza, 3) THEN
                  tprodfranqgar(vindex2).cvisible := 0;
               ELSE
                  tprodfranqgar(vindex2).cvisible := 1;
               END IF;
            END LOOP;

            tprodfranq(vindex).garantias := tprodfranqgar;
            tprodfranq(vindex).grupo.cempres := frq.cempres;
            tprodfranq(vindex).grupo.cgrup := frq.cgrup;
            vpasexec := 5;

            SELECT b.cversion, b.ctipgrup,
                   b.ctipvisgrup, bd.tgrup,
                   ff_desvalorfijo(309, pac_md_common.f_get_cxtidioma, b.ctipvisgrup)
                                                                                   ttipvisgrup
              INTO tprodfranq(vindex).grupo.cversion, tprodfranq(vindex).grupo.ctipgrup,
                   tprodfranq(vindex).grupo.ctipvisgrup, tprodfranq(vindex).grupo.tgrup,
                   tprodfranq(vindex).grupo.ttipvisgrup
              FROM bf_codgrup b, bf_desgrup bd, bf_versiongrup bv
             WHERE b.cgrup = frq.cgrup
               AND bd.cgrup = b.cgrup
               AND bd.cempres = pcempres
               AND bd.cempres = b.cempres
               AND bv.cempres = bd.cempres
               AND b.cversion = bd.cversion
               AND b.cversion = bv.cversion
               AND bv.cempres = b.cempres
               AND bv.cgrup = b.cgrup
               AND((pcversion IS NOT NULL
                    AND b.cversion = pcversion)
                   OR(((v_issuplem = 1
                        AND(EXISTS(SELECT cversion
                                     FROM bf_bonfranseg
                                    WHERE cgrup = frq.cgrup
                                      AND sseguro = pssegpol
                                      AND nriesgo = pnriesgo
                                      AND ffinefe IS NOT NULL
                                      AND nmovimi = (SELECT MAX(nmovimi)
                                                       FROM movseguro
                                                      WHERE sseguro = pssegpol))
                            AND bv.cversion = (SELECT cversion
                                                 FROM bf_bonfranseg
                                                WHERE cgrup = frq.cgrup
                                                  AND nriesgo = pnriesgo
                                                  AND sseguro = pssegpol
                                                  AND nmovimi = (SELECT MAX(nmovimi)
                                                                   FROM movseguro
                                                                  WHERE sseguro = pssegpol)
                                                  AND ffinefe IS NOT NULL)
                            OR(NOT EXISTS(SELECT cversion
                                            FROM bf_bonfranseg
                                           WHERE cgrup = frq.cgrup
                                             AND sseguro = pssegpol
                                             AND nriesgo = pnriesgo
                                             AND nmovimi = (SELECT MAX(nmovimi)
                                                              FROM movseguro
                                                             WHERE sseguro = pssegpol)
                                             AND ffinefe IS NOT NULL)
                               AND bv.cversion = (SELECT cversion
                                                    FROM bf_versiongrup
                                                   WHERE cempres = bd.cempres
                                                     AND cgrup = frq.cgrup
                                                     AND fdesde <= pfefecto
                                                     AND(fhasta >= pfefecto
                                                         OR fhasta IS NULL)))))
                       OR(v_issuplem = 0
                          AND bv.cversion = (SELECT cversion
                                               FROM bf_versiongrup
                                              WHERE cempres = bd.cempres
                                                AND cgrup = frq.cgrup
                                                AND fdesde <= pfefecto
                                                AND(fhasta >= pfefecto
                                                    OR fhasta IS NULL))))))
               AND bd.cidioma = pac_md_common.f_get_cxtidioma;

            vpasexec := 6;

            IF pcsubgrup IS NULL THEN
               vsubgrup := frq.csubgrupunic;

               IF frq.csubgrupunic IS NULL THEN
                  IF frq.cformulasub IS NOT NULL THEN
                     vnumerr := pac_bonfran.f_resuelve_formula(3, psseguro, pcactivi,
                                                               psproduc, frq.cgrup, pfefecto,
                                                               pnriesgo, frq.cformulasub,
                                                               pnmovimi, vsubgrup);

                     IF vnumerr <> 0 THEN
                        RAISE e_object_error;
                     END IF;

                     tprodfranq(vindex).csubgrupunic := vsubgrup;
                  END IF;
               END IF;
            ELSE
               vsubgrup := pcsubgrup;
            END IF;

            IF vsubgrup IS NOT NULL THEN
               FOR frqsub IN (SELECT b.cempres, b.cgrup, b.csubgrup, b.cversion,
                                     b.ctipgrupsubgrup, bd.tgrupsubgrup
                                FROM bf_grupsubgrup b, bf_desgrupsubgrup bd
                               WHERE b.cgrup = frq.cgrup
                                 AND b.cempres = pcempres
                                 AND b.cempres = bd.cempres
                                 AND b.cgrup = bd.cgrup
                                 AND b.csubgrup = bd.csubgrup
                                 AND b.csubgrup = vsubgrup
                                 AND b.cversion = tprodfranq(vindex).grupo.cversion
                                 AND bd.cversion = b.cversion
                                 AND bd.cidioma = pcidioma) LOOP
                  IF tgrupsubgrup IS NULL THEN
                     tgrupsubgrup := tbf_grupsubgrup();
                  END IF;

                  vpasexec := 7;
                  vindex3 := tgrupsubgrup.COUNT + 1;
                  tgrupsubgrup.EXTEND;
                  tgrupsubgrup(vindex3).cempres := frqsub.cempres;
                  tgrupsubgrup(vindex3).cgrup := frqsub.cgrup;
                  tgrupsubgrup(vindex3).csubgrup := frqsub.csubgrup;
                  tgrupsubgrup(vindex3).cversion := frqsub.cversion;
                  tgrupsubgrup(vindex3).ctipgrupsubgrup := frqsub.ctipgrupsubgrup;
                  tgrupsubgrup(vindex3).tgrupsubgrup := frqsub.tgrupsubgrup;
                  vpasexec := 8;

                  FOR c_nivel IN (SELECT   b.cempres, b.cgrup, b.csubgrup, b.cversion,
                                           b.cnivel, b.norden, b.cdtorec, b.formulaselecc,
                                           b.formulavalida, b.formulasinies, b.ctipnivel,
                                           b.cvalor1, b.impvalor1, b.cvalor2, b.impvalor2,
                                           b.cimpmin, b.impmin, b.cimpmax, b.impmax,
                                           b.cdefecto, b.ccontratable, b.cinterviene,
                                           b.cpolitica, tnivel, id_listlibre
                                      --, lvalor1, lvalor2--, limpmin--, limpmax
                                  FROM     bf_detnivel b, bf_desnivel bdl
                                     WHERE b.cempres = pcempres
                                       AND b.cempres = bdl.cempres
                                       AND b.csubgrup = frqsub.csubgrup
                                       AND b.cgrup = frq.cgrup
                                       AND b.cgrup = bdl.cgrup
                                       AND b.csubgrup = bdl.csubgrup
                                       AND b.cversion = bdl.cversion
                                       AND b.cversion = tprodfranq(vindex).grupo.cversion
                                       AND bdl.cversion = b.cversion
                                       AND b.cnivel = bdl.cnivel
                                       AND b.cnivel = NVL(pcnivel, b.cnivel)
                                       AND b.cversion = frqsub.cversion
                                       AND cidioma = pcidioma
                                  ORDER BY norden ASC) LOOP
                     vformula := 1;
                     vcnivel := NULL;

                     IF pcnivel IS NULL THEN
                        IF tgrupsubgrup(vindex3).ctipgrupsubgrup = 1 THEN
                           --  IF v_issuplem = 1 THEN
                           BEGIN
                              SELECT cnivel, impvalor1, cniveldefecto
                                INTO vcnivel, vimpvalor1, vcniveldefecto
                                FROM bf_bonfranseg
                               WHERE cgrup = frq.cgrup
                                 AND sseguro = psseguro
                                 AND csubgrup = frqsub.csubgrup
                                 AND nriesgo = pnriesgo
                                 AND cnivel = c_nivel.cnivel
                                 AND nmovimi = pnmovimi
                                 AND ffinefe IS NULL;
                           EXCEPTION
                              WHEN NO_DATA_FOUND THEN
                                 vcnivel := NULL;

                                 BEGIN
                                    SELECT cvalor1, impvalor1, cvalor2, impvalor2,
                                           cimpmin, impmin, cimpmax, impmax, cnivel,
                                           cniveldefecto
                                      INTO vcvalor1, vimpvalor1, vcvalor2, vimpvalor2,
                                           vcimpmin, vimpmin, vcimpmax, vimpmax, vcnivel,
                                           vcniveldefecto
                                      FROM bf_bonfranseg
                                     WHERE cgrup = frq.cgrup
                                       AND sseguro = psseguro
                                       -- AND csubgrup = frqsub.csubgrup
                                       AND nriesgo = pnriesgo
                                       AND cnivel = c_nivel.cnivel
                                       AND nmovimi = pnmovimi
                                       AND ffinefe IS NULL;
                                 EXCEPTION
                                    WHEN OTHERS THEN
                                       vcnivel := NULL;
                                 END;
                           END;

                           IF vcnivel IS NULL THEN
                              IF c_nivel.formulaselecc IS NOT NULL THEN
                                 vnumerr :=
                                    pac_bonfran.f_resuelve_formula(3, psseguro, pcactivi,
                                                                   psproduc, frq.cgrup,
                                                                   pfefecto, pnriesgo,
                                                                   c_nivel.formulaselecc,
                                                                   pnmovimi, vformula);

                                 IF vnumerr <> 0 THEN
                                    RAISE e_object_error;
                                 END IF;
                              END IF;
                           END IF;
                        ELSE
                           BEGIN
                              SELECT cvalor1, impvalor1, cvalor2, impvalor2, cimpmin,
                                     impmin, cimpmax, impmax, cnivel, cniveldefecto
                                INTO vcvalor1, vimpvalor1, vcvalor2, vimpvalor2, vcimpmin,
                                     vimpmin, vcimpmax, vimpmax, vcnivel, vcniveldefecto
                                FROM bf_bonfranseg
                               WHERE cgrup = frq.cgrup
                                 AND sseguro = psseguro
                                 AND csubgrup = frqsub.csubgrup
                                 AND nriesgo = pnriesgo
                                 AND cnivel = c_nivel.cnivel
                                 AND nmovimi = pnmovimi
                                 AND ffinefe IS NULL;
                           EXCEPTION
                              WHEN NO_DATA_FOUND THEN
                                 vcnivel := NULL;

                                 BEGIN
                                    SELECT cvalor1, impvalor1, cvalor2, impvalor2,
                                           cimpmin, impmin, cimpmax, impmax, cnivel,
                                           cniveldefecto
                                      INTO vcvalor1, vimpvalor1, vcvalor2, vimpvalor2,
                                           vcimpmin, vimpmin, vcimpmax, vimpmax, vcnivel,
                                           vcniveldefecto
                                      FROM bf_bonfranseg
                                     WHERE cgrup = frq.cgrup
                                       AND sseguro = psseguro
                                       AND nriesgo = pnriesgo
                                       AND cnivel = c_nivel.cnivel
                                       AND nmovimi = pnmovimi
                                       AND ffinefe IS NULL;
                                 EXCEPTION
                                    WHEN OTHERS THEN
                                       vcnivel := NULL;
                                 END;
                           END;
                        END IF;
                     ELSE
                        vcnivel := pcnivel;
                     END IF;

                     IF vformula = 1
                        AND(c_nivel.ccontratable = 'S'
                            OR vcnivel IS NOT NULL) THEN
                        IF tdetnivel IS NULL THEN
                           tdetnivel := tbf_detnivel();
                        END IF;

                        vpasexec := 9;
                        vpasexec := 91;
                        vindex4 := tdetnivel.COUNT + 1;
                        tdetnivel.EXTEND;
                        vpasexec := 92;
                        tdetnivel(vindex4).cempres := c_nivel.cempres;
                        tdetnivel(vindex4).cgrup := c_nivel.cgrup;
                        tdetnivel(vindex4).csubgrup := c_nivel.csubgrup;
                        tdetnivel(vindex4).cversion := c_nivel.cversion;
                        tdetnivel(vindex4).cnivel := c_nivel.cnivel;

                        IF vdefectogrup IS NOT NULL
                           AND vdefectogrup = c_nivel.cnivel THEN
                           tdetnivel(vindex4).cdefecto := 'S';
                        ELSIF vdefectogrup IS NULL THEN
                           tdetnivel(vindex4).cdefecto := c_nivel.cdefecto;
                        END IF;

                        IF (tgrupsubgrup(vindex3).ctipgrupsubgrup NOT IN(3, 4)
                            AND((vcnivel IS NOT NULL
                                 AND c_nivel.cvalor1 = 2)
                                OR tgrupsubgrup(vindex3).ctipgrupsubgrup = 2)) THEN
                           tdetnivel(vindex4).cdefecto := 'S';

                           IF vimpvalor1 IS NULL THEN
                              tdetnivel(vindex4).tnivel := c_nivel.tnivel;
                           ELSE
                              tdetnivel(vindex4).tnivel := vimpvalor1;
                           END IF;
                        ELSE
                           tdetnivel(vindex4).tnivel := c_nivel.tnivel;
                        END IF;

                        tdetnivel(vindex4).norden := c_nivel.norden;
                        tdetnivel(vindex4).cdtorec := c_nivel.cdtorec;
                        tdetnivel(vindex4).formulaselecc := c_nivel.formulaselecc;
                        tdetnivel(vindex4).tformulavalida := c_nivel.formulavalida;
                        tdetnivel(vindex4).formulasinies := c_nivel.formulasinies;
                        vpasexec := 93;
                        tdetnivel(vindex4).ctipnivel := c_nivel.ctipnivel;
                        tdetnivel(vindex4).cvalor1 := c_nivel.cvalor1;
                        tdetnivel(vindex4).impvalor1 := c_nivel.impvalor1;
                        tdetnivel(vindex4).cvalor2 := c_nivel.cvalor2;
                        tdetnivel(vindex4).impvalor2 := c_nivel.impvalor2;
                        tdetnivel(vindex4).cimpmin := c_nivel.cimpmin;
                        tdetnivel(vindex4).impmin := c_nivel.impmin;
                        tdetnivel(vindex4).cimpmax := c_nivel.cimpmax;
                        tdetnivel(vindex4).impmax := c_nivel.impmax;
                        tdetnivel(vindex4).ccontratable := c_nivel.ccontratable;
                        tdetnivel(vindex4).cinterviene := c_nivel.cinterviene;
                        tdetnivel(vindex4).id_listlibre := c_nivel.id_listlibre;

                        IF tgrupsubgrup(vindex3).ctipgrupsubgrup IN(3, 4)
                           AND c_nivel.cvalor1 = 99
                           AND c_nivel.id_listlibre IS NOT NULL THEN
                           tdetnivel(vindex4).listacvalor1 :=
                                                     f_get_bf_listalibre(c_nivel.id_listlibre);

                           IF pcvalor1 IS NOT NULL THEN
                              SELECT id_listlibre_2, id_listlibre_min, id_listlibre_max
                                INTO lvalor2, limpmin, limpmax
                                FROM bf_listlibre
                               WHERE cempres = pcempres
                                 AND id_listlibre = c_nivel.id_listlibre
                                 AND catribu = pcvalor1;

                              tdetnivel(vindex4).lvalor2 := lvalor2;
                              tdetnivel(vindex4).limpmin := limpmin;
                              tdetnivel(vindex4).limpmax := limpmax;
                           END IF;

                           IF lvalor2 IS NOT NULL THEN
                              tdetnivel(vindex4).listacvalor2 := f_get_bf_listalibre(lvalor2);
                           END IF;

                           IF limpmin IS NOT NULL THEN
                              tdetnivel(vindex4).listacimpmin := f_get_bf_listalibre(limpmin);
                           END IF;

                           IF limpmax IS NOT NULL THEN
                              tdetnivel(vindex4).listacimpmax := f_get_bf_listalibre(limpmax);
                           END IF;
                        END IF;

                        vpasexec := 95;
                     END IF;
                  END LOOP;

                  vpasexec := 10;
                  tgrupsubgrup(vindex3).lniveles := tdetnivel;
               END LOOP;

               tprodfranq(vindex).grupo.lsubgrupos := tgrupsubgrup;
               tprodfranq(vindex).lniveles := tdetnivel;
            END IF;
         END IF;
      END LOOP;

      vpasexec := 11;

      IF tprodfranq IS NOT NULL
         AND tprodfranq.COUNT > 0 THEN
         FOR vfranq IN tprodfranq.FIRST .. tprodfranq.LAST LOOP
            marcar := FALSE;

            IF tprodfranq(vfranq).garantias IS NOT NULL
               AND tprodfranq(vfranq).garantias.COUNT > 0 THEN
               marcar := FALSE;

               FOR vfranqgar IN
                  tprodfranq(vfranq).garantias.FIRST .. tprodfranq(vfranq).garantias.LAST LOOP
                  FOR cur IN (SELECT DISTINCT par.cgarant   --, par.tgarant
                                         FROM seguros seg, movseguro mov, garanseg gar,
                                              garangen par
                                        WHERE seg.sseguro = mov.sseguro
                                          AND gar.sseguro = mov.sseguro
                                          AND gar.nmovimi = mov.nmovimi
                                          AND par.cidioma = pcidioma
                                          AND par.cgarant = gar.cgarant
                                          AND seg.sseguro = psseguro) LOOP
                     vpasexec := 7;

                     IF cur.cgarant = tprodfranq(vfranq).garantias(vfranqgar).cgarant THEN
                        marcar := TRUE;
                     END IF;
                  END LOOP;
               END LOOP;

               IF marcar THEN
                  bon_cgrup := tprodfranq(vfranq).cgrup;
                  bon_csubgrup := tprodfranq(vfranq).csubgrupunic;
                  bon_cversion := tprodfranq(vfranq).grupo.cversion;
                  bon_finiefe := f_sysdate;
                  bon_ctipgrup := tprodfranq(vfranq).grupo.ctipgrup;
                  bon_tgrup := tprodfranq(vfranq).grupo.tgrup;
                  bon_ctipvisgrup := tprodfranq(vfranq).grupo.ctipvisgrup;
                  bon_ttipvisgrup := tprodfranq(vfranq).grupo.ttipvisgrup;
                  bon_ctipgrupsubgrup :=
                     tprodfranq(vfranq).grupo.lsubgrupos
                                                    (tprodfranq(vfranq).grupo.lsubgrupos.FIRST).ctipgrupsubgrup;

                  IF tprodfranq(vfranq).lniveles IS NOT NULL
                     AND tprodfranq(vfranq).lniveles.COUNT > 0 THEN
                     IF tprodfranq(vfranq).lniveles.COUNT = 1
                        AND tprodfranq(vfranq).grupo.lsubgrupos
                                                     (tprodfranq(vfranq).grupo.lsubgrupos.FIRST).ctipgrupsubgrup =
                                                                                              1 THEN
                        bon_cnivel :=
                           tprodfranq(vfranq).lniveles(tprodfranq(vfranq).lniveles.FIRST).cnivel;
                        bon_tnivel :=
                           tprodfranq(vfranq).lniveles(tprodfranq(vfranq).lniveles.FIRST).tnivel;
                        bon_cvalor1 :=
                           tprodfranq(vfranq).lniveles(tprodfranq(vfranq).lniveles.FIRST).cvalor1;
                        bon_tvalor1 :=
                           tprodfranq(vfranq).lniveles(tprodfranq(vfranq).lniveles.FIRST).tvalor1;
                        bon_impvalor1 :=
                           tprodfranq(vfranq).lniveles(tprodfranq(vfranq).lniveles.FIRST).impvalor1;
                        bon_cvalor2 :=
                           tprodfranq(vfranq).lniveles(tprodfranq(vfranq).lniveles.FIRST).cvalor2;
                        bon_tvalor2 :=
                           tprodfranq(vfranq).lniveles(tprodfranq(vfranq).lniveles.FIRST).tvalor2;
                        bon_impvalor2 :=
                           tprodfranq(vfranq).lniveles(tprodfranq(vfranq).lniveles.FIRST).impvalor2;
                        bon_cimpmin :=
                           tprodfranq(vfranq).lniveles(tprodfranq(vfranq).lniveles.FIRST).cimpmin;
                        bon_timpmin :=
                           tprodfranq(vfranq).lniveles(tprodfranq(vfranq).lniveles.FIRST).timpmin;
                        bon_impmin :=
                           tprodfranq(vfranq).lniveles(tprodfranq(vfranq).lniveles.FIRST).impmin;
                        bon_cimpmax :=
                           tprodfranq(vfranq).lniveles(tprodfranq(vfranq).lniveles.FIRST).cimpmax;
                        bon_timpmax :=
                           tprodfranq(vfranq).lniveles(tprodfranq(vfranq).lniveles.FIRST).timpmax;
                        bon_impmax :=
                           tprodfranq(vfranq).lniveles(tprodfranq(vfranq).lniveles.FIRST).impmax;
                        bon_cniveldefecto := tprodfranq(vfranq).formuladefecto;
                     END IF;

                     FOR vlstniveles IN
                        tprodfranq(vfranq).lniveles.FIRST .. tprodfranq(vfranq).lniveles.LAST LOOP
                        IF tprodfranq(vfranq).lniveles(vlstniveles).cdefecto = 'S'
                           AND tprodfranq(vfranq).grupo.lsubgrupos
                                                     (tprodfranq(vfranq).grupo.lsubgrupos.FIRST).ctipgrupsubgrup =
                                                                                              1 THEN
                           bon_cnivel := tprodfranq(vfranq).lniveles(vlstniveles).cnivel;
                           bon_tnivel := tprodfranq(vfranq).lniveles(vlstniveles).tnivel;
                           bon_cvalor1 := tprodfranq(vfranq).lniveles(vlstniveles).cvalor1;
                           bon_tvalor1 := tprodfranq(vfranq).lniveles(vlstniveles).tvalor1;
                           bon_impvalor1 := tprodfranq(vfranq).lniveles(vlstniveles).impvalor1;
                           bon_cvalor2 := tprodfranq(vfranq).lniveles(vlstniveles).cvalor2;
                           bon_tvalor2 := tprodfranq(vfranq).lniveles(vlstniveles).tvalor2;
                           bon_impvalor2 := tprodfranq(vfranq).lniveles(vlstniveles).impvalor2;
                           bon_cimpmin := tprodfranq(vfranq).lniveles(vlstniveles).cimpmin;
                           bon_timpmin := tprodfranq(vfranq).lniveles(vlstniveles).timpmin;
                           bon_impmin := tprodfranq(vfranq).lniveles(vlstniveles).impmin;
                           bon_cimpmax := tprodfranq(vfranq).lniveles(vlstniveles).cimpmax;
                           bon_timpmax := tprodfranq(vfranq).lniveles(vlstniveles).timpmax;
                           bon_impmax := tprodfranq(vfranq).lniveles(vlstniveles).impmax;
                           bon_cniveldefecto := tprodfranq(vfranq).formuladefecto;
                        END IF;

                        IF tprodfranq(vfranq).lniveles(vlstniveles).listacvalor1 IS NOT NULL
                           AND tprodfranq(vfranq).lniveles(vlstniveles).listacvalor1.COUNT = 1 THEN
                           bon_cvalor1 :=
                              tprodfranq(vfranq).lniveles(vlstniveles).listacvalor1
                                  (tprodfranq(vfranq).lniveles(vlstniveles).listacvalor1.FIRST).catribu;
                        END IF;

                        IF tprodfranq(vfranq).lniveles(vlstniveles).listacvalor2 IS NOT NULL
                           AND tprodfranq(vfranq).lniveles(vlstniveles).listacvalor2.COUNT = 1 THEN
                           bon_cvalor2 :=
                              tprodfranq(vfranq).lniveles(vlstniveles).listacvalor2
                                  (tprodfranq(vfranq).lniveles(vlstniveles).listacvalor2.FIRST).catribu;
                        END IF;

                        IF tprodfranq(vfranq).lniveles(vlstniveles).listacimpmin IS NOT NULL
                           AND tprodfranq(vfranq).lniveles(vlstniveles).listacimpmin.COUNT = 1 THEN
                           bon_cimpmin :=
                              tprodfranq(vfranq).lniveles(vlstniveles).listacimpmin
                                  (tprodfranq(vfranq).lniveles(vlstniveles).listacimpmin.FIRST).catribu;
                        END IF;

                        IF tprodfranq(vfranq).lniveles(vlstniveles).listacimpmax IS NOT NULL
                           AND tprodfranq(vfranq).lniveles(vlstniveles).listacimpmax.COUNT = 1 THEN
                           bon_cimpmax :=
                              tprodfranq(vfranq).lniveles(vlstniveles).listacimpmax
                                  (tprodfranq(vfranq).lniveles(vlstniveles).listacimpmax.FIRST).catribu;
                        END IF;
                     END LOOP;
                  END IF;

                  INSERT INTO bf_bonfransegcar
                              (sproces, sseguro, nriesgo, cgrup, csubgrup,
                               cnivel, cversion, nmovimi, finiefe,
                               ctipgrup, cvalor1, impvalor1, cvalor2,
                               impvalor2, cimpmin, impmin, cimpmax,
                               impmax, ffinefe, cniveldefecto)
                       VALUES (psproces, psseguro, pnriesgo, bon_cgrup, bon_csubgrup,
                               bon_cnivel, bon_cversion, pnmovimi + 1, bon_finiefe,
                               bon_ctipgrup, bon_cvalor1, bon_impvalor1, bon_cvalor2,
                               bon_impvalor2, bon_cimpmin, bon_impmin, bon_cimpmax,
                               bon_impmax, bon_ffinefe, bon_cniveldefecto);
               END IF;

               marcar := FALSE;
            END IF;
         END LOOP;
      END IF;

      RETURN 0;
   --
   EXCEPTION
      WHEN e_param_error THEN
         p_tab_error(f_sysdate, f_user, 'pac_dincartera.f_actualizar_franq', 1,
                     'Error  e_param_error vparam:' || vparam,
                     'psqcode =>' || SQLCODE || ' psqerrm =>' || SQLERRM);
         RETURN NULL;
      WHEN e_object_error THEN
         p_tab_error(f_sysdate, f_user, 'pac_dincartera.f_actualizar_franq', 1,
                     'Error  e_object_error vparam:' || vparam,
                     'psqcode =>' || SQLCODE || ' psqerrm =>' || SQLERRM);
         RETURN NULL;
      WHEN OTHERS THEN
         -- BUG -21546_108724- 02/02/2012 - JLTS- Cierre de cursores
         IF cur%ISOPEN THEN
            CLOSE cur;
         END IF;

         p_tab_error(f_sysdate, f_user, 'pac_dincartera.f_actualizar_franq', 1,
                     'Error no controlado vparam:' || vparam,
                     'psqcode =>' || SQLCODE || ' psqerrm =>' || SQLERRM);
         RETURN NULL;
   END f_actualizar_franq;

      /****************************************************************************
      f_set_bonus_malus

      Bug 26638/161275 - 15/04/2014 - AMC
   *****************************************************************************/
   FUNCTION f_set_bonus_malus(
      psproces IN NUMBER,
      psseguro IN NUMBER,
      pnriesgo IN NUMBER,
      pnmovimi IN NUMBER,
      psproduc IN NUMBER,
      pfrenova IN DATE,
      pcempres IN NUMBER)
      RETURN NUMBER IS
      vimpvalor1     NUMBER;
      vcgrup         NUMBER;
      vcsubgrup      NUMBER;
      vcsubgrup0     NUMBER;
      --  vcversion      NUMBER;
      vcnivel        NUMBER;
      --    vcnivel0       NUMBER;
      num_err        NUMBER;
      vnsiniestros   NUMBER;
      vcnivelnew     NUMBER;
      vntraza        NUMBER;
      vsubtabla      NUMBER;
      vparam         VARCHAR2(3000)
         := ' psproces:' || psproces || ' psseguro:' || psseguro || ' pnriesgo:' || pnriesgo
            || ' pnmovimi:' || pnmovimi || ' psproduc:' || psproduc || ' pfrenova:'
            || pfrenova || ' pcempres:' || pcempres;
--            || 'vimpvalor1 ' || vimpvalor1 || ' vcgrup ' || vcgrup || ' vcnivel:' || vcnivel
--            || ' vcnivelnew ' || vcnivelnew || ' vcsubgrup ' || vcsubgrup || ' vnsiniestros '
--            || vnsiniestros || ' vsubtabla ' || vsubtabla || ' vcsubgrup0 ' || vcsubgrup0;
   BEGIN
      vntraza := 1;

      -- Sumamos los valores de los bonus malus y ajubonus ..
      -- Descuento t¿cnico y comercial
      SELECT SUM(impvalor1)
        INTO vimpvalor1
        FROM bf_bonfransegcar
       WHERE sproces = psproces
         AND sseguro = psseguro
         AND ctipgrup = 1
         AND nriesgo = NVL(pnriesgo, 1)
         AND nmovimi = pnmovimi;   -- Bug 26638/189219 - 14/10/2014 - AMC

      vparam := vparam || ' Sum importes. vimpvalor1 ' || vimpvalor1;
      vntraza := 2;

      IF vimpvalor1 > 50 THEN
         vimpvalor1 := 50;
      ELSIF vimpvalor1 < -50 THEN
         vimpvalor1 := -50;
      END IF;

      vparam := vparam || ' vimpvalor1 ' || vimpvalor1;
      vntraza := 3;
      -- Grupo 51, exper, descuento t¿cnico
      num_err := f_parproductos(psproduc, 'GRUPBONUSMALUS', vcgrup);
      vntraza := 4;
      vparam := vparam || ' - vcgrup ' || vcgrup;

      -- Buscamos el nivel que coresponde a la suma de los bonus malus
      SELECT cnivel
        INTO vcnivel
        FROM bf_detnivel
       WHERE cempres = pcempres
         AND cgrup = vcgrup
         AND impvalor1 = vimpvalor1
         AND cversion IN(SELECT MAX(cversion)
                           FROM bf_grupsubgrup
                          WHERE cempres = pcempres
                            AND cgrup = vcgrup);

      vparam := vparam || ' - vcnivel ' || vcnivel;
      vntraza := 5;
      -- Buscamos el numero de siniesros durante la anulalidad
      vnsiniestros := pac_planbenef.f_autos_siniestros('CAR', psseguro, pnriesgo, pfrenova,
                                                       pnmovimi, NULL, NULL, NULL, NULL, 4926);
      vparam := vparam || ' - vnsiniestros ' || vnsiniestros;
      vntraza := 6;
      -- Buscamos apartir de nuevo nivel y el n¿ de siniestros el nivel que la corresponde en la renovaci¿n
      num_err := f_parproductos(psproduc, 'SUBTABLABONUSMALUS', vsubtabla);
      vcnivelnew := pac_subtablas.f_vsubtabla(-1, vsubtabla, 334, 1, psproduc, vcnivel,
                                              vnsiniestros, NULL, NULL, NULL, NULL, NULL, NULL,
                                              NULL, pfrenova);
      vntraza := 7;
      vparam := vparam || ' - vcnivelnew ' || vcnivelnew;

      -- Buscamos el valor del nuevo nivel
      SELECT impvalor1, csubgrup
        INTO vimpvalor1, vcsubgrup
        FROM bf_detnivel
       WHERE cempres = pcempres
         AND cgrup = vcgrup
         AND cnivel = vcnivelnew
         AND cversion IN(SELECT MAX(cversion)
                           FROM bf_grupsubgrup
                          WHERE cempres = pcempres
                            AND cgrup = vcgrup);

      vparam := vparam || ' - vimpvalor1 ' || vimpvalor1 || ' - vcsubgrup ' || vcsubgrup;
      vntraza := 8;

      -- Actualizamos el bonus malus principal con los nuevos valores y el resto con el nivel del valor 0.
      UPDATE bf_bonfransegcar
         SET cnivel = vcnivelnew,
             impvalor1 = vimpvalor1,
             csubgrup = vcsubgrup
       WHERE sproces = psproces
         AND sseguro = psseguro
         AND ctipgrup = 1
         AND nriesgo = NVL(pnriesgo, nriesgo)
         AND nmovimi = pnmovimi
         AND cgrup = vcgrup;

      vntraza := 9;
      -- QT 0017266: PREPRODUCCION El descuento comercial lo est¿ quitando en la renovaci¿n no lo mantiene.
      vntraza := 10;

      -- Modificamos el descuento comercial a Cero , ya lo hemos tenido en cuenta en el descuento t¿cnico.-
      UPDATE bf_bonfransegcar c
         SET (cnivel, csubgrup) =
                (SELECT cnivel, csubgrup
                   FROM bf_detnivel
                  WHERE cempres = pcempres
                    AND cgrup = c.cgrup
                    AND impvalor1 = 0
                    AND cversion IN(SELECT MAX(cversion)
                                      FROM bf_grupsubgrup
                                     WHERE cempres = pcempres
                                       AND cgrup = c.cgrup)),
             impvalor1 = 0
       WHERE c.sproces = psproces
         AND c.sseguro = psseguro
         AND c.ctipgrup = 1
         AND c.nriesgo = NVL(pnriesgo, nriesgo)
         AND c.nmovimi = pnmovimi
         AND c.cgrup <> vcgrup;

      p_tab_error(f_sysdate, f_user, 'pac_dincartera.f_set_bonus_malus', vntraza, ' - ',
                  'vparam:' || vparam);
      vntraza := 11;
      RETURN 0;
   EXCEPTION
      WHEN OTHERS THEN
         p_tab_error(f_sysdate, f_user, 'pac_dincartera.f_set_bonus_malus', vntraza,
                     'Error no controlado vparam:' || vparam, SQLERRM);
         RETURN 1;
   END f_set_bonus_malus;
END pac_dincartera;

/

  GRANT EXECUTE ON "AXIS"."PAC_DINCARTERA" TO "R_AXIS";
  GRANT EXECUTE ON "AXIS"."PAC_DINCARTERA" TO "CONF_DWH";
  GRANT EXECUTE ON "AXIS"."PAC_DINCARTERA" TO "PROGRAMADORESCSI";
