CREATE OR REPLACE PACKAGE BODY PAC_ADM
AS
   /******************************************************************************
       NOMBRE:      PAC_ADM
       PROPÓSITO:   Funciones para la gestión de impagados

       REVISIONES:
       Ver        Fecha        Autor             Descripción
       ---------  ----------  ---------------  ------------------------------------
       1.0        27/02/2009   MCC              1. Creación del package.Bug 9204
       2.0        19/05/2009   APD              2. 0010127: IAX- Consultas de pólizas, simulaciones, reembolsos y póliza reteneidas
       2.1        21/05/2009   APD              6.1 BUG10178: IAX - Vista AGENTES_AGENTE por empresa
       3.0        09/07/2009   ETM              3.BUG 0010676: CEM - Días de gestión de un recibo
       4.0        02/09/2009   DCT              4.BUG 0011031: CEM - Eliminacion parametro mensajes en PAC_ADM y PAC_MD_ADM
       5.0        22/09/2009   NMM              5. 10676: CEM - Días de gestión de un recibo ( canviar paràmetre)
       6.0        22/09/2009   XVM              6. BUG9028: Recibos temporales para tarificación
       7.0        14/10/2009   LCF              7. BUG9422: Limpiar estructura de impuestos antigua
       8.0        01/02/2010   JMF              8. 0011733 APR - suplemento de cambio forma de pago
       9.0        18/02/2010   JMF              9. 0012679 CEM - Treure la taula MOVRECIBOI
      10.0        22/02/2010   JMC             10. BUG 13038 se añade función f_get_last_rec
      11.0        01/04/2010   FAL             11. 0012589: CEM - Recibos con copago y consorcio
      12.0        21/04/2010   DRA             12. 0014202: CRE - Parámetro nuevo para el pac_adm
      13.0        19/05/2010   DRA             13. 0014061: CEM - Fichero DWH
      14.0        03/06/2010   JTS             14. 14438: CEM - Unificación de recibos
      15.0        30/06/2010   JGR             15. 15211: CRE800 - Modificación de recibos
      16.0        10/08/2010   RSC             16. 14775: AGA003 - Error en dades rebut plantilla Condicionat Particular AGA012
      17.0        11/10/2010   ICV             17. 0016140: AGA003 - filtro de estado de impresion en recibos
      18.0        04/11/2010   ICV             18. 0016325: CRT101 - Modificación de recibos para correduría
      19.0        21/05/2010   ICV             19. 14586: CRT - Añadir campo recibo compañia
      20.0        17/11/2010   ICV             20. 0016383: AGA003 - recargo por devolución de recibo (renegociación de recibos)
      21.0        25/11/2010   APD             21. 16768: APR - Implementación y parametrización del producto GROUPLIFE (II)
      22.0        23/03/2011   DRA             22. 0018054: AGM003 - Administración - Secuencia de nrecibo.
      23.0        18/04/2011   JMF             23. 0018135 CCAT701 - Paquetes propios y Consorcio de CTV en iAXIS
      24.0        31/05/2011   ETM             24.0018631: ENSA102- Alta del certificado 0 en Contribución definida
      25.0        21/05/2010   ICV             25. 0018838: CRT901 - Pantalla para modificar estado de un recibo
      26.0        18/07/2011   SRA             26. 0018908: LCOL003 - Modificación de las pantallas de gestión de recibos
      27.0        11/11/2011   APD             27.0018946: LCOL_P001 - PER - Visibilidad en personas
      28.0        15/11/2011   JMF             28. 0020010: LCOL_A001-Registrar los nuevos medios de pago
      29.0        14/11/2011   FAL             29. 0019627: GIP102 - Reunificación de recibos - FAL - 10/11/2011
      30.0        21/11/2011   JMP             30. 0018423: LCOL000 - Multimoneda
      31.0        22/11/2011   RSC             31. 0020241: LCOL_T004-Parametrización de Rescates (retiros)
      32.0        28/11/2011   JMP             32. 0018423: LCOL000 - Multimoneda
      33.0        22/12/2011   JGR             33. 0020038: Anulación de recibos según el convenio - Nota: 0101405
      34.0        03/01/2012   JMF             34. 0020761 LCOL_A001- Quotes targetes
      35.0        07/02/2012   JMF             35. 0021028 LCOL - Duplicar rebuts en rehabilitacions de polisses
      36.0        13/02/2012   APD             36. 0021223: LCOL: Consulta de recibos
      37.0        20/02/2012   APD             37. 0021421: LCOL_C001: Incidencia en el traspaso de cartera
      38.0        27/03/2012   JGR             38. 0020546: LCOL_A001 - UAT-ADM - Errors cobrant/descobrant rebuts - 104206
      39.0        20/04/2012   JGR             39. 0022047: LCOL_A001-Activar la pantalla de impagados para recibos cobrados - 0113135
      40.0        13/06/2012   JGR             40. 0022512: LCOL_A001-Modificacion medio de pago de Debito a Efectivo - No se modifica el subestado
      41.0        29/05/2012   JGR             41. 0022327: MDP_A001-Consulta de recibos - 0115278
      42.0        30/05/2012   DCG             42. 0022327: MDP_A001-Consulta de recibos - 0115681
      43.0        01/06/2012   JGR             43. 0022082: LCOL_A003-Mantenimiento de matriculas
      44.0        07/08/2012   APD             44. 0022342: MDP_A001-Devoluciones
      45.0        28/08/2012   DCG             45. 0022327: MDP_A001-Consulta de recibos - 0121869
      46.0        12/09/2012   JGR             46. 0022763: MDP_A001-Unificacion / Desunificacion de recibos
      47.0        20/11/2012   ECP             47. 0024672: LCOL_A003-Domiciliaciones - QT 0005339: Consultas en los aplciativosy validaciones pendientes
      48.0        12/12/2012   JGR             48. 0024754: (POSDE100)-Desarrollo-GAPS Administracion-Id 156 - Las consultas de facturas se puedan hacer por sucursal y regional
      49.0        11/01/2013   RDD             49. 0025639: RSA003-Consulta de recibos por agente
      50.0        03/04/2013   DCG             50. 0026069: LCOL_F003-Fase 3 - Contabilidad de Autos
      51.0        03/04/2013   JGR             51. 0025151: LCOL999-Redefinir el circuito de prenotificaciones - 0142020
      52.0        22/04/2013   AVT             52. 0026755: LCOL_A004-Qtracker: 7266 (iAxis F3A UAT_PILOTO): ERROR EN EMISI?N CON COASEGURO CEDIDO
      53.0        29/05/2013   JGR             53. 0027049: LCOL_A003-Datos parecen duplicados en la consulta de matr?culas - QT: 0007408
      54.0        04/07/2013   MMM             54. 0027579: LCOL_A003-Error en campo de cuenta bancaria pantalla consulta de matriculas vs. mantenimiento de personas - QT-8301
      55.0        05/09/2013   dlF             55. 0028081: Error General al consultar RECIBOS
      56.0        18/10/2013   JGR             56. 0028565: QT-9609 - LCOL_MILL-QT-9609: Error en subestado de recibo al consultar matrícula.
      57.0        30/10/2013   AGG             57. 0028706: CRT904-Errores en recibos
      58.0        22/11/2013   AFM             58. 0029068: La Rehabilitación de póliza no está rehabilitando los recibos. En f_clonrecibo, cambiar orden 1.-insert movrecibo 2.-Multimoneda
      59.0        06/11/2013   CEC             59. 0026295: RSA702-Desarrollar el modulo de Caja
      60.0        25/11/2013   MMM             60. 0028986: LCOL_A004-Qtracker: 10043, 10046, 10051
      61.0        27/11/2013   AFM             61. 0029068: La Rehabilitación de póliza no está rehabilitando los recibos
      62.0        28/11/2013   SHA             62. 0028615: LCOL_A001- Consulta de recibos
      63.0        02/12/2013   MMM             63. 0028565: QT-9609 - LCOL_MILL-QT-9609 Error en subestado de recibo al consultar matrícula
      64.0        13/12/2010   JMF             0029068: La Rehabilitación de póliza no está rehabilitando los recibos
      65.0        20/03/2014   DRA             65. 0027421: POSAN600-(POSDE600)-Desarrollo-GAPS Tecnico-Id 96 - Recibos remesados en anulaciones
      66.0        10/07/2014   JGR             66. 0032092: LCOL_PROD-0013339: Los recibos segun adjunto no se encuentran asociados a ninguna sucursal - 179550
      67.0        06/03/2015   KJSC            67. BUG 35103-200056.KJSC. Se debe sustituir w_empresa por el número de recibo (pnrecibo).
      68.0        04/06/2015   MDS             68. 0035803: UNIFICACION DE RECIBOS:: POLIZA 2011400028 (bug hermano interno)
      69.0        19/06/2015   VCG             69. AMA-209-Redondeo SRI
      70.0        01/04/2019   JLTS            70. IAXIS-3407. Se actualiza incluyendo que solo sea para 0 o 3
      71.0        10/05/2019   JLTS            71. IAXIS-3887. Se ajustan algunos filteos de la funciÃ³n f_get_consultarecibos_mv
      72.0        24/05/2019   ECP             72. IAXIS-3592. Proceso de terminación por no pago
      73.0        21/06/2019   SGM             73. IAXIS-4134 Reporte de acuerdo de pago
      74.0        09/07/2019   DFR             74. IAXIS 3651 Proceso calculo de comisiones de outsourcing
      75.0        17/07/2019   DFR             75. IAXIS-3591 Visualizar los importes del recibo de manera ordenada y sin repetir conceptos.
      76.0        20/07/2019   JLTS            76. IAXIS-4515 Ajustes de las funciones f_get_vdetrecibos y f_get_vdetrecibos_monpol
      77.0        01/08/2019   Shakti          77. IAXIS-4944 TAREAS CAMPOS LISTENER
      78.0        08/08/2019   JLTS            78. IAXIS-4995 Se realiza ajuste a las consultas de la funciones f_get_vdetrecibos y f_get_vdetrecibos_monpol
      79.0        12/09/2019   ECP             79. IAXIS-5149.Verificación por qué no se esta ejecutando el proceso de cancelación por no pago.
      80.0        23/10/2019   DFR             80. IAXIS-4926: Anulación de póliza y movimientos con recibos abonados y Reversión de recaudos en recibos.
      81.0        28/10/2019   SGM             81. IAXIS-6149: Realizar consulta de personas publicas
      82.0        18/11/2019   DFR             82. IAXIS-7627: Verificación de campo CSUBTIPREC de la tabla RECIBOS para efectos contables.    
      83.0        09/12/2019   ECP             79. IAXIS-5149.Verificación por qué no se esta ejecutando el proceso de cancelación por no pago.    
      84.0        19/01/2020   JLTS            84. IAXIS-3264. Ajuste en la consulta de la función f_get_detrecibo_gtias incluyendo el campo cmotmov_baja
                                                   según funcion pac_adm.f_cmotmov_baja, adicion de la función f_cmotmov_baja para enviar a la pantalla
                                                   si el recibo fue creado por un movimeinto de baja de amparo.
      85.0        24/02/2020  JRVG             85. IAXIS-5347 - Bug IAXIS-11902 Se crea la funcion f_por_comisi para obtener el porcentaje de comision por poliza.
      86.0        11/03/2020  JRVG             86. IAXIS BUG-6149 C¿lculo errado de tarifa para p¿lizas con madurez 0-49
      87.0        05/05/2020  JRVG             87. IAXIS 4136 - Creacion de f_get_import_vdetrecibos_mon y f_get_import_vdetrecibos
   ******************************************************************************/
   e_object_error   EXCEPTION;
   e_param_error    EXCEPTION;

   /*************************************************************************
          Funcion para obtener los datos de gestión de impagados
          param in pcempres   : código de la empresa
          param in pcmaqfisi  : Máquina física
          param in pcterminal : Terminal Axis
          return           : 0 indica cambio realizado correctamente
                             <> 0 indica error
   *************************************************************************/
   FUNCTION f_get_impagados (
      psseguro   IN   NUMBER,
      pnrecibo   IN   NUMBER,
      psmovrec   IN   NUMBER,
      pcidioma   IN   NUMBER
   )                                               -- BUG14202:DRA:22/04/2010
      RETURN VARCHAR2
   IS
      --v_ctractat     tmp_impagados.ctractat%TYPE;
      --v_ffejecu      DATE;
      --v_cactimp      tmp_impagados.cactimp%TYPE;
      --v_ccarta       modelos.tmodelo%TYPE;
      --v_fimpres      DATE;
      v_select   VARCHAR2 (4000);
      vobject    VARCHAR2 (500)  := 'PAC_ADM.f_get_impagados';
      vparam     VARCHAR2 (500)
         :=    'parámetros - psseguro: '
            || psseguro
            || ', pnrecibo: '
            || pnrecibo
            || ', psmovrec: '
            || psmovrec
            || ', pcidioma: '
            || pcidioma;
      vpasexec   NUMBER (5)      := 1;
   --v_cot          VARCHAR2(200);
   BEGIN
      IF pnrecibo IS NOT NULL
      THEN
         IF psmovrec IS NOT NULL
         THEN
            vpasexec := 2;
            v_select :=
                  ' SELECT i.nrecibo,ff_desvalorfijo(92, '
               || pcidioma
               || ' ,i.ctractat) as ctractat, i.FFEJECU, ff_desvalorfijo(204,'
               || pcidioma
               || ' ,i.CACTIMP) as cactimp,'
               || ' c.FIMPRES, ff_obten_modelo(i.ccarta) as ccarta'
               || ' FROM tmp_impagados i, gescartas c '
               || ' WHERE i.nrecibo = c.nrecibo (+) AND i.ccarta = c.ctipcar (+) '
               || ' AND i.nrecibo = '
               || pnrecibo
               || ' AND  c.smovrec = '
               || psmovrec
               || ' order by FFEJECU, FIMPRES';
         ELSE
            vpasexec := 3;
            v_select :=
                  ' SELECT i.nrecibo,ff_desvalorfijo(92, '
               || pcidioma
               || ' ,i.ctractat) as ctractat, i.FFEJECU, ff_desvalorfijo(204,'
               || pcidioma
               || ' ,i.CACTIMP) as cactimp,'
               || ' c.FIMPRES, ff_obten_modelo(i.ccarta) as ccarta'
               || ' FROM tmp_impagados i, gescartas c '
               || ' WHERE i.nrecibo = c.nrecibo (+) AND i.ccarta = c.ctipcar (+) '
               || ' AND i.nrecibo = '
               || pnrecibo
               || ' order by FFEJECU, FIMPRES';
         END IF;
      ELSE
         vpasexec := 4;
         v_select :=
               ' SELECT i.nrecibo,ff_desvalorfijo(92, '
            || pcidioma
            || ' ,i.ctractat) as ctractat, i.FFEJECU, ff_desvalorfijo(204,'
            || pcidioma
            || ' ,i.CACTIMP) as cactimp,'
            || ' c.FIMPRES, ff_obten_modelo(i.ccarta) as ccarta'
            || ' FROM tmp_impagados i, gescartas c '
            || ' WHERE i.sseguro = '
            || psseguro
            || ' AND   c.sseguro = '
            || psseguro
            || ' order by FFEJECU, FIMPRES';
      END IF;

      RETURN v_select;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      vobject,
                      vpasexec,
                      vparam,
                      SQLCODE || ' - ' || SQLERRM
                     );
         RETURN 1000455;
   END f_get_impagados;

   /*************************************************************************
     Selecciona información sobre recibos dependiendo de los parámetros de entrada
      param in pnrecibo   :   numero de recibo.
      param in pcempres   :   empresa.
      param in psproduc   :   producto
      param in pnpoliza   :   póliza
      param in pncertif   :   certificado.
      param in pciprec    :   tipo de recibo.
      param in pcestrec   :   estado del recibo.
      param in pfemisioini:   fecha de emisión. (inicio del rango)
      param in pfemisiofin:   fecha de emisión.  ( fin del rango)
      param in pfefeini   :   fecha inicio efecto.  (inicio del rango)
      param in pfefefin   :   fecha fin efecto.  (inicio del rango)
      param in ptipo      :   nos indicará si es tomador o asegurado ( tomador :=1, asegurado =2)
              (check que nos permitirá indicar si buscamos por los datos del tomador o por los datos del asegurado)
      param in psperson   :   código identificador de la persona
      param in pcreccia   :   recibo compañia.
   *************************************************************************/
   FUNCTION f_get_consultarecibos (
      pnrecibo      IN   NUMBER,
      pcempres      IN   NUMBER,
      psproduc      IN   NUMBER,
      pnpoliza      IN   NUMBER,
      pncertif      IN   NUMBER,
      pctiprec      IN   NUMBER,
      pcestrec      IN   NUMBER,
      pfemisioini   IN   DATE,
      pfemisiofin   IN   DATE,
      pfefeini      IN   DATE,
      pfefefin      IN   DATE,
      ptipo         IN   NUMBER,
      psperson      IN   NUMBER,
      pcreccia      IN   VARCHAR2,
      --Bug 14586-PFA-21/05/2010- Añadir campo recibo compañia
      pcpolcia      IN   VARCHAR2,
      pcidioma      IN   NUMBER,                    -- BUG14202:DRA:22/04/2010
      -- Ini bug 18908 - 18/07/2011 - SRA
      pcramo        IN   NUMBER,
      pcsucursal    IN   NUMBER,
      pcagente      IN   NUMBER,
      pcxtempres    IN   NUMBER,
      pctipcob      IN   NUMBER,
      pcondicion    IN   VARCHAR2 DEFAULT NULL
   )
      -- Fin bug 18908 - 18/07/2011 - SRA
   RETURN VARCHAR2                                             --SYS_REFCURSOR
   IS
      vobject     VARCHAR2 (500)  := 'PAC_ADM.F_Get_ConsultaRecibos';
      vparam      VARCHAR2 (550)
         :=    'parámetros - pnrecibo: '
            || pnrecibo
            || ', pcempres: '
            || pcempres
            || ', psproduc: '
            || psproduc
            || ', pnpoliza: '
            || pnpoliza
            || ', pncertif: '
            || pncertif
            || ', pctiprec: '
            || pctiprec
            || ', pcestrec: '
            || pcestrec
            || ', pfemisioini: '
            || pfemisioini
            || ', pfemisiofin: '
            || pfemisiofin
            || ', pfefeini: '
            || pfefeini
            || ', pfefefin: '
            || pfefefin
            || ', ptipo'
            || ptipo
            || ', psperson: '
            || psperson
            || ', pcreccia: '
            || pcreccia
            || ', pcidioma: '
            || pcidioma
            ||                                      --Bug 14586-PFA-21/05/2010

               -- Ini bug 18908 - 18/07/2011 - SRA
               'pcramo: '
            || pcramo
            || 'pcsucursal: '
            || pcsucursal
            || 'pcagente: '
            || pcagente
            || 'pctipcob: '
            || pctipcob;
      -- Fin bug 18908 - 18/07/2011 - SRA
      vpasexec    NUMBER (5)      := 1;
      --vnumerr        NUMBER(8) := 0;
      vsquery     VARCHAR2 (9000);
      v_max_reg   NUMBER;                -- número màxim de registres mostrats
      vtabla      VARCHAR2 (200);
      --Bug 38316-216899 KJSC Traer estado del recibo 29/10/2015
      vestado     VARCHAR2 (200);
        -- IAXIS-3592 -- ECP -- 24/05/2019
      v_sum_importe NUMBER;
      v_sum_impuesto NUMBER;
      v_sum_gastos NUMBER;
      v_sum_impcom NUMBER;
      
      -- IAXIS-5149 --ECP -- 12/09/2019
      v_sum_comis NUMBER;
      --IAXIS-5149  -- ECP -- 12/09/2019


          -- IAXIS-3592 -- ECP -- 24/05/2019
   BEGIN
      vpasexec := 1;
        -- IAXIS-3592 -- ECP -- 24/05/2019
      BEGIN
         SELECT NVL (SUM (b.iconcep_monpol), SUM (b.iconcep))
           INTO v_sum_importe
           FROM detmovrecibo a, detmovrecibo_parcial b
          WHERE a.nrecibo = pnrecibo
            AND a.nrecibo = b.nrecibo
            AND a.smovrec = (SELECT MAX (b.smovrec)
                               FROM detmovrecibo b
                              WHERE b.nrecibo = a.nrecibo)
            AND a.norden = b.norden
            AND b.cconcep IN (0,50); -- IAXIS-4995 - JLTS - 08/08/2019
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            v_sum_importe := 0;
      END;

      v_sum_importe := NVL (v_sum_importe, 0);

      BEGIN
         SELECT NVL (SUM (b.iconcep_monpol), SUM (b.iconcep))
           INTO v_sum_gastos
           FROM detmovrecibo a, detmovrecibo_parcial b
          WHERE a.nrecibo = pnrecibo
            AND a.nrecibo = b.nrecibo
            AND a.smovrec = (SELECT MAX (b.smovrec)
                               FROM detmovrecibo b
                              WHERE b.nrecibo = a.nrecibo)
            AND a.norden = b.norden
            AND b.cconcep IN (14);
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            v_sum_gastos := 0;
      END;

      v_sum_gastos := NVL (v_sum_gastos, 0);

      BEGIN
         SELECT NVL (SUM (b.iconcep_monpol), SUM (b.iconcep))
           INTO v_sum_impuesto
           FROM detmovrecibo a, detmovrecibo_parcial b
          WHERE a.nrecibo = pnrecibo
            AND a.nrecibo = b.nrecibo
            AND a.smovrec = (SELECT MAX (b.smovrec)
                               FROM detmovrecibo b
                              WHERE b.nrecibo = a.nrecibo)
            AND a.norden = b.norden
            AND b.cconcep IN (4, 86);
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            v_sum_impuesto := 0;
      END;

      v_sum_impuesto := NVL (v_sum_impuesto, 0);

      BEGIN
         SELECT NVL (SUM (b.iconcep_monpol), SUM (b.iconcep))
           INTO v_sum_impcom
           FROM detmovrecibo a, detmovrecibo_parcial b
          WHERE a.nrecibo = pnrecibo
            AND a.nrecibo = b.nrecibo
            AND a.smovrec = (SELECT MAX (b.smovrec)
                               FROM detmovrecibo b
                              WHERE b.nrecibo = a.nrecibo)
            AND a.norden = b.norden
            AND b.cconcep IN (32,82); -- IAXIS-4995 - JLTS - 08/08/2019
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            v_sum_impcom := 0;
      END;

      v_sum_impcom := NVL (v_sum_impcom, 0);
      
      --IAXIS-5149  -- ECP -- 12/09/2019
      BEGIN
         SELECT NVL (SUM (b.iconcep_monpol), SUM (b.iconcep))
           INTO v_sum_comis
           FROM detmovrecibo a, detmovrecibo_parcial b
          WHERE a.nrecibo = pnrecibo
            AND a.nrecibo = b.nrecibo
            AND a.smovrec = (SELECT MAX (b.smovrec)
                               FROM detmovrecibo b
                              WHERE b.nrecibo = a.nrecibo)
            AND a.norden = b.norden
            AND b.cconcep IN (11); -- IAXIS-4995 - JLTS - 08/08/2019
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            v_sum_comis := 0;
      END;

      v_sum_comis := NVL (v_sum_comis, 0);
      --IAXIS-5149  -- ECP -- 12/09/2019

      --Mirem si agafem la moneda del producte  o la moneda de cobrament. XPL#03012011#20592
      IF NVL (pac_parametros.f_parempresa_n (pcxtempres, 'MONEDA_POL'), 0) = 1
      THEN
         vtabla := 'vdetrecibos_monpol';
      ELSE
         vtabla := 'vdetrecibos';
      END IF;

      --INI Bug 38316-216899 KJSC Traer estado del recibo 29/10/2015
      IF NVL (pac_parametros.f_parempresa_n (pcxtempres, 'ESTADO_PRB'), 0) = 1
      THEN
         vestado := 'f_cestrec_mv(r.nrecibo, null)';
      ELSE
         vestado := 'f_cestrec(r.nrecibo, null)';
      END IF;

      --FIN Bug 38316-216899 KJSC Traer estado del recibo 29/10/2015

      -- DRA 4-12-2008: bug mantis 8359
      -- Bug 10127 - APD - 19/05/2009 - se elimina la vista seguros_agente
      --                                se añade la subselect con la tabla agentes_agente
      --Bug 14586-PFA-21/05/2010 - se añade campo creccia
      -- Bug 18946 - APD - 28/10/2011 - se sustituye la vista agentes_agente por agentes_agente_pol
      -- IAXIS-3592 -- ECP -- 11/06/2019
      IF vtabla = 'vdetrecibos_monpol'
      THEN
        -- INI -IAXIS-4995 - JLTS - 08/08/2019
         vsquery :=
               'SELECT   r.nrecibo,
                f_desproducto_T(s.cramo, s.cmodali, s.ctipseg, s.ccolect, 2,'
            || pcidioma
            || ') tsproduc,
                r.cdelega ||'' - ''||f_desagente_T(r.cdelega) tdelega,
                r.cagente ||'' - ''||f_desagente_T(r.cagente) tagente,
                f_nombre(t.sperson, 1,s.cagente) nom_tomador,
                r.femisio, r.fefecto, r.fvencim, v.itotalr total_recibo,
                s.npoliza||'' - ''||s.ncertif npoliza,
                ff_desvalorfijo( 8 , '
            || pcidioma
            -- 30/06/2010 JGR 15. 15211: CRE800 - Modificación de recibos / f_cestrec(r.nrecibo, f_sysdate) -> NULL
            || ', r.ctiprec ) ttiprec,
                f_cestrec(r.nrecibo, null) cestrec,
                ff_desvalorfijo( 1 , '
            || pcidioma
            -- 30/06/2010 JGR 15. 15211: CRE800 - Modificación de recibos / f_cestrec(r.nrecibo, f_sysdate) -> NULL
            --Bug 38316-216899 KJSC Traer estado del recibo 29/10/2015
            || ', '
            || vestado
            || ' ) testrec, r.creccia
       FROM recibos r, '
            || vtabla
            || ' v, seguros s, tomadores t, agentes_agente_pol aa ';
      ELSE
         vsquery :=
               'SELECT   r.nrecibo,
                f_desproducto_T(s.cramo, s.cmodali, s.ctipseg, s.ccolect, 2,'
            || pcidioma
            || ') tsproduc,
                r.cdelega ||'' - ''||f_desagente_T(r.cdelega) tdelega,
                r.cagente ||'' - ''||f_desagente_T(r.cagente) tagente,
                f_nombre(t.sperson, 1,s.cagente) nom_tomador,
                r.femisio, r.fefecto, r.fvencim, v.itotalr  total_recibo,
                s.npoliza||'' - ''||s.ncertif npoliza,
                ff_desvalorfijo( 8 , '
            || pcidioma
            -- 30/06/2010 JGR 15. 15211: CRE800 - Modificación de recibos / f_cestrec(r.nrecibo, f_sysdate) -> NULL
            || ', r.ctiprec ) ttiprec,
                f_cestrec(r.nrecibo, null) cestrec,
                ff_desvalorfijo( 1 , '
            || pcidioma
            -- 30/06/2010 JGR 15. 15211: CRE800 - Modificación de recibos / f_cestrec(r.nrecibo, f_sysdate) -> NULL
            --Bug 38316-216899 KJSC Traer estado del recibo 29/10/2015
            || ', '
            || vestado
            || ' ) testrec, r.creccia
       FROM recibos r, '
            || vtabla
            || ' v, seguros s, tomadores t, agentes_agente_pol aa ';
       -- FIN -IAXIS-4995 - JLTS - 08/08/2019
      END IF;

      --Fin IAXIS - 3592-- ECP-- 27/05/2019--
      -- IAXIS-3592 -- ECP -- 11/06/2019

      -- Ini bug 18908 - 18/07/2011 - SRA
      IF pcsucursal IS NOT NULL
      THEN
         vsquery := vsquery || ', segurosredcom sc ';
      END IF;

      -- Fin bug 18908 - 18/07/2011 - SRA

      -- 33. 0020038: Anulación de recibos según el convenio - Nota: 0101405 - Inicio
      vsquery :=
            vsquery
         || 'WHERE r.sseguro= s.sseguro
         and t.sseguro = s.sseguro
         and t.nordtom in ( select min(tt.nordtom) from tomadores tt where tt.sseguro = t.sseguro)
         and r.nrecibo = v.nrecibo
         and s.cagente = aa.cagente
         and not exists (select ''1'' from adm_recunif ar where ar.nrecibo = r.nrecibo
                     AND ((NVL(f_parproductos_v(s.sproduc, ''RECUNIF''), 0) = 2 and ar.nrecibo != ar.nrecunif ) or
                           NVL(f_parproductos_v(s.sproduc, ''RECUNIF''), 0) != 2))
         and s.cempres = aa.cempres';

      --      vsquery :=
      --         vsquery
      --         || 'WHERE r.sseguro= s.sseguro
      --         and t.sseguro = s.sseguro
      --         and t.nordtom in ( select min(tt.nordtom) from tomadores tt where tt.sseguro = t.sseguro)
      --         and r.nrecibo = v.nrecibo
      --         and s.cagente = aa.cagente
      --         and not exists (select ''1'' from adm_recunif ar where ar.nrecibo = r.nrecibo)
      --         and s.cempres = aa.cempres';
      -- 33. 0020038: Anulación de recibos según el convenio - Nota: 0101405 - Fin

      --Bug.: 16383 - ICV- 17/11/2010 - Evitar que los recibos unificados salgan en las consultas de impago/modif/etc..
      --Bug10426-XVM-15/09/2009: S'ha afegit la taula 'agentes_agente aa' amb les seves condicions
      -- Bug 10127 - APD - 19/05/2009 - fin
      IF pnrecibo IS NOT NULL
      THEN
         vsquery := vsquery || ' and r.nrecibo = ' || pnrecibo;
      END IF;

      --Bug 14586-PFA-21/05/2010- ini
      IF pcreccia IS NOT NULL
      THEN
         vsquery :=
            vsquery || ' and r.creccia = ' || CHR (39) || pcreccia
            || CHR (39);
      END IF;

      --Bug 14586-PFA-21/05/2010- ini
      IF pcpolcia IS NOT NULL
      THEN
         vsquery :=
            vsquery || ' and s.cpolcia = ' || CHR (39) || pcpolcia
            || CHR (39);
      END IF;

      --Bug 14586-PFA-21/05/2010- fin
      IF pcempres IS NOT NULL
      THEN
         vsquery := vsquery || ' and s.cempres = ' || pcempres;
      END IF;

      IF psproduc IS NOT NULL
      THEN
         vsquery := vsquery || ' and s.sproduc = ' || psproduc;
      END IF;

      IF pnpoliza IS NOT NULL
      THEN
         vsquery := vsquery || ' and s.npoliza = ' || pnpoliza;
      END IF;

      IF pncertif IS NOT NULL
      THEN
         vsquery := vsquery || ' and s.ncertif = ' || pncertif;
      END IF;

      IF pctiprec IS NOT NULL
      THEN
         vsquery := vsquery || ' and r.ctiprec = ' || pctiprec;
      END IF;

      IF pcestrec IS NOT NULL
      THEN
         --ini Bug 0011733 - 01/02/2010 - JMF
         --vsquery := vsquery || ' and f_cestrec(r.nrecibo, f_sysdate) = ' || pcestrec;
         --ini Bug 0017970 - 28/03/2011 - JMF -- : ENSA101- Campos pantallas de siniestros y mejoras
         --vsquery := vsquery || ' and f_cestrec(r.nrecibo, null) = ' || pcestrec;
         IF pcestrec = 0
         THEN
            --vsquery := vsquery || ' and f_cestrec(r.nrecibo, null) in (0,3)'; --Bug. 0029379
            -- vsquery := vsquery || ' and f_cestrec(r.nrecibo, null) in (0)';
             -- IAXIS-3592 -- ECP -- 20/06/2019
            vsquery := vsquery || ' and f_cestrec(r.nrecibo, null) in (0,3)';

            -- IAXIS-3592 -- ECP -- 20/06/2019
         -- 39. 0022047: LCOL_A001-Activar la pantalla de impagados para recibos cobrados - 0113135 - Inicio
         ELSIF     NVL
                      (pac_parametros.f_parempresa_n
                                           (pac_md_common.f_get_cxtempresa (),
                                            'IMPAGA_CESTREC3'
                                           ),
                       0
                      ) = 1
               AND pcestrec = 1
         THEN
            vsquery := vsquery || ' and f_cestrec(r.nrecibo, null) in (1,3)';
         -- 39. 0022047: LCOL_A001-Activar la pantalla de impagados para recibos cobrados - 0113135 - Fin
         ELSE
            vsquery :=
                  vsquery || ' and f_cestrec(r.nrecibo, null) = ' || pcestrec;
         END IF;
      --fin Bug 0017970 - 28/03/2011 - JMF
      --fin Bug 0011733 - 01/02/2010 - JMF
      END IF;

      IF pfemisioini IS NOT NULL
      THEN
         vsquery :=
               vsquery
            || ' and r.femisio >= to_date('''
            || TO_CHAR (pfemisioini, 'ddmmyyyy')
            || ''',''ddmmyyyy'')';
      END IF;

      IF pfemisiofin IS NOT NULL
      THEN
         vsquery :=
               vsquery
            || ' and r.femisio <= to_date('''
            || TO_CHAR (pfemisiofin, 'ddmmyyyy')
            || ''',''ddmmyyyy'')';
      END IF;

      IF pfefeini IS NOT NULL
      THEN
         vsquery :=
               vsquery
            || ' and r.fefecto >= to_date('''
            || TO_CHAR (pfefeini, 'ddmmyyyy')
            || ''',''ddmmyyyy'')';
      END IF;

      IF pfefefin IS NOT NULL
      THEN
         vsquery :=
               vsquery
            || ' and r.fefecto <= to_date('''
            || TO_CHAR (pfefefin, 'ddmmyyyy')
            || ''',''ddmmyyyy'')';
      END IF;

      IF ptipo = 1 AND psperson IS NOT NULL
      THEN
         vsquery := vsquery || ' and t.sperson = ' || psperson;
      END IF;

      IF ptipo = 2 AND psperson IS NOT NULL
      THEN
         vsquery :=
               vsquery
            || ' and r.nrecibo in
            (select d.nrecibo
               from detrecibos d, riesgos ri
              where d.nrecibo = r.nrecibo
                and d.nriesgo = ri.nriesgo
                and ri.sseguro= s.sseguro
                and ri.sperson = '
            || psperson
            || ')';
      END IF;

      -- Bug 25151/137983 - 05/03/2013 - AMC
      IF ptipo = 3                                             --22080 Pagador
         AND psperson IS NOT NULL
      THEN
         vsquery :=
               vsquery
            || ' and ((r.sperson is not null and r.sperson = '
            || psperson
            || ') '
            || ' or (r.sperson is null and t.sperson = '
            || psperson
            || '))';
      END IF;

      -- Fi Bug 25151/137983 - 05/03/2013 - AMC

      -- Ini bug 18908 - 18/07/2011 - SRA
      IF pcramo IS NOT NULL
      THEN
         vsquery := vsquery || CHR (13) || ' and s.cramo = ' || pcramo;
      END IF;

      IF pcsucursal IS NOT NULL
      THEN
         vsquery :=
               vsquery
            || CHR (13)
            || ' and sc.ctipage = 2 and sc.sseguro = s.sseguro and sc.cagente = '
            || pcsucursal
            || CHR (13);
      END IF;

      IF pcagente IS NOT NULL
      THEN
         vsquery := vsquery || CHR (13) || ' and r.cagente = ' || pcagente;
      --bug0025639 - 11/01/2013 - RDD
      END IF;

      IF pctipcob IS NOT NULL
      THEN
         vsquery := vsquery || CHR (13) || ' and r.ctipcob = ' || pctipcob;
      END IF;

      -- Fin bug 18908 - 18/07/2011 - SRA
      v_max_reg := pac_parametros.f_parinstalacion_n ('N_MAX_REG');

      IF v_max_reg IS NOT NULL
      THEN
         IF INSTR (vsquery, 'order by', -1, 1) > 0
         THEN
            -- se hace de esta manera para mantener el orden de los registros
            vsquery :=
               'select * from (' || vsquery || ') where rownum <= '
               || v_max_reg;
         ELSE
            vsquery := vsquery || ' and rownum <= ' || v_max_reg;
         END IF;
      END IF;

      IF pcondicion IS NOT NULL
      THEN
         vsquery := vsquery || pcondicion;
      END IF;

      RETURN vsquery;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      vobject,
                      vpasexec,
                      vparam,
                      SQLCODE || ' - ' || SQLERRM
                     );
         RETURN NULL;
   END f_get_consultarecibos;

   -- ini Bug 0012679 - 18/02/2010 - JMF
   /*************************************************************************
     Selecciona información sobre recibos dependiendo de los parámetros de entrada
      param in pnrecibo   :   numero de recibo.
      param in pcempres   :   empresa.
      param in psproduc   :   producto
      param in pnpoliza   :   póliza
      param in pncertif   :   certificado.
      param in pciprec    :   tipo de recibo.
      param in pcestrec   :   estado del recibo.
      param in pfemisioini:   fecha de emisión. (inicio del rango)
      param in pfemisiofin:   fecha de emisión.  ( fin del rango)
      param in pfefeini   :   fecha inicio efecto.  (inicio del rango)
      param in pfefefin   :   fecha fin efecto.  (inicio del rango)
      param in ptipo      :   nos indicará si es tomador o asegurado ( tomador :=1, asegurado =2)
              (check que nos permitirá indicar si buscamos por los datos del tomador o por los datos del asegurado)
      param in psperson   :   código identificador de la persona.
   *************************************************************************/
   FUNCTION f_get_consultarecibos_mv (
      pnrecibo      IN   NUMBER,
      pcempres      IN   NUMBER,
      psproduc      IN   NUMBER,
      pnpoliza      IN   NUMBER,
      pncertif      IN   NUMBER,
      pctiprec      IN   NUMBER,
      pcestrec      IN   NUMBER,
      pfemisioini   IN   DATE,
      pfemisiofin   IN   DATE,
      pfefeini      IN   DATE,
      pfefefin      IN   DATE,
      ptipo         IN   NUMBER,
      psperson      IN   NUMBER,
      pcidioma      IN   NUMBER,
      precunif      IN   NUMBER,                    -- BUG14202:DRA:22/04/2010
      pcestimp      IN   NUMBER,              --Bug.: 16140 - 11/10/2010 - ICV
      pcreccia      IN   VARCHAR2,            --Bug.: 14586 - 16/11/2010 - ICV
      pcpolcia      IN   VARCHAR2,
      pccompani     IN   NUMBER,             --Bug.: 16310 - 24/12/2010 - JBN)
      pliquidad     IN   NUMBER,              --Bug.: 18732 - 07/06/201 - JBN)
      pfiltro       IN   NUMBER,
      -- Ini bug 18908 - 18/07/2011 - SRA
      pcramo        IN   NUMBER,
      pcsucursal    IN   NUMBER,
      pcagente      IN   NUMBER,
      pctipcob      IN   NUMBER,
      pdomi_sn      IN   NUMBER,
      -- Inici Bug 20326/99335 - BFP 05/12/2011
      cbanco        IN   NUMBER,
      ctipcuenta    IN   NUMBER,
      -- Inici Bug 20326/99335 - BFP 05/12/2011
      pcxtempres    IN   NUMBER,
      cobban        IN   NUMBER,                 --BUG20501 - JTS - 28/12/2011
      prebut_ini         VARCHAR2 DEFAULT NULL,       --Bug 22080 - 25/06/2012
      -- Inici Bug 22327/115681 - DCG 30/05/2011
      pnanuali      IN   NUMBER DEFAULT NULL,
      pnfracci      IN   NUMBER DEFAULT NULL,
      ptipnegoc     IN   NUMBER DEFAULT NULL,
      -- Fi Bug 22327/115681 - DCG 30/05/2011
      pcondicion    IN   VARCHAR2 DEFAULT NULL,
      pctipage01    IN   NUMBER DEFAULT NULL,
      -- 48. 0024754 POS JGR 12/12/2012
      pnrecunif     IN   VARCHAR2 DEFAULT NULL,
      --0031322/0175728:NSS:12/06/2014
      pnreccaj      IN   NUMBER DEFAULT NULL,
      -- BUG CONF-441 - 14/12/2016 - JAEG
      pcmreca       IN   NUMBER
            DEFAULT NULL                   -- BUG CONF-441 - 14/12/2016 - JAEG
   )
      RETURN VARCHAR2                                          --SYS_REFCURSOR
   IS
      vobject          VARCHAR2 (500)  := 'PAC_ADM.f_get_consultarecibos_mv';
      vparam           VARCHAR2 (500)
         :=    'parámetros - pnrecibo: '
            || pnrecibo
            || ', pcempres: '
            || pcempres
            || ', psproduc: '
            || psproduc
            || ', pnpoliza: '
            || pnpoliza
            || ', pncertif: '
            || pncertif
            || ', pctiprec: '
            || pctiprec
            || ', pcestrec: '
            || pcestrec
            || ', pfemisioini: '
            || pfemisioini
            || ', pfemisiofin: '
            || pfemisiofin
            || ', pfefeini: '
            || pfefeini
            || ', pfefefin: '
            || pfefefin
            || ', ptipo'
            || ptipo
            || ', psperson: '
            || psperson
            || ', pcidioma: '
            || pcidioma
            || ',precunif: '
            || precunif
            || ' , pcestimp: '
            || pcestimp
            || ' pcreccia : '
            || pcreccia
            || ' pcpolcia : '
            || pcpolcia
            || ' pccompani:'
            || pccompani
            || 'pliquidad: '
            || pliquidad
            || 'pfiltro: '
            || pfiltro
            -- Ini bug 18908 - 18/07/2011 - SRA
            || 'pcramo: '
            || pcramo
            || 'pcsucursal: '
            || pcsucursal
            || 'pcagente: '
            || pcagente
            || 'pctipcob: '
            || pctipcob
            || 'pdomi_sn: '
            || pdomi_sn
            || 'cbanco: '
            || cbanco
            || 'ctipcuenta: '
            || ctipcuenta
            || 'pcxtempres: '
            || pcxtempres
            || 'cobban: '
            || cobban
            || 'prebut_ini: '
            || prebut_ini
            || 'pnanuali: '
            || pnanuali
            || 'pnfracci: '
            || pnfracci
            || 'ptipnegoc: '
            || ptipnegoc
            || 'pcondicion: '
            || pcondicion
            || 'pctipage01: '
            || pctipage01
            || ' pnrecunif: '
            || pnrecunif                      --0031322/0175728:NSS:12/06/2014
            || 'pnreccaj: '
            || pnreccaj
            || 'pcmreca: '
            || pcmreca;                    -- BUG CONF-441 - 14/12/2016 - JAEG
      -- Fin bug 18908 - 18/07/2011 - SRA
      vpasexec         NUMBER (5)      := 1;
      --vnumerr        NUMBER(8) := 0;
      vsquery          VARCHAR2 (9000);
      v_max_reg        NUMBER;           -- número màxim de registres mostrats
      vqueryfiltro     VARCHAR2 (1000) := '';
      v_query_agente   VARCHAR2 (100);
      vtabla           VARCHAR2 (200);
      v_sum_importe    NUMBER;
   --vsseguro1      recibos.nrecibo%TYPE;   -- 44. 0022763: MDP_A001-Unificacion / Desunificacion de recibos
   --vsseguro2      recibos.nrecibo%TYPE;   -- 44. 0022763: MDP_A001-Unificacion / Desunificacion de recibos
   -- Inici Bug 22327/115681 - DCG 30/05/2011
   -- Fi Bug 22327/115681 - DCG 30/05/2011
   BEGIN
      vpasexec := 1;

      -- DRA 4-12-2008: bug mantis 8359
      -- Bug 10127 - APD - 19/05/2009 - se elimina la vista seguros_agente
      --                                se añade la subselect con la tabla agentes_agente
      -- Ini bug 18908 - 18/07/2011 - SRA
      IF pfiltro = 0
      THEN
         IF NVL
               (pac_parametros.f_parempresa_n
                                           (pac_md_common.f_get_cxtempresa (),
                                            'FILTRO_AGE'
                                           ),
                0
               ) = 1
         THEN
            IF pcagente IS NOT NULL
            THEN
               v_query_agente := ' AND r.cagente = ' || pcagente;
            END IF;

            vqueryfiltro :=
                  vqueryfiltro
               || ' and s.cagente in (SELECT a.cagente
                                    FROM (SELECT     LEVEL nivel, cagente
                                                FROM redcomercial r
                                               WHERE
                                                  r.fmovfin is null
                                          START WITH r.cempres = '
               || pcempres
               || v_query_agente
               || ' and r.fmovfin is null
                                          CONNECT BY PRIOR r.cagente =(r.cpadre + 0)
                                                 AND PRIOR r.cempres =(r.cempres + 0)
                                                 and r.fmovfin is null
                                                 AND r.cagente >= 0) rr,
                                         agentes a
                                   where rr.cagente = a.cagente)';
         END IF;
      END IF;

      --Mirem si agafem la moneda del producte o la moneda de cobrament. XPL#03012011#20592
      IF NVL (pac_parametros.f_parempresa_n (pcxtempres, 'MONEDA_POL'), 0) = 1
      THEN
         vtabla := 'vdetrecibos_monpol';
      ELSE
         vtabla := 'vdetrecibos';
      END IF;

      -- IAXIS-3592 -- ECP -- 24/05/2019
      BEGIN
         SELECT NVL (SUM (b.iconcep_monpol), SUM (b.iconcep))
           INTO v_sum_importe
           FROM detmovrecibo a, detmovrecibo_parcial b
          WHERE a.nrecibo = pnrecibo
            AND a.nrecibo = b.nrecibo
            AND a.smovrec = (SELECT MAX (b.smovrec)
                               FROM detmovrecibo b
                              WHERE b.nrecibo = a.nrecibo)
            AND a.norden = b.norden
            AND b.cconcep IN (0, 50); -- IAXIS-4995 - JLTS - 08/08/2019
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            v_sum_importe := 0;
      END;

      -- Bug 18946 - APD - 28/10/2011 - se sustituye la vista agentes_agente por agentes_agente_pol
      vsquery :=
            'SELECT r.nrecibo,
                f_desproducto_T(s.cramo, s.cmodali, s.ctipseg, s.ccolect, 2,'
         || pcidioma
         || ') tsproduc,
                r.cdelega ||'' - ''||f_desagente_T(r.cdelega) tdelega,
                r.cagente ||'' - ''||f_desagente_T(r.cagente) tagente,
                f_nombre(t.sperson, 1,s.cagente) nom_tomador,
                r.femisio, r.fefecto, r.fvencim, v.itotalr total_recibo,
                ff_desvalorfijo( 8 , '
         || pcidioma
         || ', r.ctiprec ) ttiprec,
             f_cestrec_mv (r.nrecibo, null) cestrec,
                ff_desvalorfijo( 383 , '
         || pcidioma
         || ',f_cestrec_mv (r.nrecibo, null)) testrec, r.cvalidado, r.creccia,
         s.ccompani,
         ff_descompania(pac_cuadre_adm.f_es_vida(s.sseguro)) tcompani,
         pp.nnumide,
         ff_desactividad (s.cactivi, s.cramo, PAC_MD_COMMON.f_get_cxtidioma, 2) tactivi, v.icombru,
         FF_DESRAMO(s.cramo, PAC_MD_COMMON.f_get_cxtidioma) tramo,
         s.npoliza||'' - ''||s.ncertif npoliza, '
         -- Bug 21421 - APD - 20/02/2012 - se debe utilizar la tabla recibosredcom en vez
         -- de seguredcom
         -- Bug 21223 - APD - 13/02/2012
         --||' sc.cagente ||'' - ''||f_desagente_T(sc.cagente) sucursal '
         --|| ' sc.c02 ||'' - ''||f_desagente_T(sc.c02) sucursal '
                -- || ' rc.cagente ||'' - ''||f_desagente_T(rc.cagente) sucursal, '
   -- INI - IAXIS-4153 JLTS 07/06/2019. Se ajusta consulta para que tome bien la Sucursal
         || ' pac_redcomercial.f_busca_padre(r.cempres, r.cagente, null, f_sysdate)|| '' - '' ||  f_desagente_t(pac_agentes.f_get_cageliq(r.cempres, 2, r.cagente)) sucursal, '
   -- FIN - IAXIS-4153 JLTS 07/06/2019. Se ajusta consulta para que tome bien la Sucursal
                 || ' f_desriesgo_t(r.sseguro, r.nriesgo, f_sysdate, ' ||
                 pcidioma
         || ') descriesg, DECODE(r.nanuali, 0, NULL, 1, ''P'', ''C'') tnegoci, '
         || 'ff_desvalorfijo(1026,'
         || pcidioma
         || ', r.ctipcob ) ctipcob, '
         || 'ff_desvalorfijo(75,'
         || pcidioma
         || ', r.cestimp ) cestimp, '
         || 'r.nanuali, r.nfracci '        --Bug 22327/115681 - DCG 30/05/2011
         -- fin Bug 21223 - APD - 13/02/2012
         -- fin Bug 21421 - APD - 20/02/2012
         || 'FROM recibos r, '
         || vtabla
         || ' v, seguros s, tomadores t, agentes_agente_pol aa, per_personas pp ';

      -- IAXIS-3592 -- ECP -- 24/05/2019
           --       FROM cobbancario c,recibos r, vdetrecibos v, seguros s, tomadores t, agentes_agente_pol aa, per_personas pp ';  -- Bug 0020599/0101728 - FAL - 22/12/2011
           --IF pcsucursal IS NOT NULL THEN --BUG20501 - JTS - 28/12/2011
           -- Bug 21421 - APD - 20/02/2012 - se debe utilizar la tabla recibosredcom en vez
           -- de seguredcom
           -- Bug 21223 - APD - 13/02/2012
           --vsquery := vsquery || ', segurosredcom sc ';
           --vsquery := vsquery || ', seguredcom sc ';
           --vsquery := vsquery || ', recibosredcom rc ';  -- 66. 0032092 - 179550 (-)

      -- fin Bug 21223 - APD - 13/02/2012
      -- fin Bug 21421 - APD - 20/02/2012
      --END IF; --FiBUG20501 - JTS - 28/12/2011

      -- 48. 0024754 POS JGR 12/12/2012 - Inicio
      IF pctipage01 IS NOT NULL
      THEN
         vsquery := vsquery || ', recibosredcom rc2 ';
      END IF;                          -- 48. 0024754 POS JGR 12/12/2012 - Fin

      -- INI BUG 0031322/0175728:NSS:12/06/2014
      IF pnrecunif IS NOT NULL
      THEN
         vsquery :=
              vsquery || ', (SELECT DISTINCT nrecunif FROM adm_recunif) u   ';
      END IF;

      -- FIN BUG 0031322/0175728:NSS:12/06/2014

      -- 48. 0024754 POS JGR 12/12/2012 - Fin
      vsquery :=
            vsquery
         || ' WHERE r.sseguro= s.sseguro '
         --         || 'and r.ccobban = c.ccobban '   -- bug 20326/99335 - BFP 05/12/2011            -- Bug 0020599/0101728 - FAL - 22/12/2011 - Se comenta
         || 'and pp.sperson = t.sperson
         and t.sseguro = s.sseguro
         and t.nordtom in (select min(tt.nordtom) from tomadores tt where tt.sseguro = t.sseguro)
         and r.nrecibo = v.nrecibo
         and s.cagente = aa.cagente
         and s.cempres = aa.cempres '
                                     -- Bug 21421 - APD - 20/02/2012 - se debe utilizar la tabla recibosredcom en vez
                                     -- de seguredcom
                                     -- Bug 21223 - APD - 13/02/2012
                                     --||' and sc.ctipage(+) = 2 '
                                     --|| ' and sc.c02(+) <> 0
                                     --and sc.fmovfin(+) is null '
                                     -- fin Bug 21223 - APD - 13/02/2012
                                     --|| ' and sc.sseguro(+) = s.sseguro';   --BUG20501 - JTS - 28/12/2011
                                     -- 66. 0032092 - 179550 - Inicio
      ;

      --|| ' and rc.nrecibo(+) = r.nrecibo '
      --|| ' and rc.cempres(+) = r.cempres '
      --|| ' and rc.ctipage(+) = 2 ';
      -- 66. 0032092 - 179550 - Fin

      -- fin Bug 21421 - APD - 20/02/2012

      -- 48. 0024754 POS JGR 12/12/2012 - Inicio
      IF pctipage01 IS NOT NULL
      THEN
         vsquery :=
               vsquery
            || ' and rc2.nrecibo = r.nrecibo '
            || ' and rc2.cempres = r.cempres '
            || ' and rc2.cagente ='
            || pctipage01
            || ' and rc2.ctipage = 1 ';
      END IF;

      -- 48. 0024754 POS JGR 12/12/2012 - Fin
      vsquery := vsquery || vqueryfiltro;

      --Bug10426-XVM-15/09/2009: S'ha afegit la taula 'agentes_agente aa' amb les seves condicions

      -- Bug 10127 - APD - 19/05/2009 - fin
      -- bug 20326/99335 - BFP 05/12/2011
      IF ctipcuenta IS NOT NULL
      THEN
         vsquery := vsquery || ' and r.ctipban = ' || ctipcuenta;
      END IF;

      IF cbanco IS NOT NULL
      THEN
         vsquery :=
               vsquery
            || ' and (SELECT SUBSTR(r.cbancar, NVL(pos_entidad, 1), NVL(long_entidad, 0))
                  FROM tipos_cuenta tt
                 WHERE tt.ctipban = r.ctipban) = '
            || cbanco;
      END IF;

      -- bug 20326/99335 - BFP 05/12/2011
      IF pnrecibo IS NOT NULL
      THEN
         vsquery := vsquery || ' and r.nrecibo = ' || pnrecibo;
      END IF;

      IF pcempres IS NOT NULL
      THEN
         vsquery := vsquery || ' and s.cempres = ' || pcempres;
      END IF;

      IF psproduc IS NOT NULL
      THEN
         vsquery := vsquery || ' and s.sproduc = ' || psproduc;
      END IF;

      IF pnpoliza IS NOT NULL
      THEN
         vsquery := vsquery || ' and s.npoliza = ' || pnpoliza;
      END IF;

      IF pncertif IS NOT NULL
      THEN
         vsquery := vsquery || ' and s.ncertif = ' || pncertif;
      END IF;

      IF pctiprec IS NOT NULL
      THEN
         vsquery := vsquery || ' and r.ctiprec = ' || pctiprec;
      END IF;

      IF pcestrec IS NOT NULL
      THEN
         --ini Bug 0011733 - 01/02/2010 - JMF
         --vsquery := vsquery || ' and f_cestrec(r.nrecibo, f_sysdate) = ' || pcestrec;
         vsquery :=
              vsquery || ' and f_cestrec_mv (r.nrecibo, null) = ' || pcestrec;
      --fin Bug 0011733 - 01/02/2010 - JMF
      END IF;

      -- INI IAXIS-3887 - JLTS - 09/05/2019. Se ajusta fechas con TRUNC
      IF pfemisioini IS NOT NULL
      THEN
         vsquery :=
               vsquery
            || ' and TRUNC(r.femisio) >= to_date('''
            || TO_CHAR (pfemisioini, 'ddmmyyyy')
            || ''',''ddmmyyyy'')';
      END IF;

      IF pfemisiofin IS NOT NULL
      THEN
         vsquery :=
               vsquery
            || ' and TRUNC(r.femisio) <= to_date('''
            || TO_CHAR (pfemisiofin, 'ddmmyyyy')
            || ''',''ddmmyyyy'')';
      END IF;

      IF pfefeini IS NOT NULL
      THEN
         vsquery :=
               vsquery
            || ' and TRUNC(r.fefecto) >= to_date('''
            || TO_CHAR (pfefeini, 'ddmmyyyy')
            || ''',''ddmmyyyy'')';
      END IF;

      IF pfefefin IS NOT NULL
      THEN
         vsquery :=
               vsquery
            || ' and TRUNC(r.fefecto) <= to_date('''
            || TO_CHAR (pfefefin, 'ddmmyyyy')
            || ''',''ddmmyyyy'')';
      END IF;

      -- FIN IAXIS-3887 - JLTS - 09/05/2019. Se ajusta fechas con TRUNC

      --Bug.: 16140 - 11/10/2010 - ICV
      IF pcestimp IS NOT NULL
      THEN
         vsquery := vsquery || ' and r.cestimp = ' || pcestimp;
      END IF;

      --Bug.: 14586 - 16/11/2010 - ICV
      IF pcreccia IS NOT NULL
      THEN
         vsquery :=
            vsquery || ' and r.creccia = ' || CHR (39) || pcreccia
            || CHR (39);
      END IF;

      --Bug.: 14586 - 16/11/2010 - ICV
      IF pcpolcia IS NOT NULL
      THEN
         vsquery :=
            vsquery || ' and s.cpolcia = ' || CHR (39) || pcpolcia
            || CHR (39);
      END IF;

      --Fin Bug.: 16140
      IF ptipo = 1 AND psperson IS NOT NULL
      THEN
         -- INI IAXIS-3407 - 01/04/2019 - JLTS. Se actualiza incluyendo que solo sea para 0 o 3
         vsquery :=
               vsquery
            || ' and (t.sperson = '
            || psperson
            || ' or t.sperson IN (SELECT pr.sperson FROM per_personas_rel pr'
            || ' WHERE  pr.sperson_rel = '
            || psperson
            || ' and pr.CTIPPER_REL in (0,3)))';
      -- FIN IAXIS-3407 - 01/04/2019 - JLTS. Se actualiza incluyendo que solo sea para 0 o 3
      END IF;

      -- INI IAXIS-3887 - JLTS - 09/05/2019. Se ajusta el filtro para que tome directamente el asegurado
      IF ptipo = 2 AND psperson IS NOT NULL
      THEN
         vsquery :=
               vsquery
            || ' and exists (select 1  from asegurados a  where a.sseguro= s.sseguro and a.sperson = '
            || psperson
            || ')';
      END IF;

      -- FIN IAXIS-3887 - JLTS - 09/05/2019. Se ajusta el filtro para que tome directamente el asegurado
      IF ptipo = 3                                             --22080 Pagador
         AND psperson IS NOT NULL
      THEN
         vsquery :=
               vsquery
            || ' and ((r.sperson is not null and r.sperson = '
            || psperson
            || ') '
            || ' or (r.sperson is null and t.sperson = '
            || psperson
            || '))';
      END IF;

      IF pccompani IS NOT NULL
      THEN
         vsquery := vsquery || ' and s.ccompani = ' || pccompani;
      END IF;

      IF pliquidad IS NOT NULL
      THEN
         IF pliquidad = 0
         THEN
            vsquery := vsquery || ' and not exists ';
         ELSE
            vsquery := vsquery || ' and exists ';
         END IF;

         vsquery :=
               vsquery
            || ' (select 1 from adm_liquida_recibos alr where alr.nrecibo = r.nrecibo) ';
      END IF;

      -- Ini bug 18908 - 18/07/2011 - SRA
      IF pcramo IS NOT NULL
      THEN
         vsquery := vsquery || CHR (13) || ' and s.cramo = ' || pcramo;
      END IF;

      IF pcsucursal IS NOT NULL
      THEN
         --BUG20501 - JTS - 28/12/2011
         -- Bug 21421 - APD - 20/02/2012 - se debe utilizar la tabla recibosredcom en vez
         -- de seguredcom
         /*vsquery := vsquery || CHR(13)
         || ' and sc.ctipage = 2 and sc.sseguro = s.sseguro and sc.cagente = '
         || pcsucursal || CHR(13);*/
         -- Bug 21223 - APD - 13/02/2012
         --vsquery := vsquery || ' and sc.cagente = ' || pcsucursal || CHR(13);
         --vsquery := vsquery || ' and sc.c02 = ' || pcsucursal || CHR(13);
   -- INI - IAXIS-4153 JLTS 07/06/2019. Se ajusta consulta para que tome bien la Sucursal
         vsquery :=
               vsquery
            || ' and pac_agentes.f_get_cageliq(r.cempres, 2, r.cagente) = pac_agentes.f_get_cageliq(r.cempres, 2, '||pcsucursal||') '
         -- FIN - IAXIS-4153 JLTS 07/06/2019. Se ajusta consulta para que tome bien la Sucursal
            || ' )) '
            || CHR (13);
      -- fin Bug 21223 - APD - 13/02/2012
      -- fin Bug 21421 - APD - 20/02/2012
      END IF;                                  --FiBUG20501 - JTS - 28/12/2011

      IF pcagente IS NOT NULL
      THEN
         vsquery := vsquery || CHR (13) || ' and r.cagente = ' || pcagente;
      --bug25639 - RDD - 11/01/2013
      END IF;

      IF pctipcob IS NOT NULL
      THEN
         vsquery := vsquery || CHR (13) || ' and r.ctipcob = ' || pctipcob;
      END IF;

      IF pdomi_sn = 1
      THEN
         vsquery := vsquery || CHR (13) || ' and r.cbancar is not null';
      ELSIF pdomi_sn = 2
      THEN
         vsquery := vsquery || CHR (13) || ' and r.cbancar is null';
      END IF;

      --BUG20501 - JTS - 28/12/2011
      IF cobban IS NOT NULL
      THEN
         vsquery := vsquery || CHR (13) || ' and r.ccobban = ' || cobban;
      END IF;

      --Bug.: 22080 - 25/06/2012 - ICV
      IF prebut_ini IS NOT NULL
      THEN
         vsquery :=
               vsquery
            || ' and r.nrecibo in (select cv.nrecibo from cnvrecibos cv where cv.rebut_ini =
           '
            || CHR (39)
            || prebut_ini
            || CHR (39)
            || ') ';
      END IF;

      -- Fin bug 18908 - 18/07/2011 - SRA
      /*v_max_reg := pac_parametros.f_parinstalacion_n('N_MAX_REG');

      IF v_max_reg IS NOT NULL
      THEN
         IF INSTR(vsquery, 'order by', -1, 1) > 0
         THEN
            -- se hace de esta manera para mantener el orden de los registros
            vsquery := 'select * from (' || vsquery || ') where rownum <= ' ||
                       v_max_reg;
         ELSE
            vsquery := vsquery || ' and rownum <= ' || v_max_reg;
         END IF;
      END IF;*/

      --BUG 14438 - JTS - 03/06/2010
      IF precunif = 1
      THEN
         vsquery :=
               vsquery
            || ' and r.nrecibo not in (select nrecibo from adm_recunif) ';
         vsquery :=
               vsquery
            || ' and r.nrecibo not in (select nrecunif from adm_recunif) ';
         vsquery :=
               vsquery
            || ' and f_parproductos_v(s.sproduc, ''RECUNIF'') IN (1,3) ';
         vsquery := vsquery || ' and r.cestaux = 0';
         vsquery := vsquery || ' and f_cestrec_mv (r.nrecibo, null) in (0,4)';

         -- BUG 0038675 - FAL - 12/11/2015 - Permitir agrupar pdtes. e impagados

         -- BUG 0031322/0175728:NSS:12/06/2014

         -- BUG 0019627: GIP102 - Reunificación de recibos - FAL - 10/11/2011

         -- 46. 0022763: MDP_A001-Unificacion / Desunificacion de recibos - Inicio
         IF NVL
               (pac_parametros.f_parempresa_n
                                           (pac_md_common.f_get_cxtempresa (),
                                            'FILTRO_RECUNIF'
                                           ),
                0
               ) = 1
         THEN
            -- reemplazos.sseguro   -- Identificador de la póliza que reemplaza a la otra (Póliza nueva)
            -- reemplazos.sreempl   -- Identificador de la póliza a reemplazar (póliza de reemplazo)

            /*
            1. La póliza tenga una póliza anulada por reemplazo asociada:

            2. Se mostrarán los dos recibos que se podrían unificar, siempre y cuando estos recibos estén en estado pendiente.
               Estos recibos serán el extorno de la póliza reemplazada y el recibo de nueva producción de la nueva póliza,
               y han de tener el mismo tomador, el mismo mediador, el mismo efecto y la misma cuenta bancaria.
               Si se trata de recibos con canal de cobro mediador no se requerirá que tengan similar cuenta bancaria.
            */
            vsquery :=
                  vsquery
               || ' and not exists (select 1 from adm_recunif x where x.nrecunif = r.nrecibo) '
               || ' and f_cestrec(r.nrecibo, f_sysdate) = 0 ';
         END IF;
      ELSIF precunif = 2
      THEN
         vsquery :=
               vsquery
            || ' and exists (select 1 from adm_recunif x where x.nrecunif = r.nrecibo)';
      -- 46. 0022763: MDP_A001-Unificacion / Desunificacion de recibos - Fin
      END IF;

      -- Inici Bug 22327/115681 - DCG 30/05/2011
      IF pnanuali IS NOT NULL
      THEN
         vsquery := vsquery || ' and r.nanuali = ' || pnanuali;
      END IF;

      IF pnfracci IS NOT NULL
      THEN
         vsquery := vsquery || ' and r.nfracci = ' || pnfracci;
      END IF;

      IF ptipnegoc IS NOT NULL
      THEN
         IF ptipnegoc = '1'
         THEN
            -- Producción
            vsquery := vsquery || ' and r.nanuali = ' || ptipnegoc;
         ELSE
            -- Cartera
            vsquery := vsquery || ' and r.nanuali >= ' || ptipnegoc;
         END IF;
      END IF;

      -- Fi Bug 22327/115681 - DCG 30/05/2011

      --Fi BUG 14438
      IF pcondicion IS NOT NULL
      THEN
         vsquery := vsquery || pcondicion;
      END IF;

      -- INI BUG 0031322/0175728:NSS:12/06/2014
      IF pnrecunif IS NOT NULL
      THEN
         vsquery :=
               vsquery
            || 'AND r.nrecibo = u.nrecunif AND u.nrecunif IN ( '
            || pnrecunif
            || ')';
      END IF;

      -- INI BUG CONF-441 - 14/12/2016 - JAEG
      IF pnreccaj IS NOT NULL
      THEN
         --
         vsquery :=
               vsquery
            || ' AND r.nrecibo IN (SELECT nrecibo FROM movrecibo WHERE nreccaj = '
            || pnreccaj
            || ')';
      --
      END IF;

      IF pcmreca IS NOT NULL
      THEN
         --
         vsquery :=
               vsquery
            || ' AND r.nrecibo IN (SELECT nrecibo FROM movrecibo WHERE cmreca = '
            || pcmreca
            || ')';
      --
      END IF;

      -- FIN BUG CONF-441 - 14/12/2016 - JAEG

      -- FIN BUG 0031322/0175728:NSS:12/06/2014
      RETURN vsquery;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      vobject,
                      vpasexec,
                      vparam,
                      SQLCODE || ' - ' || SQLERRM
                     );
         RETURN NULL;
   END f_get_consultarecibos_mv;

   -- fin Bug 0012679 - 18/02/2010 - JMF

   -- BUG14202:DRA:22/04/2010:Inici
/************************************************************************
   Recupera información del recibo
*************************************************************************/
/*************************************************************************
    Se encarga de recuperar la lista de movrecibos de un recibo en concreto
    param in pnrecibo   :   numero de recibo.
*************************************************************************/
   FUNCTION f_get_detrecibos_det (
      pcempres   IN   NUMBER,
      pnrecibo   IN   NUMBER,
      pconcep    IN   NUMBER
   )
      RETURN VARCHAR2
   IS
      --vnumerr        NUMBER(8) := 0;
      squery     VARCHAR2 (2000);
      vpasexec   NUMBER (8)      := 1;
      vparam     VARCHAR2 (500)
         := 'parámetros - pnrecibo: ' || pnrecibo || ', pconcep: ' || pconcep;
      vobject    VARCHAR2 (200)  := 'PAC_ADM.F_Get_Detrecibos_det';
   --numrecs        NUMBER;
   --v_error        NUMBER;
   BEGIN
      --Mirem si agafem la moneda del producte o la moneda de cobrament. XPL#03012011#20592
      squery :=
            'SELECT cgarant, nriesgo, iconcep, iconcep_monpol, cageven , nmovima
            FROM detrecibos
           WHERE nrecibo = '
         || pnrecibo
         || ' AND cconcep =  '
         || pconcep;
      vpasexec := 3;
      RETURN squery;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      vobject,
                      vpasexec,
                      vparam,
                      SQLCODE || ' - ' || SQLERRM
                     );
         RETURN NULL;
   END f_get_detrecibos_det;

   -- BUG14202:DRA:27/04/2010:Fi

   /*************************************************************************
       Se encarga de recuperar la lista de movrecibos de un recibo en concreto
       param in pnrecibo   :   numero de recibo.
   *************************************************************************/
   FUNCTION f_get_detrecibos (pcempres IN NUMBER, pnrecibo IN NUMBER)
      RETURN VARCHAR2
   IS
      --vnumerr        NUMBER(8) := 0;
      squery     VARCHAR2 (2000);
      vpasexec   NUMBER (8)      := 1;
      vparam     VARCHAR2 (500)  := 'parámetros - pnrecibo: ' || pnrecibo;
      vobject    VARCHAR2 (200)  := 'PAC_ADM.F_Get_Detrecibos';
      vtipage    NUMBER;
   --numrecs        NUMBER;
   BEGIN
      -- falta la búsqueda del tconcep --
      --Mirem si agafem la moneda del producte o la moneda de cobrament. XPL#03012011#20592
      SELECT ctipage
        -- INI CONF-403 LR - Ajuste muestra impuestos solo para corredores
      INTO   vtipage
        FROM agentes a, recibos r
       WHERE a.cagente = r.cagente AND r.nrecibo = pnrecibo;

      IF (vtipage IN (4))
      THEN
         squery :=
               'SELECT cconcep, sum (nvl( iconcep, 0)) iconcep, sum (nvl( iconcep_monpol, 0)) iconcep_monpol
          FROM detrecibos
         WHERE nrecibo = '
            || pnrecibo
            || ' GROUP BY cconcep';
      ELSE
         squery :=
               'SELECT cconcep, sum (nvl( iconcep, 0)) iconcep, sum (nvl( iconcep_monpol, 0)) iconcep_monpol
          FROM detrecibos
         WHERE nrecibo = '
            || pnrecibo
            || '
                and cconcep not in (32,33,34,35,82,83,84,85)
                GROUP BY cconcep';
      END IF;                                               -- FIN CONF-403 LR

      RETURN squery;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      vobject,
                      vpasexec,
                      vparam,
                      SQLCODE || ' - ' || SQLERRM
                     );
         RETURN NULL;
   END f_get_detrecibos;

   /*************************************************************************
       Se encarga de recuperar el vmovrecibo de un recibo en concreto
       param in pnrecibo   :   numero de recibo.
   *************************************************************************/
   FUNCTION f_get_vdetrecibos (
      pcempres   IN   NUMBER,
      pnrecibo   IN   NUMBER,
      pcidioma   IN   NUMBER
   )
      -- BUG14202:DRA:22/04/2010
   RETURN VARCHAR2
   IS
      --vnumerr        NUMBER(8) := 0;
      squery           VARCHAR2 (2000);
      vpasexec         NUMBER (8)      := 1;
      vparam           VARCHAR2 (500)
         := 'parámetros - pnrecibo: ' || pnrecibo || ', pcidioma: '
            || pcidioma;
      vobject          VARCHAR2 (200)  := 'PAC_ADM.F_Get_VDetrecibos';
      --numrecs        NUMBER;
      vtabla           VARCHAR2 (200);
      v_sum_importe    NUMBER;
      v_sum_gastos     NUMBER;
      v_sum_impuesto   NUMBER;
      v_sum_impcom     NUMBER;
      v_sum_total      NUMBER;
      -- Ini 5149 -- ECP -- 12/09/2019
      v_sum_comisi     NUMBER;
      v_sum_comisi_ch  VARCHAR2(50); -- IAXIS-4926 23/10/2019
      -- Ini 5149 -- ECP -- 12/09/2019
         -- Ini 5149 -- ECP -- 09/12/2019
      v_sum_importe_dif     NUMBER;
     
      -- Ini 5149 -- ECP -- 09/12/2019
      -- INI -IAXIS-4995 - JLTS - 08/08/2019
      v_sum_importe_ch    VARCHAR2(50);
      v_sum_gastos_ch     VARCHAR2(50);
      v_sum_impuesto_ch   VARCHAR2(50);
      v_sum_impcom_ch     VARCHAR2(50);
      v_sum_total_ch      VARCHAR2(50);
      -- FIN -IAXIS-4995 - JLTS - 08/08/2019
   BEGIN
      vtabla := 'vdetrecibos';

      -- IAXIS-3592 -- ECP -- 24/05/2019
      BEGIN
         SELECT NVL (SUM (b.iconcep), 0)
           INTO v_sum_importe
           FROM detmovrecibo a, detmovrecibo_parcial b
          WHERE a.nrecibo = pnrecibo
            AND a.nrecibo = b.nrecibo
            AND a.smovrec = (SELECT MAX (b.smovrec)
                               FROM detmovrecibo b
                              WHERE b.nrecibo = a.nrecibo)
            AND a.norden = b.norden
            AND a.smovrec = b.smovrec -- IAXIS-4926 23/10/2019
            AND b.cconcep IN (0,50); -- IAXIS-4995 - JLTS - 08/08/2019
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            v_sum_importe := 0;
      END;

      BEGIN
         SELECT NVL (SUM (b.iconcep), 0)
           INTO v_sum_gastos
           FROM detmovrecibo a, detmovrecibo_parcial b
          WHERE a.nrecibo = pnrecibo
            AND a.nrecibo = b.nrecibo
            AND a.smovrec = (SELECT MAX (b.smovrec)
                               FROM detmovrecibo b
                              WHERE b.nrecibo = a.nrecibo)
            AND a.norden = b.norden
            AND a.smovrec = b.smovrec -- IAXIS-4926 23/10/2019
            AND b.cconcep IN (14);
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            v_sum_gastos := 0;
      END;
      -- INI -IAXIS-4995 - JLTS - 08/08/2019
      BEGIN
         SELECT nvl(SUM(b.iconcep), 0)
           INTO v_sum_impuesto
           FROM detmovrecibo a, detmovrecibo_parcial b
          WHERE a.nrecibo = pnrecibo
            AND a.nrecibo = b.nrecibo
            AND a.smovrec = (SELECT MAX (b.smovrec)
                               FROM detmovrecibo b
                              WHERE b.nrecibo = a.nrecibo)
            AND a.norden = b.norden
            AND a.smovrec = b.smovrec -- IAXIS-4926 23/10/2019
            AND b.cconcep IN (4, 86);
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            v_sum_impuesto  := 0;
      END;
      -- FIN -IAXIS-4995 - JLTS - 08/08/2019
      BEGIN
         SELECT NVL (SUM (b.iconcep), 0)
           INTO v_sum_impcom
           FROM detmovrecibo a, detmovrecibo_parcial b
          WHERE a.nrecibo = pnrecibo
            AND a.nrecibo = b.nrecibo
            AND a.smovrec = (SELECT MAX (b.smovrec)
                               FROM detmovrecibo b
                              WHERE b.nrecibo = a.nrecibo)
            AND a.norden = b.norden
            AND a.smovrec = b.smovrec -- IAXIS-4926 23/10/2019
            AND b.cconcep IN (32,82); -- IAXIS-4995 - JLTS - 08/08/2019
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            v_sum_impcom := 0;
      END;
      -- INI -IAXIS-4995 - JLTS - 08/08/2019
      -- Ini 5149 -- ECP -- 12/09/2019
      BEGIN
         SELECT NVL (SUM (b.iconcep_monpol), 0)
           INTO v_sum_comisi
           FROM detmovrecibo a, detmovrecibo_parcial b
          WHERE a.nrecibo = pnrecibo
            AND a.nrecibo = b.nrecibo
            AND a.smovrec = (SELECT MAX (b.smovrec)
                               FROM detmovrecibo b
                              WHERE b.nrecibo = a.nrecibo)
            AND a.norden = b.norden
            AND a.smovrec = b.smovrec -- IAXIS-4926 23/10/2019
            AND b.cconcep IN (11); 
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            v_sum_comisi := 0;
      END;
      v_sum_total := v_sum_importe + v_sum_gastos + v_sum_impuesto;
      
      if v_sum_importe    < 1 THEN v_sum_importe_ch := REPLACE(TO_CHAR(v_sum_importe,'0D0000000000'),',','.'); else v_sum_importe_ch := REPLACE(v_sum_importe,',','.'); end if;
      if v_sum_gastos     < 1 THEN v_sum_gastos_ch := REPLACE(TO_CHAR(v_sum_gastos,'0D0000000000'),',','.'); else v_sum_gastos_ch := REPLACE(v_sum_gastos,',','.'); end if;
      if v_sum_impuesto   < 1 THEN v_sum_impuesto_ch := REPLACE(TO_CHAR(v_sum_impuesto,'0D0000000000'),',','.'); else v_sum_impuesto_ch := REPLACE(v_sum_impuesto,',','.'); end if;
      if v_sum_impcom     < 1 THEN v_sum_impcom_ch := REPLACE(TO_CHAR(v_sum_impcom,'0D0000000000'),',','.'); else v_sum_impcom_ch := REPLACE(v_sum_impcom,',','.'); end if;
      if v_sum_total      < 1 THEN v_sum_total_ch := REPLACE(TO_CHAR(v_sum_total,'0D0000000000'),',','.'); else v_sum_total_ch := REPLACE(v_sum_total,',','.'); end if;


      if v_sum_comisi     < 1 THEN v_sum_comisi_ch := REPLACE(TO_CHAR(v_sum_comisi,'0D0000000000'),',','.'); else v_sum_comisi_ch := REPLACE(v_sum_comisi,',','.'); end if;
      
      
      -- Ini IAXIS-5149 -- ECP -- 09/12/2019 v_sum_importe_dif
      -- Ini BUG IAXIS-12983 JRVG 16/03/2020 (iderreg)
            squery :=
            '
            SELECT
               case when itotpri - '||v_sum_importe_ch ||' <= 0 then 0 else decode(itotalr - '||v_sum_gastos_ch||' - '||v_sum_importe_ch ||' - '||v_sum_impuesto_ch||',0,itotalr - '||v_sum_gastos_ch||' - '||v_sum_importe_ch ||' - '||v_sum_impuesto_ch||',itotpri - '||v_sum_importe_ch ||') end  iprinet, irecext,
               iconsor, ireccon,
               case when itotimp - '||v_sum_impuesto_ch||' <= 0 then 0 else decode(itotalr - '||v_sum_gastos_ch||' - '||v_sum_importe_ch ||' - '||v_sum_impuesto_ch||',0,itotalr - '||v_sum_gastos_ch||' - '||v_sum_importe_ch ||' - '||v_sum_impuesto_ch||',decode(itotimp - '||v_sum_impuesto_ch||',1,0,itotimp - '||v_sum_impuesto_ch||')) end iips,   ff_desvalorfijo( 27,'
         || pcidioma
         || ', 4) tiips,
               idgs,   ff_desvalorfijo( 27,'
         || pcidioma
         || ', 5) tidgs,
               iarbitr,ff_desvalorfijo( 27,'
         || pcidioma
         || ', 6) tiarbitr,
               ifng,   ff_desvalorfijo( 27,'
         || pcidioma
         || ', 7) tifng,
               irecfra, idtotec, idtocom,
               icombru- '||v_sum_comisi_ch||' icombru, icomret, idtoom,
               ipridev  , itotpri , itotdto,
               itotcon, itotimp,(itotalr - '||v_sum_total_ch||') itotalr,               
               case when ABS(itotrec - '||v_sum_gastos_ch||') <= 0 then 0 else (itotrec - '||v_sum_gastos_ch||') end iderreg,
               itotrec , icomdev- '||v_sum_comisi_ch||' icomdev,
               iretdev, icednet, icedrex,
               icedcon, icedrco, icedips,
               iceddgs, icedarb, icedfng,
               icedrfr, iceddte, iceddco,
               icedcbr, icedcrt, iceddom,
               icedpdv, icedreg, icedcdv,
               icedrdv, it1pri ,  it1dto,
               it1con,  it1imp,  it1rec,
               it1totr, it2pri,  it2dto,
               it2con,  it2imp,  it2rec,
               it2totr , icomcia, icombrui,
               icomreti, icomdevi, icomdrti,
               icombruc, icomretc, icomdevc,
               icomdrtc, iocorec
               , '
         || 'iimp_1, iimp_2, iimp_3, iimp_4  '
         ||                               -- 38. 27/03/2012 JGR 0020546/104206
            ' FROM '
         || vtabla
         || '
            where nrecibo = '
         || pnrecibo;
         
         -- Fin BUG IAXIS-12983 JRVG 16/03/2020
       
      -- FIN -IAXIS-4995 - JLTS - 08/08/2019
      -- FIN IAXIS-3592 --ECP -- 27/05/2019
          -- Fin IAXIS-5149 -- ECP -- 09/12/2019
      RETURN squery;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      vobject,
                      vpasexec,
                      vparam,
                      SQLCODE || ' - ' || SQLERRM
                     );
         RETURN NULL;
   END f_get_vdetrecibos;

   /*************************************************************************
       Se encarga de recuperar el vmovrecibo de un recibo en concreto
       param in pnrecibo   :   numero de recibo.
   *************************************************************************/
   FUNCTION f_get_vdetrecibos_monpol (
      pcempres   IN   NUMBER,
      pnrecibo   IN   NUMBER,
      pcidioma   IN   NUMBER
   )
      -- BUG14202:DRA:22/04/2010
   RETURN VARCHAR2
   IS
      --vnumerr        NUMBER(8) := 0;
      squery           VARCHAR2 (2000);
      vpasexec         NUMBER (8)      := 1;
      vparam           VARCHAR2 (500)
         := 'parámetros - pnrecibo: ' || pnrecibo || ', pcidioma: '
            || pcidioma;
      vobject          VARCHAR2 (200)  := 'PAC_ADM.F_Get_VDetrecibos';
      --numrecs        NUMBER;
      vtabla           VARCHAR2 (200);
      -- INI IAXIS-3592 --ECP -- 27/05/2019
      v_sum_importe    NUMBER;
      v_sum_gastos     NUMBER;
      v_sum_impuesto   NUMBER;
      v_sum_impcom     NUMBER;
      v_sum_total      NUMBER;
      v_tolerancia     NUMBER; -- IAXIS-4515 - JLTS - ajuste de valores
      
      v_sum_comisi     NUMBER; --IAXIS-5149 -- ECP -- 12/09/2019
   BEGIN
     -- INI - IAXIS-4515 - JLTS - ajuste de valores
      v_tolerancia := NVL(pac_parametros.f_parempresa_n(pac_md_common.f_get_cxtempresa, 'TOLERANCIA_COP'),
                              0);
      -- IAXIS-3592 -- ECP -- 24/05/2019
      BEGIN
         SELECT NVL (SUM (b.iconcep_monpol), 0)
           INTO v_sum_importe
           FROM detmovrecibo a, detmovrecibo_parcial b
          WHERE a.nrecibo = pnrecibo
            AND a.nrecibo = b.nrecibo
            AND a.smovrec = (SELECT MAX (b.smovrec)
                               FROM detmovrecibo b
                              WHERE b.nrecibo = a.nrecibo)
            AND a.norden = b.norden
            AND b.cconcep IN (0,50); -- IAXIS-4995 - JLTS - 08/08/2019
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            v_sum_importe := 0;
      END;

      BEGIN
         SELECT NVL (SUM (b.iconcep_monpol), 0)
           INTO v_sum_gastos
           FROM detmovrecibo a, detmovrecibo_parcial b
          WHERE a.nrecibo = pnrecibo
            AND a.nrecibo = b.nrecibo
            AND a.smovrec = (SELECT MAX (b.smovrec)
                               FROM detmovrecibo b
                              WHERE b.nrecibo = a.nrecibo)
            AND a.norden = b.norden
            AND b.cconcep IN (14);
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            v_sum_gastos := 0;
      END;

      BEGIN
         -- INI -IAXIS-4995 - JLTS - 08/08/2019
         SELECT nvl(SUM(b.iconcep_monpol), 0)
           INTO v_sum_impuesto
           FROM detmovrecibo a, detmovrecibo_parcial b
          WHERE a.nrecibo = pnrecibo
            AND a.nrecibo = b.nrecibo
            AND a.smovrec = (SELECT MAX (b.smovrec)
                               FROM detmovrecibo b
                              WHERE b.nrecibo = a.nrecibo)
            AND a.norden = b.norden
            AND b.cconcep IN (4,86);
     -- FIN -IAXIS-4995 - JLTS - 08/08/2019
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            v_sum_impuesto := 0;
      END;

      BEGIN
         SELECT NVL (SUM (b.iconcep_monpol), 0)
           INTO v_sum_impcom
           FROM detmovrecibo a, detmovrecibo_parcial b
          WHERE a.nrecibo = pnrecibo
            AND a.nrecibo = b.nrecibo
            AND a.smovrec = (SELECT MAX (b.smovrec)
                               FROM detmovrecibo b
                              WHERE b.nrecibo = a.nrecibo)
            AND a.norden = b.norden
            AND b.cconcep IN (32,82); -- IAXIS-4995 - JLTS - 08/08/2019
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            v_sum_impcom := 0;
      END;
      -- INI -IAXIS-4995 - JLTS - 08/08/2019
      
      -- Ini 5149 -- ECP -- 12/09/2019
      BEGIN
         SELECT NVL (SUM (b.iconcep_monpol), 0)
           INTO v_sum_comisi
           FROM detmovrecibo a, detmovrecibo_parcial b
          WHERE a.nrecibo = pnrecibo
            AND a.nrecibo = b.nrecibo
            AND a.smovrec = (SELECT MAX (b.smovrec)
                               FROM detmovrecibo b
                              WHERE b.nrecibo = a.nrecibo)
            AND a.norden = b.norden
            AND b.cconcep IN (11); -- IAXIS-4995 - JLTS - 08/08/2019
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            v_sum_comisi := 0;
      END;
     
      v_sum_total :=
                  v_sum_importe + v_sum_gastos + v_sum_impuesto;
                  p_tab_error (f_sysdate,
                      f_user,
                      'f_genera_contabilidad_recibo',
                      vpasexec,
                      vpasexec,
                         SQLCODE
                      || ' - '
                      || SQLERRM
                      || ' pnrecibo-->'
                      || pnrecibo
                      || 'v_sum_importe-->'
                      || v_sum_importe
                      || ' v_sum_gastos->'
                      || v_sum_gastos
                      || ' v_sum_impuesto-->'
                      || v_sum_impuesto
                      || ' v_sum_comisi-->'
                      || v_sum_comisi
                      || ' v_sum_impcom-->'
                      ||  v_sum_impcom
                      || ' v_tolerancia-->'
                      || v_tolerancia
                      );
      vtabla := 'vdetrecibos_monpol';
      squery :=
            'SELECT case when ABS(itotpri - '||v_sum_importe||') <= '||v_tolerancia||' then 0 else (itotpri - '||v_sum_importe||') end iprinet,'
               ||' irecext,'
               ||' iconsor, ireccon,'
               ||' case when ABS(itotimp - '||v_sum_impuesto||') <= '||v_tolerancia||' then 0 else ( itotimp - '||v_sum_impuesto||') end iips,'
               ||' ff_desvalorfijo( 27,'
         || pcidioma
         || ', 4) tiips,
               idgs,   ff_desvalorfijo( 27,'
         || pcidioma
         || ', 5) tidgs,
               iarbitr,ff_desvalorfijo( 27,'
         || pcidioma
         || ', 6) tiarbitr,
               ifng,   ff_desvalorfijo( 27,'
         || pcidioma
         || ', 7) tifng,'
               ||' irecfra, idtotec, idtocom,'
               ||' case when ABS(icombru - '||v_sum_comisi||') <= '||v_tolerancia||' then 0 else (icombru-  '||v_sum_comisi||') end icombru, icomret, idtoom,'
               ||' case when ABS(ipridev) <= '||v_tolerancia||' then 0 else (ipridev) end ipridev, '
               ||' case when ABS(itotpri) <= '||v_tolerancia||' then 0 else (itotpri) end itotpri , itotdto, itotcon, '
               ||' case when ABS(itotimp) <= '||v_tolerancia||' then 0 else (itotimp) end itotimp, '
               ||' case when ABS(itotalr - '||v_sum_total||') <= '||v_tolerancia||' then 0 else (itotalr - '||v_sum_total||') end itotalr,'
               ||' case when ABS(itotrec - '||v_sum_gastos||') <= '||v_tolerancia||' then 0 else (itotrec - '||v_sum_gastos||') end iderreg, itotrec, icomdev- '||v_sum_impcom||','
               ||' iretdev, icednet, icedrex,
               icedcon, icedrco, icedips,
               iceddgs, icedarb, icedfng,
               icedrfr, iceddte, iceddco,
               icedcbr, icedcrt, iceddom,
               icedpdv, icedreg, icedcdv,
               icedrdv, case when ABS(it1pri) <= '||v_tolerancia||' then 0 else (it1pri) end it1pri,  it1dto,
               it1con,  case when ABS(it1imp) <= '||v_tolerancia||' then 0 else (it1imp) end it1imp,  
               case when ABS(it1rec) <= '||v_tolerancia||' then 0 else (it1rec) end it1rec,
               it1totr, it2pri,  it2dto,
               it2con,  it2imp,  it2rec,
               it2totr , icomcia, icombrui,
               icomreti, icomdevi, icomdrti,
               icombruc, icomretc, icomdevc,
               icomdrtc, iocorec
               , '
         || 'iimp_1, iimp_2, iimp_3, iimp_4  '
         ||                               -- 38. 27/03/2012 JGR 0020546/104206
            ' FROM '
         || vtabla
         || '
            where nrecibo = '
         || pnrecibo;
         -- Ini 5149 -- ECP -- 12/09/2019
      -- FIN -IAXIS-4995 - JLTS - 08/08/2019
      -- FIN IAXIS-3592 --ECP -- 27/05/2019
       
      RETURN squery;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      vobject,
                      vpasexec,
                      vparam,
                      SQLCODE || ' - ' || SQLERRM
                     );
         RETURN NULL;
   END f_get_vdetrecibos_monpol;

   /*************************************************************************
       Se encarga de recuperar la lista de movrecibos de un recibo en concreto
       param in pnrecibo   :   numero de recibo.
   *************************************************************************/
   FUNCTION f_get_movrecibos (pnrecibo IN NUMBER, pcidioma IN NUMBER)
      -- BUG14202:DRA:22/04/2010
   RETURN VARCHAR2
   IS
      --vnumerr        NUMBER(8) := 0;
      squery     VARCHAR2 (2000);
      vpasexec   NUMBER (8)      := 1;
      vparam     VARCHAR2 (500)
         := 'parámetros - pnrecibo: ' || pnrecibo || ', pcidioma: '
            || pcidioma;
      vobject    VARCHAR2 (200)  := 'PAC_ADM.F_Get_Movrecibos';
   --numrecs        NUMBER;
   BEGIN
      -- Bug 19791/97335 - 08/11/2011 - AMC
      -----Changes for 4944 started
      squery :=
            'SELECT   smovrec, cusuari,
                   smovagr, cestrec, cestant,
                   fmovini, fmovfin, fcontab,
                   fmovdia, cmotmov, ccobban,
                   cdelega, ctipcob, fefeadm,
                   ff_desvalorfijo( 1 , '
         || pcidioma
         || ',cestrec) testrec,
                   ff_desvalorfijo(1026, '
         || pcidioma
         || ',ctipcob) ttipcob,
                   (select distinct cmotivo from tmp_impagados t where t.nrecibo = m.nrecibo
                    and t.smovrec = m.smovrec) cmotivo, '
         || 
         /*          ff_desvalorfijo(73,'
         || pcidioma
         || ', (select distinct cmotivo
                                                       from tmp_impagados t
                                                       where t.nrecibo = m.nrecibo
                                                       and t.smovrec = m.smovrec))' */
         ' NDOCSAP tmotivo, 
               nreccaj, ff_desvalorfijo(8001181 , '
         || pcidioma
         || ', cmreca) tmreca,CINDICAF, CSUCURSAL 
                FROM movrecibo m
                Where nrecibo ='
         || pnrecibo
         || ' order by smovrec desc';
      -- Fi Bug 19791/97335 - 08/11/2011 - AMC
      -----Changes for 4944 Ended
      RETURN squery;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      vobject,
                      vpasexec,
                      vparam,
                      SQLCODE || ' - ' || SQLERRM
                     );
         RETURN NULL;
   END f_get_movrecibos;

   /*************************************************************************
       Se encarga de recuperar la información de un recibo en concreto
       param in pnrecibo   :   numero de recibo.
   *************************************************************************/
   FUNCTION f_get_datosrecibo (pnrecibo IN NUMBER, pcidioma IN NUMBER)
      -- BUG14202:DRA:22/04/2010
   RETURN VARCHAR2
   IS
      --vnumerr        NUMBER(8) := 0;
      squery     VARCHAR2 (4000);
      vpasexec   NUMBER (8)      := 1;
      vparam     VARCHAR2 (500)
         := 'parámetros - pnrecibo: ' || pnrecibo || ', pcidioma: '
            || pcidioma;
      vobject    VARCHAR2 (200)  := 'PAC_ADM.F_Get_DatosRecibo';
   BEGIN
      vpasexec := 3;
      -- BUG12679:DRA:28/04/2010:Inici
      -- Bug 8745 - 02/03/2009 - RSC -    IAX: Adaptación iAxis a productos colectivos con certificados
      -- Recogemos 'esccero' de la tabla RECIBOS
      -- BUG 0020761 - 03/01/2012 - JMF: ncuotar
      -- Bug 22342 - APD - 14/06/2012 - se añade la tabla recibos_comp y la recuperacion
      -- en la select de los campos CACCPRE, CACCRET y TOBSERV
      squery :=
            'SELECT r.nrecibo, cagente, cempres, nmovimi, sseguro, femisio, fefecto, fvencim,'
         || ' ctiprec,  ff_desvalorfijo( 8,'
         || pcidioma
         || ', ctiprec) ttiprec, cdelega, ccobban, cestaux, nanuali, nfracci, cestimp, ff_desvalorfijo( 75,'
         || pcidioma
         || ', cestimp)   testimp , festimp, nriesgo, cforpag, ff_desvalorfijo( 17,'
         || pcidioma
         || ', cforpag)  TFORPAG, ctipban, cbancar, nmovanu, cretenc, pretenc, ncuacoa, ctipcoa, ff_desvalorfijo( 59,'
         || pcidioma
         || ', ctipcoa) ttipcoa, cestsop, nperven, ctransf, cgescob,  ff_desvalorfijo( 694,'
         || pcidioma
         || ', cgescob) tgescob, cmanual, decode( cmanual, 1, f_axis_literales( 101327,'
         || pcidioma
         -- 30/06/2010 JGR 15. 15211: CRE800 - Modificación de recibos / f_cestrec(r.nrecibo, f_sysdate) -> NULL
         || '), null) tmanual, f_cestrec(r.nrecibo, null)  cestrec, ff_desvalorfijo( 1 ,'
         -- 30/06/2010 JGR 15. 15211: CRE800 - Modificación de recibos / f_cestrec(r.nrecibo, f_sysdate) -> NULL
         || pcidioma
         || ',f_cestrec(r.nrecibo, null)) testrec, creccia, esccero'
         -- Bug 14586-PFA-21/05/2010- Añadir campo recibo compañia
         || ', ctipcob '                     -- Bug 0020010 - JMF - 15/11/2011
         || ', ncuotar, rc.caccpre, rc.caccret, rc.tobserv '
         || ' FROM recibos r, recibos_comp rc WHERE r.nrecibo = rc.nrecibo(+) and r.nrecibo ='
         || pnrecibo;
      -- BUG12679:DRA:28/04/2010:Fi
      RETURN squery;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      vobject,
                      vpasexec,
                      vparam,
                      SQLCODE || ' - ' || SQLERRM
                     );
         RETURN NULL;
   END f_get_datosrecibo;

   -- BUG12679:DRA:07/05/2010:Inici
   /*************************************************************************
       Se encarga de recuperar la información de un recibo en concreto
       param in pnrecibo   :   numero de recibo.
   *************************************************************************/
   FUNCTION f_get_datosrecibo_mv (pnrecibo IN NUMBER, pcidioma IN NUMBER)
      -- BUG14202:DRA:22/04/2010
   RETURN VARCHAR2
   IS
      --vnumerr        NUMBER(8) := 0;
      squery     VARCHAR2 (4000);
      vpasexec   NUMBER (8)      := 1;
      vparam     VARCHAR2 (500)
         := 'parámetros - pnrecibo: ' || pnrecibo || ', pcidioma: '
            || pcidioma;
      vobject    VARCHAR2 (200)  := 'PAC_ADM.F_Get_DatosRecibo_mv';
   BEGIN
      vpasexec := 3;
      -- BUG12679:DRA:28/04/2010:Inici
      -- Bug 8745 - 02/03/2009 - RSC -    IAX: Adaptación iAxis a productos colectivos con certificados
      -- Recogemos 'esccero' de la tabla RECIBOS
      -- BUG 0020761 - 03/01/2012 - JMF: ncuotar
      squery :=
            'SELECT nrecibo, cagente, cempres, nmovimi, sseguro, femisio, fefecto, fvencim,'
         || ' ctiprec,  ff_desvalorfijo( 8,'
         || pcidioma
         || ',DECODE(ctiprec,3,DECODE(nfracci,0,3,16),ctiprec)) ttiprec, cdelega, ccobban, cestaux, nanuali, nfracci, cestimp, ff_desvalorfijo( 75,'
         || pcidioma
         || ', cestimp)   testimp , festimp, nriesgo, cforpag, ff_desvalorfijo( 17,'
         || pcidioma
         || ', cforpag)  TFORPAG, ctipban, cbancar, nmovanu, cretenc, pretenc, ncuacoa, ctipcoa, ff_desvalorfijo( 59,'
         || pcidioma
         || ', ctipcoa) ttipcoa, cestsop, nperven, ctransf, cgescob,  ff_desvalorfijo (694,'
         || pcidioma
         || ', cgescob) tgescob, cmanual, decode( cmanual, 1, f_axis_literales (101327,'
         || pcidioma
         || '), null) tmanual, f_cestrec_mv(nrecibo, null)  cestrec, ff_desvalorfijo (383 ,'
         || pcidioma
         || ',f_cestrec_mv(nrecibo, null)) testrec, esccero, cvalidado, creccia, cmodifi'
         || ', ncuotar, sperson, ctipcob, ff_desvalorfijo (1026,'
         || pcidioma
         || ', ctipcob) ttipcob, ctipapor, ctipaportante '
         --AAC_INI-CONF_OUTSOURCING-20160906
         || ', cgescar '
         --AAC_FI-CONF_OUTSOURCING-20160906
         || 'FROM recibos WHERE nrecibo ='
         || pnrecibo;
      -- BUG12679:DRA:28/04/2010:Fi
      RETURN squery;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      vobject,
                      vpasexec,
                      vparam,
                      SQLCODE || ' - ' || SQLERRM
                     );
         RETURN NULL;
   END f_get_datosrecibo_mv;

   -- BUG12679:DRA:07/05/2010:Fi

   /*BUG 0010676: 09/07/2009 : ETM -- CEM - Días de gestión de un recibo--INI */

   /*************************************************************************
       Se encarga de recuperar Nº de dias en los que un recibo pagado se considera que esta en periodo de gestion
       param in pnrecibo   :   numero de recibo.
   *************************************************************************/
   -- 10676.22/09/2009.NMM. Es canviarà el paràmetre pnrecibo per p_companyia.
   --FUNCTION f_get_diasgest(p_companyia IN NUMBER)
   -- BUG 35103-200056.KJSC . Se debe sustituir w_empresa por el número de recibo (pnrecibo).
   FUNCTION f_get_diasgest (pnrecibo IN NUMBER, pfestrec IN DATE DEFAULT NULL)
      RETURN NUMBER
   IS
      v_diasgest      parempresas.nvalpar%TYPE;
      vobject         VARCHAR2 (200)              := 'PAC_ADM.F_GET_DIASGEST';
      v_pasexec       NUMBER (8)                       := 1;
      -- vparam         VARCHAR2(500) := 'paràmetres - p_companyia: ' || p_companyia;

      -- BUG 35103-200056.KJSC . Se debe sustituir w_empresa por el número de recibo (pnrecibo).
      vparam          VARCHAR2 (500) := 'paràmetres - pnrecibo: ' || pnrecibo;
      v_ctipo         codparam.ctipo%TYPE;
      v_dias2         parempresas.nvalpar%TYPE;
      v_mes           NUMBER;
      v_cuenta        recibos.cbancar%TYPE;
      v_ctipbanc      recibos.ctipban%TYPE;
      v_cobrador      recibos.ccobban%TYPE;
      v_entcobrador   cobbancario.descripcion%TYPE;
      vposenti        tipos_cuenta.pos_entidad%TYPE;
      vlongenti       tipos_cuenta.long_entidad%TYPE;
      ventidad        NUMBER;
      ventrecibo      bancos.tbanco%TYPE;
      v_tipocuenta    NUMBER;
      v_dias3         NUMBER;
      --Por correo recibido el dia 09 de abril del 2015, cuyo remitente es Joan Miramunt Farras se agrega este parametro de empresa y el v_cdoment
      pcempres        NUMBER;
      v_cdoment       NUMBER;
      v_dias          NUMBER;
   BEGIN
      -- 10676.22/09/2009.NMM.No cal recuperar cia., ja la tenim.
      /*SELECT r.cempres
       INTO v_empres
       FROM recibos r, seguros s
      WHERE r.nrecibo = pnrecibo
        AND r.sseguro = s.sseguro;*/

      --BEGIN
      -- 10676.22/09/2009.NMM.
      /*SELECT NVL(nvalpar, 0)
       INTO v_param
       FROM parempresas
      WHERE cparam = 'DIASGEST_DIRECTO'
        AND cempres = v_empres;*/
      /* v_dies := pac_parametros.f_parempresa_n(p_companyia, 'DIASGEST_DIRECTO');
      v_pasexec := 2;*/
      --Por correo recibido el dia 16 de abril del 2015, cuyo remitente es Joan Miramunt Farras se agrega esta cosulta
      IF pnrecibo IS NOT NULL
      THEN
         SELECT r.cempres
           INTO pcempres
           FROM recibos r, seguros s
          WHERE r.nrecibo = pnrecibo AND r.sseguro = s.sseguro;
      ELSE
         pcempres := pac_md_common.f_get_cxtempresa ();
      END IF;

      v_pasexec := 10;
      v_ctipo := pac_parametros.f_parempresa_n (pcempres, 'DIASGEST_TIPO');
      v_pasexec := 20;
      v_diasgest := pac_parametros.f_parempresa_n (pcempres, 'DIASGEST');

      -- BUG 35103-200056.KJSC .Se trae el numero de tipo de la tabla parempresas

      /*SELECT NVL (nvalpar, 0)
              INTO v_ctipo
              FROM parempresas
             WHERE cparam = 'DIASGEST_TIPO'
               AND cempres = pcempres;
      */
      -- BUG 35103-200056.KJSC .Se trae el campo nvalpar de parempresas cuando el parametro es DIASGEST

      /* SELECT NVL (nvalpar, 0)
       INTO v_dias
       FROM parempresas
      WHERE cparam = 'DIASGEST'
        AND cempres = pcempres;*/

      --No dias directo
      IF v_ctipo = 1
      THEN
         v_dias := v_diasgest;
      --No dias por mes
      ELSIF v_ctipo = 2
      THEN
         SELECT TO_CHAR (fvalpar, 'MM')
           INTO v_mes
           FROM parempresas
          WHERE cparam = 'DIASGEST' AND cempres = pcempres;

         v_dias2 := vtramo (NULL, v_diasgest, v_mes);
         v_dias := v_dias2;
      --No dias por Entidad propia/externa
      ELSIF v_ctipo = 3
      THEN
         --Se obtiene cta bancaria,tipo de cuenta y cobrador bancario
         SELECT cbancar, ctipban, ccobban
           INTO v_cuenta, v_ctipbanc, v_cobrador
           FROM recibos
          WHERE nrecibo = pnrecibo;

         --Entidad cobrador
         SELECT descripcion, cdoment
           INTO v_entcobrador, v_cdoment
           FROM cobbancario
          WHERE ccobban = v_cobrador;

         SELECT pos_entidad, long_entidad
           INTO vposenti, vlongenti
           FROM tipos_cuenta
          WHERE ctipban = v_ctipbanc;

         v_pasexec := 30;
         ventidad := TO_NUMBER (SUBSTR (v_cuenta, vposenti, vlongenti));

         IF v_cdoment = ventidad
         THEN
            --CUENTA PROPIA
            v_tipocuenta := 1;
         ELSE
            --CUENTA EXTERNA
            v_tipocuenta := 2;
         END IF;

         v_dias3 := vtramo (NULL, v_diasgest, v_tipocuenta);
         v_dias := v_dias3;
      ELSE
         v_dias := 0;
      END IF;

      RETURN v_dias;
   /*  IF v_dies = 1 THEN
   -- 10676.22/09/2009.NMM.
   /*SELECT NVL(nvalpar, 0)
     INTO v_dias
     FROM parempresas
    WHERE cparam = 'DIASGEST'
      AND cempres = v_empres;*/
   /*   v_pasexec := 3;
      v_dies := pac_parametros.f_parempresa_n(p_companyia, 'DIASGEST');
      v_pasexec := 4;
      RETURN(v_dies);
   ELSIF v_dies = 0 THEN
      v_pasexec := 5;
      RETURN(0);
   END IF;

   --END;
   v_pasexec := 6;
   RETURN(0);*/
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      vobject,
                      v_pasexec,
                      vparam,
                      SQLCODE || ' - ' || SUBSTR (SQLERRM, 1, 300)
                     );
         RETURN (NULL);
   END f_get_diasgest;

   /* FIN --BUG 0010676: 09/07/2009 : ETM*/

   /****************************************************************************
      F_RECRIES: Calcula  el recibo del seguro.
            pctipreb = 1 => Por tomador   (Solo un recibo)
            pctipreb = 2 => Por asegurado (Tantos recibos como riesgos haya)
            pctipreb = 3 => Por colectivo (Un recibo al tomador) Luego se pasa un prceso
                                        que junta los recibos por póliza incluyendo los certificados.
            pctipreb = 4 => Rebut per aportant (taula aportaseg)
      ALLIBADM
      1.- Devuelve el error que se produce en insrecibo o detrecibo
      2.- Si fallan todos los riesgos (error 103108) no da error
      3.- Se añade el parametro PCMOVIMI para pasarselo a f_insrecibo.
          Nos indica si es producto es de ahorro(pcmovimi not null)
          o no lo es (pcmovimi = null)
      4.- Se distingue entre el modo real y modo pruebas(informe previo)
          Se añade el parametro pcempres
      5.- Desaparece el parámetro psmovseg.
          Se añade el parámetro pnmovimi
      6.- Cambios para el caso de un recibo por riesgo

      7.- El tratamiento de recibo por riesgo no funciona cuando se
               trata de la baja de riesgos. SAVEPOINT anula el cursor cuando
               se hace el rollback. Se añaden los delete's.
      8.- Se hacen dos cursores de riesgos, uno para modo P y otro para modo R
      9.- Se cambia el error 103138 por el error generado por f_detrecibo
          para obtener más información.
      10.- Se añade un nuevo modo = 'H' para la rehabilitación de garantias
                y riesgos. Se lee de garancar y se graba en recibos.
      11.- Se añaden los deletes sobre RECIBOS, MOVRECIBO, RECIBOSREDCOM y
           RECIBOSCAR (pmodo='P') cuando el recibo es por tomador y la función
           F_DETRECIBO no graba ningún concepto y devuelve valor 103108.
           Deberá borrar los datos de AGENTESCOB y AGENTESCOBCAR para ese recibo.
           En F_DETRECIBO se ha vuelto a incorporar la funcionalidad que avisa
           que no se grabaron conceptos y deje de grabar el concepto 99 .
      12.- S'afegeix la gestió dels col.lectius de vida, amb rebuts per aportant
      13.- Se añade el parámetro pcgarant para el caso pmodo = 'A' poder
                pasar la garantía asociada (ahora se graba siempre la 282)
      14.- Se añaden los parametros funcion y tabla para el calculo del primer recibo al tarifar,
                el parametro tabla indica a que tablas tiene que ir a buscar importes ('EST','SOL',NULLL),
                el parametro función indica si estoy tarifando (TAR) o en la cartera o previo de cartera (CAR)
   ****************************************************************************/
   FUNCTION f_recries (
      pctipreb          IN       NUMBER,
      psseguro          IN       NUMBER,
      pcagente          IN       NUMBER,
      pfemisio          IN       DATE,
      pfefecto          IN       DATE,
      pfvencimi         IN       DATE,
      pctiprec          IN       NUMBER,
      pnanuali          IN       NUMBER,
      pnfracci          IN       NUMBER,
      pccobban          IN       NUMBER,
      pcestimp          IN       NUMBER,
      psproces          IN       NUMBER,
      ptipomovimiento   IN       NUMBER,
      pmodo             IN       VARCHAR2,
      pcmodcom          IN       NUMBER,
      pfcaranu          IN       DATE,
      pnimport          IN       NUMBER,
      pcmovimi          IN       NUMBER,
      pcempres          IN       NUMBER,
      pnmovimi          IN       NUMBER,
      pcpoliza          IN       NUMBER,
      pnimport2         OUT      NUMBER,
      pnordapo          IN       NUMBER DEFAULT NULL,
      pcgarant          IN       NUMBER DEFAULT NULL,
      pttabla           IN       VARCHAR2 DEFAULT NULL,
      pfuncion          IN       VARCHAR2 DEFAULT 'CAR',
      ptraspasa         IN       NUMBER DEFAULT 1
   )
      RETURN NUMBER
   IS
      CURSOR riesgo_modor
      IS
         SELECT nriesgo
           FROM movseguro m, seguros s, riesgos r
          WHERE s.sseguro = r.sseguro
            AND m.sseguro = s.sseguro
            AND m.nmovimi = pnmovimi
            AND s.sseguro = psseguro
            AND TRUNC (r.fefecto) <= TRUNC (pfefecto)
            AND (   (r.fanulac IS NULL)
                 OR (TRUNC (r.fanulac) > TRUNC (pfefecto) AND cmotmov <> 242)
                 OR (TRUNC (r.fanulac) >= TRUNC (pfefecto) AND cmotmov = 242)
                )
            AND pmodo <> 'H'                                -- pmodo = 'R','A'
         UNION                                -- Per mode H llegim de garancar
         SELECT DISTINCT (nriesgo)
                    FROM garancar
                   WHERE sproces = psproces
                     AND finiefe <= pfefecto
                     AND (ffinefe > pfefecto OR ffinefe IS NULL)
                     AND pmodo = 'H';

      CURSOR riesgo_modop (ptabla IN VARCHAR2)
      IS
         SELECT nriesgo
           FROM riesgos
          WHERE sseguro = psseguro
            AND TRUNC (fefecto) <= TRUNC (pfefecto)
            AND (fanulac IS NULL OR (TRUNC (fanulac) > TRUNC (pfefecto)))
         UNION
         SELECT nriesgo
           FROM estriesgos
          WHERE sseguro = psseguro
            AND TRUNC (fefecto) <= TRUNC (pfefecto)
            AND (fanulac IS NULL OR (TRUNC (fanulac) > TRUNC (pfefecto)))
            AND 'EST' LIKE ptabla
         UNION
         SELECT nriesgo
           FROM solriesgos
          WHERE ssolicit = psseguro AND 'SOL' LIKE ptabla;

      -- Cursor d'aportants
      -- si ens arriba un aportant concret, forcem a que no reparteixi l'import
      -- segons les proporcions que li toquen, sino un 100%
      /*
      CURSOR capo(psseguro NUMBER, pfefecto DATE, pnorden NUMBER) IS
         SELECT        DECODE(pnorden, NULL, ctipimp, 1) ctipimp,
                       DECODE(pnorden, NULL, pimport, 100) pimport,
                       DECODE(pnorden, NULL, iimport, 0) iimport, cforpag, norden, fcarpro,
                       fcarant, cbancar
                  FROM aportaseg
                 WHERE sseguro = psseguro
                   AND finiefe <= pfefecto
                   AND(ffinefe IS NULL
                       OR ffinefe > pfefecto)
                   AND(norden = pnorden
                       OR pnorden IS NULL)
                   AND cforpag IS NOT NULL
         FOR UPDATE OF fcarant, fcarpro;
      */
      num_err      NUMBER;
      num_recibo   NUMBER;
      --almenosuno     NUMBER;
      --error          NUMBER;
      texto        VARCHAR2 (400);
      pnnumlin     NUMBER;
      xfmovim      DATE;
      xtipo        VARCHAR2 (20);
      --lnrenova       NUMBER;
      --lfcarant_nou   DATE;
      --lfcarpro_nou   DATE;
      --lfvencim       DATE;
      v_idioma     NUMBER;

      FUNCTION f_dates_aportant (
         psseguro       IN       NUMBER,
         pnrenova       IN       NUMBER,
         pcforpag       IN       NUMBER,
         pfcarpro       IN       DATE,
         pfcarant_nou   OUT      DATE,
         pfcarpro_nou   OUT      DATE
      )
         RETURN NUMBER
      IS
         lmeses   NUMBER;
         ldia     VARCHAR2 (2);
      BEGIN
         lmeses := 12 / pcforpag;
         ldia := SUBSTR (LPAD (pnrenova, 4, '0'), 3, 2);
         pfcarant_nou := pfcarpro;
         pfcarpro_nou := f_summeses (pfcarpro, lmeses, ldia);
         RETURN 0;
      EXCEPTION
         WHEN OTHERS
         THEN
            RETURN 141037;
      END f_dates_aportant;
   BEGIN
      -- Bug 19096 - RSC - 03/08/2011 - LCOL - Parametrización básica producto Vida Individual Pagos Permanentes (Añadimos 'RRIE')
      IF pmodo IN ('R', 'A', 'ANP', 'H', 'RRIE')
      THEN
         IF pctipreb IN (1, 3)
         THEN
            -- Un solo recibo al tomador, o un solo recibo por colectivo
            -- Si el tipo de recibo es por colectivo:
            -- Generamos el recibo con otra secuencia por que luego pasaremos un proceso que
            -- junte los recibos por poliza (incluyendo los certificados )
            IF pctipreb = 3
            THEN
               xtipo := 'SI';
            ELSE
               xtipo := NULL;
            END IF;

            num_err :=
               pac_adm.f_insrecibo_adm (psseguro,
                                        pcagente,
                                        pfemisio,
                                        pfefecto,
                                        pfvencimi,
                                        pctiprec,
                                        pnanuali,
                                        pnfracci,
                                        pccobban,
                                        pcestimp,
                                        NULL,
                                        num_recibo,
                                        pmodo,
                                        psproces,
                                        pcmovimi,
                                        pnmovimi,
                                        pfefecto,
                                        xtipo,
                                        NULL,
                                        NULL,
                                        pttabla,
                                        pfuncion
                                       );

            IF num_err <> 0
            THEN
               --Devuelve el error de insrecibo
               RETURN num_err;
            -- RETURN 103136;   --Error en la funcion insrecibo
            ELSE
               num_err :=
                  pac_adm.f_detrecibo (psproces,
                                       psseguro,
                                       num_recibo,
                                       ptipomovimiento,
                                       pmodo,
                                       pcmodcom,
                                       pfemisio,
                                       pfefecto,
                                       pfvencimi,
                                       pfcaranu,
                                       pnimport,
                                       NULL,
                                       pnmovimi,
                                       pcpoliza,
                                       pnimport2,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       pcgarant,
                                       pttabla,
                                       pfuncion
                                      );

               IF pfemisio < pfefecto
               THEN
                  xfmovim := pfefecto;
               ELSE
                  xfmovim := pfemisio;
               END IF;

               IF num_err = 103108
               THEN
                  --Error controlado
                  --no se ha grabado nada en detrecibo
                  --no se emite recibo de ese riesgo
                  BEGIN
                     DELETE      tmp_adm_movrecibo
                           WHERE nrecibo = num_recibo;

                     IF pmodo NOT IN ('P', 'PRIE')
                     THEN
                        DELETE      tmp_adm_recibosredcom
                              WHERE nrecibo = num_recibo;
                     END IF;

                     DELETE      tmp_adm_recibos
                           WHERE nrecibo = num_recibo;
                  EXCEPTION
                     WHEN OTHERS
                     THEN
                        RETURN 105155;
                  END;
               -- ROLLBACK TO A;
               ELSIF num_err <> 0 AND num_err <> 105154
               THEN
                  --Devuelve el error de detrecibo
                  RETURN num_err;
               -- RETURN 103137;   --Error en la funcion detrecibo
               ELSIF num_err = 105154
               THEN
                  v_idioma :=
                       pac_parametros.f_parempresa_n (pcempres, 'IDIOMA_DEF');
                  texto := f_axis_literales (num_err, v_idioma);
                  num_recibo := NULL;
                  pnnumlin := NULL;
                  num_err :=
                            f_proceslin (psproces, texto, psseguro, pnnumlin);
               ELSE
                  -- si no hay error fusionamos los recibos no imprimibles
                  num_err :=
                     pac_adm.f_tmpprima_minima_extorn (psseguro,
                                                       num_recibo,
                                                       2,
                                                       NULL,
                                                       pccobban,
                                                       7,
                                                       pcagente,
                                                       pfemisio,
                                                       NULL
                                                      );

                  IF num_err <> 0
                  THEN
                     RETURN num_err;
                  END IF;

                  IF ptipomovimiento IN (21, 22)
                  THEN
                     num_err :=
                        pac_adm.f_tmpfusionsupcar (psseguro,
                                                   num_recibo,
                                                   pfefecto,
                                                   pfemisio,
                                                   'R',
                                                   psproces
                                                  );

                     IF num_err <> 0
                     THEN
                        RETURN num_err;
                     END IF;
                  END IF;
               END IF;
            END IF;
         ELSIF pctipreb = 2
         THEN
            -- Un recibo por riesgo(asegurado)
            BEGIN
               FOR rie IN riesgo_modor
               LOOP
                  -- SAVEPOINT A;
                  num_err :=
                     pac_adm.f_insrecibo_adm (psseguro,
                                              pcagente,
                                              pfemisio,
                                              pfefecto,
                                              pfvencimi,
                                              pctiprec,
                                              pnanuali,
                                              pnfracci,
                                              pccobban,
                                              pcestimp,
                                              rie.nriesgo,
                                              num_recibo,
                                              pmodo,
                                              psproces,
                                              pcmovimi,
                                              pnmovimi,
                                              pfefecto,
                                              NULL,
                                              NULL,
                                              NULL,
                                              pttabla,
                                              pfuncion
                                             );

                  IF num_err <> 0
                  THEN
                     RETURN num_err;          --Error en la funcion insrecibo
                  ELSE
                     num_err :=
                        pac_adm.f_detrecibo (psproces,
                                             psseguro,
                                             num_recibo,
                                             ptipomovimiento,
                                             pmodo,
                                             pcmodcom,
                                             pfemisio,
                                             pfefecto,
                                             pfvencimi,
                                             pfcaranu,
                                             pnimport,
                                             rie.nriesgo,
                                             pnmovimi,
                                             pcpoliza,
                                             pnimport2,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             pcgarant,
                                             pttabla,
                                             pfuncion
                                            );

                     IF num_err <> 0
                     THEN
                        IF num_err = 103108
                        THEN
                           --Error controlado
                           --no se ha grabado nada en detrecibo
                           --no se emite recibo de ese riesgo
                           BEGIN
                              DELETE      tmp_adm_movrecibo
                                    WHERE nrecibo = num_recibo;

                              IF pmodo NOT IN ('P', 'PRIE')
                              THEN
                                 DELETE      tmp_adm_recibosredcom
                                       WHERE nrecibo = num_recibo;
                              END IF;

                              DELETE      tmp_adm_recibos
                                    WHERE nrecibo = num_recibo;
                           EXCEPTION
                              WHEN OTHERS
                              THEN
                                 RETURN 105155;
                           END;
                        -- ROLLBACK TO A;
                        ELSIF num_err = 105154
                        THEN
                           -- Error. Nº. asegurados = 0.
                           v_idioma :=
                              pac_parametros.f_parempresa_n (pcempres,
                                                             'IDIOMA_DEF'
                                                            );
                           texto := f_axis_literales (num_err, v_idioma);
                           num_recibo := NULL;
                           pnnumlin := NULL;
                           num_err :=
                              f_proceslin (psproces, texto, psseguro,
                                           pnnumlin);
                        ELSE
                           --Error fatal
                           --Se cambia el error a retornar para obtener más información.
                           --RETURN 103138;  --Error para un riesgo en la función detrecibo
                           RETURN num_err;
                        END IF;
                     ELSE
                        num_err :=
                           pac_adm.f_tmpprima_minima_extorn (psseguro,
                                                             num_recibo,
                                                             2,
                                                             NULL,
                                                             pccobban,
                                                             7,
                                                             pcagente,
                                                             pfemisio,
                                                             NULL
                                                            );

                        IF num_err <> 0
                        THEN
                           RETURN num_err;
                        END IF;

                        -- si no hay error fusionamos los recibos no imprimibles
                        IF ptipomovimiento IN (21, 22)
                        THEN
                           num_err :=
                              pac_adm.f_tmpfusionsupcar (psseguro,
                                                         num_recibo,
                                                         pfefecto,
                                                         pfemisio,
                                                         'R',
                                                         psproces
                                                        );

                           IF num_err <> 0
                           THEN
                              RETURN num_err;
                           END IF;
                        END IF;

                        num_recibo := NULL;
                     --Que calcule el siguiente;
                     END IF;
                  END IF;
               END LOOP;
            EXCEPTION
               -- Se producirá una excepción ORA -01002 cuando haya un rollback
               -- en el bucle.
               WHEN OTHERS
               THEN
                  --DBMS_OUTPUT.put_line(SQLERRM);
                  RETURN 104952;                --Error en la función RECRIES
            END;
         ELSIF pctipreb = 4
         THEN
            -- Rebut per aportant
            -- veure si per forma de pagament li toca
            -- cridar a f_insrecibo amb cforpag i cbancar
            -- Necessitem nrenova per obtenir la data de propera cartera per cada aportant
            --BEGIN
            --   SELECT nrenova
            --     INTO lnrenova
            --     FROM seguros
            --    WHERE sseguro = psseguro;
            --EXCEPTION
            --   WHEN OTHERS THEN
            --      RETURN 101919;
            --END;

            -- RSC 11/02/2009 Cambios Bug 7854 ------------------------------------
            --FOR vapo IN capo (psseguro, pfefecto, pnordapo) LOOP
            -- Cal veure si a aquest aportant li toca fer rebut
            -- En cas de nova producció o suplement sempre farem rebut
            -- en cas de renovació mirarem la data de propera cartera
            --IF    pctiprec <> 3
            --   OR vapo.fcarpro = pfefecto THEN
            -- s'ha de calcular la data de venciment del rebut, que serà
            -- la data de propera cartera nova de l'aportant
            --IF pctiprec = 3 THEN
            --   num_err :=
            --      f_dates_aportant (psseguro, lnrenova, vapo.cforpag,
            --                        vapo.fcarpro, lfcarant_nou,
            --                        lfcarpro_nou);
            --   lfvencim := lfcarpro_nou;

            --   IF num_err <> 0 THEN
            --      RETURN num_err;
            --   END IF;
            --ELSE
            --   lfvencim := pfvencimi;
            --END IF;

            -- Bug 7854 - 11/02/2009 - RSC - Recibo del certificado cero.
            -- Recibo del Certificado 0
            num_err :=
               pac_adm.f_insrecibo_adm (psseguro,
                                        pcagente,
                                        pfemisio,
                                        pfefecto,
                                        pfvencimi,
                                        pctiprec,
                                        pnanuali,
                                        pnfracci,
                                        pccobban,
                                        pcestimp,
                                        NULL,
                                        num_recibo,
                                        pmodo,
                                        psproces,
                                        pcmovimi,
                                        pnmovimi,
                                        pfefecto,
                                        'CERTIF0',
                                        NULL,
                                        NULL,
                                        pttabla,
                                        pfuncion
                                       );

            IF num_err <> 0
            THEN
               RETURN num_err;                --Error en la funcion insrecibo
            ELSE
               num_err :=
                  pac_adm.f_detrecibo (psproces,
                                       psseguro,
                                       num_recibo,
                                       ptipomovimiento,
                                       pmodo,
                                       pcmodcom,
                                       pfemisio,
                                       pfefecto,
                                       pfvencimi,
                                       pfcaranu,
                                       pnimport,
                                       NULL,
                                       pnmovimi,
                                       pcpoliza,
                                       pnimport2,
                                       NULL,
                                       1,
                                       NULL,
                                       NULL,
                                       pcgarant,
                                       pttabla,
                                       pfuncion
                                      );

               IF num_err <> 0
               THEN
                  IF num_err = 103108
                  THEN
                     --Error controlado
                     --no se ha grabado nada en detrecibo
                     --no se emite recibo de ese riesgo
                     BEGIN
                        DELETE      tmp_adm_movrecibo
                              WHERE nrecibo = num_recibo;

                        IF pmodo NOT IN ('P', 'PRIE')
                        THEN
                           DELETE      tmp_adm_recibosredcom
                                 WHERE nrecibo = num_recibo;
                        END IF;

                        DELETE      tmp_adm_recibos
                              WHERE nrecibo = num_recibo;
                     EXCEPTION
                        WHEN OTHERS
                        THEN
                           RETURN 105155;
                     END;
                  ELSIF num_err = 105154
                  THEN
                     -- Error. Nº. asegurados = 0.
                     v_idioma :=
                        pac_parametros.f_parempresa_n (pcempres,
                                                       'IDIOMA_DEF');
                     texto := f_axis_literales (num_err, v_idioma);
                     num_recibo := NULL;
                     pnnumlin := NULL;
                     num_err :=
                            f_proceslin (psproces, texto, psseguro, pnnumlin);
                  ELSE
                     --Error fatal
                     -- Se cambia el error a retornar para obtener más información.
                     --RETURN 103138;  --Error para un riesgo en la función detrecibo
                     RETURN num_err;
                  END IF;
               ELSE
                  num_err :=
                     pac_adm.f_tmpprima_minima_extorn (psseguro,
                                                       num_recibo,
                                                       2,
                                                       NULL,
                                                       pccobban,
                                                       7,
                                                       pcagente,
                                                       pfemisio,
                                                       NULL
                                                      );

                  IF num_err <> 0
                  THEN
                     RETURN num_err;
                  END IF;

                  -- si no hay error fusionamos los recibos no imprimibles
                  IF ptipomovimiento IN (21, 22)
                  THEN
                     num_err :=
                        pac_adm.f_tmpfusionsupcar (psseguro,
                                                   num_recibo,
                                                   pfefecto,
                                                   pfemisio,
                                                   'R',
                                                   psproces
                                                  );

                     IF num_err <> 0
                     THEN
                        RETURN num_err;
                     END IF;
                  END IF;
               -- Insertem el rebut per aportant
               --BEGIN
               --   INSERT INTO aportarec
               --               (sseguro, norden, nrecibo)
               --        VALUES (psseguro, vapo.norden, num_recibo);
               --EXCEPTION
               --   WHEN OTHERS THEN
               --      RETURN 140613;
               --END;

               --IF pctiprec = 3 THEN
               -- Si és un rebut de cartera, actualitzem les dates dels aportants
               --   UPDATE aportaseg
               --      SET fcarant = lfcarant_nou,
               --          fcarpro = lfcarpro_nou
               --    WHERE CURRENT OF capo;
               --END IF;

               --num_recibo := NULL;
               --Que calcule el siguiente;
               END IF;
            END IF;

            -- Hay que ponerlo a NULL para que genere otro numero de recibo
            num_recibo := NULL;
            -- Bug 7854 - 11/02/2009 - RSC - Recibo del certificado cero.
            -- Recibo del Certificado N
            num_err :=
               pac_adm.f_insrecibo_adm (psseguro,
                                        pcagente,
                                        pfemisio,
                                        pfefecto,
                                        pfvencimi,
                                        pctiprec,
                                        pnanuali,
                                        pnfracci,
                                        pccobban,
                                        pcestimp,
                                        NULL,
                                        num_recibo,
                                        pmodo,
                                        psproces,
                                        pcmovimi,
                                        pnmovimi,
                                        pfefecto,
                                        'CERTIFN',
                                        NULL,
                                        NULL,
                                        pttabla,
                                        pfuncion
                                       );

            IF num_err <> 0
            THEN
               RETURN num_err;                --Error en la funcion insrecibo
            ELSE
               num_err :=
                  pac_adm.f_detrecibo (psproces,
                                       psseguro,
                                       num_recibo,
                                       ptipomovimiento,
                                       pmodo,
                                       pcmodcom,
                                       pfemisio,
                                       pfefecto,
                                       pfvencimi,
                                       pfcaranu,
                                       pnimport,
                                       NULL,
                                       pnmovimi,
                                       pcpoliza,
                                       pnimport2,
                                       NULL,
                                       2,
                                       NULL,
                                       NULL,
                                       pcgarant,
                                       pttabla,
                                       pfuncion
                                      );

               IF num_err <> 0
               THEN
                  IF num_err = 103108
                  THEN
                     --Error controlado
                     --no se ha grabado nada en detrecibo
                     --no se emite recibo de ese riesgo
                     BEGIN
                        DELETE      tmp_adm_movrecibo
                              WHERE nrecibo = num_recibo;

                        IF pmodo NOT IN ('P', 'PRIE')
                        THEN
                           DELETE      tmp_adm_recibosredcom
                                 WHERE nrecibo = num_recibo;
                        END IF;

                        DELETE      tmp_adm_recibos
                              WHERE nrecibo = num_recibo;
                     EXCEPTION
                        WHEN OTHERS
                        THEN
                           RETURN 105155;
                     END;
                  ELSIF num_err = 105154
                  THEN
                     -- Error. Nº. asegurados = 0.
                     v_idioma :=
                        pac_parametros.f_parempresa_n (pcempres,
                                                       'IDIOMA_DEF');
                     texto := f_axis_literales (num_err, v_idioma);
                     num_recibo := NULL;
                     pnnumlin := NULL;
                     num_err :=
                            f_proceslin (psproces, texto, psseguro, pnnumlin);
                  ELSE
                     --Error fatal
                     -- Se cambia el error a retornar para obtener más información.
                     --RETURN 103138;  --Error para un riesgo en la función detrecibo
                     RETURN num_err;
                  END IF;
               ELSE
                  num_err :=
                     pac_adm.f_tmpprima_minima_extorn (psseguro,
                                                       num_recibo,
                                                       2,
                                                       NULL,
                                                       pccobban,
                                                       7,
                                                       pcagente,
                                                       pfemisio,
                                                       NULL
                                                      );

                  IF num_err <> 0
                  THEN
                     RETURN num_err;
                  END IF;

                  -- si no hay error fusionamos los recibos no imprimibles
                  IF ptipomovimiento IN (21, 22)
                  THEN
                     num_err :=
                        pac_adm.f_tmpfusionsupcar (psseguro,
                                                   num_recibo,
                                                   pfefecto,
                                                   pfemisio,
                                                   'R',
                                                   psproces
                                                  );

                     IF num_err <> 0
                     THEN
                        RETURN num_err;
                     END IF;
                  END IF;
               -- Insertem el rebut per aportant
               --BEGIN
               --   INSERT INTO aportarec
               --               (sseguro, norden, nrecibo)
               --        VALUES (psseguro, vapo.norden, num_recibo);
               --EXCEPTION
               --   WHEN OTHERS THEN
               --      RETURN 140613;
               --END;

               --IF pctiprec = 3 THEN
               -- Si és un rebut de cartera, actualitzem les dates dels aportants
               --   UPDATE aportaseg
               --      SET fcarant = lfcarant_nou,
               --          fcarpro = lfcarpro_nou
               --    WHERE CURRENT OF capo;
               --END IF;

               --num_recibo := NULL;
               --Que calcule el siguiente;
               END IF;
            END IF;
         --END IF;
         --END LOOP;
         ------------ FI DELS CANVIS
         END IF;
      -- Bug 14775 - RSC - 10/08/2010 - AGA003 - Error en dades rebut plantilla Condicionat Particular AGA012
      --RETURN 0;
      -- Fin 14775
      ELSIF pmodo IN ('P', 'PRIE')
      THEN
         IF pctipreb IN (1, 3)
         THEN
            -- Un solo recibo al tomador o por colectivo.
            IF pttabla = 'SOL'
            THEN
               num_recibo := psseguro;
            ELSE
               num_recibo := f_contador ('04', pcempres);
            END IF;

            -- Si el tipo de recibo es por colectivo:
            -- Generamos el recibo con otra secuencia por que luego pasaremos un proceso que
            -- junte los recibos por poliza (incluyendo los certificados )
            IF pctipreb = 3
            THEN
               xtipo := 'SI';
            ELSE
               xtipo := NULL;
            END IF;

            num_err :=
               pac_adm.f_insrecibo_adm (psseguro,
                                        pcagente,
                                        pfemisio,
                                        pfefecto,
                                        pfvencimi,
                                        pctiprec,
                                        pnanuali,
                                        pnfracci,
                                        pccobban,
                                        pcestimp,
                                        NULL,
                                        num_recibo,
                                        pmodo,
                                        psproces,
                                        pcmovimi,
                                        pnmovimi,
                                        pfefecto,
                                        xtipo,
                                        NULL,
                                        NULL,
                                        pttabla,
                                        pfuncion
                                       );

            IF num_err <> 0
            THEN
               RETURN num_err;
            -- RETURN 103136;
            END IF;

            num_err :=
               pac_adm.f_detrecibo (psproces,
                                    psseguro,
                                    num_recibo,
                                    ptipomovimiento,
                                    pmodo,
                                    pcmodcom,
                                    pfemisio,
                                    pfefecto,
                                    pfvencimi,
                                    pfcaranu,
                                    pnimport,
                                    NULL,
                                    pnmovimi,
                                    pcpoliza,
                                    pnimport2,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    pcgarant,
                                    pttabla,
                                    pfuncion
                                   );

            IF num_err = 103108
            THEN
               --Error controlado
               --no se ha grabado nada en detrecibocar
               --no se emite recibo de ese riesgo
               BEGIN
                  DELETE      tmp_adm_recibos
                        WHERE nrecibo = num_recibo AND sproces = psproces;
               EXCEPTION
                  WHEN OTHERS
                  THEN
                     RETURN 105158;
               END;
            ELSIF num_err NOT IN (0, 105154)
            THEN
               --Devuelve el error de detrecibo
               RETURN num_err;
            -- RETURN 103137;   --Error en la funcion detrecibo
            ELSIF num_err = 105154
            THEN
               v_idioma :=
                       pac_parametros.f_parempresa_n (pcempres, 'IDIOMA_DEF');
               texto := f_axis_literales (num_err, v_idioma);
               num_recibo := NULL;
               pnnumlin := NULL;
               num_err := f_proceslin (psproces, texto, psseguro, pnnumlin);
            ELSE
               -- si no hay error fusionamos los recibos no imprimibles
               IF ptipomovimiento IN (21, 22)
               THEN
                  num_err :=
                     pac_adm.f_tmpfusionsupcar (psseguro,
                                                num_recibo,
                                                pfefecto,
                                                pfemisio,
                                                'P',
                                                psproces
                                               );

                  IF num_err <> 0
                  THEN
                     RETURN num_err;
                  END IF;
               END IF;
            END IF;
         ELSIF pctipreb = 2
         THEN
            -- Un recibo por riesgo(asegurado)
            BEGIN
               FOR rie IN riesgo_modop (pttabla)
               LOOP
                  IF pttabla = 'SOL'
                  THEN
                     num_recibo := psseguro;
                  ELSE
                     num_recibo := f_contador ('04', pcempres);
                  END IF;

                  num_err :=
                     pac_adm.f_insrecibo_adm (psseguro,
                                              pcagente,
                                              pfemisio,
                                              pfefecto,
                                              pfvencimi,
                                              pctiprec,
                                              pnanuali,
                                              pnfracci,
                                              pccobban,
                                              pcestimp,
                                              rie.nriesgo,
                                              num_recibo,
                                              pmodo,
                                              psproces,
                                              pcmovimi,
                                              pnmovimi,
                                              pfefecto,
                                              NULL,
                                              NULL,
                                              NULL,
                                              pttabla,
                                              pfuncion
                                             );

                  IF num_err <> 0
                  THEN
                     RETURN num_err;
                  END IF;

                  num_err :=
                     pac_adm.f_detrecibo (psproces,
                                          psseguro,
                                          num_recibo,
                                          ptipomovimiento,
                                          pmodo,
                                          pcmodcom,
                                          pfemisio,
                                          pfefecto,
                                          pfvencimi,
                                          pfcaranu,
                                          pnimport,
                                          rie.nriesgo,
                                          pnmovimi,
                                          pcpoliza,
                                          pnimport2,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL,
                                          pcgarant,
                                          pttabla,
                                          pfuncion
                                         );

                  IF num_err <> 0
                  THEN
                     IF num_err = 103108
                     THEN
                        --Error controlado
                        --no se ha grabado nada en detrecibo
                        --no se emite recibo de ese riesgo
                        BEGIN
                           DELETE      tmp_adm_recibos
                                 WHERE nrecibo = num_recibo
                                   AND sproces = psproces;
                        EXCEPTION
                           WHEN OTHERS
                           THEN
                              RETURN 105158;
                        END;
                     -- ROLLBACK TO A;
                     ELSIF num_err = 105154
                     THEN
                        -- Error. Nº. asegurados = 0.
                        v_idioma :=
                           pac_parametros.f_parempresa_n (pcempres,
                                                          'IDIOMA_DEF'
                                                         );
                        texto := f_axis_literales (num_err, v_idioma);
                        num_recibo := NULL;
                        pnnumlin := NULL;
                        num_err :=
                             f_proceslin (psproces, texto, psseguro, pnnumlin);
                     ELSE
                        --Error fatal
                        --Se cambia el error a retornar para obtener más información.
                        --RETURN 103138;  --Error para un riesgo en la función detrecibo
                        RETURN num_err;
                     END IF;
                  ELSE
                     -- si no hay error fusionamos los recibos no imprimibles
                     IF ptipomovimiento IN (21, 22)
                     THEN
                        num_err :=
                           pac_adm.f_tmpfusionsupcar (psseguro,
                                                      num_recibo,
                                                      pfefecto,
                                                      pfemisio,
                                                      'P',
                                                      psproces
                                                     );

                        IF num_err <> 0
                        THEN
                           RETURN num_err;
                        END IF;
                     END IF;

                     num_recibo := NULL;
                  --Que calcule el siguiente;
                  END IF;
               END LOOP;
            -- sheila: Aqui miramos si el producto es colectivo y si lo es generamos un recibo
            -- a nombre del tomador para la póliza.
            EXCEPTION
               -- Se producirá una excepción ORA -01002 cuando haya un rollback
               -- en el bucle.
               WHEN OTHERS
               THEN
                  --DBMS_OUTPUT.put_line('err2 ' || SQLERRM);
                  RETURN 104952;                --Error en la función RECRIES
            END;
         ELSIF pctipreb = 4
         THEN
            -- Rebut per aportant
            -- veure si per forma de pagament li toca
            -- cridar a f_insrecibo amb cforpag i cbancar
            -- Necessitem nrenova per obtenir la data de propera cartera per cada aportant
            --BEGIN
            --   SELECT nrenova
            --     INTO lnrenova
            --    FROM seguros
            --    WHERE sseguro = psseguro;
            --EXCEPTION
            --   WHEN OTHERS THEN
            --      RETURN 101919;
            --END;

            --FOR vapo IN capo (psseguro, pfefecto, pnordapo) LOOP
            -- Cal veure si a aquest aportant li toca fer rebut
            -- En cas de nova producció o suplement sempre farem rebut
            -- en cas de renovació mirarem la data de propera cartera
            --IF    pctiprec <> 3
            --   OR vapo.fcarpro = pfefecto THEN
            -- s'ha de calcular la data de venciment del rebut, que serà
            -- la data de propera cartera nova de l'aportant
            --   IF pctiprec = 3 THEN
            --      num_err :=
            --         f_dates_aportant (psseguro, lnrenova, vapo.cforpag,
            --                           vapo.fcarpro, lfcarant_nou,
            --                           lfcarpro_nou);
            --      lfvencim := lfcarpro_nou;

            --      IF num_err <> 0 THEN
            --         RETURN num_err;
            --      END IF;
            --   ELSE
            --      lfvencim := pfvencimi;
            --   END IF;

            -- Bug 7854 - 11/02/2009 - RSC - Recibo del certificado cero.
            -- Recibo del Certificado 0

            --num_recibo := f_contador ('04', pcempres);
            IF pttabla = 'SOL'
            THEN
               num_recibo := psseguro;
            ELSE
               num_recibo := f_contador ('04', pcempres);
            END IF;

            num_err :=
               pac_adm.f_insrecibo_adm (psseguro,
                                        pcagente,
                                        pfemisio,
                                        pfefecto,
                                        pfvencimi,
                                        pctiprec,
                                        pnanuali,
                                        pnfracci,
                                        pccobban,
                                        pcestimp,
                                        NULL,
                                        num_recibo,
                                        pmodo,
                                        psproces,
                                        pcmovimi,
                                        pnmovimi,
                                        pfefecto,
                                        'CERTIF0',
                                        NULL,
                                        NULL,
                                        pttabla,
                                        pfuncion
                                       );

            IF num_err <> 0
            THEN
               RETURN num_err;                --Error en la funcion insrecibo
            ELSE
               num_err :=
                  pac_adm.f_detrecibo (psproces,
                                       psseguro,
                                       num_recibo,
                                       ptipomovimiento,
                                       pmodo,
                                       pcmodcom,
                                       pfemisio,
                                       pfefecto,
                                       pfvencimi,
                                       pfcaranu,
                                       pnimport,
                                       NULL,
                                       pnmovimi,
                                       pcpoliza,
                                       pnimport2,
                                       NULL,
                                       1,
                                       NULL,
                                       NULL,
                                       pcgarant,
                                       pttabla,
                                       pfuncion
                                      );

               IF num_err <> 0
               THEN
                  IF num_err = 103108
                  THEN
                     --Error controlado
                     --no se ha grabado nada en detrecibo
                     --no se emite recibo de ese riesgo
                     BEGIN
                        DELETE      tmp_adm_recibos
                              WHERE nrecibo = num_recibo;
                     EXCEPTION
                        WHEN OTHERS
                        THEN
                           RETURN 105158;
                     END;
                  ELSIF num_err = 105154
                  THEN
                     -- Error. Nº. asegurados = 0.
                     v_idioma :=
                        pac_parametros.f_parempresa_n (pcempres,
                                                       'IDIOMA_DEF');
                     texto := f_axis_literales (num_err, v_idioma);
                     num_recibo := NULL;
                     pnnumlin := NULL;
                     num_err :=
                            f_proceslin (psproces, texto, psseguro, pnnumlin);
                  ELSE
                     --Error fatal
                     --Se cambia el error a retornar para obtener más información.
                     --RETURN 103138;  --Error para un riesgo en la función detrecibo
                     RETURN num_err;
                  END IF;
               ELSE
                  -- si no hay error fusionamos los recibos no imprimibles
                  IF ptipomovimiento IN (21, 22)
                  THEN
                     num_err :=
                        pac_adm.f_tmpfusionsupcar (psseguro,
                                                   num_recibo,
                                                   pfefecto,
                                                   pfemisio,
                                                   'P',
                                                   psproces
                                                  );

                     IF num_err <> 0
                     THEN
                        RETURN num_err;
                     END IF;
                  END IF;
               --num_recibo := NULL;
               --Que calcule el siguiente;
               END IF;
            END IF;

            -- Bug 7854 - 11/02/2009 - RSC - Recibo del certificado cero.
            -- Recibo del Certificado N

            --num_recibo := f_contador ('04', pcempres);

            /*
            IF pttabla = 'SOL' THEN
               num_recibo := psseguro;
            ELSE
               num_recibo := f_contador('04', pcempres);
            END IF;
            */
            num_err :=
               pac_adm.f_insrecibo_adm (psseguro,
                                        pcagente,
                                        pfemisio,
                                        pfefecto,
                                        pfvencimi,
                                        pctiprec,
                                        pnanuali,
                                        pnfracci,
                                        pccobban,
                                        pcestimp,
                                        NULL,
                                        num_recibo,
                                        pmodo,
                                        psproces,
                                        pcmovimi,
                                        pnmovimi,
                                        pfefecto,
                                        'CERTIFN',
                                        NULL,
                                        NULL,
                                        pttabla,
                                        pfuncion
                                       );

            IF num_err <> 0
            THEN
               RETURN num_err;                --Error en la funcion insrecibo
            ELSE
               num_err :=
                  pac_adm.f_detrecibo (psproces,
                                       psseguro,
                                       num_recibo,
                                       ptipomovimiento,
                                       pmodo,
                                       pcmodcom,
                                       pfemisio,
                                       pfefecto,
                                       pfvencimi,
                                       pfcaranu,
                                       pnimport,
                                       NULL,
                                       pnmovimi,
                                       pcpoliza,
                                       pnimport2,
                                       NULL,
                                       2,
                                       NULL,
                                       NULL,
                                       pcgarant,
                                       pttabla,
                                       pfuncion
                                      );

               IF num_err <> 0
               THEN
                  IF num_err = 103108
                  THEN
                     --Error controlado
                     --no se ha grabado nada en detrecibo
                     --no se emite recibo de ese riesgo
                     BEGIN
                        DELETE      tmp_adm_recibos
                              WHERE nrecibo = num_recibo;
                     EXCEPTION
                        WHEN OTHERS
                        THEN
                           RETURN 105158;
                     END;
                  ELSIF num_err = 105154
                  THEN
                     -- Error. Nº. asegurados = 0.
                     v_idioma :=
                        pac_parametros.f_parempresa_n (pcempres,
                                                       'IDIOMA_DEF');
                     texto := f_axis_literales (num_err, v_idioma);
                     num_recibo := NULL;
                     pnnumlin := NULL;
                     num_err :=
                            f_proceslin (psproces, texto, psseguro, pnnumlin);
                  ELSE
                     --Error fatal
                     --Se cambia el error a retornar para obtener más información.
                     --RETURN 103138;  --Error para un riesgo en la función detrecibo
                     RETURN num_err;
                  END IF;
               ELSE
                  -- si no hay error fusionamos los recibos no imprimibles
                  IF ptipomovimiento IN (21, 22)
                  THEN
                     num_err :=
                        pac_adm.f_tmpfusionsupcar (psseguro,
                                                   num_recibo,
                                                   pfefecto,
                                                   pfemisio,
                                                   'P',
                                                   psproces
                                                  );

                     IF num_err <> 0
                     THEN
                        RETURN num_err;
                     END IF;
                  END IF;
               --num_recibo := NULL;
               --Que calcule el siguiente;
               END IF;
            END IF;
         --END IF;
         --END LOOP;
         ------------ FI DELS CANVIS
         END IF;
      -- Bug 14775 - RSC - 10/08/2010 - AGA003 - Error en dades rebut plantilla Condicionat Particular AGA012
      --RETURN 0;
      -- Fin Bug 14775
      END IF;

      --Bug 9028-XVM-280709: Fem el traspas de les taules tmp a les reals.
      IF pmodo NOT IN ('P', 'PRIE') AND ptraspasa = 1
      THEN
         num_err :=
                 pac_adm.f_trasrecibo (pcempres, psseguro, num_recibo, pmodo);

         IF num_err <> 0
         THEN
            RETURN num_err;
         END IF;
      END IF;

      -- Bug 14775 - RSC - 10/08/2010 - AGA003 - Error en dades rebut plantilla Condicionat Particular AGA012
      RETURN 0;
   -- Fin Bug 14755
   END f_recries;

   FUNCTION f_trasrecibo (
      pcempres     IN   NUMBER,
      psseguro     IN   NUMBER,
      num_recibo   IN   NUMBER,
      pmodo        IN   VARCHAR2
   )
      RETURN NUMBER
   IS
      vnrecibo        movrecibo.nrecibo%TYPE;
      --       vnrecibo       NUMBER(9); --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      v_smovrec       movrecibo.smovrec%TYPE;
      v_smovagr       movrecibo.smovagr%TYPE;
      v_smovrec2      movrecibo.smovrec%TYPE;
      v_nrecibo       movrecibo.nrecibo%TYPE;
      v_cusuari       movrecibo.cusuari%TYPE;
      v_smovagr2      movrecibo.smovagr%TYPE;
      v_cestrec       movrecibo.cestrec%TYPE;
      v_cestant       movrecibo.cestant%TYPE;
      v_fmovini       movrecibo.fmovini%TYPE;
      v_fmovfin       movrecibo.fmovfin%TYPE;
      v_fcontab       movrecibo.fcontab%TYPE;
      v_fmovdia       movrecibo.fmovdia%TYPE;
      v_cmotmov       movrecibo.cmotmov%TYPE;
      v_ccobban       movrecibo.ccobban%TYPE;
      v_cdelega       movrecibo.cdelega%TYPE;
      v_ctipcob       movrecibo.ctipcob%TYPE;
      v_fefeadm       movrecibo.fefeadm%TYPE;
      --v_cgescob      movrecibo.cgescob%TYPE;
      v_sreaemi       reasegemi.sreaemi%TYPE;
      v_sreaemi_tmp   reasegemi.sreaemi%TYPE;
   BEGIN
      -- BUG18054:DRA:23/03/2011:Inici
      vnrecibo := pac_adm.f_get_seq_cont (pcempres);

      /****************************************************
      IF pcempres = 1 THEN
         SELECT seq_cont_01.NEXTVAL
           INTO vnrecibo
           FROM DUAL;
      ELSIF pcempres = 2 THEN
         SELECT seq_cont_02.NEXTVAL
           INTO vnrecibo
           FROM DUAL;
      ELSIF pcempres = 3 THEN
         SELECT seq_cont_03.NEXTVAL
           INTO vnrecibo
           FROM DUAL;
      ELSIF pcempres = 4 THEN
         SELECT seq_cont_04.NEXTVAL
           INTO vnrecibo
           FROM DUAL;
      ELSIF pcempres = 5 THEN
         SELECT seq_cont_05.NEXTVAL
           INTO vnrecibo
           FROM DUAL;
      ELSIF pcempres = 6 THEN
         SELECT seq_cont_06.NEXTVAL
           INTO vnrecibo
           FROM DUAL;
      ELSIF pcempres = 7 THEN
         SELECT seq_cont_07.NEXTVAL
           INTO vnrecibo
           FROM DUAL;
      ELSIF pcempres = 8 THEN
         SELECT seq_cont_08.NEXTVAL
           INTO vnrecibo
           FROM DUAL;
      ELSE
         SELECT seq_cont_09.NEXTVAL
           INTO vnrecibo
           FROM DUAL;
      END IF;
      ********************************************/
      -- BUG18054:DRA:23/03/2011:Fi
      IF vnrecibo = 0
      THEN
         RETURN 102876;               -- Número incorrecto de recibo devuelto
      END IF;                                               -- por el contador

      INSERT INTO recibos
                  (nrecibo, cagente, cempres, nmovimi, sseguro, femisio,
                   fefecto, fvencim, ctiprec, cdelega, ccobban, cestaux,
                   nanuali, nfracci, cestimp, nriesgo, cforpag, cbancar,
                   nmovanu, cretenc, pretenc, ncuacoa, ctipcoa, cestsop,
                   cmanual, nperven, ctransf, cgescob, festimp, ctipban,
                   esccero, ctipcob)
         (SELECT vnrecibo, cagente, cempres, nmovimi, sseguro, femisio,
                 fefecto, fvencim, ctiprec, cdelega, ccobban, cestaux,
                 nanuali, nfracci, cestimp, nriesgo, cforpag, cbancar,
                 nmovanu, cretenc, pretenc, ncuacoa, ctipcoa, cestsop,
                 cmanual, nperven, ctransf, cgescob, festimp, ctipban,
                 esccero, ctipcob
            FROM tmp_adm_recibos
           WHERE nrecibo = num_recibo);

      INSERT INTO detrecibos
                  (nrecibo, cconcep, cgarant, nriesgo, iconcep, cageven,
                   nmovima)
         (SELECT vnrecibo, cconcep, cgarant, nriesgo, iconcep, cageven,
                 nmovima
            FROM tmp_adm_detrecibos
           WHERE nrecibo = num_recibo);

      INSERT INTO vdetrecibos
                  (nrecibo, iprinet, irecext, iconsor, ireccon, iips, idgs,
                   iarbitr, ifng, irecfra, idtotec, idtocom, icombru, icomret,
                   idtoom, ipridev, itotpri, itotdto, itotcon, itotimp,
                   itotalr, iderreg, itotrec, icomdev, iretdev, icednet,
                   icedrex, icedcon, icedrco, icedips, iceddgs, icedarb,
                   icedfng, icedrfr, iceddte, iceddco, icedcbr, icedcrt,
                   iceddom, icedpdv, icedreg, icedcdv, icedrdv, it1pri,
                   it1dto, it1con, it1imp, it1rec, it1totr, it2pri, it2dto,
                   it2con, it2imp, it2rec, it2totr, icomcia, icombrui,
                   icomreti, icomdevi, icomdrti, icombruc, icomretc, icomdevc,
                   icomdrtc, iocorec, iimp_1, iimp_2, iimp_3, iimp_4
                                                                    -- 38. 27/03/2012 JGR 0020546/104206
                  )
         (SELECT vnrecibo, iprinet, irecext, iconsor, ireccon, iips, idgs,
                 iarbitr, ifng, irecfra, idtotec, idtocom, icombru, icomret,
                 idtoom, ipridev, itotpri, itotdto, itotcon, itotimp, itotalr,
                 iderreg, itotrec, icomdev, iretdev, icednet, icedrex,
                 icedcon, icedrco, icedips, iceddgs, icedarb, icedfng,
                 icedrfr, iceddte, iceddco, icedcbr, icedcrt, iceddom,
                 icedpdv, icedreg, icedcdv, icedrdv, it1pri, it1dto, it1con,
                 it1imp, it1rec, it1totr, it2pri, it2dto, it2con, it2imp,
                 it2rec, it2totr, icomcia, icombrui, icomreti, icomdevi,
                 icomdrti, icombruc, icomretc, icomdevc, icomdrtc, iocorec,
                 iimp_1, iimp_2, iimp_3,
                 iimp_4                   -- 38. 27/03/2012 JGR 0020546/104206
            FROM tmp_adm_vdetrecibos
           WHERE nrecibo = num_recibo);

      BEGIN
         SELECT smovrec.NEXTVAL
           INTO v_smovrec
           FROM DUAL;
      EXCEPTION
         WHEN OTHERS
         THEN
            RETURN 104060;
      END;

      BEGIN
         SELECT smovagr.NEXTVAL
           INTO v_smovagr
           FROM DUAL;
      EXCEPTION
         WHEN OTHERS
         THEN
            RETURN 104061;    -- Error al llegir la seqüència (smovagr) de BD
      END;

      UPDATE tmp_adm_movrecibo
         SET smovrec = v_smovrec,
             smovagr = v_smovagr
       WHERE nrecibo = num_recibo;

      SELECT smovrec, nrecibo, cusuari, smovagr, cestrec,
             cestant, fmovini, fmovfin, fcontab, fmovdia,
             cmotmov, ccobban, cdelega, ctipcob, fefeadm
        INTO v_smovrec2, v_nrecibo, v_cusuari, v_smovagr2, v_cestrec,
             v_cestant, v_fmovini, v_fmovfin, v_fcontab, v_fmovdia,
             v_cmotmov, v_ccobban, v_cdelega, v_ctipcob, v_fefeadm
        FROM tmp_adm_movrecibo
       WHERE nrecibo = num_recibo;

      INSERT INTO movrecibo
                  (smovrec, nrecibo, cusuari, smovagr, cestrec,
                   cestant, fmovini, fmovfin, fcontab, fmovdia,
                   cmotmov, ccobban, cdelega, ctipcob, fefeadm, cgescob
                  )
           VALUES (v_smovrec2, vnrecibo, v_cusuari, v_smovagr2, v_cestrec,
                   v_cestant, v_fmovini, v_fmovfin, v_fcontab, v_fmovdia,
                   v_cmotmov, v_ccobban, v_cdelega, v_ctipcob, NULL, NULL
                  );

      INSERT INTO recibosredcom
                  (nrecibo, cempres, cagente, ctipage, nnivel)
         (SELECT vnrecibo, cempres, cagente, ctipage, nnivel
            FROM tmp_adm_recibosredcom
           WHERE nrecibo = num_recibo);

------------------
-- Reaseguro
------------------
      BEGIN
         SELECT sreaemi
           INTO v_sreaemi_tmp
           FROM tmp_adm_reasegemi
          WHERE nrecibo = num_recibo;

         BEGIN
            SELECT sreaemi.NEXTVAL
              INTO v_sreaemi
              FROM DUAL;
         EXCEPTION
            WHEN OTHERS
            THEN
               RETURN 104061; -- Error al llegir la seqüència (smovagr) de BD
         END;

         INSERT INTO reasegemi
                     (sreaemi, sseguro, nrecibo, nfactor, fefecte, fvencim,
                      fcierre, fgenera, cmotces, sproces)
            (SELECT v_sreaemi, sseguro, nrecibo, nfactor, fefecte, fvencim,
                    fcierre, fgenera, cmotces, sproces
               FROM tmp_adm_reasegemi
              WHERE nrecibo = num_recibo);

         INSERT INTO detreasegemi
                     (sreaemi, cgarant, icesion, scontra, nversio, ctramo,
                      ipritarrea, idtosel, psobreprima, scesrea, nriesgo,
                      pcesion, sfacult, icapces, iextrap, iextrea)
            (SELECT v_sreaemi, cgarant, icesion, scontra, nversio, ctramo,
                    ipritarrea, idtosel, psobreprima, scesrea, nriesgo,
                    pcesion, sfacult, icapces, iextrap, iextrea
               FROM tmp_adm_detreasegemi
              WHERE sreaemi = v_sreaemi_tmp);
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            NULL;
      END;

      DELETE FROM tmp_adm_recibosredcom
            WHERE nrecibo = num_recibo;

      DELETE FROM tmp_adm_recibos
            WHERE nrecibo = num_recibo;

      DELETE FROM tmp_adm_detrecibos
            WHERE nrecibo = num_recibo;

      DELETE FROM tmp_adm_vdetrecibos
            WHERE nrecibo = num_recibo;

      DELETE FROM tmp_adm_movrecibo
            WHERE nrecibo = num_recibo;

------------------
-- Reaseguro
------------------
      DELETE FROM tmp_adm_detreasegemi
            WHERE sreaemi = v_sreaemi_tmp;

      DELETE FROM tmp_adm_reasegemi
            WHERE nrecibo = num_recibo;

      RETURN 0;
   EXCEPTION
      WHEN OTHERS
      THEN
         RETURN 9002042;                         --Error al traspassar rebuts
   END f_trasrecibo;

   /****************************************************************************
      F_INSRECIBO : Insertar un registro en la tabla de recibos.
      A Gestión de datos referentes a los recibos
       Controlar error de si f_contador retorna 0
      (quiere decir que nrecibo = 0 (error))
       Afegim les insercions en RECIBOSREDCOM
       Afegim el camp CDELEGA a la taula RECIBOS
       Afegim els paràmetres pnriesgo, psmovseg,
      i la funció f_movrecibo.
      Segons el nou paràmetre pmodo, s' ha de
      grabar a la taula RECIBOS o RECIBOSCAR(es graba el nou paràmetre
      psproces).
      S' afegeix la funció f_insrecibor, per a grabar
      les dades a la xarxa comercial.
      Per correduria s'informen els camps cestaux y cestimp.
      De la select principal, se recuperan ctipemp y cforpag.
      S'afegeix el nou mode ='H' per rehabilitació de riscos i
                    garanties.
       Traballi amb l'agent de venda i permeti digits control "00"
    Si P_CCOBBAN es nulo hacía que el RECIBOS.CESTIMP se grabara
         con un 1 de pendiente de imprimir, incluso cuando el recibo es bancario,
         corregida 1a select para que lo decida dependiendo el CCOBBAN que grabamos en el recibo.

     {Se añaden los parametros funcion y tabla para el calculo del primer recibo al tarifar,
      el parametro tabla indica a que tablas tiene que ir a buscar importes ('EST','SOL',NULLL),
      el parametro función indica si estoy tarifando (TAR) o en la cartera o previo de cartera (CAR)
     }
      Se añade el ctipban (tipo de CCC) y se mofica la llamada a F_CCC
   ****************************************************************************/
   FUNCTION f_insrecibo_adm (
      psseguro   IN       NUMBER,
      pcagente   IN       NUMBER,
      pfemisio   IN       DATE,
      pfefecto   IN       DATE,
      pfvencim   IN       DATE,
      pctiprec   IN       NUMBER,
      pnanuali   IN       NUMBER,
      pnfracci   IN       NUMBER,
      pccobban   IN       NUMBER,
      pcestimp   IN       NUMBER,
      pnriesgo   IN       NUMBER,
      pnrecibo   IN OUT   NUMBER,
      pmodo      IN       VARCHAR2,
      psproces   IN       NUMBER,
      pcmovimi   IN       NUMBER,
      pnmovimi   IN       NUMBER,
      pfmovini   IN       DATE,
      ptipo      IN       VARCHAR2 DEFAULT NULL,
      pcforpag   IN       NUMBER DEFAULT NULL,
      -- Si es passen el paràmetres
      pcbancar   IN       VARCHAR2 DEFAULT NULL,
      --  no s'agafen de seguros (dades de l'aportant)
      pttabla    IN       VARCHAR2 DEFAULT NULL,
      pfuncion   IN       VARCHAR2 DEFAULT 'CAR',
      pctipban   IN       NUMBER DEFAULT NULL
   )
      RETURN NUMBER
   IS
      error          NUMBER                           := 0;
      num_err        NUMBER                           := 0;
      xcagente       tmp_adm_recibos.cagente%TYPE;
      --       xcagente       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xnanuali       tmp_adm_recibos.nanuali%TYPE;
      --       xnanuali       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xnfracci       tmp_adm_recibos.nfracci%TYPE;
      --       xnfracci       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xccobban       tmp_adm_recibos.ccobban%TYPE;
      --       xccobban       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xcestimp       tmp_adm_recibos.cestimp%TYPE;
      --       xcestimp       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xcempres       tmp_adm_recibos.cempres%TYPE;
      --       xcempres       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xsmovrec       tmp_adm_movrecibo.smovrec%TYPE;
      --       xsmovrec       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      --xnliqmen       NUMBER;
      xcforpag       tmp_adm_recibos.cforpag%TYPE;
      --       xcforpag       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xcbancar       seguros.cbancar%TYPE;
      dummy          segcleafrac.sseguro%TYPE;
      --       dummy          NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xnbancar       seguros.cbancar%TYPE;
      xnbancarf      seguros.cbancar%TYPE;
      xtbancar       seguros.cbancar%TYPE;
      xncuacoa       tmp_adm_recibos.ncuacoa%TYPE;
      --       xncuacoa       NUMBER;   -- Coaseguro --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xctipcoa       tmp_adm_recibos.ctipcoa%TYPE;
      --       xctipcoa       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xcestaux       tmp_adm_recibos.cestaux%TYPE;
      --       xcestaux       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xcestsop       tmp_adm_recibos.cestsop%TYPE;
      --       xcestsop       NUMBER;   -- generacion de soportes --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xfmovim        DATE;
      xnperven       tmp_adm_recibos.nperven%TYPE;
      --       xnperven       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xcdelega       tmp_adm_recibos.cdelega%TYPE;
      --       xcdelega       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xctipemp       estseguros.cforpag%TYPE;
      --       xctipemp       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xctippag       estseguros.cbancar%TYPE;
      --       xctippag       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xccarpen       estseguros.ncuacoa%TYPE;
      --       xccarpen       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xcgescob       tmp_adm_recibos.cgescob%TYPE;
      --       xcgescob       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      quants         NUMBER;
      xcperven       NUMBER;
      xcdelega2      NUMBER;
      xctipban       seguros.ctipban%TYPE;
      xctipcob       movrecibo.ctipcob%TYPE;
      xcbancob       parempresas.nvalpar%TYPE;
      --       xcbancob       NUMBER(1); --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xcmanual       tmp_adm_recibos.cmanual%TYPE;
      --       xcmanual       NUMBER(1); --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      -- Bug 7854 - 11/02/2009 - RSC - Recibo del certificado cero.
      xesccero       NUMBER                           := 0;
      -- Bug 9383 - 05/03/2009 - RSC - CRE - Unificación de recibos
      xsproduc       productos.sproduc%TYPE;
      xcerosseguro   seguros.sseguro%TYPE;
      xcerocagente   seguros.cagente%TYPE;
      xceroccobban   seguros.ccobban%TYPE;
      xcerocbancar   seguros.cbancar%TYPE;
      xceronbancar   seguros.cbancar%TYPE;
      xcerotbancar   seguros.cbancar%TYPE;
      xceroctipban   seguros.ctipban%TYPE;
      -- Bug 7854 - 11/02/2009 - RSC - Recibo del certificado cero.
      dummy1         NUMBER;
      dummy2         seguros.cbancar%TYPE;
   BEGIN
      IF pttabla = 'SOL'
      THEN
         BEGIN
            SELECT NVL (pcagente, s.cagente),
                   DECODE (NVL (a.csoprec, 0), 0, 0, 1),  -- estado de soporte
                   NVL (pcestimp,
                        DECODE (a.csoprec,
                                2, 0,
                                DECODE (pccobban, NULL, 1, 4)
                               )
                       ),
                   -- est. de imp.
                   s.cforpag, p.ctippag, p.ccarpen, 1 cempres,
                   p.sproduc                                 -- RSC 04/03/2009
              INTO xcagente,
                   xcestsop,
                   xcestimp,
                   xcforpag, xctippag, xccarpen, xcempres,
                   xsproduc
              FROM agentes a, solseguros s, productos p
             WHERE s.ssolicit = psseguro
               AND a.cagente = s.cagente
               AND s.cramo = p.cramo
               AND s.cmodali = p.cmodali
               AND s.ctipseg = p.ctipseg
               AND s.ccolect = p.ccolect;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               RETURN 101903;             -- Assegurança no trobada a SEGUROS
            WHEN OTHERS
            THEN
               RETURN 101919;                   -- Error al llegir de SEGUROS
         END;
      ELSIF pttabla = 'EST'
      THEN
         BEGIN
            SELECT NVL (pcagente, s.cagente), NVL (pnanuali, s.nanuali),
                   NVL (pnfracci, s.nfracci), NVL (pccobban, s.ccobban),
                   DECODE (NVL (a.csoprec, 0), 0, 0, 1),  -- estado de soporte
                   NVL (pcestimp,
                        DECODE (a.csoprec,
                                2, 0,
                                DECODE (pccobban, NULL, 1, 4)
                               )
                       ),
                   -- est. de imp.
                   s.cforpag, s.cbancar, s.ncuacoa, s.ctipcoa, s.cempres,
                   e.ctipemp, p.ctippag, p.ccarpen,              --, s.cgescob
                                                   s.ctipban, s.ctipcob,
                   p.sproduc                                 -- RSC 04/03/2009
              INTO xcagente, xnanuali,
                   xnfracci, xccobban,
                   xcestsop,
                   xcestimp,
                   xcforpag, xcbancar, xncuacoa, xctipcoa, xcempres,
                   xctipemp, xctippag, xccarpen,                  --, xcgescob
                                                xctipban, xctipcob,
                   xsproduc
              FROM agentes a, estseguros s, empresas e, productos p
             WHERE s.sseguro = psseguro
               AND a.cagente = s.cagente
               AND e.cempres = s.cempres
               AND s.cramo = p.cramo
               AND s.cmodali = p.cmodali
               AND s.ctipseg = p.ctipseg
               AND s.ccolect = p.ccolect;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               RETURN 101903;             -- Assegurança no trobada a SEGUROS
            WHEN OTHERS
            THEN
               RETURN 101919;                   -- Error al llegir de SEGUROS
         END;
      ELSE
         BEGIN
            SELECT NVL (pcagente, s.cagente), NVL (pnanuali, s.nanuali),
                   NVL (pnfracci, s.nfracci), NVL (pccobban, s.ccobban),
                   DECODE (NVL (a.csoprec, 0), 0, 0, 1),  -- estado de soporte
                   NVL (pcestimp,
                        DECODE (a.csoprec,
                                2, 0,
                                DECODE (NVL (pccobban, s.ccobban),
                                        NULL, 1,
                                        4
                                       )
                               )
                       ),
                   -- est. de imp.
                   NVL (pcforpag, s.cforpag), NVL (pcbancar, s.cbancar),
                   NVL (pctipban, s.ctipban), s.ncuacoa, s.ctipcoa,
                   s.cempres, e.ctipemp, p.ctippag, p.ccarpen, s.ctipcob,
                   p.sproduc                                 -- RSC 04/03/2009
              INTO xcagente, xnanuali,
                   xnfracci, xccobban,
                   xcestsop,
                   xcestimp,
                   xcforpag, xcbancar,
                   xctipban, xncuacoa, xctipcoa,
                   xcempres, xctipemp, xctippag, xccarpen, xctipcob,
                   xsproduc
              FROM agentes a, seguros s, empresas e, productos p
             WHERE s.sseguro = psseguro
               AND a.cagente = s.cagente
               AND e.cempres = s.cempres
               AND s.cramo = p.cramo
               AND s.cmodali = p.cmodali
               AND s.ctipseg = p.ctipseg
               AND s.ccolect = p.ccolect;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               RETURN 101903;             -- Assegurança no trobada a SEGUROS
            WHEN OTHERS
            THEN
               RETURN 101919;                   -- Error al llegir de SEGUROS
         END;
      END IF;

      IF xctipcoa = 8
      THEN
         -- Es un coaseguro aceptado de recibo unico
         xcestimp := 0;                                 -- No debe imprimirse
      END IF;

      IF xctipcoa = 8 OR xctipcoa = 9
      THEN
         -- Es un coaseguro aceptado
         xcestaux := 1;             -- Recibo retenido (por ser de coaseguro)
      ELSE
         xcestaux := 0;                     -- Recibo válido (útil, en vigor)
      END IF;

      -- Bug 9383 - 05/03/2009 - RSC - CRE - Unificación de recibos
      IF NVL (f_parproductos_v (xsproduc, 'RECUNIF'), 0) IN (1, 3)
      THEN
         -- BUG 0019627: GIP102 - Reunificación de recibos - FAL - 10/11/2011
         IF    (pctiprec = 3 AND NVL (ptipo, 'NO') = 'CERTIF0'
               )                        -- Recibos de cartera de certificado 0
            OR (    NVL (f_parproductos_v (xsproduc, 'RECUNIF_NP'), 0) = 1
                AND NVL (ptipo, 'NO') = 'CERTIF0'
               )
         THEN
            xcestaux := 2;
         END IF;
      END IF;

      IF xcbancar IS NOT NULL
      THEN
         xnbancar := xcbancar;         --TO_NUMBER (xcbancar); JFD 01/10/2007
         --error       := f_ccc (xnbancar, dummy, xnbancarf);
         error := f_ccc (xnbancar, xctipban, dummy, xnbancarf);

         IF    error = 0
            OR (error = 102493 AND f_parinstalacion_n ('DIGICTRL00') = 1)
         THEN
            --> Permite dígito control = '00'
            xtbancar := xcbancar; ---LPAD (xnbancarf, 20, '0');JFD 01/10/2007
         ELSE
            RETURN error;
         END IF;
      END IF;

      -- Per correduria s'informen els camps cestaux y cestimp.
      -- Afegim el camp cgescob (1 - Cobra la corredoria, 2 - Cobra la cia)
      --                 Afegim el control de si cal que quedin pendents de validar els
      --                 rebuts de cartera (ccarpen = 0 NO, 1 Si)
      IF NVL (xctipemp, 0) = 1
      THEN
         -- Correduria
         --
         -- Rebuts pendents de validar xccarpen : 0 - No , 1 - Cartera, 2 - NP i Cartera
         --
         IF (pctiprec <> 0) AND NVL (xccarpen, 0) <> 0
         THEN
            xcestaux := 1;
         -- Pendent de validar amb la cia. els que no son nova producció
         ELSIF NVL (xccarpen, 0) = 2
         THEN
            xcestaux := 1;                  -- Pendent de validar amb la cia.
         ELSE
            xcestaux := 0;
         END IF;

         -- Bug 9383 - 05/03/2009 - RSC - CRE - Unificación de recibos
         IF NVL (f_parproductos_v (xsproduc, 'RECUNIF'), 0) IN (1, 3)
         THEN
            -- BUG 0019627: GIP102 - Reunificación de recibos - FAL - 10/11/2011
            IF pctiprec = 3 AND NVL (ptipo, 'NO') = 'CERTIF0'
            THEN
               -- Recibos de cartera de certificado 0
               xcestaux := 2;
            END IF;
         END IF;

         --
         -- Gestio de cobrament ctippag : 3 - Gestiona la cia, 4 - Gest. Cia excepte 1º rebut
         --
         xcgescob := 1;                                 -- Gestiona Corredoria

         IF pctiprec = 0 AND xctippag = 3
         THEN
            -- NP i gestiona la Cia
            xcestimp := 0;                                   -- No imprimible
            xcgescob := 2;                      -- Gestió de cobrament la cia
         END IF;

         IF (pctiprec <> 0) AND xctippag IN (3, 4)
         THEN
            -- Cobra la cia.
            xcestimp := 0;
            xcgescob := 2;
         END IF;
      END IF;

      xcdelega := f_delega (psseguro, pfefecto);

      -- Bug 19096 - RSC - 03/08/2011 - LCOL - Parametrización básica producto Vida Individual Pagos Permanentes (Añadimos RRIE)
      IF    pmodo = 'R'
         OR pmodo = 'A'
         OR pmodo = 'ANP'
         OR pmodo = 'H'
         OR pmodo = 'RRIE'
      THEN
         -- !!!! ---- SGA --------- controla si es una polissa provinent del estudis. no s'imprimeix
         IF pctiprec = 0
         THEN
            quants := 0;

            BEGIN
               SELECT COUNT (*)
                 INTO quants
                 FROM cnvpolizas
                WHERE sistema = 'ES'
                  AND NVL (f_parinstalacion_t ('CODIINST'), ' ') = 'SGA'
                  AND sseguro = psseguro;
            EXCEPTION
               WHEN OTHERS
               THEN
                  quants := 0;
            END;

            IF quants <> 0
            THEN
               xcestimp := 0;            -- Es un estudi. No debe imprimirse.
            END IF;
         END IF;

-- !!! -------------------------------------------------------------------
         IF pnrecibo IS NULL OR pnrecibo = 0
         THEN
            IF NVL (ptipo, 'NO') = 'SI'
            THEN
               -- Si esta variable esta informada significa que generamos los recibos con una
               -- secuencia "ficticia" por que luego en la emisión de pólizas y despues de la cartera se pasará un proceso
               -- que juntara todos los recibos por póliza colectiva en uno !

               -- Bug XXXX - RSC - 29/07/2010 - Recibos temporales
               SELECT seq_nrectmp.NEXTVAL
                 INTO pnrecibo
                 FROM DUAL;

               INSERT INTO tmp_adm_recibos
                           (sproces, nrecibo, sseguro
                           )
                    VALUES (psproces, pnrecibo, psseguro
                           );
            -- Bug XXXX - RSC - 29/07/2010 - Recibos temporales
            ELSE
               SELECT seq_nrectmp.NEXTVAL
                 INTO pnrecibo
                 FROM DUAL;
            END IF;

            -- Fin Bug XXXX

            --  Segons el par instal.lació , utilitzarem el peride de venda segons
            --  vendes o meritació
            xcperven := NVL (f_parinstalacion_n ('PERMERITA'), 0);

            IF xcperven = 1
            THEN
               xnperven :=
                  pac_merita.f_permerita (pctiprec,
                                          pfemisio,
                                          pfefecto,
                                          xcempres
                                         );
            ELSE
               xnperven := f_perventa (NULL, pfemisio, pfefecto, xcempres);
            END IF;

            --JTS 18/12/2008 APRA 8437
            BEGIN
               SELECT nvalpar
                 INTO xcbancob
                 FROM parempresas
                WHERE cparam = 'CBANCOB' AND cempres = xcempres;
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  xcbancob := NULL;
                  xcmanual := NULL;
            END;

            BEGIN
               -- Bug 10787 - APD - 24/07/2009 - se modifica la condición IF ya que puede ser que
               -- el valor de la variable xcbancob sea 0 y no se quiere que entre en el IF
               --         IF xcbancob IS NOT NULL THEN
               IF NVL (xcbancob, 0) = 1
               THEN
                  IF xcbancob = 1 AND xctipcob = 2
                  THEN
                     SELECT cbancob
                       INTO xtbancar
                       FROM seg_cbancar
                      WHERE sseguro = psseguro
                        --AND nmovimi = pnmovimi --BUG 9868 - 21/04/2009 - JTS
                        AND TRUNC (finiefe) <= TRUNC (pfefecto)
                        --BUG 12897 - 29/01/2010 - JMF
                        --AND NVL(TRUNC(ffinefe), TRUNC(pfefecto)) >= TRUNC(pfefecto);
                        AND NVL (TRUNC (ffinefe), TRUNC (pfefecto) + 1) >
                                                              TRUNC (pfefecto);

                     IF xtbancar IS NULL
                     THEN
                        xcmanual := 1;
                        xcestimp := 1;          --BUG 9868 - 21/04/2009 - JTS
                        xccobban := NULL;
                     ELSE
                        xcmanual := 2;
                     END IF;
                  ELSE
                     xcmanual := 1;
                     xcestimp := 1;             --BUG 9868 - 21/04/2009 - JTS
                     xtbancar := NULL;
                  END IF;
               END IF;
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  xcmanual := 1;
                  xcestimp := 1;                --BUG 9868 - 21/04/2009 - JTS
                  xtbancar := NULL;
                  xccobban := NULL;
            END;

            --JTS

            --  BUG 001248  MCA     28/12/2009
            IF xctipcob = 4
            THEN
               --Tipo de cobro Broker
               xcgescob := 3;   -- La gestión del recibo es 'Gestiona Broker'
            ELSE
               xcgescob := NULL;
            END IF;

            --  Fin BUG 001248

            -- Bug 7854 y 8745 - 11/02/2009 - RSC - Adaptación iAxis a productos colectivos con certificados y
            -- Bug 5467 - 10/02/2009 - RSC - CRE - Desarrollo de sistema de copago
            IF NVL (ptipo, 'NO') = 'CERTIF0'
            THEN
               xesccero := 1;

               -- Bug 9383 - 05/03/2009 - RSC -  CRE: Unificación de recibos
               SELECT s1.sseguro, s1.cagente, s1.ccobban,
                      s1.cbancar, s1.ctipban
                 INTO xcerosseguro, xcerocagente, xceroccobban,
                      xcerocbancar, xceroctipban
                 FROM seguros s1, seguros s2
                WHERE s1.npoliza = s2.npoliza
                  AND s1.ncertif = 0
                  AND s2.sseguro = psseguro;

               -- Bug 9383 - 05/03/2009 - RSC -  CRE: Unificación de recibos
               IF xcerocbancar IS NOT NULL
               THEN
                  xceronbancar := xcerocbancar;
                  error := f_ccc (xceronbancar, xceroctipban, dummy1, dummy2);

                  IF    error = 0
                     OR (    error = 102493
                         AND f_parinstalacion_n ('DIGICTRL00') = 1
                        )
                  THEN
                     xcerotbancar := xcerocbancar;
                  ELSE
                     RETURN error;
                  END IF;
               END IF;

               BEGIN
                  -- Bug 10787 - APD - 24/07/2009 - Campo CTIPCOB a nivel de recibo
                  -- se añade el campo ctipcob en la tabla recibos
                  -- se informa su valor con el valor que tenga en ese momento el
                  -- campot ctipcob de la tabla seguros

                  -- Bug 11905 - 12/11/2009 - RSC - CRE201- Error en el agente de recibos de tomador del colectivo
                  -- Para el recibo del certificado 0 se debe grabar el agente del certificado N.
                  INSERT INTO tmp_adm_recibos
                              (nrecibo, sseguro, cagente, femisio,
                               fefecto, fvencim, ctiprec, cestaux,
                               nanuali, nfracci, ccobban, cestimp,
                               cempres, cdelega, nriesgo, cforpag,
                               cbancar, nmovimi, ncuacoa, ctipcoa,
                               cestsop, nperven, cgescob, ctipban,
                               cmanual, esccero, ctipcob
                              )
                       VALUES (pnrecibo, psseguro, xcerocagente, pfemisio,
                               pfefecto, pfvencim, pctiprec, xcestaux,
                               xnanuali, xnfracci, xceroccobban, xcestimp,
                               xcempres, xcdelega, pnriesgo, xcforpag,
                               xcerotbancar, pnmovimi, xncuacoa, xctipcoa,
                               xcestsop, xnperven, xcgescob, xceroctipban,
                               xcmanual, xesccero, xctipcob
                              );
               -- Bug 10787 - APD - 24/07/2009 - fin Campo CTIPCOB a nivel de recibo
               -- Fin Bug 11905
               EXCEPTION
                  WHEN DUP_VAL_ON_INDEX
                  THEN
                     RETURN 102307;            -- Registre duplicat a RECIBOS
                  WHEN OTHERS
                  THEN
                     p_tab_error (f_sysdate,
                                  f_user,
                                  'PAC_ADM.F_INSRECIBO',
                                  0,
                                  'Error 103847',
                                  SQLERRM
                                 );
                     RETURN 103847;            -- Error a l' inserir a RECIBOS
               END;
            ELSE
               BEGIN
                  -- Bug 10787 - APD - 24/07/2009 - Campo CTIPCOB a nivel de recibo
                  -- se añade el campo ctipcob en la tabla recibos
                  -- se informa su valor con el valor que tenga en ese momento el
                  -- campot ctipcob de la tabla seguros
                  INSERT INTO tmp_adm_recibos
                              (nrecibo, sseguro, cagente, femisio,
                               fefecto, fvencim, ctiprec, cestaux,
                               nanuali, nfracci, ccobban, cestimp,
                               cempres, cdelega, nriesgo, cforpag,
                               cbancar, nmovimi, ncuacoa, ctipcoa,
                               cestsop, nperven, cgescob, ctipban,
                               cmanual, esccero, ctipcob
                              )
                       VALUES (pnrecibo, psseguro, xcagente, pfemisio,
                               pfefecto, pfvencim, pctiprec, xcestaux,
                               xnanuali, xnfracci, xccobban, xcestimp,
                               xcempres, xcdelega, pnriesgo, xcforpag,
                               xtbancar, pnmovimi, xncuacoa, xctipcoa,
                               xcestsop, xnperven, xcgescob, xctipban,
                               xcmanual, 0, xctipcob
                              );
               EXCEPTION
                  WHEN DUP_VAL_ON_INDEX
                  THEN
                     RETURN 102307;            -- Registre duplicat a RECIBOS
                  WHEN OTHERS
                  THEN
                     p_tab_error (f_sysdate,
                                  f_user,
                                  'PAC_ADM.F_INSRECIBO',
                                  0,
                                  'Error 103847',
                                  SQLERRM
                                 );
                     RETURN 103847;            -- Error a l' inserir a RECIBOS
               END;
            END IF;

--------------------------------------------------------------------------
-- Grabamos la redcomercial. Cuando se haya adaptado todo a seguredcom podrá eliminarse
            num_err :=
               pac_adm.f_tmpinsrecibor (pnrecibo, xcempres, xcagente,
                                        pfemisio);

            IF num_err = 0
            THEN
               xsmovrec := 0;

               IF pfemisio < pfefecto
               THEN
                  xfmovim := pfefecto;
               ELSE
                  xfmovim := pfemisio;
               END IF;

               IF f_parinstalacion_n ('AGTEVENTA') = 1
               THEN
                  xcdelega2 := xcagente;
               ELSE
                  xcdelega2 :=
                            f_delegacion (NULL, xcempres, xcagente, pfemisio);
               END IF;

               -- Damos de alta el movimiento
               num_err :=
                  pac_adm.f_tmpmovrecibo (pnrecibo,
                                          0,
                                          xsmovrec,
                                          xfmovim,
                                          xccobban,
                                          xcdelega2,
                                          NULL
                                         );
               RETURN num_err;
            ELSE
               RETURN num_err;
            END IF;
         -- Bug XXXX - RSC - 29/07/2010 - Recibos temporales
         --END IF;
         -- Fin Bug XXXX
         END IF;
      ELSIF pmodo IN ('P', 'PRIE')
      THEN
         IF     pnrecibo IS NOT NULL
            AND pnrecibo <> 0
            AND psproces IS NOT NULL
            AND psproces <> 0
         THEN
            BEGIN
               INSERT INTO tmp_adm_recibos
                           (sproces, nrecibo, sseguro, cagente,
                            femisio, fefecto, fvencim, ctiprec,
                            cestaux, nanuali, nfracci, ccobban,
                            cestimp, cempres, cdelega, nriesgo,
                            ncuacoa, ctipcoa, cestsop, cgescob
                           )
                    VALUES (psproces, pnrecibo, psseguro, xcagente,
                            pfemisio, pfefecto, pfvencim, pctiprec,
                            xcestaux, xnanuali, xnfracci, xccobban,
                            xcestimp, xcempres, xcdelega, pnriesgo,
                            xncuacoa, xctipcoa, xcestsop, xcgescob
                           );
            EXCEPTION
               WHEN DUP_VAL_ON_INDEX
               THEN
                  RETURN 9001956;      -- Registre duplicat a tmp_adm_recibos
               WHEN OTHERS
               THEN
                  RETURN 9001957;     -- Error a l' inserir a tmp_adm_recibos
            END;

            RETURN 0;
         ELSE
            RETURN 101901;        -- Pas incorrecte de paràmetres a la funció
         END IF;
      ELSIF pmodo = 'N'
      THEN
         IF     pnrecibo IS NOT NULL
            AND pnrecibo <> 0
            AND psproces IS NOT NULL
            AND psproces <> 0
         THEN
            BEGIN
               INSERT INTO tmp_adm_recibos
                           (sproces, nrecibo, sseguro, cagente,
                            femisio, fefecto, fvencim, ctiprec, cestaux,
                            nanuali, nfracci, ccobban, cestimp, cempres,
                            cdelega, nriesgo, ncuacoa, ctipcoa, cestsop,
                            cgescob
                           )
                    VALUES (psproces, pnrecibo, psseguro, xcagente,
                            f_sysdate, f_sysdate, f_sysdate, 0, xcestaux,
                            NULL, NULL, NULL, NULL, xcempres,
                            NULL, NULL, xncuacoa, xctipcoa, xcestsop,
                            xcgescob
                           );
            EXCEPTION
               WHEN DUP_VAL_ON_INDEX
               THEN
                  RETURN 103355;            -- Registre duplicat a RECIBOSCAR
               WHEN OTHERS
               THEN
                  RETURN 103848;           -- Error a l' inserir a RECIBOSCAR
            END;

            RETURN 0;
         ELSE
            RETURN 101901;        -- Pas incorrecte de paràmetres a la funció
         END IF;
      ELSE
         RETURN 101901;           -- Pas incorrecte de paràmetres a la funció
      END IF;
   END f_insrecibo_adm;

   FUNCTION f_detrecibo (
      pnproces          IN       NUMBER,
      psseguro          IN       NUMBER,
      pnrecibo          IN       NUMBER,
      ptipomovimiento   IN       NUMBER,
      pmodo             IN       VARCHAR2,
      pcmodcom          IN       NUMBER,
      pfemisio          IN       DATE,
      pfefecto          IN       DATE,
      pfvencim          IN       DATE,
      pfcaranu          IN       DATE,
      pnimport          IN       NUMBER,
      pnriesgo          IN       NUMBER,
      pnmovimi          IN       NUMBER,
      pcpoliza          IN       NUMBER,
      pnimport2         OUT      NUMBER,
      pcfpagapo         IN       NUMBER DEFAULT NULL,
      pctipapo          IN       NUMBER DEFAULT NULL,
      ppimpapo          IN       NUMBER DEFAULT NULL,
      piimpapo          IN       NUMBER DEFAULT NULL,
      pcgarant          IN       NUMBER DEFAULT NULL,
      pttabla           IN       VARCHAR2 DEFAULT NULL,
      pfuncion          IN       VARCHAR2 DEFAULT 'CAR'
   )
      RETURN NUMBER
   IS
      /* ******************************************************************
      - Obté el desglòs per risc i garantia de cadascun
      dels conceptes que formen un rebut. L' origen de la informació són les
      garanties que té l' assegurança amb els seus capitals i primes.
      - S' ha tret el càlcul del concepte 9 (Descompte tècnic).
      Per a veure si s' aplica el recàrrec per fraccionament, mirem
      també el camp crecfra, de la taula SEGUROS. També altres modificacions
      per la taula GARANCAR.
      - En el cas de proves = 'P', només en el tipus de moviment = 21
      accedirem a GARANCAR; en els altres casos, accedirem a
      GARANSEG / GARANCOLEC (depenent de si el producte és innominat o no).
      - S' afegeix funció f_vdetrecibo per omplir taula vdetrecibos i
      càlcul de l' impost FNG.
      - Modificaciones debido a la implantacion del COASEGURO.
      Donde si es un coaseguro cedido se debe repetir todos los registros
      de detrecibo por todos los conceptos sumados 50 en su codigo.
      En las extraordinarias no se coaseguran nunca.
      - CAMBIOS EN CONCEPTOS EN TABLAS POR COASEGURO
      - Iprianu ahora tendra el importe de la parte local
      - Ipritot tendra el importe total, lo que nos obliga a cambiar el campo
      recogido en el cursor cur_garanseg y cur_garansegant,cur_garancar
      - Icapital ahora tendra el importe de la parte local
      - Icaptot tendra el importe total, lo que nos obliga a cambiar el campo
      recogido en el cursor cur_garanseg y cur_garansegant,cur_garancar
      - f_difdata(pfefecto, xfvencim, 3, 3, difdias); por
      f_difdata(pfefecto, xfvencim, 1, 3, difdias); Se calculara
      por diferencia real (modulo 365) en vez del modulo 360
      - Se cambian todos los 360 por 365
      - SE ANULAN LOS DOS PASOS ANTERIORES por problemas a la hora
      de cuadrar los importes con cartera.
      - En el caso de los suplementos tanto en el modo real y en
      modo cartera lo calcularemos en modulo 365 con las variables
      difdias,difdiasanu.
      - Si el nº de asegurados es 0, se graba un recibo y se da el mensaje de error (controlado)
      - Cálculo del divisor 365 0 366 para módulo 365
      - Tratamiento de la regularizacion.
      - En el modo 'A' se graban los recibos de aportación extraord.
      - Modifico para que se grabe con cgarant=282. Antes era cgarant=null.
      - Se añade el cálculo de la comisión para la compañía.
      - Se añade reg. comisión en recibos aportación extra. si esta es por prima neta
      - Se añade pcmodcom en la llamada de f_imprecibos
      - Cambios para los nuevos campos de la tabla DETRECIBOS
      - Se ha vuelto a incorporar la funcionalidad que avisa que no se
      grabaron conceptos y en ese caso no grabe el concepto 99 .
      - S'afegeix el mode ='H' per la rehabilitació de riscos i garanties
      - Es modifica la funció perque inserti um rgistre a detrecibos encara
      que el import sigui 0 si s'ha donat d'alta o de baixa una campanya.
      - Se añade el tipomovimiento = 100 en modo 'P' para el cálculo de
      conceptos extraordinarios.
      - Modificada función "fl_grabar_calcomisprev" para que lea la fecha
      de antigüedad de una garantía de GARANSEG.falta en lugar de MOVSEGURO.
      - Modificamos la función "fl_grabar_calcomisprev" para que en modo 'P' y 'N'
      busque el la fecha de alta en garanseg con max(nmovimi).
      - S'afegeixen els paràmetres PCFPAGAPO,PCTIPAPO,PPIMPAPO,PIIMPAPO
      pel càlcul dels imports per aportant (ÉS NOMÉS PER LA PERIÒDICA).
      - Se añade el parámetro pcgarant para el caso pmodo = 'A' poder
      pasar la garantía asociada (ahora se graba siempre la 282)
      - Se añade el tipomovimiento = 11 ==> Suplemento con Recibo por diferencia
      de prima basada en provisión matemática (prima única)
      - Se añaden los parametros funcion y tabla para el calculo del primer recibo al tarifar,
        el parametro tabla indica a que tablas tiene que ir a buscar importes ('EST','SOL',NULLL),
        el parametro función indica si estoy tarifando (TAR) o en la cartera o previo de cartera (CAR)


      ****************************************************************************/
      -- Para el fetch
      w_error           VARCHAR2 (4000);
      xcgarant          NUMBER;
      xnriesgo          NUMBER;
      xfiniefe          DATE;
      xnorden           NUMBER;
      xctarifa          NUMBER;
      xicapital         garanseg.icapital%TYPE;
      --       xicapital      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xprecarg          NUMBER;
      xiprianu          NUMBER;
      xfinefe           DATE;
      xcformul          NUMBER;
      xiextrap          NUMBER;
      xctipfra          NUMBER;
      xifranqu          NUMBER;
      xnmovimi          tmp_adm_recibos.nmovimi%TYPE;
      --       xnmovimi       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xidtocom          NUMBER;
      xpdtocom          NUMBER;
      xnmovimiant       garanseg.nmovimi%TYPE;
      --       xnmovimiant    NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      -- Variables recuperadas de seguros
      xcforpag          solseguros.cforpag%TYPE;
      --       xcforpag       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xcrecfra          seguros.crecfra%TYPE;
      --       xcrecfra       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xpdtoord          seguros.pdtoord%TYPE;
      --       xpdtoord       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xcagente          seguros.cagente%TYPE;
      --       xcagente       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xfemisio          seguros.femisio%TYPE;
      --       xfemisio       DATE; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xcmodali          seguros.cmodali%TYPE;
      --       xcmodali       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xccolect          seguros.ccolect%TYPE;
      --       xccolect       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xcramo            seguros.cramo%TYPE;
      --       xcramo         NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xctipseg          seguros.ctipseg%TYPE;
      --       xctipseg       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xcactivi          seguros.cactivi%TYPE;
      --       xcactivi       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xcduraci          seguros.cduraci%TYPE;
      --       xcduraci       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xnduraci          seguros.nduraci%TYPE;
      --       xnduraci       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xndurcob          seguros.ndurcob%TYPE;
      --       xndurcob       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xcsituac          seguros.csituac%TYPE;
      --       xcsituac       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xctipcoa          tmp_adm_recibos.ctipcoa%TYPE;
      --       xctipcoa       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xncuacoa          seguros.ncuacoa%TYPE;
      --       xncuacoa       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xinnomin          seguros.cobjase%TYPE;
      --       xinnomin       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xfefepol          seguros.fefecto%TYPE;
      --       xfefepol       DATE; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xnpoliza          seguros.npoliza%TYPE;
      --       xnpoliza       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      -- Para el select del garanseg con el movimiento anterior
      xxcgarant         garanseg.cgarant%TYPE;
      --       xxcgarant      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xxnriesgo         garanseg.nriesgo%TYPE;
      --       xxnriesgo      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xxfiniefe         garanseg.finiefe%TYPE;
      --       xxfiniefe      DATE; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xxiprianu         garanseg.ipritot%TYPE;
      --       xxiprianu      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xxffinefe         garanseg.ffinefe%TYPE;
      --       xxffinefe      DATE; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xxidtocom         garanseg.idtocom%TYPE;
      --       xxidtocom      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      grabar            NUMBER;
      decimals          NUMBER                            := 0;
      xiconcep          NUMBER;
      difiprianu        NUMBER;
      comis_agente      NUMBER                            := 0;
      reten_agente      NUMBER                            := 0;
      xffinrec          DATE;
      xiprianu2         NUMBER;
      error             NUMBER                            := 0;
      xtotprimaneta     NUMBER;
      xtotprimadeve     tmp_adm_detrecibos.iconcep%TYPE;
      --       xtotprimadeve  NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      ha_grabat         BOOLEAN                           := FALSE;
      pgrabar           NUMBER;
      xidtocom2         NUMBER;
      difidtocom        NUMBER;
      xnmeses           NUMBER;
      xffinany          DATE;
      xnimpcom          NUMBER;
      xnimpret          NUMBER;
      xccomisi          NUMBER;
      xcretenc          NUMBER;
      xccalcom          productos.ccalcom%TYPE;
      --       xccalcom       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xcprorra          productos.cprorra%TYPE;
      --       xcprorra       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xcmodulo          NUMBER;
      xcmotmov          movseguro.cmotmov%TYPE;
      --       xcmotmov       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xaltarisc         BOOLEAN;
      xinsert           BOOLEAN;
      xnasegur          NUMBER;
      xnasegur1         NUMBER;
      -- xcontriesg    NUMBER;
      xctiprec          tmp_adm_recibos.ctiprec%TYPE;
      --       xctiprec       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xcimprim          NUMBER;
      xploccoa          coacuadro.ploccoa%TYPE;
      --       xploccoa       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xpcomcoa          coacedido.pcomcoa%TYPE;
      --       xpcomcoa       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xcapieve          NUMBER;
      xfmovim           DATE;
      -- Variables para el cálculo de prorrateos
      difdias           NUMBER;
      difdiasanu        NUMBER;
      difdias2          NUMBER;
      difdiasanu2       NUMBER;
      divisor           NUMBER;
      divisor2          NUMBER;
      fanyoprox         DATE;
      facnet            federaprimas.npercen%TYPE;
      --       facnet         NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      facdev            NUMBER;
      facnetsup         NUMBER;
      facdevsup         NUMBER;
      facconsor         NUMBER;
      facconsorfra      NUMBER;
      --JAMF 11903 Factor de prorrateo del consorcio fracionado
      facces            NUMBER;
      xpro_np_360       NUMBER;
      comis_cia         NUMBER                            := 0;
      xex_pte_imp       NUMBER;
      lcvalpar          NUMBER;
      xcestaux          tmp_adm_recibos.cestaux%TYPE;
      --       xcestaux       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xcageven_gar      NUMBER;
      xnmovima          NUMBER;
      xnmovima_gar      NUMBER;
      xxcageven_gar     garanseg.cageven%TYPE;
      --       xxcageven_gar  NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xxnmovima_gar     garanseg.nmovima%TYPE;
      --       xxnmovima_gar  NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      sw_aln            NUMBER;
      sw_cextr          NUMBER;
      w_nmeses_cexter   NUMBER;
      w_importe_aux     NUMBER;
      ---campanya recibos
      v_tecamp          NUMBER;
      xxcampanya        garanseg.ccampanya%TYPE;
      --       xxcampanya     NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xcampanya         garanseg.ccampanya%TYPE;
      --       xcampanya      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xpprorata         NUMBER;
      ha_grabado        NUMBER;
      lpermerita        NUMBER;
      xctipreb          seguros.ctipreb%TYPE;
      --       xctipreb       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      v_primadev        NUMBER;
      v_apperiodo       NUMBER;
      v_apextraordi     NUMBER;
      v_iprianu         garanseg.nversio%TYPE;
      --       v_iprianu      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xndiaspro         productos.ndiaspro%TYPE;
      --       xndiaspro      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      v_cgarant         detrecibos.cgarant%TYPE;
      --       v_cgarant      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xsproduc          seguros.sproduc%TYPE;
      --       xsproduc       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xclave            garanformula.clave%TYPE;
      --       xclave         NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xprovmat          NUMBER;
      xpgasext          productos.pgasext%TYPE;
      --       xpgasext       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      prima_comercial   NUMBER;
      --importecomisae NUMBER;   --JRH 02/2009 Bug 9011
      xitarrea          NUMBER;                  -- BUG: 12993 AVT 09-02-2010

      ---
      TYPE tcursor IS REF CURSOR;

      curgaran          tcursor;
      vselect           VARCHAR2 (2000);
      -- "TIPO" de garantía segun PARGARANPRO -
      -- CS comparan directamente la garantía 48
      w_pargaranpro     NUMBER;
      --CJM
      f_efecto_apgp     DATE;
      vsseguro          NUMBER;
      v_preg4313        NUMBER;

      CURSOR cur_garanseg
      IS
         SELECT cgarant, nriesgo, finiefe, norden, ctarifa, NVL (icaptot, 0),
                precarg, NVL (ipritot, 0), ffinefe, cformul, iextrap,
                ctipfra, ifranqu, nmovimi, idtocom, cageven, nmovima,
                ccampanya, pdtocom, itarrea      -- BUG: 12993 AVT 09-02-2010
           FROM garanseg g
          WHERE g.sseguro = psseguro
            AND g.nriesgo = NVL (pnriesgo, nriesgo)
            AND g.nmovimi = pnmovimi
            AND pmodo <> 'H'
            AND NVL (f_pargaranpro_v (xcramo,
                                      xcmodali,
                                      xctipseg,
                                      xccolect,
                                      NVL (xcactivi, 0),
                                      g.cgarant,
                                      'TIPO'
                                     ),
                     0
                    ) <> 4
            AND 1 =
                   DECODE
                      (pmodo,
                       'RRIE', DECODE (NVL (f_pargaranpro_v (xcramo,
                                                             xcmodali,
                                                             xctipseg,
                                                             xccolect,
                                                             NVL (xcactivi, 0),
                                                             g.cgarant,
                                                             'TIPO'
                                                            ),
                                            0
                                           ),
                                       6, 1,
                                       0
                                      ),
                       DECODE
                             (NVL (f_parproductos_v (xsproduc,
                                                     'SEPARA_RIESGO_AHORRO'
                                                    ),
                                   0
                                  ),
                              1, DECODE
                                      (NVL (f_pargaranpro_v (xcramo,
                                                             xcmodali,
                                                             xctipseg,
                                                             xccolect,
                                                             NVL (xcactivi, 0),
                                                             g.cgarant,
                                                             'TIPO'
                                                            ),
                                            0
                                           ),
                                       6, 0,
                                       1
                                      ),
                              1
                             )
                      )
         UNION
         SELECT cgarant, nriesgo, finiefe, norden, ctarifa, NVL (icaptot, 0),
                precarg, NVL (ipritot, 0), ffinefe, cformul, iextrap, ctipfra,
                ifranqu, nmovi_ant, idtocom, cageven, nmovima, ccampanya,
                pdtocom, itarrea                  -- BUG: 12993 AVT 09-02-2010
           FROM garancar g
          WHERE sproces = pnproces
            AND sseguro = psseguro
            AND nriesgo = NVL (pnriesgo, nriesgo)
            AND TRUNC (pfefecto) >= TRUNC (finiefe)
            AND ((TRUNC (pfefecto) < TRUNC (ffinefe)) OR (ffinefe IS NULL))
            AND pmodo = 'H'
            AND NVL (f_pargaranpro_v (xcramo,
                                      xcmodali,
                                      xctipseg,
                                      xccolect,
                                      NVL (xcactivi, 0),
                                      g.cgarant,
                                      'TIPO'
                                     ),
                     0
                    ) <> 4                    --JRH Las del tipo 4 no cogerlas
            AND 1 =
                   DECODE (NVL (f_parproductos_v (xsproduc,
                                                  'SEPARA_RIESGO_AHORRO'
                                                 ),
                                0
                               ),
                           1, DECODE (NVL (f_pargaranpro_v (xcramo,
                                                            xcmodali,
                                                            xctipseg,
                                                            xccolect,
                                                            NVL (xcactivi, 0),
                                                            g.cgarant,
                                                            'TIPO'
                                                           ),
                                           0
                                          ),
                                      6, 0,
                                      1
                                     ),
                           1
                          );

      CURSOR cur_garansegant
      IS
         SELECT cgarant, nriesgo, finiefe, norden, ctarifa, NVL (icaptot, 0),
                precarg, NVL (ipritot, 0), ffinefe, cformul, iextrap, ctipfra,
                ifranqu, nmovimi, idtocom, cageven, nmovima, ccampanya,
                pdtocom, itarrea                  -- BUG: 12993 AVT 09-02-2010
           FROM garanseg
          WHERE sseguro = psseguro
            AND nriesgo = NVL (pnriesgo, nriesgo)
            AND nmovimi = xnmovimiant
            AND NVL (f_pargaranpro_v (xcramo,
                                      xcmodali,
                                      xctipseg,
                                      xccolect,
                                      NVL (xcactivi, 0),
                                      cgarant,
                                      'TIPO'
                                     ),
                     0
                    ) <> 4
            -- Bug 7926 - RSC - 28/05/2009 -- Se modifica la select del cursor  para que tenga en
            --                                cuenta si la garantía ha vencido ya (solo para el previo,
            --                                ya que en la cartera real ya se da de baja la garantía antes
            --                                y por tanto la garantía ya no entra en el cursor.
            AND pfefecto <
                   DECODE (pmodo,
                           'P', NVL (pac_seguros.f_vto_garantia (sseguro,
                                                                 nriesgo,
                                                                 cgarant,
                                                                 xnmovimiant
                                                                ),
                                     pfefecto + 1
                                    ),
                           'PRIE', NVL
                                     (pac_seguros.f_vto_garantia (sseguro,
                                                                  nriesgo,
                                                                  cgarant,
                                                                  xnmovimiant
                                                                 ),
                                      pfefecto + 1
                                     ),
                           pfefecto + 1
                          )
            -- Bug 19096 - RSC - 03/08/2011 - LCOL - Parametrización básica producto Vida Individual Pagos Permanentes
            AND 1 =
                   DECODE
                      (pmodo,
                       'RRIE', DECODE
                                    (NVL (f_pargaranpro_v (xcramo,
                                                           xcmodali,
                                                           xctipseg,
                                                           xccolect,
                                                           NVL (xcactivi, 0),
                                                           garanseg.cgarant,
                                                           'TIPO'
                                                          ),
                                          0
                                         ),
                                     6, 1,
                                     0
                                    ),
                       DECODE
                           (NVL (f_parproductos_v (xsproduc,
                                                   'SEPARA_RIESGO_AHORRO'
                                                  ),
                                 0
                                ),
                            1, DECODE
                                    (NVL (f_pargaranpro_v (xcramo,
                                                           xcmodali,
                                                           xctipseg,
                                                           xccolect,
                                                           NVL (xcactivi, 0),
                                                           garanseg.cgarant,
                                                           'TIPO'
                                                          ),
                                          0
                                         ),
                                     6, 0,
                                     1
                                    ),
                            1
                           )
                      );

      CURSOR cur_garancar
      IS
         SELECT cgarant, nriesgo, finiefe, norden, ctarifa, NVL (icaptot, 0),
                precarg, NVL (ipritot, 0), ffinefe, cformul, iextrap, idtocom,
                cageven, nmovima, pdtocom,
                itarrea                           -- BUG: 12993 AVT 09-02-2010
           FROM garancar
          WHERE sproces = pnproces
            AND sseguro = psseguro
            AND nriesgo = NVL (pnriesgo, nriesgo)
            AND TRUNC (pfefecto) >= TRUNC (finiefe)
            AND ((TRUNC (pfefecto) < TRUNC (ffinefe)) OR (ffinefe IS NULL))
            AND (canulado IS NULL OR canulado = 2)
            AND NVL (f_pargaranpro_v (xcramo,
                                      xcmodali,
                                      xctipseg,
                                      xccolect,
                                      NVL (xcactivi, 0),
                                      cgarant,
                                      'TIPO'
                                     ),
                     0
                    ) <> 4                   --JRH Las del tipo 4 no cogerlas;
            -- Bug 7926 - RSC - 28/05/2009 -- Se modifica la select del cursor  para que tenga en
            --                                cuenta si la garantía ha vencido ya (solo para el previo,
            --                                ya que en la cartera real ya se da de baja la garantía antes
            --                                y por tanto la garantía ya no entra en el cursor.
            AND pfefecto <
                   DECODE (pmodo,
                           'P', NVL (pac_seguros.f_vto_garantia (sseguro,
                                                                 nriesgo,
                                                                 cgarant,
                                                                 nmovi_ant
                                                                ),
                                     pfefecto + 1
                                    ),
                           'PRIE', NVL (pac_seguros.f_vto_garantia (sseguro,
                                                                    nriesgo,
                                                                    cgarant,
                                                                    nmovi_ant
                                                                   ),
                                        pfefecto + 1
                                       ),
                           pfefecto + 1
                          )
            -- Bug 13569 - RSC - 10/03/2010 -  APR - error en la renovación de pólizas con aportaciones únicas
            AND NVL (cunica, 0) = 0
            -- Bug 19096 - RSC - 03/08/2011 - LCOL - Parametrización básica producto Vida Individual Pagos Permanentes
            AND 1 =
                   DECODE
                      (pmodo,
                       'PRIE', DECODE
                                    (NVL (f_pargaranpro_v (xcramo,
                                                           xcmodali,
                                                           xctipseg,
                                                           xccolect,
                                                           NVL (xcactivi, 0),
                                                           garancar.cgarant,
                                                           'TIPO'
                                                          ),
                                          0
                                         ),
                                     6, 1,
                                     0
                                    ),
                       DECODE
                           (NVL (f_parproductos_v (xsproduc,
                                                   'SEPARA_RIESGO_AHORRO'
                                                  ),
                                 0
                                ),
                            1, DECODE
                                    (NVL (f_pargaranpro_v (xcramo,
                                                           xcmodali,
                                                           xctipseg,
                                                           xccolect,
                                                           NVL (xcactivi, 0),
                                                           garancar.cgarant,
                                                           'TIPO'
                                                          ),
                                          0
                                         ),
                                     6, 0,
                                     1
                                    ),
                            1
                           )
                      );

      -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
      -- Bug 5467 - 10/06/2009 - RSC - Desarrollo de sistema de copago
      -- Bug 5467 - 30/06/2009 - RSC - Desarrollo de sistema de copago
      CURSOR cur_aportaseg (psseguro NUMBER, pfefecto DATE, pnorden NUMBER)
      IS
         SELECT ctipimp, pimport, iimport
           FROM aportaseg
          WHERE sseguro = psseguro
            AND finiefe <= pfefecto
            AND (ffinefe IS NULL OR ffinefe > pfefecto)
            AND (norden = pnorden OR pnorden IS NULL);

      -- Fin Bug 7854 y 8745
      -- Fin Bug 5467
      FUNCTION fl_inbucle_extrarec (
         pnrecibo    IN       NUMBER,
         pfemisrec   IN       DATE,
         psseguro    IN       NUMBER,
         pcgarant    IN       NUMBER,
         pploccoa    IN       NUMBER,
         pctipcoa    IN       NUMBER,
         pcageven    IN       NUMBER,
         pnmovima    IN       NUMBER,
         pnproces    IN       NUMBER,
         pnriesgo    IN       NUMBER,
         pnmeses     IN       NUMBER,
         ha_grabat   OUT      NUMBER
      )
         RETURN NUMBER
      IS
         /********************************************************************************************
           Se añade el parámetro de salida ha_grabat para saber si se
             han grabado registros en DETRECIBOS
         *********************************************************************************************/
         CURSOR cur_inbucle_extrarec (
            esseguro   NUMBER,
            ecgarant   NUMBER,
            enriesgo   NUMBER,
            enmeses    NUMBER,
            eefemis    DATE
         )
         IS
            SELECT SUM (NVL (iextrarec, 0))
              FROM extrarec
             WHERE sseguro = esseguro
               AND cgarant = ecgarant
               AND nriesgo = enriesgo
               AND nrecibo IS NULL;

         w_importe   NUMBER;
      BEGIN
         --
         -- Rutina que, dentro del bucle de tratamiento del recibo, graba acumulados
         --   de conceptos extraordinarios para la garantia dada
         --
         OPEN cur_inbucle_extrarec (psseguro,
                                    pcgarant,
                                    pnriesgo,
                                    pnmeses,
                                    pfemisrec
                                   );

         FETCH cur_inbucle_extrarec
          INTO w_importe;

         IF cur_inbucle_extrarec%NOTFOUND
         THEN
            CLOSE cur_inbucle_extrarec;

            RETURN 0;
         END IF;

         CLOSE cur_inbucle_extrarec;

         IF w_importe <> 0
         THEN
            --
            -- Insercion de un registro en DETRECIBOS con codigo de concepto 26, y posterior
            --   UPDATE de la tabla EXTRAREC informando NRECIBO en los registros sumados en
            --   el cursor.
            --
            -- Bug 19096 - RSC - 03/08/2011 - LCOL - Parametrización básica producto Vida Individual Pagos Permanentes (Afegim RRIE)
            IF pmodo IN ('R', 'RRIE')
            THEN
               -- (MODE REAL PRODUCCIÓ I CARTERA)
               error :=
                  pac_adm.f_instmpdetrec (pnrecibo,
                                          26,
                                          w_importe,
                                          pploccoa,
                                          pcgarant,
                                          pnriesgo,
                                          pctipcoa,
                                          pcageven,
                                          pnmovima
                                         );
               ha_grabat := 1;
            END IF;

            IF error <> 0
            THEN
               RETURN error;
            END IF;

            -- Bug 19096 - RSC - 03/08/2011 - LCOL - Parametrización básica producto Vida Individual Pagos Permanentes (Afegim RRIE)
            IF pmodo IN ('R', 'RRIE')
            THEN
               BEGIN
                  UPDATE extrarec
                     SET nrecibo = pnrecibo
                   WHERE sseguro = psseguro
                     AND cgarant = pcgarant
                     AND nriesgo = pnriesgo;
               EXCEPTION
                  WHEN OTHERS
                  THEN
                     RETURN 111939;       -- Error modificando tabla EXTRAREC
               END;
            END IF;
         END IF;

         RETURN 0;
      EXCEPTION
         WHEN OTHERS
         THEN
            IF cur_inbucle_extrarec%ISOPEN
            THEN
               CLOSE cur_inbucle_extrarec;
            END IF;

            RETURN 111938;         -- Error leyendo datos de la tabla EXTRAREC
      END fl_inbucle_extrarec;

      FUNCTION fl_grabar_calcomisprev (
         psseguro       IN       NUMBER,
         pnrecibo       IN       NUMBER,
         pcgarant       IN       NUMBER,
         pnriesgo       IN       NUMBER,
         pcageven       IN       NUMBER,
         pnmovima       IN       NUMBER,
         picalcom       IN OUT   NUMBER,
         pfefecto_rec   IN       DATE,
         pfvto_rec      IN       DATE,
         pmodo          IN       VARCHAR2,
         pnproces       IN       NUMBER
      )
         RETURN NUMBER
      IS
         sw_cgencom   NUMBER;
         sw_cgendev   NUMBER;
         error        NUMBER;
         w_difmeses   NUMBER;
         w_fechaux1   garanseg.falta%TYPE;
         --          w_fechaux1     DATE; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
         w_fechaux2   DATE;
         w_calcom     NUMBER;
         w_nmeses     NUMBER;
         w_icomcob    NUMBER                := 0;
      /*Añado el parametro pcpoliza (si es baja la falta del ultimo mov)
      además se añade a las selects el nmovima*/
      BEGIN
         --
         -- Funcion que graba los datos necesarios en la tabla CALCOMISPREV
         --   para poder realizar el calculo de comisiones para ALN
         --
         --
         -- Buscamos la primera fecha de inicio de la garantia en la tabla GARANSEG
         --
         -- Bug 19096 - RSC - 03/08/2011 - LCOL - Parametrización básica producto Vida Individual Pagos Permanentes (Afegim RRIE)
         IF pmodo IN ('R', 'H', 'RRIE')
         THEN
            BEGIN
               SELECT g.falta
                 INTO w_fechaux1
                 FROM garanseg g
                WHERE g.sseguro = psseguro
                  AND g.nriesgo = pnriesgo
                  AND g.cgarant = pcgarant
                  AND g.nmovima = pnmovima
                  AND g.nmovimi =
                         (SELECT MAX (nmovimi)
                            FROM garanseg g
                           WHERE g.sseguro = psseguro
                             AND g.nriesgo = pnriesgo
                             AND g.cgarant = pcgarant
                             AND g.nmovima = pnmovima);
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  RETURN 104349;
               WHEN OTHERS
               THEN
                  RETURN 104349;
            END;
         ELSIF pmodo IN ('P', 'N', 'PRIE')
         THEN
            BEGIN
               SELECT g.falta
                 INTO w_fechaux1
                 FROM garanseg g
                WHERE g.sseguro = psseguro
                  AND g.nriesgo = pnriesgo
                  AND g.cgarant = pcgarant
                  AND g.nmovima = pnmovima
                  AND g.nmovimi =
                         (SELECT MAX (nmovimi)
                            FROM garanseg g
                           WHERE g.sseguro = psseguro
                             AND g.nriesgo = pnriesgo
                             AND g.cgarant = pcgarant
                             AND g.nmovima = pnmovima);
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  RETURN 104349;
               WHEN OTHERS
               THEN
                  RETURN 104349;
            END;
         END IF;

         --
         -- Buscamos la diferencia en meses de la fecha de efecto de la garantia
         --   y la fecha de efecto del recibo
         --
         error := f_difdata (w_fechaux1, pfefecto_rec, 1, 2, w_difmeses);

         IF error <> 0
         THEN
            RETURN error;
         END IF;

         --
         -- Si la diferencia en meses es cero, generamos la comision devengada
         --
         IF w_difmeses = 0
         THEN
            sw_cgendev := 1;
         ELSE
            sw_cgendev := 0;
         END IF;

         --
         -- Si la diferencia de meses es menor que el numero de meses de pago, se generan
         --   comisiones
         --
         BEGIN
            SELECT DECODE (NVL (nmescob, 0), 0, 12, nmescob)
              INTO w_nmeses
              FROM agentes
             WHERE cagente = pcageven;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               w_nmeses := 12;
            WHEN OTHERS
            THEN
               w_nmeses := 12;
         END;

         --
         -- Calculamos el importe a aplicar a los agentes cobradores
         --
         -- Bug 19096 - RSC - 03/08/2011 - LCOL - Parametrización básica producto Vida Individual Pagos Permanentes (Afegim RRIE)
         IF pmodo = 'R' OR pmodo = 'H' OR pmodo = 'RRIE'
         THEN
            BEGIN
               SELECT SUM (NVL (iconcep, 0))
                 INTO w_icomcob
                 FROM tmp_adm_detrecibos
                WHERE nrecibo = pnrecibo
                  AND cgarant = pcgarant
                  AND nriesgo = pnriesgo
                  AND nmovima = pnmovima
                  AND cconcep IN (0, 26);
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  w_icomcob := 0;
               WHEN OTHERS
               THEN
                  w_icomcob := 0;
            END;
         ELSIF pmodo IN ('P', 'PRIE')
         THEN
            BEGIN
               SELECT SUM (NVL (iconcep, 0))
                 INTO w_icomcob
                 FROM tmp_adm_detrecibos
                WHERE nrecibo = pnrecibo
                  AND cgarant = pcgarant
                  AND nriesgo = pnriesgo
                  AND nmovima = pnmovima
                  AND cconcep IN (0, 26);
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  w_icomcob := 0;
               WHEN OTHERS
               THEN
                  w_icomcob := 0;
            END;
         END IF;

         IF w_difmeses <= w_nmeses
         THEN
            sw_cgencom := 1;
         ELSE
            sw_cgencom := 0;
         END IF;

         --
         -- Calculo del porcentaje de comisión a pagar para dicho recibo
         --
         w_fechaux2 := ADD_MONTHS (w_fechaux1, w_nmeses);

         IF pfvto_rec < w_fechaux2
         THEN
            w_fechaux1 := pfvto_rec;
         ELSE
            w_fechaux1 := w_fechaux2;
         END IF;

         IF pfefecto_rec > w_fechaux1
         THEN
            w_calcom := 0;
            sw_cgencom := 0;
            sw_cgendev := 0;
         ELSE
            error := f_difdata (pfefecto_rec, w_fechaux1, 1, 2, w_difmeses);

            IF error <> 0
            THEN
               RETURN error;
            END IF;

            w_calcom := w_difmeses;
         END IF;

         IF NVL (picalcom, 0) = 0
         THEN
            --
            -- Si el importe es nulo o cero, no se calcularán comisiones
            --
            sw_cgencom := 0;
            sw_cgendev := 0;
         END IF;

         BEGIN
            INSERT INTO calcomisprev
                        (nrecibo, cgarant, nriesgo, cageven, nmovima,
                         icalcom, pcalcom, icomcob, nmesagt,
                         cgencom, cgendev
                        )
                 VALUES (pnrecibo, pcgarant, pnriesgo, pcageven, pnmovima,
                         picalcom, w_calcom, w_icomcob, w_nmeses,
                         sw_cgencom, sw_cgendev
                        );
         EXCEPTION
            WHEN OTHERS
            THEN
               RETURN 111923;
         -- Error al insertar datos en la tabla CALCOMISPREV
         END;

         RETURN 0;
      END fl_grabar_calcomisprev;
-------------------------------------------------------------------------------------
-- FUNCIO PRINCIPAL
-------------------------------------------------------------------------------------
   BEGIN
      --Cal veure si s'han de deixar els extorns pendents d'imprimir o de transferir
      xex_pte_imp := NVL (f_parinstalacion_n ('EX_PTE_IMP'), 0);
      sw_aln := 0;

      IF NVL (f_parinstalacion_t ('CONCEPEXTR'), 'NO') = 'SI'
      THEN
         sw_cextr := 1;
         w_nmeses_cexter := NVL (f_parinstalacion_n ('CEXTRNMES'), 0);
      ELSE
         sw_cextr := 0;
      END IF;

      IF pttabla = 'SOL'
      THEN
         BEGIN
            SELECT cforpag, cagente, cmodali, ccolect, cramo, ctipseg,
                   cactivi, cduraci, nduraci, ndurcob, cobjase,
                   sproduc, falta
              INTO xcforpag, xcagente, xcmodali, xccolect, xcramo, xctipseg,
                   xcactivi, xcduraci, xnduraci, xndurcob, xinnomin,
                   xsproduc, xfefepol
              FROM solseguros
             WHERE ssolicit = psseguro;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               RETURN 101903;     -- Seguro no encontrado en la tabla SEGUROS
            WHEN OTHERS
            THEN
               RETURN 101919;    -- Error al llegir dades de la taula SEGUROS
         END;
      ELSIF pttabla = 'EST'
      THEN
         BEGIN
            SELECT NVL (pcfpagapo, cforpag), crecfra, pdtoord, cagente,
                   femisio, cmodali, ccolect, cramo, ctipseg, cactivi,
                   cduraci, nduraci, ndurcob, csituac, ctipcoa,
                   ncuacoa, cobjase, fefecto, npoliza, ctipreb, sproduc
              INTO xcforpag, xcrecfra, xpdtoord, xcagente,
                   xfemisio, xcmodali, xccolect, xcramo, xctipseg, xcactivi,
                   xcduraci, xnduraci, xndurcob, xcsituac, xctipcoa,
                   xncuacoa, xinnomin, xfefepol, xnpoliza, xctipreb, xsproduc
              FROM estseguros
             WHERE sseguro = psseguro;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               RETURN 101903;     -- Seguro no encontrado en la tabla SEGUROS
            WHEN OTHERS
            THEN
               RETURN 101919;    -- Error al llegir dades de la taula SEGUROS
         END;
      ELSE
         BEGIN
            SELECT NVL (pcfpagapo, cforpag), crecfra, pdtoord, cagente,
                   femisio, cmodali, ccolect, cramo, ctipseg, cactivi,
                   cduraci, nduraci, ndurcob, csituac, ctipcoa,
                   ncuacoa, cobjase, fefecto, npoliza, ctipreb, sproduc
              INTO xcforpag, xcrecfra, xpdtoord, xcagente,
                   xfemisio, xcmodali, xccolect, xcramo, xctipseg, xcactivi,
                   xcduraci, xnduraci, xndurcob, xcsituac, xctipcoa,
                   xncuacoa, xinnomin, xfefepol, xnpoliza, xctipreb, xsproduc
              FROM seguros
             WHERE sseguro = psseguro;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               RETURN 101903;     -- Seguro no encontrado en la tabla SEGUROS
            WHEN OTHERS
            THEN
               RETURN 101919;    -- Error al llegir dades de la taula SEGUROS
         END;
      END IF;

      BEGIN
         SELECT ccalcom, cprorra,
                                 -- JLB - I - BUG 18423 COjo la moneda del producto
                                 --DECODE (cdivisa, 2, 2, 3, 1),
                                 pac_monedas.f_moneda_producto (sproduc),
                -- JLB - f - BUG 18423 COjo la moneda del producto
                ndiaspro, pgasext
           INTO xccalcom, xcprorra, decimals,
                xndiaspro, xpgasext
           FROM productos
          WHERE cramo = xcramo
            AND cmodali = xcmodali
            AND ctipseg = xctipseg
            AND ccolect = xccolect;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            RETURN 104347;                  -- Producte no trobat a PRODUCTOS
         WHEN OTHERS
         THEN
            RETURN 102705;                    -- Error al llegir de PRODUCTOS
      END;

      IF pmodo IN ('A', 'ANP')
      THEN
-- només grabem a DETRECIBOS
-- ***********************************************************************
-- Cas d' Estalvi (aportació extraordinària), grabem directament a la prima
-- neta de DETRECIBOS, i sortim de la funció.
-- ***********************************************************************
         IF pnimport IS NOT NULL AND pnimport <> 0
         THEN
            BEGIN
               SELECT ctiprec, ctipcoa
                 INTO xctiprec, xctipcoa
                 FROM tmp_adm_recibos
                WHERE nrecibo = pnrecibo;
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  RETURN 101902;                 -- Rebut no trobat a RECIBOS
               WHEN OTHERS
               THEN
                  RETURN 102367;                -- Error al llegir de RECIBOS
            END;

            -- Si el modo es ANP ' Aportación en el alta', se calcula la prima devengada
            IF     pmodo = 'ANP'
               AND NVL (f_parproductos_v (xsproduc, 'NOMESEXTRA'), 0) <> 0
            THEN
               SELECT NVL (SUM (g.icapital), 0), SUM (g.iprianu),
                      MAX (g.cgarant)
                 INTO v_apperiodo, v_iprianu,
                      v_cgarant
                 FROM garanseg g, seguros s
                WHERE g.sseguro = psseguro
                  AND g.nriesgo = NVL (pnriesgo, 1)
                  AND s.sseguro = g.sseguro
                  AND NVL (f_pargaranpro_v (s.cramo,
                                            s.cmodali,
                                            s.ctipseg,
                                            s.ccolect,
                                            s.cactivi,
                                            g.cgarant,
                                            'TIPO'
                                           ),
                           0
                          ) = 3;

               SELECT NVL (SUM (icapital), 0)
                 INTO v_apextraordi                                      --282
                 FROM garanseg g, seguros s
                WHERE g.sseguro = psseguro
                  AND g.nriesgo = NVL (pnriesgo, 1)
                  AND s.sseguro = g.sseguro
                  AND NVL (f_pargaranpro_v (s.cramo,
                                            s.cmodali,
                                            s.ctipseg,
                                            s.ccolect,
                                            s.cactivi,
                                            g.cgarant,
                                            'TIPO'
                                           ),
                           0
                          ) = 4;

               v_primadev := v_iprianu;

               --if NVL(v_apextraordi,0) <> 0 then --JRH 10/2008
               --  v_cgarant:=NVL (pcgarant, 282);
               --end if;

               --IF NVL(f_parproductos_v(xsproduc, 'NOMESEXTRA'),0) = 0 then --JRH 08/2008
               --    v_apperiodo:=0;
               --    v_cgarant:=NVL (pcgarant, 282);
               --end if;
               IF     (xndiaspro IS NOT NULL)
                  AND TO_NUMBER (TO_CHAR (xfefepol, 'dd')) >= xndiaspro
                  AND xcforpag = 12
               THEN
                  v_primadev := v_iprianu - v_apperiodo;
               END IF;

               IF v_apextraordi <> 0
               THEN
                  -- Si se hace una aportación extraordinaria inicial se debe restar una aportación.
                  -- abans     v_primadev := v_ApExtraordi + v_primadev - v_apPeriodo;
                  error :=
                     pac_adm.f_instmpdetrec (pnrecibo,
                                             21,
                                             v_primadev - v_apperiodo,
                                             0,
                                             v_cgarant,
                                             NVL (pnriesgo, 1),
                                             0
                                            );

                  IF error <> 0
                  THEN
                     RETURN error;
                  END IF;

                  -- queda pendent insertar la prima devengada de l'aportació extraordinaria
                  v_primadev := v_apextraordi;
               END IF;
            ELSE
               v_primadev := pnimport;
            END IF;

            BEGIN
               -- Prima Neta
               error :=
                  pac_adm.f_instmpdetrec (pnrecibo,
                                          0,
                                          pnimport,
                                          0,
                                          NVL (pcgarant, 282),
                                          NVL (pnriesgo, 1),
                                          0
                                         );

               IF error <> 0
               THEN
                  RETURN error;
               END IF;

               error :=
                  pac_adm.f_instmpdetrec (pnrecibo,
                                          21,
                                          v_primadev,
                                          0,
                                          NVL (pcgarant, 282),
                                          NVL (pnriesgo, 1),
                                          0
                                         );

               IF error <> 0
               THEN
                  RETURN error;
               END IF;

               IF xccalcom = 1
               THEN
                  -- Sobre prima
                  error :=
                     f_pcomisi (psseguro,
                                pcmodcom,
                                f_sysdate,
                                comis_agente,
                                reten_agente,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                pttabla,
                                pfuncion
                               );

                  IF error <> 0
                  THEN
                     RETURN error;
                  END IF;
               END IF;

               xpprorata := 1;
               error :=
                  pac_adm.f_imprecibos (pnproces,
                                        pnrecibo,
                                        ptipomovimiento,
                                        pmodo,
                                        NVL (pnriesgo, 1),
                                        xpdtoord,
                                        xcrecfra,
                                        xcforpag,
                                        xcramo,
                                        xcmodali,
                                        xctipseg,
                                        xccolect,
                                        xcactivi,
                                        comis_agente,
                                        reten_agente,
                                        psseguro,
                                        pcmodcom,
                                        decimals,
                                        xpprorata,
                                        pttabla,
                                        pfuncion
                                       );

               IF error <> 0
               THEN
                  p_tab_error (f_sysdate,
                               f_user,
                               'PAC_ADM.IMPRECIBOS',
                               NULL,
                               'error al insertar en impuestos.',
                               error || ' ( sseguro =' || psseguro || '  )'
                              );
                  RETURN error;
               END IF;

               --

               -- Fin Comisión
               IF pnimport < 0
               THEN
                  IF xctiprec <> 10
                  THEN
                     -- No és un extorn d' anul.lació
                     BEGIN
                        lpermerita :=
                                    NVL (f_parinstalacion_n ('PERMERITA'), 0);

                        -- xex_pte_imp = 1 (Extorn pendent d'imprimir)
                        -- xex_pte_imp = 0 (Extorn pendent de transferir)
                        UPDATE tmp_adm_recibos
                           SET ctiprec = 9,        -- Si la prima és negativa,
                               cestimp =
                                  DECODE (cestimp,
                                          4, DECODE (xex_pte_imp, 0, 7, 1),
                                          cestimp
                                         ),
                               nperven =
                                  DECODE (lpermerita,
                                          0, nperven,
                                          1, TO_CHAR (femisio, 'yyyymm')
                                         )
                         WHERE nrecibo = pnrecibo;   -- es tracta d' un extorn
                     EXCEPTION
                        WHEN OTHERS
                        THEN
                           RETURN 102358;
                     -- Error al modificar la taula RECIBOS
                     END;

                     -- BUG: 12961 AVT 22-02-2010 s'ajusta pels rebuts d'extorn
                     FOR reg IN (SELECT   cgarant, SUM (iconcep) iconcep
                                     FROM tmp_adm_detrecibos
                                    WHERE nrecibo = pnrecibo
                                 GROUP BY cgarant)
                     LOOP
                        IF reg.iconcep = 0
                        THEN
                           BEGIN
                              DELETE      tmp_adm_detrecibos
                                    WHERE nrecibo = pnrecibo
                                      AND cgarant = reg.cgarant;
                           EXCEPTION
                              WHEN NO_DATA_FOUND
                              THEN
                                 NULL;
                              WHEN OTHERS
                              THEN
                                 RETURN 104377;
                           END;
                        END IF;
                     END LOOP;
                  END IF;

                  error := pac_adm.f_extornpos (pnrecibo, pmodo, pnproces);

                  IF error <> 0
                  THEN
                     RETURN error;
                  END IF;
               END IF;

               error := pac_adm.f_tmp_vdetrecibos (pmodo, pnrecibo, pnproces);

               IF error = 0
               THEN
                  error :=
                     pac_cesionesrea.f_cessio_det (pnproces,
                                                   psseguro,
                                                   pnrecibo,
                                                   xcactivi,
                                                   xcramo,
                                                   xcmodali,
                                                   xctipseg,
                                                   xccolect,
                                                   pfefecto,
                                                   pfvencim,
                                                   1,
                                                   decimals,
                                                   1,
                                                   'EST'
                                                  );
               END IF;

               RETURN error;
            EXCEPTION
               WHEN DUP_VAL_ON_INDEX
               THEN
                  RETURN 102311;           -- registre duplicat en DETRECIBOS
               WHEN OTHERS
               THEN
                  ROLLBACK;
                  w_error := SQLERRM;
                  RETURN SQLCODE;          -- Error a l' inserir a DETRECIBOS
            END;
         ELSE
            RETURN 101901;        -- Pas incorrecte de paràmetres a la funció
         END IF;
      ELSE
         -- Estem en el cas de proves ('P') o real ('R') o recibo anual impresión ('N') o
         -- recibo sobre intereses ('I'), Rehabilitacio ('H'), 'Diferencia provisión ('PM')
         -- Comprobem si existeix l' assegurança entrada com a paràmetre
         IF pmodo = 'N'
         THEN
            -- Estem en el cas de rebut previ (anual)
            xcforpag := 1;
         END IF;

         IF pfuncion = 'CAR'
         THEN
            error := f_buscanmovimi (psseguro, 1, 1, xnmovimiant);
         ELSE
            xnmovimiant := 1;
         END IF;

         IF error <> 0
         THEN
            RETURN error;
         END IF;

         IF xccalcom = 1
         THEN
            -- Sobre prima
            NULL;
         -- Se comenta la llamada a f_pcomisi ya que el calculo de la comisión se realiza dentro de f_imprecibos
         /*
                  error :=
                     f_pcomisi (psseguro,
                                pcmodcom,
                                F_SYSDATE,
                                comis_agente,
                                reten_agente,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                pttabla,
                                pfuncion
                               );

                  IF error <> 0
                  THEN
                     RETURN error;
                  END IF;
         */
         ELSIF xccalcom = 2
         THEN
            -- Sobre interés
            comis_agente := 0;
            reten_agente := 0;
            comis_cia := 0;
         ELSIF xccalcom = 3
         THEN
            -- Sobre prov. mat.
            comis_agente := 0;
            reten_agente := 0;
            comis_cia := 0;
         END IF;

         IF pnmovimi IS NOT NULL AND pfuncion = 'CAR'
         THEN
            BEGIN
               SELECT cmotmov
                 INTO xcmotmov
                 FROM movseguro
                WHERE sseguro = psseguro AND nmovimi = pnmovimi;

               IF xcmotmov = 243
               THEN
                  xaltarisc := TRUE;
               ELSE
                  xaltarisc := FALSE;
               END IF;
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  RETURN 104348;       -- Num. moviment no trobat a MOVSEGURO
               WHEN OTHERS
               THEN
                  RETURN 104349;              -- Error al llegir de MOVSEGURO
            END;
         END IF;

         IF ptipomovimiento = 6
         THEN
            -- Estem en el cas de rebut de regularització
            xcforpag := 0;        -- Calcularem com a forma de pagament única

            -- Si no es una regularització de tickets
            IF xcmotmov NOT IN (602, 604)
            THEN
               -- o de capital eventual
               xcduraci := 3;
            -- Aplicarem reducció per assegurança de temporada
            ELSIF xcmotmov = 604
            THEN
               xcapieve := 1;                       -- Es de capital eventual
            END IF;
         END IF;

         /******** Cálculo de los factores a aplicar para el prorrateo ********/
         xffinrec := pfvencim;
         xffinany := pfcaranu;

         --Inicio CJMR
         --busca sseguro de la póliza 0
         SELECT sseguro
           INTO vsseguro
           FROM seguros
          WHERE npoliza = xnpoliza AND ncertif = 0;

         BEGIN
            SELECT p.crespue
              INTO v_preg4313
              FROM pregunpolseg p
             WHERE p.sseguro = vsseguro
               AND p.cpregun = 4313
               AND p.nmovimi =
                      (SELECT MAX (nmovimi)
                         FROM pregunpolseg p2
                        WHERE p2.sseguro = p.sseguro
                              AND p2.cpregun = p.cpregun);
         EXCEPTION
            WHEN OTHERS
            THEN
               v_preg4313 := 0;
         END;

         /*error := pac_preguntas.f_get_pregunpolseg(vsseguro, 4313, 'ESTE', v_preg4313);

         IF error <> 0 THEN
            RETURN error;
         END IF;*/
         IF ptipomovimiento IN (0, 1) AND v_preg4313 = 1
         THEN
            f_efecto_apgp :=
                        TO_DATE (frenovacion (NULL, vsseguro, 2), 'yyyymmdd');
         END IF;

         IF ptipomovimiento IN (0, 1) AND v_preg4313 = 1
         THEN
            fanyoprox := ADD_MONTHS (f_efecto_apgp, 12);
         ELSE
            fanyoprox := ADD_MONTHS (pfefecto, 12);
         END IF;

         --Fin CJMR

         -- Para calcular el divisor del modulo 365 (365 o 366)
         IF xcforpag <> 0
         THEN
            IF xffinany IS NULL
            THEN
               IF xndurcob IS NULL
               THEN
                  RETURN 104515;
               -- El camp ndurcob de SEGUROS ha de estar informat
               END IF;

               xnmeses := (xndurcob + 1) * 12;

               --CJM
               IF ptipomovimiento IN (0, 1) AND v_preg4313 = 1
               THEN
                  xffinany := ADD_MONTHS (f_efecto_apgp, xnmeses);
               ELSE
                  xffinany := ADD_MONTHS (pfefecto, xnmeses);
               END IF;

               IF xffinrec IS NULL
               THEN
                  xffinrec := xffinany;
               END IF;
            END IF;
         ELSE
            xffinany := xffinrec;
         END IF;

         -- Cálculo de días
         IF xcprorra = 2
         THEN
            -- Mod. 360
            xcmodulo := 3;
         ELSE
            -- Mod. 365
            xcmodulo := 1;
         END IF;

         --CJM
         IF ptipomovimiento IN (0, 1) AND v_preg4313 = 1
         THEN
            error := f_difdata (f_efecto_apgp, xffinrec, 3, 3, difdias);
         ELSE
            error := f_difdata (pfefecto, xffinrec, 3, 3, difdias);
         END IF;

         IF error <> 0
         THEN
            RETURN error;
         END IF;

         --CJM
         IF ptipomovimiento IN (0, 1) AND v_preg4313 = 1
         THEN
            error := f_difdata (f_efecto_apgp, xffinany, 3, 3, difdiasanu);
         ELSE
            error := f_difdata (pfefecto, xffinany, 3, 3, difdiasanu);
         END IF;

         IF error <> 0
         THEN
            RETURN error;
         END IF;

         --CJM
         IF ptipomovimiento IN (0, 1) AND v_preg4313 = 1
         THEN
            error :=
                   f_difdata (f_efecto_apgp, xffinrec, xcmodulo, 3, difdias2);
         ELSE
            error := f_difdata (pfefecto, xffinrec, xcmodulo, 3, difdias2);
         END IF;

         -- dias recibo
         IF error <> 0
         THEN
            RETURN error;
         END IF;

         --CJM
         IF ptipomovimiento IN (0, 1) AND v_preg4313 = 1
         THEN
            error :=
                f_difdata (f_efecto_apgp, xffinany, xcmodulo, 3, difdiasanu2);
         ELSE
            error := f_difdata (pfefecto, xffinany, xcmodulo, 3, difdiasanu2);
         END IF;

         -- dias venta
         IF error <> 0
         THEN
            RETURN error;
         END IF;

         --CJM
         IF ptipomovimiento IN (0, 1) AND v_preg4313 = 1
         THEN
            error :=
                  f_difdata (f_efecto_apgp, fanyoprox, xcmodulo, 3, divisor2);
         ELSE
            error := f_difdata (pfefecto, fanyoprox, xcmodulo, 3, divisor2);
         END IF;

         -- divisor del módulo de suplementos para pagos anuales
         IF error <> 0
         THEN
            RETURN error;
         END IF;

         --CJM
         IF ptipomovimiento IN (0, 1) AND v_preg4313 = 1
         THEN
            error :=
                    f_difdata (f_efecto_apgp, xffinrec, xcmodulo, 3, divisor);
         ELSE
            error := f_difdata (xfefepol, xffinrec, xcmodulo, 3, divisor);
         END IF;

         -- divisor del periodo para pago único
         IF error <> 0
         THEN
            RETURN error;
         END IF;

         -- Calculem els factors a aplicar per prorratejar
         -- També el factor per la reassegurança = diesrebut/dies cessio
         IF xcprorra IN (1, 2)
         THEN
            -- Per dies
            IF    xcforpag <> 0
               --  DRA:28/10/2013:0028690: POSTEC Camio forma de pago
               OR NVL (f_parproductos_v (xsproduc, 'PRORR_PRIMA_UNICA'), 0) =
                                                                             1
            THEN
               -- El càlcul del factor a la nova producció si s'ha de prorratejar, es fará modul 360 o
               -- mòdul 365 segon un paràmetre d'instal.lació
               xpro_np_360 := f_parinstalacion_n ('PRO_NP_360');

               IF NVL (xpro_np_360, 1) = 1
               THEN
                  facnet := difdias / 360;
                  facdev := difdiasanu / 360;
               ELSE
                  IF MOD (difdias, 30) = 0
                  THEN
                     -- No hi ha prorrata
                     facnet := difdias / 360;
                     facdev := difdiasanu / 360;

                     IF difdiasanu = 0
                     THEN
                        difdiasanu := 360;
                     END IF;
                  --facces      :=  difdias / difdiasanu;
                  ELSE
                     -- Hi ha prorrata, prorratejem mòdul 365
                     facnet := difdias2 / divisor2;
                     facdev := difdiasanu2 / divisor2;
                  END IF;
               END IF;

               facnetsup := difdias2 / divisor2;
               facdevsup := difdiasanu2 / divisor2;
            ELSE
               facnet := 1;
               facdev := 1;
               facnetsup := difdias2 / divisor;
               facdevsup := difdiasanu2 / divisor;
            END IF;
         ELSIF xcprorra = 3
         THEN
            BEGIN
               IF ptipomovimiento IN (0, 1) AND v_preg4313 = 1
               THEN
                  SELECT f1.npercen / 100
                    INTO facnet
                    FROM federaprimas f1
                   WHERE f1.npoliza = xnpoliza
                     AND f1.diames =
                            (SELECT MAX (f2.diames)
                               FROM federaprimas f2
                              WHERE f1.npoliza = f2.npoliza
                                AND f2.diames <=
                                              TO_CHAR (f_efecto_apgp, 'mm/dd'));
               ELSE
                  SELECT f1.npercen / 100
                    INTO facnet
                    FROM federaprimas f1
                   WHERE f1.npoliza = xnpoliza
                     AND f1.diames =
                            (SELECT MAX (f2.diames)
                               FROM federaprimas f2
                              WHERE f1.npoliza = f2.npoliza
                                AND f2.diames <= TO_CHAR (pfefecto, 'mm/dd'));
               END IF;
            EXCEPTION
               WHEN OTHERS
               THEN
                  RETURN 109086;
            -- Porcentajes de prorrateo no dados de alta para la póliza
            END;

            IF xcforpag <> 0
            THEN
               RETURN 109087;
            -- Tipo de prorrateo incompatible con la forma de pago
            ELSE
               facdev := facnet;
               facnetsup := facnet;
               facdevsup := facnet;
            END IF;
         ELSE
            RETURN 109085;                   -- Codi de prorrateig inexistent
         END IF;

         IF NVL (f_parinstalacion_n ('PRO_SP_360'), 0) = 1
         THEN
            facnetsup := facnet;
            facdevsup := facdev;
         END IF;

         -- nunu Factor de prorrateig de reassegurança
         IF ptipomovimiento IN (0, 6, 21, 22)
         THEN
            facces := facnet;
         ELSE
            facces := facnetsup;
         END IF;

         IF ptipomovimiento = 11
         THEN
            facnetsup := 1;
            facdevsup := 1;
         END IF;

         -- Bug 19096 - RSC - 03/08/2011 - LCOL - Parametrización básica producto Vida Individual Pagos Permanentes (Afegim RRIE)
         IF pmodo = 'R' OR pmodo = 'I' OR pmodo = 'H' OR pmodo = 'RRIE'
         THEN
            BEGIN
               SELECT ctiprec, cestaux
                 INTO xctiprec, xcestaux
                 FROM tmp_adm_recibos
                WHERE nrecibo = pnrecibo;
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  RETURN 101902;                 -- Rebut no trobat a RECIBOS
               WHEN OTHERS
               THEN
                  RETURN 102367;                -- Error al llegir de RECIBOS
            END;
         ELSE
            BEGIN
               SELECT ctiprec, cestaux
                 INTO xctiprec, xcestaux
                 FROM tmp_adm_recibos
                WHERE sproces = pnproces AND nrecibo = pnrecibo;
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  RETURN 105304;              -- Rebut no trobat a RECIBOSCAR
               WHEN OTHERS
               THEN
                  RETURN 105305;             -- Error al llegir de RECIBOSCAR
            END;
         END IF;

         -- Buscamos el porcentaje local si es un coaseguro.
         IF xctipcoa != 0
         THEN
            BEGIN
               SELECT ploccoa
                 INTO xploccoa
                 FROM coacuadro
                WHERE ncuacoa = xncuacoa AND sseguro = psseguro;
            EXCEPTION
               WHEN OTHERS
               THEN
                  RETURN 105447;
            END;
         END IF;

--****************************************************************
--******************   M O D O    R E A L  ***********************
--******************   MODO REHABILITACION ***********************
--****************************************************************

         -- Bug 19096 - RSC - 03/08/2011 - LCOL - Parametrización básica producto Vida Individual Pagos Permanentes (Afegim 'RRIE')
         IF pmodo = 'R' OR pmodo = 'H' OR pmodo = 'RRIE'
         THEN
            -- MODE REAL (Producció, Cartera i Rehabilitacio)
            OPEN cur_garanseg;

            FETCH cur_garanseg
             INTO xcgarant, xnriesgo, xfiniefe, xnorden, xctarifa, xicapital,
                  xprecarg, xiprianu, xfinefe, xcformul, xiextrap, xctipfra,
                  xifranqu, xnmovimi, xidtocom, xcageven_gar, xnmovima_gar,
                  xcampanya, xpdtocom, xitarrea; -- BUG: 12993 AVT 09-02-2010

            WHILE cur_garanseg%FOUND
            LOOP
               w_pargaranpro :=
                  f_pargaranpro_v (xcramo,
                                   xcmodali,
                                   xctipseg,
                                   xccolect,
                                   xcactivi,
                                   xcgarant,
                                   'TIPO'
                                  );
               xnasegur := NULL;
               xnasegur1 := NULL;
               xidtocom := 0 - NVL (xidtocom, 0);

               -- comprobem si hi ha més d'un registre pel mateix cgarant-nriesgo-
               -- nmovimi-finiefe
               BEGIN
                  SELECT DECODE (nasegur, NULL, 1, nasegur), nmovima
                    INTO xnasegur, xnmovima
                    FROM riesgos
                   WHERE sseguro = psseguro AND nriesgo = xnriesgo;
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     CLOSE cur_garanseg;

                     RETURN 103836;
                  WHEN OTHERS
                  THEN
                     CLOSE cur_garanseg;

                     RETURN 103509;
               END;

-- *******************************************************************************
-- Fase 1: Càlcul de la Prima Neta (cconcep = 0) y de la Prima Devengada (Fase 2).
-- *******************************************************************************
-- ********** Conceptos extraordinarios ***********
               IF sw_cextr = 1
               THEN
                  error :=
                     fl_inbucle_extrarec (pnrecibo,
                                          pfemisio,
                                          psseguro,
                                          xcgarant,
                                          xploccoa,
                                          xctipcoa,
                                          xcageven_gar,
                                          xnmovima_gar,
                                          pnproces,
                                          xnriesgo,
                                          w_nmeses_cexter,
                                          ha_grabado
                                         );

                  IF ha_grabado = 1
                  THEN
                     ha_grabat := TRUE;
                  END IF;

                  IF error <> 0
                  THEN
                     CLOSE cur_garanseg;

                     RETURN error;
                  END IF;
               END IF;

               IF ptipomovimiento IN (0, 6, 21, 22)
               THEN
                  -- ********** Prima Neta ***********
                  xiprianu2 :=
                             f_round (xiprianu * facnet * xnasegur, decimals);

                  -- En PP y PPA comprobamos en carrtera y renovación que no sobrepasamos el limite de aportaciones.
                  IF     ptipomovimiento IN (21, 22)
                     AND w_pargaranpro = 3
                     --{si el tipo de garantía es prima ahorro }-xcgarant = 48
                     AND NVL (xiprianu2, 0) > 0
                  THEN
                     DECLARE
                        persona      NUMBER;
                        agrupacion   NUMBER;
                        pendiente    NUMBER;
                        minimo       NUMBER;
                        partes       NUMBER;
                        traspasos    NUMBER;
                     BEGIN
                        SELECT COUNT (1)
                          INTO partes
                          FROM prestaplan
                         WHERE sseguro = psseguro;

                        IF partes = 0
                        THEN
                           --> Parte de prestaciones
                           -- Miramos que si en PP y Ahorro tienen mas de 1 recibo pendiente no genera cartera
                           IF f_recpen_pp (psseguro, 1) > 1
                           THEN
                              xiprianu2 := 0;
                              xiprianu := 0;
                           ELSE
                              -- Añadimos 'TIPO_LIMITE' (Cúmulos PIAS)
                              IF    NVL (f_parproductos_v (xsproduc,
                                                           'APORTMAXIMAS'
                                                          ),
                                         0
                                        ) = 1
                                 OR NVL (f_parproductos_v (xsproduc,
                                                           'TIPO_LIMITE'
                                                          ),
                                         0
                                        ) <> 0
                              THEN
                                 -- Bug 10053 - APD - 08/05/2009 - se sustituye la funcion f_maxapor_pp por
                                 -- pac_ppa_planes.ff_importe_por_aportar_persona
                                 SELECT cagrpro, riesgos.sperson,
                                        garanpro.iprimin,
                                        DECODE
                                           (NVL
                                               (f_parproductos_v
                                                               (xsproduc,
                                                                'APORTMAXIMAS'
                                                               ),
                                                0
                                               ),
                                            1, pac_ppa_planes.ff_importe_por_aportar_persona
                                               (TO_NUMBER (TO_CHAR (pfefecto,
                                                                    'yyyy'
                                                                   )
                                                          ),
                                                psseguro,
                                                riesgos.nriesgo,
                                                riesgos.sperson
                                               ),
                                            --                                           f_maxapor_pp(riesgos.sperson,
                                            --                                                         TO_NUMBER(TO_CHAR(pfefecto, 'yyyy')),
                                            --                                                         psseguro),
                                            pac_limites_ahorro.ff_importe_por_aportar_persona
                                               (TO_NUMBER (TO_CHAR (pfefecto,
                                                                    'yyyy'
                                                                   )
                                                          ),
                                                f_parproductos_v
                                                                (xsproduc,
                                                                 'TIPO_LIMITE'
                                                                ),
                                                riesgos.sperson,
                                                pfefecto
                                               )
                                           )
                                   INTO agrupacion, persona,
                                        minimo,
                                        pendiente
                                   FROM seguros, riesgos, garanpro
                                  WHERE seguros.sseguro = riesgos.sseguro
                                    AND riesgos.fanulac IS NULL
                                    AND garanpro.sproduc = seguros.sproduc
                                    AND NVL
                                           (f_pargaranpro_v (seguros.cramo,
                                                             seguros.cmodali,
                                                             seguros.ctipseg,
                                                             seguros.ccolect,
                                                             seguros.cactivi,
                                                             garanpro.cgarant,
                                                             'TIPO'
                                                            ),
                                            0
                                           ) = 3
                                    --AND garanpro.cgarant = 48
                                    AND seguros.sseguro = psseguro;

                                 -- Bug 10053 - APD - 08/05/2009 - Fin

                                 --IF PENDIENTE > 0 AND PENDIENTE < MINIMO THEN
                                 --  XIPRIANU2 := 0;
                                 -- XIPRIANU := 0;
                                 IF pendiente <= 0
                                 THEN
                                    xiprianu2 := 0;
                                    xiprianu := 0;
                                 ELSIF pendiente > 0 AND xiprianu2 > pendiente
                                 THEN
                                    --AND PENDIENTE >MINIMO
                                    xiprianu2 := pendiente;
                                    xiprianu := pendiente;
                                 END IF;
                              END IF;
                           END IF;

                           -- Si tiene TDC Salida Confirmados Totales no generamos el recibo ya que
                           -- estos traspasos anularán la póliza
                           SELECT COUNT (*)
                             INTO traspasos
                             FROM trasplainout
                            WHERE cinout = 2
                              AND cestado = 2
                              AND ctiptras = 1
                              AND sseguro = psseguro;

                           IF traspasos > 0
                           THEN
                              xiprianu2 := 0;
                              xiprianu := 0;
                           END IF;
                        ELSE
                           --> tIENE PARTE DE PRESTACIONES
                           xiprianu2 := 0;
                           xiprianu := 0;
                        END IF;                        -- PArte de prstaciones
                     END;
                  END IF;

                  -- Copiamos la prima para el dtos de campanya
                  xpprorata := facnet;

                  -- Si te ctipreb = 4 (per aportant) la prima s'ha de repartir
                  -- segons pctipapo = 1 ( Aplicar el porcentatge = ppimpapo)
                  --        pctipapo = 1 (import fixe = piimpapo)
                  IF xctipreb = 4
                  THEN
                     -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                     -- Bug 7854 y 8745 Eliminamos esta condiciona 'w_pargaranpro = 3'
                     --IF w_pargaranpro = 3 THEN
                     --IF pctipapo = 1 THEN
                     --   xiprianu2 :=
                     --          f_round (xiprianu2 * ppimpapo / 100, decimals);
                     --ELSIF pctipapo = 2 THEN
                     --   xiprianu2 :=
                     --        f_round (piimpapo * facnet * xnasegur, decimals);
                     --END IF;

                     -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                     IF pctipapo = 1
                     THEN
                        FOR vapor IN cur_aportaseg (psseguro,
                                                    pfefecto,
                                                    xnriesgo
                                                   )
                        LOOP
                           IF vapor.ctipimp = 1
                           THEN
                              xiprianu2 :=
                                 f_round (xiprianu2 * vapor.pimport / 100,
                                          decimals
                                         );
                              -- Bug 13397 - RSC - 26/02/2010 - CRE201 - Error cartera PIAM Colectivo (257)
                              xitarrea :=
                                 f_round (xitarrea * vapor.pimport / 100,
                                          decimals
                                         );
                           -- Fin Bug 13397
                           ELSIF vapor.ctipimp = 2
                           THEN
                              --xiprianu2 := f_round (vapor.iimport * facnet * xnasegur, decimals);
                              xiprianu2 := LEAST (xiprianu2, vapor.iimport);
                              -- Bug 13397 - RSC - 26/02/2010 - CRE201 - Error cartera PIAM Colectivo (257)
                              xitarrea := LEAST (xitarrea, vapor.iimport);
                           -- Fin Bug 13397
                           END IF;
                        END LOOP;
                     ELSIF pctipapo = 2
                     THEN
                        FOR vapor IN cur_aportaseg (psseguro,
                                                    pfefecto,
                                                    xnriesgo
                                                   )
                        LOOP
                           IF vapor.ctipimp = 1
                           THEN
                              xiprianu2 :=
                                 f_round (  xiprianu2
                                          * (1 - (vapor.pimport / 100)),
                                          decimals
                                         );
                              -- Bug 13397 - RSC - 26/02/2010 - CRE201 - Error cartera PIAM Colectivo (257)
                              xitarrea :=
                                 f_round (  xitarrea
                                          * (1 - (vapor.pimport / 100)),
                                          decimals
                                         );
                           -- Fin Bug 13397
                           ELSIF vapor.ctipimp = 2
                           THEN
                              --xiprianu2 := f_round (vapor.iimport * facnet * xnasegur, decimals);
                              xiprianu2 :=
                                      GREATEST (0, xiprianu2 - vapor.iimport);
                              -- Bug 13397 - RSC - 26/02/2010 - CRE201 - Error cartera PIAM Colectivo (257)
                              xitarrea :=
                                       GREATEST (0, xitarrea - vapor.iimport);
                           -- Fin Bug 13397
                           END IF;
                        END LOOP;
                     END IF;
                  --ELSE
                  --   xiprianu2 := 0;
                  --END IF;
                  END IF;

                  -- BUG: 12993 AVT 09-02-2010
                  IF NVL (xiprianu2, 0) <> 0 OR NVL (xitarrea, 0) <> 0
                  THEN
                     error :=
                        pac_adm.f_instmpdetrec (pnrecibo,
                                                0,
                                                xiprianu2,
                                                xploccoa,
                                                xcgarant,
                                                xnriesgo,
                                                xctipcoa,
                                                xcageven_gar,
                                                xnmovima_gar
                                               );

                     IF error = 0
                     THEN
                        ha_grabat := TRUE;

                        IF sw_aln = 1
                        THEN
                           w_importe_aux :=
                                      f_round (xiprianu * xnasegur, decimals);
                           error :=
                              fl_grabar_calcomisprev (psseguro,
                                                      pnrecibo,
                                                      xcgarant,
                                                      xnriesgo,
                                                      xcageven_gar,
                                                      xnmovima_gar,
                                                      w_importe_aux,
                                                      pfefecto,
                                                      pfvencim,
                                                      pmodo,
                                                      pnproces
                                                     );

                           IF error <> 0
                           THEN
                              CLOSE cur_garanseg;

                              RETURN error;
                           END IF;
                        END IF;
                     ELSE
                        CLOSE cur_garanseg;

                        RETURN error;
                     END IF;
                  END IF;

                  --  ******* Descuento comercial *******
                  xidtocom2 :=
                              f_round (xidtocom * facnet * xnasegur, decimals);

                  -- Si te ctipreb = 4 (per aportant) l'import s'ha de repartir
                  -- segons pctipapo = 1 ( Aplicar el porcentatge = ppimpapo)
                  --        pctipapo = 1 (import fixe = piimpapo)
                  IF xctipreb = 4
                  THEN
                     -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                     -- Bug 7854 y 8745 Eliminamos esta condiciona 'w_pargaranpro = 3'
                     --IF w_pargaranpro = 3
                     --THEN
                     /*
                     IF pctipapo = 1
                     THEN
                        xidtocom2 :=
                               f_round (xidtocom2 * ppimpapo / 100, decimals);
                     ELSIF pctipapo = 2
                     THEN
                        -- hen de calcular el descompte per l'import fixe xiprianu2
                        xidtocom2 :=
                           f_round (  f_round ((xiprianu2 * xpdtocom) / 100,
                                               decimals
                                              )
                                    * facnet
                                    * xnasegur,
                                    decimals
                                   );
                     END IF;
                     */

                     -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                     IF pctipapo = 1
                     THEN
                        FOR vapor IN cur_aportaseg (psseguro,
                                                    pfefecto,
                                                    xnriesgo
                                                   )
                        LOOP
                           IF vapor.ctipimp = 1
                           THEN
                              xidtocom2 :=
                                 f_round (xidtocom2 * vapor.pimport / 100,
                                          decimals
                                         );
                           ELSIF vapor.ctipimp = 2
                           THEN
                              xidtocom2 :=
                                 f_round (  f_round (  (xiprianu2 * xpdtocom
                                                       )
                                                     / 100,
                                                     decimals
                                                    )
                                          * facnet
                                          * xnasegur,
                                          decimals
                                         );

                              -- Se porratea el importe de descuento

                              --BUG11280-XVM-29092009 inici
                              IF xiprianu2 <> 0
                              THEN
                                 xidtocom2 :=
                                    LEAST (  (xidtocom2 * vapor.iimport)
                                           / xiprianu2,
                                           vapor.iimport
                                          );
                              ELSE
                                 xidtocom2 := 0;
                              END IF;
                           --BUG11280-XVM-29092009 fi
                           END IF;
                        END LOOP;
                     ELSIF pctipapo = 2
                     THEN
                        FOR vapor IN cur_aportaseg (psseguro,
                                                    pfefecto,
                                                    xnriesgo
                                                   )
                        LOOP
                           IF vapor.ctipimp = 1
                           THEN
                              xidtocom2 :=
                                 f_round (  xidtocom2
                                          * (1 - (vapor.pimport / 100)),
                                          decimals
                                         );
                           ELSIF vapor.ctipimp = 2
                           THEN
                              xidtocom2 :=
                                 f_round (  f_round (  (xiprianu2 * xpdtocom
                                                       )
                                                     / 100,
                                                     decimals
                                                    )
                                          * facnet
                                          * xnasegur,
                                          decimals
                                         );

                              --BUG11280-XVM-29092009 inici
                              IF xiprianu2 <> 0
                              THEN
                                 xidtocom2 :=
                                    GREATEST (0,
                                                (  (xidtocom2 * vapor.iimport
                                                   )
                                                 / xiprianu2
                                                )
                                              - vapor.iimport
                                             );
                              ELSE
                                 xidtocom2 := 0;
                              END IF;
                           --BUG11280-XVM-29092009 fi
                           END IF;
                        END LOOP;
                     END IF;
                  --ELSE
                  --   xidtocom2 := 0;
                  --END IF;
                  END IF;

                  IF xidtocom2 <> 0 AND xidtocom2 IS NOT NULL
                  THEN
                     error :=
                        pac_adm.f_instmpdetrec (pnrecibo,
                                                10,
                                                xidtocom2,
                                                xploccoa,
                                                xcgarant,
                                                xnriesgo,
                                                xctipcoa,
                                                xcageven_gar,
                                                xnmovima_gar
                                               );

                     IF error = 0
                     THEN
                        ha_grabat := TRUE;
                     ELSE
                        CLOSE cur_garanseg;

                        RETURN error;
                     END IF;
                  END IF;

                  -- ******** Prima Devengada **********
                  IF ptipomovimiento IN (0, 2, 6, 21)
                  THEN
                     xiprianu2 :=
                             f_round (xiprianu * facdev * xnasegur, decimals);

                     -- Si te ctipreb = 4 (per aportant) la prima s'ha de repartir
                     -- segons pctipapo = 1 ( Aplicar el porcentatge = ppimpapo)
                     --        pctipapo = 1 (import fixe = piimpapo)
                     IF xctipreb = 4
                     THEN
                        -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                        -- Bug 7854 y 8745 Eliminamos esta condiciona 'w_pargaranpro = 3'
                        --IF w_pargaranpro = 3
                        --THEN
                        /*
                        IF pctipapo = 1
                        THEN
                           xiprianu2 :=
                               f_round (xiprianu2 * ppimpapo / 100, decimals);
                        ELSIF pctipapo = 2
                        THEN
                           xiprianu2 :=
                              f_round (piimpapo * facdev * xnasegur,
                                       decimals);
                        END IF;
                        */

                        -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                        IF pctipapo = 1
                        THEN
                           FOR vapor IN cur_aportaseg (psseguro,
                                                       pfefecto,
                                                       xnriesgo
                                                      )
                           LOOP
                              IF vapor.ctipimp = 1
                              THEN
                                 xiprianu2 :=
                                    f_round (xiprianu2 * vapor.pimport / 100,
                                             decimals
                                            );
                              ELSIF vapor.ctipimp = 2
                              THEN
                                 --xiprianu2 := f_round (vapor.iimport * facnet * xnasegur, decimals);
                                 xiprianu2 :=
                                             LEAST (xiprianu2, vapor.iimport);
                              END IF;
                           END LOOP;
                        ELSIF pctipapo = 2
                        THEN
                           FOR vapor IN cur_aportaseg (psseguro,
                                                       pfefecto,
                                                       xnriesgo
                                                      )
                           LOOP
                              IF vapor.ctipimp = 1
                              THEN
                                 xiprianu2 :=
                                    f_round (  xiprianu2
                                             * (1 - (vapor.pimport / 100)),
                                             decimals
                                            );
                              ELSIF vapor.ctipimp = 2
                              THEN
                                 --xiprianu2 := f_round (vapor.iimport * facnet * xnasegur, decimals);
                                 xiprianu2 :=
                                      GREATEST (0, xiprianu2 - vapor.iimport);
                              END IF;
                           END LOOP;
                        END IF;
                     --ELSE
                     --   xiprianu2 := 0;
                     --END IF;
                     END IF;

                     IF NVL (xiprianu2, 0) <> 0
                     THEN
                        -- Comprovar si ha de generar venda, segons el paràmetre per garantia GENVENTA
                        error :=
                           f_pargaranpro (xcramo,
                                          xcmodali,
                                          xctipseg,
                                          xccolect,
                                          xcactivi,
                                          xcgarant,
                                          'GENVENTA',
                                          lcvalpar
                                         );

                        IF error <> 0
                        THEN
                           RETURN error;
                        ELSE
                           IF NVL (lcvalpar, 1) = 1
                           THEN
                              -- La garantia genera venda
                              error :=
                                 pac_adm.f_instmpdetrec (pnrecibo,
                                                         21,
                                                         xiprianu2,
                                                         xploccoa,
                                                         xcgarant,
                                                         xnriesgo,
                                                         xctipcoa,
                                                         xcageven_gar,
                                                         xnmovima_gar
                                                        );

                              IF error = 0
                              THEN
                                 ha_grabat := TRUE;
                              ELSE
                                 CLOSE cur_garanseg;

                                 RETURN error;
                              END IF;
                           END IF;
                        END IF;
---------------
                     END IF;
                  END IF;
-- *******************************************************
-- **************** Suplementos **************************
-- *******************************************************
               ELSIF ptipomovimiento IN (1, 11)
               THEN
                  BEGIN
                     xxcgarant := NULL;
                     xxnriesgo := NULL;
                     xxfiniefe := NULL;
                     xxiprianu := NULL;
                     xxffinefe := NULL;
                     xxidtocom := NULL;

                     SELECT cgarant, nriesgo, finiefe, ipritot,
                            ffinefe, idtocom, cageven,
                            nmovima, ccampanya
                       INTO xxcgarant, xxnriesgo, xxfiniefe, xxiprianu,
                            xxffinefe, xxidtocom, xxcageven_gar,
                            xxnmovima_gar, xxcampanya
                       FROM garanseg
                      WHERE sseguro = psseguro
                        AND cgarant = xcgarant
                        AND nriesgo = xnriesgo
                        AND nmovimi = xnmovimiant
                        AND nmovima = xnmovima_gar;
                  EXCEPTION
                     WHEN NO_DATA_FOUND
                     THEN
                        NULL;                   -- No hi ha garantia anterior
                     WHEN TOO_MANY_ROWS
                     THEN
                        CLOSE cur_garanseg;

                        error := 102310;
                        -- Garantia-Risc repetida en GARANSEG
                        RETURN error;
                     WHEN OTHERS
                     THEN
                        CLOSE cur_garanseg;

                        error := 103500;       -- Error al llegir de GARANSEG
                        RETURN error;
                  END;

                  IF ptipomovimiento = 11
                  THEN
                     -- Calculamos la prima comercial a esta fecha a traves de la reserva
                     -- matemática
                     BEGIN
                        SELECT clave
                          INTO xclave
                          FROM garanformula
                         WHERE cramo = xcramo
                           AND cmodali = xcmodali
                           AND ctipseg = xctipseg
                           AND ccolect = xccolect
                           AND cactivi = xcactivi
                           AND cgarant = xcgarant
                           AND ccampo = 'IPROVMAT';
                     EXCEPTION
                        WHEN OTHERS
                        THEN
                           CLOSE cur_garanseg;

                           error := 110087;
                           -- Error al insertar en GARANFORMULA
                           RETURN error;
                     END;

                     error :=
                        pac_calculo_formulas.calc_formul (pfefecto,
                                                          xsproduc,
                                                          xcactivi,
                                                          xcgarant,
                                                          xnriesgo,
                                                          psseguro,
                                                          xclave,
                                                          xprovmat,
                                                          xnmovimiant
                                                         );

                     IF error <> 0
                     THEN
                        CLOSE cur_garanseg;

                        RETURN error;
                     END IF;

                     prima_comercial :=
                                       NVL (xprovmat, 0)
                                     / (1 - (xpgasext / 100));
                     xxiprianu := prima_comercial;
                  END IF;

                  xxidtocom := 0 - NVL (xxidtocom, 0);
                  difiprianu :=
                       NVL (xiprianu * xnasegur, 0)
                     - NVL (xxiprianu * xnasegur, 0);
                  difidtocom :=
                       NVL (xidtocom * xnasegur, 0)
                     - NVL (xxidtocom * xnasegur, 0);
                  xinsert := TRUE;
                  --Calculamos la prima para dtos. de campanya
                  --utilizamos el prorrateo de alta de garantía.
                  xpprorata := facnetsup;

                  IF xaltarisc
                  THEN
                     IF xnmovima = pnmovimi
                     THEN
                        xinsert := TRUE;
                     ELSE
                        xinsert := FALSE;
                     END IF;
                  END IF;

                  --mirem si s'ha donat d'alta una campanya.
                  IF f_parinstalacion_n ('CAMPANYA') = 1
                  THEN
                     IF NVL (xxcampanya, -2) <> NVL (xcampanya, -2)
                     THEN
                        v_tecamp := 1;
                     ELSE
                        v_tecamp := 0;
                     END IF;
                  ELSE
                     v_tecamp := 0;
                  END IF;

                  -- si tiene campanya forzamos que entre y grabe en detrecibos.
                  IF xinsert OR v_tecamp = 1
                  THEN
                     -- ******* Prima Neta ********
                     xiconcep := f_round (difiprianu * facnetsup, decimals);

                     -- facnetsup ya aplica la forma de pago

                     -- Si te ctipreb = 4 (per aportant) la prima s'ha de repartir
                     -- segons pctipapo = 1 ( Aplicar el porcentatge = ppimpapo)
                     --        pctipapo = 1 (import fixe = piimpapo)
                     IF xctipreb = 4
                     THEN
                        -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                        -- Bug 7854 y 8745 Eliminamos esta condiciona 'w_pargaranpro = 3'
                        --IF w_pargaranpro = 3
                        --THEN
                        /*
                        IF pctipapo = 1 THEN
                           xiconcep :=
                                f_round (xiconcep * ppimpapo / 100, decimals);
                        ELSIF pctipapo = 2 THEN
                           -- Apliquem la proporció del fixe sobre l'anual
                           xiconcep :=
                              f_round ((xiconcep * piimpapo / xiprianu),
                                       decimals
                                      );
                        END IF;
                        */

                        -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                        IF pctipapo = 1
                        THEN
                           FOR vapor IN cur_aportaseg (psseguro,
                                                       pfefecto,
                                                       xnriesgo
                                                      )
                           LOOP
                              IF vapor.ctipimp = 1
                              THEN
                                 xiconcep :=
                                    f_round (xiconcep * vapor.pimport / 100,
                                             decimals
                                            );
                              ELSIF vapor.ctipimp = 2
                              THEN
                                 xiconcep := LEAST (xiconcep, vapor.iimport);
                              END IF;
                           END LOOP;
                        ELSIF pctipapo = 2
                        THEN
                           FOR vapor IN cur_aportaseg (psseguro,
                                                       pfefecto,
                                                       xnriesgo
                                                      )
                           LOOP
                              IF vapor.ctipimp = 1
                              THEN
                                 xiconcep :=
                                    f_round (  xiconcep
                                             * (1 - (vapor.pimport / 100)),
                                             decimals
                                            );
                              ELSIF vapor.ctipimp = 2
                              THEN
                                 xiconcep :=
                                       GREATEST (0, xiconcep - vapor.iimport);
                              END IF;
                           END LOOP;
                        END IF;
                     --ELSE
                     --   xiconcep := 0;
                     --END IF;
                     END IF;

                     IF    NVL (xiconcep, 0) <> 0
                        OR NVL (xitarrea, 0) <> 0      -- 12993 AVT 09-02-2010
                        OR NVL (v_tecamp, 0) = 1
                     THEN
                        error :=
                           pac_adm.f_instmpdetrec (pnrecibo,
                                                   0,
                                                   xiconcep,
                                                   xploccoa,
                                                   xcgarant,
                                                   xnriesgo,
                                                   xctipcoa,
                                                   xcageven_gar,
                                                   xnmovima_gar
                                                  );

                        IF error = 0
                        THEN
                           ha_grabat := TRUE;

                           IF sw_aln = 1
                           THEN
                              w_importe_aux := f_round (difiprianu, decimals);
                              error :=
                                 fl_grabar_calcomisprev (psseguro,
                                                         pnrecibo,
                                                         xcgarant,
                                                         xnriesgo,
                                                         xcageven_gar,
                                                         xnmovima_gar,
                                                         w_importe_aux,
                                                         pfefecto,
                                                         pfvencim,
                                                         pmodo,
                                                         pnproces
                                                        );

                              IF error <> 0
                              THEN
                                 CLOSE cur_garanseg;

                                 RETURN error;
                              END IF;
                           END IF;
                        ELSE
                           CLOSE cur_garanseg;

                           RETURN error;
                        END IF;
                     END IF;

                     -- ******** Descuento comercial ******
                     xiconcep := f_round (difidtocom * facnetsup, decimals);

                     -- Si te ctipreb = 4 (per aportant) la prima s'ha de repartir
                     -- segons pctipapo = 1 ( Aplicar el porcentatge = ppimpapo)
                     --        pctipapo = 1 (import fixe = piimpapo)
                     IF xctipreb = 4
                     THEN
                        -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                        -- Bug 7854 y 8745 Eliminamos esta condiciona 'w_pargaranpro = 3'
                        --IF w_pargaranpro = 3 THEN
                        /*
                        IF pctipapo = 1 THEN
                           xiconcep :=
                                f_round (xiconcep * ppimpapo / 100, decimals);
                        ELSIF pctipapo = 2 THEN
                           -- Apliquem la proporció del fixe sobre l'anual
                           xiconcep :=
                              f_round ((xiconcep * piimpapo / xiprianu),
                                       decimals
                                      );
                        END IF;
                        */

                        -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                        IF pctipapo = 1
                        THEN
                           FOR vapor IN cur_aportaseg (psseguro,
                                                       pfefecto,
                                                       xnriesgo
                                                      )
                           LOOP
                              IF vapor.ctipimp = 1
                              THEN
                                 xiconcep :=
                                    f_round (xiconcep * vapor.pimport / 100,
                                             decimals
                                            );
                              ELSIF vapor.ctipimp = 2
                              THEN
                                 xiconcep := LEAST (xiconcep, vapor.iimport);
                              END IF;
                           END LOOP;
                        ELSIF pctipapo = 2
                        THEN
                           FOR vapor IN cur_aportaseg (psseguro,
                                                       pfefecto,
                                                       xnriesgo
                                                      )
                           LOOP
                              IF vapor.ctipimp = 1
                              THEN
                                 xiconcep :=
                                    f_round (  xiconcep
                                             * (1 - (vapor.pimport / 100)),
                                             decimals
                                            );
                              ELSIF vapor.ctipimp = 2
                              THEN
                                 xiconcep :=
                                       GREATEST (0, xiconcep - vapor.iimport);
                              END IF;
                           END LOOP;
                        END IF;
                     --ELSE
                     --   xiconcep := 0;
                     --END IF;
                     END IF;

                     IF xiconcep <> 0 AND xiconcep IS NOT NULL
                     THEN
                        error :=
                           pac_adm.f_instmpdetrec (pnrecibo,
                                                   10,
                                                   xiconcep,
                                                   xploccoa,
                                                   xcgarant,
                                                   xnriesgo,
                                                   xctipcoa,
                                                   xcageven_gar,
                                                   xnmovima_gar
                                                  );

                        IF error = 0
                        THEN
                           ha_grabat := TRUE;
                        ELSE
                           CLOSE cur_garanseg;

                           RETURN error;
                        END IF;
                     END IF;

                     -- ****** Prima Devengada ******
                     xiconcep := f_round (difiprianu * facdevsup, decimals);

                     -- Si te ctipreb = 4 (per aportant) la prima s'ha de repartir
                     -- segons pctipapo = 1 ( Aplicar el porcentatge = ppimpapo)
                     --        pctipapo = 1 (import fixe = piimpapo)
                     IF xctipreb = 4
                     THEN
                        -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                        -- Bug 7854 y 8745 Eliminamos esta condiciona 'w_pargaranpro = 3'
                        --IF w_pargaranpro = 3 THEN
                        /*
                        IF pctipapo = 1 THEN
                           xiconcep :=
                                f_round (xiconcep * ppimpapo / 100, decimals);
                        ELSIF pctipapo = 2 THEN
                           -- Apliquem la proporció del fixe sobre l'anual
                           xiconcep :=
                              f_round ((xiconcep * piimpapo / xiprianu),
                                       decimals
                                      );
                        END IF;
                        */

                        -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                        IF pctipapo = 1
                        THEN
                           FOR vapor IN cur_aportaseg (psseguro,
                                                       pfefecto,
                                                       xnriesgo
                                                      )
                           LOOP
                              IF vapor.ctipimp = 1
                              THEN
                                 xiconcep :=
                                    f_round (xiconcep * vapor.pimport / 100,
                                             decimals
                                            );
                              ELSIF vapor.ctipimp = 2
                              THEN
                                 xiconcep := LEAST (xiconcep, vapor.iimport);
                              END IF;
                           END LOOP;
                        ELSIF pctipapo = 2
                        THEN
                           FOR vapor IN cur_aportaseg (psseguro,
                                                       pfefecto,
                                                       xnriesgo
                                                      )
                           LOOP
                              IF vapor.ctipimp = 1
                              THEN
                                 xiconcep :=
                                    f_round (  xiconcep
                                             * (1 - (vapor.pimport / 100)),
                                             decimals
                                            );
                              ELSIF vapor.ctipimp = 2
                              THEN
                                 xiconcep :=
                                       GREATEST (0, xiconcep - vapor.iimport);
                              END IF;
                           END LOOP;
                        END IF;
                     --ELSE
                     --   xiconcep := 0;
                     --END IF;
                     END IF;

                     IF NVL (xiconcep, 0) <> 0
                     THEN
                        -- Comprovar si ha de generar venda, segons el paràmetre per garantia GENVENTA
                        error :=
                           f_pargaranpro (xcramo,
                                          xcmodali,
                                          xctipseg,
                                          xccolect,
                                          xcactivi,
                                          xcgarant,
                                          'GENVENTA',
                                          lcvalpar
                                         );

                        IF error <> 0
                        THEN
                           RETURN error;
                        ELSE
                           IF NVL (lcvalpar, 1) = 1
                           THEN
                              -- La garantia genera venda
                              error :=
                                 pac_adm.f_instmpdetrec (pnrecibo,
                                                         21,
                                                         xiconcep,
                                                         xploccoa,
                                                         xcgarant,
                                                         xnriesgo,
                                                         xctipcoa,
                                                         xcageven_gar,
                                                         xnmovima_gar
                                                        );

                              IF error = 0
                              THEN
                                 ha_grabat := TRUE;
                              ELSE
                                 CLOSE cur_garanseg;

                                 RETURN error;
                              END IF;
                           END IF;
                        END IF;
---------------
                     END IF;
                  END IF;                             -- Fi del if del xinsert
               ELSIF ptipomovimiento = 100
               THEN
                  NULL;
               ELSE
                  CLOSE cur_garanseg;

                  error := 101901;
                  -- Paso incorrecto de parámetros a la función
                  RETURN error;
               END IF;

               FETCH cur_garanseg
                INTO xcgarant, xnriesgo, xfiniefe, xnorden, xctarifa,
                     xicapital, xprecarg, xiprianu, xfinefe, xcformul,
                     xiextrap, xctipfra, xifranqu, xnmovimi, xidtocom,
                     xcageven_gar, xnmovima_gar, xcampanya, xpdtocom,
                     xitarrea;                    -- BUG: 12993 AVT 09-02-2010
            END LOOP;

            CLOSE cur_garanseg;

-- ********************************************************************
-- Ara buscarem les garanties que estaven en (fefecto-1) i ara no estan
-- ********************************************************************
            IF ptipomovimiento IN (1, 11)
            THEN
               OPEN cur_garansegant;

               FETCH cur_garansegant
                INTO xcgarant, xnriesgo, xfiniefe, xnorden, xctarifa,
                     xicapital, xprecarg, xiprianu, xfinefe, xcformul,
                     xiextrap, xctipfra, xifranqu, xnmovimi, xidtocom,
                     xcageven_gar, xnmovima_gar, xcampanya, xpdtocom,
                     xitarrea;                   -- BUG: 12993 AVT 09-02-2010

               WHILE cur_garansegant%FOUND
               LOOP
                  xnasegur := NULL;
                  xnasegur1 := NULL;

                  BEGIN
                     SELECT DECODE (nasegur, NULL, 1, nasegur)
                       INTO xnasegur1
                       FROM riesgos
                      WHERE sseguro = psseguro AND nriesgo = xnriesgo;
                  EXCEPTION
                     WHEN NO_DATA_FOUND
                     THEN
                        CLOSE cur_garansegant;

                        RETURN 103836;
                     WHEN OTHERS
                     THEN
                        CLOSE cur_garansegant;

                        RETURN 103509;
                  END;

                  xidtocom := 0 - NVL (xidtocom, 0);

                  BEGIN
                     grabar := 0;
                     xxcgarant := NULL;
                     xxnriesgo := NULL;
                     xxfiniefe := NULL;
                     xxiprianu := NULL;
                     xxffinefe := NULL;
                     xxidtocom := NULL;

                     SELECT cgarant, nriesgo, finiefe, ipritot,
                            ffinefe, idtocom, cageven,
                            nmovima, ccampanya
                       INTO xxcgarant, xxnriesgo, xxfiniefe, xxiprianu,
                            xxffinefe, xxidtocom, xxcageven_gar,
                            xxnmovima_gar, xcampanya
                       FROM garanseg
                      WHERE sseguro = psseguro
                        AND cgarant = xcgarant
                        AND nriesgo = xnriesgo
                        AND nmovimi = pnmovimi
                        AND nmovima = xnmovima_gar;
                  EXCEPTION
                     WHEN NO_DATA_FOUND
                     THEN
                        grabar := 1;          -- És una garantia desapareguda
                     WHEN TOO_MANY_ROWS
                     THEN
                        CLOSE cur_garansegant;

                        error := 102310;
                        -- Garantia-Risc repetida en GARANSEG
                        RETURN error;
                     WHEN OTHERS
                     THEN
                        CLOSE cur_garansegant;

                        error := 103500;       -- Error al llegir de GARANSEG
                        RETURN error;
                  END;

                  IF grabar = 1
                  THEN
                     IF ptipomovimiento = 11
                     THEN
                        -- suplemento con recibo dif. PM

                        -- Calculamos la prima comercial a esta fecha a traves de la reserva
                        -- matemática
                        BEGIN
                           SELECT clave
                             INTO xclave
                             FROM garanformula
                            WHERE cramo = xcramo
                              AND cmodali = xcmodali
                              AND ctipseg = xctipseg
                              AND ccolect = xccolect
                              AND cactivi = xcactivi
                              AND cgarant = xcgarant
                              AND ccampo = 'IPROVMAT';
                        EXCEPTION
                           WHEN OTHERS
                           THEN
                              CLOSE cur_garanseg;

                              error := 110087;
                              -- Error al insertar en GARANFORMULA
                              RETURN error;
                        END;

                        error :=
                           pac_calculo_formulas.calc_formul (pfefecto,
                                                             xsproduc,
                                                             xcactivi,
                                                             xcgarant,
                                                             xnriesgo,
                                                             psseguro,
                                                             xclave,
                                                             xprovmat,
                                                             xnmovimi
                                                            );

                        IF error <> 0
                        THEN
                           CLOSE cur_garanseg;

                           RETURN error;
                        END IF;

                        prima_comercial :=
                                       NVL (xprovmat, 0)
                                     / (1 - (xpgasext / 100));
                        xiprianu := prima_comercial;
                     END IF;

                     xxidtocom := 0 - NVL (xxidtocom * xnasegur1, 0);
                     difiprianu := 0 - (xiprianu * xnasegur1);
                     difidtocom := 0 - NVL (xidtocom * xnasegur1, 0);
                     --copiamos la prima neta para dtos de campanya
                     xpprorata := facnetsup;

                     IF difiprianu <> 0
                     THEN
                        -- ******* Prima Neta ******
                        xiconcep :=
                                   f_round (difiprianu * facnetsup, decimals);

                        -- Si te ctipreb = 4 (per aportant) la prima s'ha de repartir
                        -- segons pctipapo = 1 ( Aplicar el porcentatge = ppimpapo)
                        --        pctipapo = 1 (import fixe = piimpapo)
                        IF xctipreb = 4
                        THEN
                           -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                           -- Bug 7854 y 8745 Eliminamos esta condiciona 'w_pargaranpro = 3'
                           --IF w_pargaranpro = 3 THEN
                           /*
                           IF pctipapo = 1 THEN
                              xiconcep :=
                                 f_round (xiconcep * ppimpapo / 100,
                                          decimals);
                           ELSIF pctipapo = 2 THEN
                              -- Apliquem la proporció del fixe sobre l'anual
                              xiconcep :=
                                 f_round ((xiconcep * piimpapo / xiprianu),
                                          decimals
                                         );
                           END IF;
                           */

                           -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                           IF pctipapo = 1
                           THEN
                              FOR vapor IN cur_aportaseg (psseguro,
                                                          pfefecto,
                                                          xnriesgo
                                                         )
                              LOOP
                                 IF vapor.ctipimp = 1
                                 THEN
                                    xiconcep :=
                                       f_round (xiconcep * vapor.pimport / 100,
                                                decimals
                                               );
                                    xitarrea :=
                                       f_round (xitarrea * vapor.pimport / 100,
                                                decimals
                                               );
                                 ELSIF vapor.ctipimp = 2
                                 THEN
                                    xiconcep :=
                                              LEAST (xiconcep, vapor.iimport);
                                    xitarrea :=
                                              LEAST (xitarrea, vapor.iimport);
                                 END IF;
                              END LOOP;
                           ELSIF pctipapo = 2
                           THEN
                              FOR vapor IN cur_aportaseg (psseguro,
                                                          pfefecto,
                                                          xnriesgo
                                                         )
                              LOOP
                                 IF vapor.ctipimp = 1
                                 THEN
                                    xiconcep :=
                                       f_round (  xiconcep
                                                * (1 - (vapor.pimport / 100)
                                                  ),
                                                decimals
                                               );
                                    xitarrea :=
                                       f_round (  xitarrea
                                                * (1 - (vapor.pimport / 100)
                                                  ),
                                                decimals
                                               );
                                 ELSIF vapor.ctipimp = 2
                                 THEN
                                    xiconcep :=
                                       GREATEST (0, xiconcep - vapor.iimport);
                                    xitarrea :=
                                       GREATEST (0, xitarrea - vapor.iimport);
                                 END IF;
                              END LOOP;
                           END IF;
                        --ELSE
                        --   xiconcep := 0;
                        --END IF;
                        END IF;

                        -- 12993 AVT 09-02-2010 S'afegeix el xitarrea
                        IF NVL (xiconcep, 0) <> 0 OR NVL (xitarrea, 0) <> 0
                        THEN
                           error :=
                              pac_adm.f_instmpdetrec (pnrecibo,
                                                      0,
                                                      xiconcep,
                                                      xploccoa,
                                                      xcgarant,
                                                      xnriesgo,
                                                      xctipcoa,
                                                      xcageven_gar,
                                                      xnmovima_gar
                                                     );

                           IF error = 0
                           THEN
                              ha_grabat := TRUE;

                              IF sw_aln = 1
                              THEN
                                 w_importe_aux :=
                                               f_round (difiprianu, decimals);
                                 error :=
                                    fl_grabar_calcomisprev (psseguro,
                                                            pnrecibo,
                                                            xcgarant,
                                                            xnriesgo,
                                                            xcageven_gar,
                                                            xnmovima_gar,
                                                            w_importe_aux,
                                                            pfefecto,
                                                            pfvencim,
                                                            pmodo,
                                                            pnproces
                                                           );

                                 IF error <> 0
                                 THEN
                                    CLOSE cur_garansegant;

                                    RETURN error;
                                 END IF;
                              END IF;
                           ELSE
                              CLOSE cur_garansegant;

                              RETURN error;
                           END IF;
                        END IF;

                        -- ***** Prima Devengada ******
                        xiconcep := f_round (difiprianu * facdevsup, decimals);

                        -- Si te ctipreb = 4 (per aportant) la prima s'ha de repartir
                        -- segons pctipapo = 1 ( Aplicar el porcentatge = ppimpapo)
                        --        pctipapo = 1 (import fixe = piimpapo)
                        IF xctipreb = 4
                        THEN
                           -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                           -- Bug 7854 y 8745 Eliminamos esta condiciona 'w_pargaranpro = 3'
                           --IF w_pargaranpro = 3 THEN
                           /*
                           IF pctipapo = 1
                           THEN
                              xiconcep :=
                                 f_round (xiconcep * ppimpapo / 100,
                                          decimals);
                           ELSIF pctipapo = 2 THEN
                              -- Apliquem la proporció del fixe sobre l'anual
                              xiconcep :=
                                 f_round ((xiconcep * piimpapo / xiprianu),
                                          decimals
                                         );
                           END IF;
                           */

                           -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                           IF pctipapo = 1
                           THEN
                              FOR vapor IN cur_aportaseg (psseguro,
                                                          pfefecto,
                                                          xnriesgo
                                                         )
                              LOOP
                                 IF vapor.ctipimp = 1
                                 THEN
                                    xiconcep :=
                                       f_round (xiconcep * vapor.pimport / 100,
                                                decimals
                                               );
                                 ELSIF vapor.ctipimp = 2
                                 THEN
                                    xiconcep :=
                                              LEAST (xiconcep, vapor.iimport);
                                 END IF;
                              END LOOP;
                           ELSIF pctipapo = 2
                           THEN
                              FOR vapor IN cur_aportaseg (psseguro,
                                                          pfefecto,
                                                          xnriesgo
                                                         )
                              LOOP
                                 IF vapor.ctipimp = 1
                                 THEN
                                    xiconcep :=
                                       f_round (  xiconcep
                                                * (1 - (vapor.pimport / 100)
                                                  ),
                                                decimals
                                               );
                                 ELSIF vapor.ctipimp = 2
                                 THEN
                                    xiconcep :=
                                       GREATEST (0, xiconcep - vapor.iimport);
                                 END IF;
                              END LOOP;
                           END IF;
                        --ELSE
                        --  xiconcep := 0;
                        --END IF;
                        END IF;

                        IF NVL (xiconcep, 0) <> 0
                        THEN
                           -- Comprovar si ha de generar venda, segons el paràmetre per garantia GENVENTA
                           error :=
                              f_pargaranpro (xcramo,
                                             xcmodali,
                                             xctipseg,
                                             xccolect,
                                             xcactivi,
                                             xcgarant,
                                             'GENVENTA',
                                             lcvalpar
                                            );

                           IF error <> 0
                           THEN
                              RETURN error;
                           ELSE
                              IF NVL (lcvalpar, 1) = 1
                              THEN
                                 -- La garantia genera venda
                                 error :=
                                    pac_adm.f_instmpdetrec (pnrecibo,
                                                            21,
                                                            xiconcep,
                                                            xploccoa,
                                                            xcgarant,
                                                            xnriesgo,
                                                            xctipcoa,
                                                            xcageven_gar,
                                                            xnmovima_gar
                                                           );

                                 IF error = 0
                                 THEN
                                    ha_grabat := TRUE;
                                 ELSE
                                    CLOSE cur_garansegant;

                                    RETURN error;
                                 END IF;
                              END IF;
                           END IF;
---------------
                        END IF;
                     END IF;

                     IF difidtocom <> 0 AND difidtocom IS NOT NULL
                     THEN
                        -- ******* Dte.comercial ********
                        xiconcep :=
                                   f_round (difidtocom * facnetsup, decimals);

                        -- Si te ctipreb = 4 (per aportant) la prima s'ha de repartir
                        -- segons pctipapo = 1 ( Aplicar el porcentatge = ppimpapo)
                        --        pctipapo = 1 (import fixe = piimpapo)
                        IF xctipreb = 4
                        THEN
                           -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                           -- Bug 7854 y 8745 Eliminamos esta condiciona 'w_pargaranpro = 3'
                           --IF w_pargaranpro = 3 THEN
                           /*
                           IF pctipapo = 1 THEN
                              xiconcep :=
                                 f_round (xiconcep * ppimpapo / 100,
                                          decimals);
                           ELSIF pctipapo = 2 THEN
                              -- Apliquem la proporció del fixe sobre l'anual
                              xiconcep :=
                                 f_round ((xiconcep * piimpapo / xiprianu),
                                          decimals
                                         );
                           END IF;
                           */

                           -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                           IF pctipapo = 1
                           THEN
                              FOR vapor IN cur_aportaseg (psseguro,
                                                          pfefecto,
                                                          xnriesgo
                                                         )
                              LOOP
                                 IF vapor.ctipimp = 1
                                 THEN
                                    xiconcep :=
                                       f_round (xiconcep * vapor.pimport / 100,
                                                decimals
                                               );
                                 ELSIF vapor.ctipimp = 2
                                 THEN
                                    xiconcep :=
                                              LEAST (xiconcep, vapor.iimport);
                                 END IF;
                              END LOOP;
                           ELSIF pctipapo = 2
                           THEN
                              FOR vapor IN cur_aportaseg (psseguro,
                                                          pfefecto,
                                                          xnriesgo
                                                         )
                              LOOP
                                 IF vapor.ctipimp = 1
                                 THEN
                                    xiconcep :=
                                       f_round (  xiconcep
                                                * (1 - (vapor.pimport / 100)
                                                  ),
                                                decimals
                                               );
                                 ELSIF vapor.ctipimp = 2
                                 THEN
                                    xiconcep :=
                                       GREATEST (0, xiconcep - vapor.iimport);
                                 END IF;
                              END LOOP;
                           END IF;
                        --ELSE
                        --   xiconcep := 0;
                        --END IF;
                        END IF;

                        IF NVL (xiconcep, 0) <> 0
                        THEN
                           error :=
                              pac_adm.f_instmpdetrec (pnrecibo,
                                                      10,
                                                      xiconcep,
                                                      xploccoa,
                                                      xcgarant,
                                                      xnriesgo,
                                                      xctipcoa,
                                                      xcageven_gar,
                                                      xnmovima_gar
                                                     );

                           IF error = 0
                           THEN
                              ha_grabat := TRUE;
                           ELSE
                              CLOSE cur_garansegant;

                              RETURN error;
                           END IF;
                        END IF;
                     END IF;
                  END IF;

                  FETCH cur_garansegant
                   INTO xcgarant, xnriesgo, xfiniefe, xnorden, xctarifa,
                        xicapital, xprecarg, xiprianu, xfinefe, xcformul,
                        xiextrap, xctipfra, xifranqu, xnmovimi, xidtocom,
                        xcageven_gar, xnmovima_gar, xcampanya, xpdtocom,
                        xitarrea;                 -- BUG: 12993 AVT 09-02-2010
               END LOOP;

               CLOSE cur_garansegant;
            END IF;

-- **********************************************************
-- Ara cridarem a la funció que calcula les dades del consorci
-- **********************************************************
            IF ptipomovimiento IN (1, 11)
            THEN
               facconsor := facdevsup;
               facconsorfra := facnet;                          --JAMF  11903
            ELSE
               facconsor := facdev;
               facconsorfra := facnet;                          --JAMF  11903
            END IF;

            error :=
               pac_adm.f_consorci (pnproces,
                                   psseguro,
                                   pnrecibo,
                                   pnriesgo,
                                   pfefecto,
                                   xffinrec,
                                   pmodo,
                                   ptipomovimiento,
                                   xcramo,
                                   xcmodali,
                                   xcactivi,
                                   xccolect,
                                   xctipseg,
                                   xcduraci,
                                   xnduraci,
                                   pnmovimi,
                                   pgrabar,
                                   xnmovimiant,
                                   facconsor,
                                   facconsorfra,
                                   --JAMF 11903
                                   xaltarisc,
                                   xcapieve,
                                   pttabla,
                                   pfuncion,
                                   pctipapo
                                  );

            -- Bug 12589 - FAL - 01/04/2010 -- Añadir parametro pctipapo a f_consorci
            IF error = 0
            THEN
               IF pgrabar = 1
               THEN
                  ha_grabat := TRUE;
               END IF;
            ELSE
               RETURN error;
            END IF;

-- *******1***************************************************
-- FASE 3 : Càlcul descomptes, recàrrecs i impostos
-- **********************************************************
            error :=
               pac_adm.f_imprecibos (pnproces,
                                     pnrecibo,
                                     ptipomovimiento,
                                     pmodo,
                                     pnriesgo,
                                     xpdtoord,
                                     xcrecfra,
                                     xcforpag,
                                     xcramo,
                                     xcmodali,
                                     xctipseg,
                                     xccolect,
                                     xcactivi,
                                     comis_agente,
                                     reten_agente,
                                     psseguro,
                                     pcmodcom,
                                     decimals,
                                     xpprorata,
                                     pttabla,
                                     pfuncion
                                    );

            IF error <> 0
            THEN
               RETURN error;
            END IF;

-- ********************************************************************************
-- Ara mirarem si la prima neta total és negativa. Si ho és, es tracta d' un extorn
-- ********************************************************************************
            BEGIN
               SELECT   SUM (DECODE (cconcep, 0, iconcep, 50, iconcep, 0))
                      - SUM (DECODE (cconcep, 29, iconcep, 26, iconcep, 0)),
                      -- total neta
                      SUM (DECODE (cconcep, 21, iconcep, 71, iconcep, 0))
                 -- total devengada
               INTO   xtotprimaneta,
                      xtotprimadeve
                 FROM tmp_adm_detrecibos
                WHERE nrecibo = pnrecibo
                      AND cconcep IN (0, 50, 21, 71, 26, 29);
            EXCEPTION
               WHEN OTHERS
               THEN
                  RETURN 103512;             -- Error al llegir de DETRECIBOS
            END;

            IF xtotprimaneta < 0 OR xtotprimadeve < 0
            THEN
               IF xctiprec <> 10
               THEN
                  -- No és un extorn d' anul.lació
                  BEGIN
                     lpermerita := NVL (f_parinstalacion_n ('PERMERITA'), 0);

                     -- xex_pte_imp = 1 (Extorn pendent d'imprimir)
                     -- xex_pte_imp = 0 (Extorn pendent de transferir)
                     UPDATE tmp_adm_recibos
                        SET ctiprec = 9,           -- Si la prima és negativa,
                            cestimp =
                               DECODE (cestimp,
                                       4, DECODE (xex_pte_imp, 0, 7, 1),
                                       cestimp
                                      ),
                            nperven =
                               DECODE (lpermerita,
                                       0, nperven,
                                       1, TO_CHAR (femisio, 'yyyymm')
                                      )
                      WHERE nrecibo = pnrecibo;      -- es tracta d' un extorn
                  EXCEPTION
                     WHEN OTHERS
                     THEN
                        RETURN 102358; -- Error al modificar la taula RECIBOS
                  END;

                  -- BUG: 12961 AVT 22-02-2010 s'ajusta pels rebuts d'extorn
                  FOR reg IN (SELECT   cgarant, SUM (iconcep) iconcep
                                  FROM tmp_adm_detrecibos
                                 WHERE nrecibo = pnrecibo
                              GROUP BY cgarant)
                  LOOP
                     IF reg.iconcep = 0
                     THEN
                        BEGIN
                           DELETE      tmp_adm_detrecibos
                                 WHERE nrecibo = pnrecibo
                                   AND cgarant = reg.cgarant;
                        EXCEPTION
                           WHEN NO_DATA_FOUND
                           THEN
                              NULL;
                           WHEN OTHERS
                           THEN
                              RETURN 104377;
                        END;
                     END IF;
                  END LOOP;
               END IF;

               error := pac_adm.f_extornpos (pnrecibo, pmodo, pnproces);

               IF error <> 0
               THEN
                  RETURN error;
               END IF;
            END IF;

            IF ha_grabat = TRUE
            THEN
               error := pac_adm.f_tmp_vdetrecibos (pmodo, pnrecibo);

               IF error = 0
               THEN
                  error :=
                     pac_cesionesrea.f_cessio_det (pnproces,
                                                   psseguro,
                                                   pnrecibo,
                                                   xcactivi,
                                                   xcramo,
                                                   xcmodali,
                                                   xctipseg,
                                                   xccolect,
                                                   pfefecto,
                                                   pfvencim,
                                                   facces,
                                                   decimals,
                                                   1,
                                                   'EST'
                                                  );

                  IF error <> 0
                  THEN
                     RETURN error;
                  END IF;

                  IF pfemisio < pfefecto
                  THEN
                     xfmovim := pfefecto;
                  ELSE
                     xfmovim := pfemisio;
                  END IF;

                  error :=
                     pac_adm.f_tmprebnoimprim (pnrecibo,
                                               xfmovim,
                                               xcimprim,
                                               xcestaux
                                              );
                  RETURN error;
               ELSE
                  RETURN error;
               END IF;
            ELSIF NVL (f_parinstalacion_n ('DETREC99NO'), 0) != 1
            THEN
               -- No ha grabat res a DETRECIBOS
               --    IF xinnomin = 4 THEN  -- si es innominado
               --      BEGIN
               --     SELECT NVL(COUNT(nriesgo), 0)
               --       INTO xcontriesg
               --       FROM riesgos
               --      WHERE sseguro = psseguro
               --                  AND ((nriesgo = pnriesgo) OR pnriesgo is NULL)
               --                  AND nasegur > 0
               --                  AND fanulac is null;
               --      EXCEPTION
               --     WHEN others THEN
               --       RETURN 103509;    -- Error al llegir de RIESGOS
               --      END;
               --      IF xcontriesg = 0 THEN      -- Es innominat i tots els
               -- riscs ténen nasegur = 0
               -- Si nasegur = 0, grabamos el concepto 99 en DETRECIBOS,
               -- y generamos VDETRECIBOS, y hacemos el recibo no imprimible
               BEGIN
                  SELECT MIN (cgarant), MIN (nriesgo)
                    INTO xcgarant, xnriesgo
                    FROM garanseg
                   WHERE sseguro = psseguro AND ffinefe IS NULL;
               EXCEPTION
                  WHEN OTHERS
                  THEN
                     RETURN 103500;            -- Error al llegir de GARANSEG
               END;

               -- 26755 AVT 22/04/2013 pels conceptes que el 100% va al concepte normal no fem el concepte de coaseguro (cc: 14 i 86)
               error :=
                  pac_adm.f_instmpdetrec (pnrecibo,
                                          99,
                                          0,
                                          --xploccoa
                                          100,
                                          xcgarant,
                                          xnriesgo,
                                          xctipcoa,
                                          xcageven_gar,
                                          xnmovima_gar
                                         );

               IF error = 0
               THEN
                  error := pac_adm.f_tmp_vdetrecibos (pmodo, pnrecibo);

                  IF error = 0
                  THEN
                     error :=
                        pac_cesionesrea.f_cessio_det (pnproces,
                                                      psseguro,
                                                      pnrecibo,
                                                      xcactivi,
                                                      xcramo,
                                                      xcmodali,
                                                      xctipseg,
                                                      xccolect,
                                                      pfefecto,
                                                      pfvencim,
                                                      facces,
                                                      decimals,
                                                      1,
                                                      'EST'
                                                     );

                     IF error <> 0
                     THEN
                        RETURN error;
                     END IF;

                     IF pfemisio < pfefecto
                     THEN
                        xfmovim := pfefecto;
                     ELSE
                        xfmovim := pfemisio;
                     END IF;

                     error :=
                        pac_adm.f_tmprebnoimprim (pnrecibo,
                                                  xfmovim,
                                                  xcimprim,
                                                  xcestaux
                                                 );
                     RETURN error;
                  ELSE
                     RETURN error;
                  END IF;
               ELSE
                  RETURN error;
               END IF;
            ELSE
               RETURN 103108;
            -- No se ha grabado ningún registro en el cálculo de recibos
            END IF;
         --         RETURN 105154;  -- Error especial (que se controla en la llamada de esta función
         --  ELSE
         --    RETURN 103108; -- No se ha grabado ningún registro en el cálculo de recibos
         --         END IF;
         --       ELSE              -- No és innominat
         --  RETURN 103108;   -- No s' ha grabat cap registre en el càlcul de rebuts
         --       END IF;
         ELSIF pmodo IN ('P', 'PRIE')
         THEN
-- proves (avanç cartera)
--*****************************************************************
--********************** M O D O    P R U E B A S *****************
--*****************************************************************
            IF ptipomovimiento = 21
            THEN
               OPEN cur_garancar;

               FETCH cur_garancar
                INTO xcgarant, xnriesgo, xfiniefe, xnorden, xctarifa,
                     xicapital, xprecarg, xiprianu, xfinefe, xcformul,
                     xiextrap, xidtocom, xcageven_gar, xnmovima_gar,
                     xpdtocom, xitarrea;         -- BUG: 12993 AVT 09-02-2010

               WHILE cur_garancar%FOUND
               LOOP
                  xnasegur := NULL;
                  xnasegur1 := NULL;

                  IF pttabla = 'SOL'
                  THEN
                     BEGIN
                        SELECT DECODE (nasegur, NULL, 1, nasegur)
                          INTO xnasegur
                          FROM solriesgos
                         WHERE ssolicit = psseguro AND nriesgo = xnriesgo;
                     EXCEPTION
                        WHEN NO_DATA_FOUND
                        THEN
                           CLOSE cur_garancar;

                           RETURN 103836;
                        WHEN OTHERS
                        THEN
                           CLOSE cur_garancar;

                           RETURN 103509;
                     END;
                  ELSIF pttabla = 'EST'
                  THEN
                     BEGIN
                        SELECT DECODE (nasegur, NULL, 1, nasegur)
                          INTO xnasegur
                          FROM estriesgos
                         WHERE sseguro = psseguro AND nriesgo = xnriesgo;
                     EXCEPTION
                        WHEN NO_DATA_FOUND
                        THEN
                           CLOSE cur_garancar;

                           RETURN 103836;
                        WHEN OTHERS
                        THEN
                           CLOSE cur_garancar;

                           RETURN 103509;
                     END;
                  ELSE
                     BEGIN
                        SELECT DECODE (nasegur, NULL, 1, nasegur)
                          INTO xnasegur
                          FROM riesgos
                         WHERE sseguro = psseguro AND nriesgo = xnriesgo;
                     EXCEPTION
                        WHEN NO_DATA_FOUND
                        THEN
                           CLOSE cur_garancar;

                           RETURN 103836;
                        WHEN OTHERS
                        THEN
                           CLOSE cur_garancar;

                           RETURN 103509;
                     END;
                  END IF;

                  xidtocom := 0 - NVL (xidtocom, 0);

                  -- ********** Conceptos extraordinarios ***********
                  IF sw_cextr = 1
                  THEN
                     error :=
                        fl_inbucle_extrarec (pnrecibo,
                                             pfemisio,
                                             psseguro,
                                             xcgarant,
                                             xploccoa,
                                             xctipcoa,
                                             xcageven_gar,
                                             xnmovima_gar,
                                             pnproces,
                                             xnriesgo,
                                             w_nmeses_cexter,
                                             ha_grabado
                                            );

                     IF ha_grabado = 1
                     THEN
                        ha_grabat := TRUE;
                     END IF;

                     IF error <> 0
                     THEN
                        CLOSE cur_garanseg;

                        RETURN error;
                     END IF;
                  END IF;

                  -- ******** Prima Neta *********
                  xiprianu2 :=
                              f_round (xiprianu * facnet * xnasegur, decimals);
                  xpprorata := facnet;

                  -- Si te ctipreb = 4 (per aportant) la prima s'ha de repartir
                  -- segons pctipapo = 1 ( Aplicar el porcentatge = ppimpapo)
                  --        pctipapo = 1 (import fixe = piimpapo)
                  IF xctipreb = 4
                  THEN
                     -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                     -- Bug 7854 y 8745 Eliminamos esta condiciona 'w_pargaranpro = 3'
                     --IF w_pargaranpro = 3 THEN
                     /*
                     IF pctipapo = 1
                     THEN
                        xiprianu2 :=
                               f_round (xiprianu2 * ppimpapo / 100, decimals);
                     ELSIF pctipapo = 2
                     THEN
                        xiprianu2 :=
                             f_round (piimpapo * facnet * xnasegur, decimals);
                     END IF;
                     */

                     -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                     IF pctipapo = 1
                     THEN
                        FOR vapor IN cur_aportaseg (psseguro,
                                                    pfefecto,
                                                    xnriesgo
                                                   )
                        LOOP
                           IF vapor.ctipimp = 1
                           THEN
                              xiprianu2 :=
                                 f_round (xiprianu2 * vapor.pimport / 100,
                                          decimals
                                         );
                           ELSIF vapor.ctipimp = 2
                           THEN
                              --xiprianu2 := f_round (vapor.iimport * facnet * xnasegur, decimals);
                              xiprianu2 := LEAST (xiprianu2, vapor.iimport);
                           END IF;
                        END LOOP;
                     ELSIF pctipapo = 2
                     THEN
                        FOR vapor IN cur_aportaseg (psseguro,
                                                    pfefecto,
                                                    xnriesgo
                                                   )
                        LOOP
                           IF vapor.ctipimp = 1
                           THEN
                              xiprianu2 :=
                                 f_round (  xiprianu2
                                          * (1 - (vapor.pimport / 100)),
                                          decimals
                                         );
                           ELSIF vapor.ctipimp = 2
                           THEN
                              --xiprianu2 := f_round (vapor.iimport * facnet * xnasegur, decimals);
                              xiprianu2 :=
                                      GREATEST (0, xiprianu2 - vapor.iimport);
                           END IF;
                        END LOOP;
                     END IF;
                  --ELSE
                  --   xiprianu2 := 0;
                  --END IF;
                  END IF;

                  IF NVL (xiprianu2, 0) <> 0
                  THEN
                     error :=
                        pac_adm.f_instmpdetrec (pnrecibo,
                                                0,
                                                xiprianu2,
                                                xploccoa,
                                                xcgarant,
                                                xnriesgo,
                                                xctipcoa,
                                                xcageven_gar,
                                                xnmovima_gar
                                               );

                     IF error = 0
                     THEN
                        ha_grabat := TRUE;

                        IF sw_aln = 1
                        THEN
                           w_importe_aux :=
                                      f_round (xiprianu * xnasegur, decimals);
                           error :=
                              fl_grabar_calcomisprev (psseguro,
                                                      pnrecibo,
                                                      xcgarant,
                                                      xnriesgo,
                                                      xcageven_gar,
                                                      xnmovima_gar,
                                                      w_importe_aux,
                                                      pfefecto,
                                                      pfvencim,
                                                      pmodo,
                                                      pnproces
                                                     );

                           IF error <> 0
                           THEN
                              CLOSE cur_garancar;

                              RETURN error;
                           END IF;
                        END IF;
                     ELSE
                        CLOSE cur_garancar;

                        RETURN error;
                     END IF;
                  END IF;

                  -- ******* Dte. comercial *******
                  xidtocom2 :=
                              f_round (xidtocom * facnet * xnasegur, decimals);

                  -- Si te ctipreb = 4 (per aportant) l'import s'ha de repartir
                  -- segons pctipapo = 1 ( Aplicar el porcentatge = ppimpapo)
                  --        pctipapo = 1 (import fixe = piimpapo)
                  IF xctipreb = 4
                  THEN
                     -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                     -- Bug 7854 y 8745 Eliminamos esta condiciona 'w_pargaranpro = 3'
                     --IF w_pargaranpro = 3 THEN
                     /*
                     IF pctipapo = 1 THEN
                        xidtocom2 :=
                               f_round (xidtocom2 * ppimpapo / 100, decimals);
                     ELSIF pctipapo = 2 THEN
                        -- hen de calcular el descompte per l'import fixe xiprianu2
                        xidtocom2 :=
                           f_round (  f_round ((xiprianu2 * xpdtocom) / 100,
                                               decimals
                                              )
                                    * facnet
                                    * xnasegur,
                                    decimals
                                   );
                     END IF;
                     */

                     -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                     IF pctipapo = 1
                     THEN
                        FOR vapor IN cur_aportaseg (psseguro,
                                                    pfefecto,
                                                    xnriesgo
                                                   )
                        LOOP
                           IF vapor.ctipimp = 1
                           THEN
                              xidtocom2 :=
                                 f_round (xidtocom2 * vapor.pimport / 100,
                                          decimals
                                         );
                           ELSIF vapor.ctipimp = 2
                           THEN
                              xidtocom2 :=
                                 f_round (  f_round (  (xiprianu2 * xpdtocom
                                                       )
                                                     / 100,
                                                     decimals
                                                    )
                                          * facnet
                                          * xnasegur,
                                          decimals
                                         );

                              -- Se porratea el importe de descuento

                              --BUG11280-XVM-29092009 inici
                              IF xiprianu2 <> 0
                              THEN
                                 xidtocom2 :=
                                    LEAST (  (xidtocom2 * vapor.iimport)
                                           / xiprianu2,
                                           vapor.iimport
                                          );
                              ELSE
                                 xidtocom2 := 0;
                              END IF;
                           --BUG11280-XVM-29092009 fi
                           END IF;
                        END LOOP;
                     ELSIF pctipapo = 2
                     THEN
                        FOR vapor IN cur_aportaseg (psseguro,
                                                    pfefecto,
                                                    xnriesgo
                                                   )
                        LOOP
                           IF vapor.ctipimp = 1
                           THEN
                              xidtocom2 :=
                                 f_round (  xidtocom2
                                          * (1 - (vapor.pimport / 100)),
                                          decimals
                                         );
                           ELSIF vapor.ctipimp = 2
                           THEN
                              xidtocom2 :=
                                 f_round (  f_round (  (xiprianu2 * xpdtocom
                                                       )
                                                     / 100,
                                                     decimals
                                                    )
                                          * facnet
                                          * xnasegur,
                                          decimals
                                         );

                              --BUG11280-XVM-29092009 inici
                              IF xiprianu2 <> 0
                              THEN
                                 xidtocom2 :=
                                    GREATEST (0,
                                                (  (xidtocom2 * vapor.iimport
                                                   )
                                                 / xiprianu2
                                                )
                                              - vapor.iimport
                                             );
                              ELSE
                                 xidtocom2 := 0;
                              END IF;
                           --BUG11280-XVM-29092009 fi
                           END IF;
                        END LOOP;
                     END IF;
                  --ELSE
                  --   xidtocom2 := 0;
                  --END IF;
                  END IF;

                  IF xidtocom2 <> 0 AND xidtocom2 IS NOT NULL
                  THEN
                     error :=
                        pac_adm.f_instmpdetrec (pnrecibo,
                                                10,
                                                xidtocom2,
                                                xploccoa,
                                                xcgarant,
                                                xnriesgo,
                                                xctipcoa,
                                                xcageven_gar,
                                                xnmovima_gar
                                               );

                     IF error = 0
                     THEN
                        ha_grabat := TRUE;
                     ELSE
                        CLOSE cur_garancar;

                        RETURN error;
                     END IF;
                  END IF;

                  -- ******** Prima Devengada *******
                  xiprianu2 :=
                              f_round (xiprianu * facdev * xnasegur, decimals);

                  -- Si te ctipreb = 4 (per aportant) la prima s'ha de repartir
                  -- segons pctipapo = 1 ( Aplicar el porcentatge = ppimpapo)
                  --        pctipapo = 1 (import fixe = piimpapo)
                  IF xctipreb = 4
                  THEN
                     -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                     -- Bug 7854 y 8745 Eliminamos esta condiciona 'w_pargaranpro = 3'
                     --IF w_pargaranpro = 3 THEN
                     /*
                     IF pctipapo = 1 THEN
                        xiprianu2 :=
                               f_round (xiprianu2 * ppimpapo / 100, decimals);
                     ELSIF pctipapo = 2 THEN
                        xiprianu2 :=
                             f_round (piimpapo * facdev * xnasegur, decimals);
                     END IF;
                     */

                     -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                     IF pctipapo = 1
                     THEN
                        FOR vapor IN cur_aportaseg (psseguro,
                                                    pfefecto,
                                                    xnriesgo
                                                   )
                        LOOP
                           IF vapor.ctipimp = 1
                           THEN
                              xiprianu2 :=
                                 f_round (xiprianu2 * vapor.pimport / 100,
                                          decimals
                                         );
                           ELSIF vapor.ctipimp = 2
                           THEN
                              --xiprianu2 := f_round (vapor.iimport * facnet * xnasegur, decimals);
                              xiprianu2 := LEAST (xiprianu2, vapor.iimport);
                           END IF;
                        END LOOP;
                     ELSIF pctipapo = 2
                     THEN
                        FOR vapor IN cur_aportaseg (psseguro,
                                                    pfefecto,
                                                    xnriesgo
                                                   )
                        LOOP
                           IF vapor.ctipimp = 1
                           THEN
                              xiprianu2 :=
                                 f_round (  xiprianu2
                                          * (1 - (vapor.pimport / 100)),
                                          decimals
                                         );
                           ELSIF vapor.ctipimp = 2
                           THEN
                              --xiprianu2 := f_round (vapor.iimport * facnet * xnasegur, decimals);
                              xiprianu2 :=
                                      GREATEST (0, xiprianu2 - vapor.iimport);
                           END IF;
                        END LOOP;
                     END IF;
                  --ELSE
                  --   xiprianu2 := 0;
                  --END IF;
                  END IF;

                  IF NVL (xiprianu2, 0) <> 0
                  THEN
                     -- Comprovar si ha de generar venda, segons el paràmetre per garantia GENVENTA
                     error :=
                        f_pargaranpro (xcramo,
                                       xcmodali,
                                       xctipseg,
                                       xccolect,
                                       xcactivi,
                                       xcgarant,
                                       'GENVENTA',
                                       lcvalpar
                                      );

                     IF error <> 0
                     THEN
                        RETURN error;
                     ELSE
                        IF NVL (lcvalpar, 1) = 1
                        THEN
                           -- La garantia genera venda
                           error :=
                              pac_adm.f_instmpdetrec (pnrecibo,
                                                      21,
                                                      xiprianu2,
                                                      xploccoa,
                                                      xcgarant,
                                                      xnriesgo,
                                                      xctipcoa,
                                                      xcageven_gar,
                                                      xnmovima_gar
                                                     );

                           IF error = 0
                           THEN
                              ha_grabat := TRUE;
                           ELSE
                              CLOSE cur_garancar;

                              RETURN error;
                           END IF;
                        END IF;
                     END IF;
---------------
                  END IF;

                  FETCH cur_garancar
                   INTO xcgarant, xnriesgo, xfiniefe, xnorden, xctarifa,
                        xicapital, xprecarg, xiprianu, xfinefe, xcformul,
                        xiextrap, xidtocom, xcageven_gar, xnmovima_gar,
                        xpdtocom, xitarrea;       -- BUG: 12993 AVT 09-02-2010
               END LOOP;

               CLOSE cur_garancar;
            ELSIF ptipomovimiento IN (0, 1, 6, 22, 100)
            THEN
               IF pfuncion = 'TAR'
               THEN
                  vselect :=
                        'SELECT cgarant, nriesgo, finiefe, norden, ctarifa, NVL (icapital, 0),'
                     || '       precarg, NVL (iprianu, 0), ffinefe, cformul, iextrap, ctipfra,'
                     || '       ifranqu, 1, idtocom, cageven, nmovima, ccampanya, pdtocom'
                     || ' FROM tmp_garancar'
                     || ' WHERE sseguro = '
                     || psseguro
                     || '   AND sproces = '
                     || pnproces;

                  IF pnriesgo IS NOT NULL
                  THEN
                     vselect := vselect || ' AND nriesgo = ' || pnriesgo;
                  END IF;
               ELSIF pfuncion = 'CAR'
               THEN
                  vselect :=
                        'SELECT cgarant, nriesgo, finiefe, norden, ctarifa, NVL (icaptot, 0),'
                     || '       precarg, NVL (ipritot, 0), ffinefe, cformul, iextrap, ctipfra,'
                     || '       ifranqu, nmovimi, idtocom, cageven, nmovima, ccampanya, pdtocom'
                     || ' FROM garanseg'
                     || ' WHERE sseguro = '
                     || psseguro;

                  IF pnriesgo IS NOT NULL
                  THEN
                     vselect := vselect || ' AND nriesgo = ' || pnriesgo;
                  END IF;

                  vselect := vselect || ' AND nmovimi = ' || pnmovimi;
                  --JRH 11/2008 Corregimos el previo de cartera para que no salgan recibos de P Extraordinaria.
                  vselect :=
                        vselect
                     || ' AND NVL (f_pargaranpro_v ('
                     || xcramo
                     || ', '
                     || '                          '
                     || xcmodali
                     || ', '
                     || '                          '
                     || xctipseg
                     || ', '
                     || '                          '
                     || xccolect
                     || ', '
                     || '                          NVL ('
                     || xcactivi
                     || ', 0),'
                     || '                          garanseg.cgarant,'
                     || '                          ''TIPO'''
                     || '                           ), 0) <> 4';
                  -- Bug 7926 - RSC - 28/05/2009 -- Se modifica la select del cursor  para que tenga en
                  --                                cuenta si la garantía ha vencido ya (solo para el previo,
                  --                                ya que en la cartera real ya se da de baja la garantía antes
                  --                                y por tanto la garantía ya no entra en el cursor.
                  vselect :=
                        vselect
                     || ' AND  TO_DATE('''
                     || TO_CHAR ((pfefecto), 'dd/mm/yyyy')
                     || ''',''dd/mm/yyyy'') '
                     || '< NVL(pac_seguros.F_VTO_GARANTIA(sseguro,
                                                                   nriesgo,
                                                                   cgarant,
                                                                   nmovimi), TO_DATE('''
                     || TO_CHAR ((pfefecto + 1), 'dd/mm/yyyy')
                     || ''',''dd/mm/yyyy''))';
               -- Fin Bug 7926
               END IF;

               OPEN curgaran FOR vselect;

               FETCH curgaran
                INTO xcgarant, xnriesgo, xfiniefe, xnorden, xctarifa,
                     xicapital, xprecarg, xiprianu, xfinefe, xcformul,
                     xiextrap, xctipfra, xifranqu, xnmovimi, xidtocom,
                     xcageven_gar, xnmovima_gar, xcampanya, xpdtocom;

               WHILE curgaran%FOUND
               LOOP
                  xnasegur := NULL;
                  xnasegur1 := NULL;

                  IF pttabla = 'SOL'
                  THEN
                     BEGIN
                        SELECT DECODE (nasegur, NULL, 1, nasegur), 1
                          INTO xnasegur, xnmovima
                          FROM solriesgos
                         WHERE ssolicit = psseguro AND nriesgo = xnriesgo;
                     EXCEPTION
                        WHEN NO_DATA_FOUND
                        THEN
                           CLOSE curgaran;

                           RETURN 103836;
                        WHEN OTHERS
                        THEN
                           CLOSE curgaran;

                           RETURN 103509;
                     END;
                  ELSIF pttabla = 'EST'
                  THEN
                     BEGIN
                        SELECT DECODE (nasegur, NULL, 1, nasegur), nmovima
                          INTO xnasegur, xnmovima
                          FROM estriesgos
                         WHERE sseguro = psseguro AND nriesgo = xnriesgo;
                     EXCEPTION
                        WHEN NO_DATA_FOUND
                        THEN
                           CLOSE curgaran;

                           RETURN 103836;
                        WHEN OTHERS
                        THEN
                           CLOSE curgaran;

                           RETURN 103509;
                     END;
                  ELSE
                     BEGIN
                        SELECT DECODE (nasegur, NULL, 1, nasegur), nmovima
                          INTO xnasegur, xnmovima
                          FROM riesgos
                         WHERE sseguro = psseguro AND nriesgo = xnriesgo;
                     EXCEPTION
                        WHEN NO_DATA_FOUND
                        THEN
                           CLOSE curgaran;

                           RETURN 103836;
                        WHEN OTHERS
                        THEN
                           CLOSE curgaran;

                           RETURN 103509;
                     END;
                  END IF;

                  -- ********** Conceptos extraordinarios ***********
                  IF sw_cextr = 1
                  THEN
                     error :=
                        fl_inbucle_extrarec (pnrecibo,
                                             pfemisio,
                                             psseguro,
                                             xcgarant,
                                             xploccoa,
                                             xctipcoa,
                                             xcageven_gar,
                                             xnmovima_gar,
                                             pnproces,
                                             xnriesgo,
                                             w_nmeses_cexter,
                                             ha_grabado
                                            );

                     IF ha_grabado = 1
                     THEN
                        ha_grabat := TRUE;
                     END IF;

                     IF error <> 0
                     THEN
                        CLOSE curgaran;

                        RETURN error;
                     END IF;
                  END IF;

                  xidtocom := 0 - NVL (xidtocom, 0);

-- *******************************************************************************
-- Fase 1: Càlcul de la Prima Neta (cconcep = 0) y de la Prima Devengada (Fase 2).
-- *******************************************************************************
                  IF ptipomovimiento IN (0, 6, 22)
                  THEN
                     -- ***** Prima Neta *****
                     xiprianu2 :=
                             f_round (xiprianu * facnet * xnasegur, decimals);
                     xpprorata := facnet;

                     -- Si te ctipreb = 4 (per aportant) la prima s'ha de repartir
                     -- segons pctipapo = 1 ( Aplicar el porcentatge = ppimpapo)
                     --        pctipapo = 1 (import fixe = piimpapo)
                     IF xctipreb = 4
                     THEN
                        -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                        -- Bug 7854 y 8745 Eliminamos esta condiciona 'w_pargaranpro = 3'
                        --IF w_pargaranpro = 3 THEN
                        /*
                        IF pctipapo = 1 THEN
                           xiprianu2 :=
                               f_round (xiprianu2 * ppimpapo / 100, decimals);
                        ELSIF pctipapo = 2 THEN
                           xiprianu2 :=
                              f_round (piimpapo * facnet * xnasegur,
                                       decimals);
                        END IF;
                        */

                        -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                        IF pctipapo = 1
                        THEN
                           FOR vapor IN cur_aportaseg (psseguro,
                                                       pfefecto,
                                                       xnriesgo
                                                      )
                           LOOP
                              IF vapor.ctipimp = 1
                              THEN
                                 xiprianu2 :=
                                    f_round (xiprianu2 * vapor.pimport / 100,
                                             decimals
                                            );
                              ELSIF vapor.ctipimp = 2
                              THEN
                                 --xiprianu2 := f_round (vapor.iimport * facnet * xnasegur, decimals);
                                 xiprianu2 :=
                                             LEAST (xiprianu2, vapor.iimport);
                              END IF;
                           END LOOP;
                        ELSIF pctipapo = 2
                        THEN
                           FOR vapor IN cur_aportaseg (psseguro,
                                                       pfefecto,
                                                       xnriesgo
                                                      )
                           LOOP
                              IF vapor.ctipimp = 1
                              THEN
                                 xiprianu2 :=
                                    f_round (  xiprianu2
                                             * (1 - (vapor.pimport / 100)),
                                             decimals
                                            );
                              ELSIF vapor.ctipimp = 2
                              THEN
                                 --xiprianu2 := f_round (vapor.iimport * facnet * xnasegur, decimals);
                                 xiprianu2 :=
                                      GREATEST (0, xiprianu2 - vapor.iimport);
                              END IF;
                           END LOOP;
                        END IF;
                     --ELSE
                     --   xiprianu2 := 0;
                     --END IF;
                     END IF;

                     IF NVL (xiprianu2, 0) <> 0
                     THEN
                        error :=
                           pac_adm.f_instmpdetrec (pnrecibo,
                                                   0,
                                                   xiprianu2,
                                                   xploccoa,
                                                   xcgarant,
                                                   xnriesgo,
                                                   xctipcoa,
                                                   xcageven_gar,
                                                   xnmovima_gar
                                                  );

                        IF error = 0
                        THEN
                           ha_grabat := TRUE;

                           IF sw_aln = 1
                           THEN
                              w_importe_aux :=
                                      f_round (xiprianu * xnasegur, decimals);
                              error :=
                                 fl_grabar_calcomisprev (psseguro,
                                                         pnrecibo,
                                                         xcgarant,
                                                         xnriesgo,
                                                         xcageven_gar,
                                                         xnmovima_gar,
                                                         w_importe_aux,
                                                         pfefecto,
                                                         pfvencim,
                                                         pmodo,
                                                         pnproces
                                                        );

                              IF error <> 0
                              THEN
                                 CLOSE curgaran;

                                 RETURN error;
                              END IF;
                           END IF;
                        ELSE
                           CLOSE curgaran;

                           RETURN error;
                        END IF;
                     END IF;

                     -- ****** Descuento comercial
                     xidtocom2 :=
                              f_round (xidtocom * facnet * xnasegur, decimals);

                     -- Si te ctipreb = 4 (per aportant) l'import s'ha de repartir
                     -- segons pctipapo = 1 ( Aplicar el porcentatge = ppimpapo)
                     --        pctipapo = 1 (import fixe = piimpapo)
                     IF xctipreb = 4
                     THEN
                        -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                        -- Bug 7854 y 8745 Eliminamos esta condiciona 'w_pargaranpro = 3'
                        --IF w_pargaranpro = 3 THEN
                        /*
                        IF pctipapo = 1 THEN
                           xidtocom2 :=
                               f_round (xidtocom2 * ppimpapo / 100, decimals);
                        ELSIF pctipapo = 2 THEN
                           -- hen de calcular el descompte per l'import fixe xiprianu2
                           xidtocom2 :=
                              f_round (  f_round ((xiprianu2 * xpdtocom) / 100,
                                                  decimals
                                                 )
                                       * facnet
                                       * xnasegur,
                                       decimals
                                      );
                        END IF;
                        */

                        -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                        IF pctipapo = 1
                        THEN
                           FOR vapor IN cur_aportaseg (psseguro,
                                                       pfefecto,
                                                       xnriesgo
                                                      )
                           LOOP
                              IF vapor.ctipimp = 1
                              THEN
                                 xidtocom2 :=
                                    f_round (xidtocom2 * vapor.pimport / 100,
                                             decimals
                                            );
                              ELSIF vapor.ctipimp = 2
                              THEN
                                 xidtocom2 :=
                                    f_round (  f_round (  (xiprianu2
                                                           * xpdtocom
                                                          )
                                                        / 100,
                                                        decimals
                                                       )
                                             * facnet
                                             * xnasegur,
                                             decimals
                                            );

                                 -- Se porratea el importe de descuento

                                 --BUG11280-XVM-29092009 inici
                                 IF xiprianu2 <> 0
                                 THEN
                                    xidtocom2 :=
                                       LEAST (  (xidtocom2 * vapor.iimport)
                                              / xiprianu2,
                                              vapor.iimport
                                             );
                                 ELSE
                                    xidtocom2 := 0;
                                 END IF;
                              --BUG11280-XVM-29092009 fi
                              END IF;
                           END LOOP;
                        ELSIF pctipapo = 2
                        THEN
                           FOR vapor IN cur_aportaseg (psseguro,
                                                       pfefecto,
                                                       xnriesgo
                                                      )
                           LOOP
                              IF vapor.ctipimp = 1
                              THEN
                                 xidtocom2 :=
                                    f_round (  xidtocom2
                                             * (1 - (vapor.pimport / 100)),
                                             decimals
                                            );
                              ELSIF vapor.ctipimp = 2
                              THEN
                                 xidtocom2 :=
                                    f_round (  f_round (  (xiprianu2
                                                           * xpdtocom
                                                          )
                                                        / 100,
                                                        decimals
                                                       )
                                             * facnet
                                             * xnasegur,
                                             decimals
                                            );

                                 --BUG11280-XVM-29092009 inici
                                 IF xiprianu2 <> 0
                                 THEN
                                    xidtocom2 :=
                                       GREATEST (0,
                                                   (  (  xidtocom2
                                                       * vapor.iimport
                                                      )
                                                    / xiprianu2
                                                   )
                                                 - vapor.iimport
                                                );
                                 ELSE
                                    xidtocom2 := 0;
                                 END IF;
                              --BUG11280-XVM-29092009 fi
                              END IF;
                           END LOOP;
                        END IF;
                     --ELSE
                     --   xidtocom2 := 0;
                     --END IF;
                     END IF;

                     IF xidtocom2 <> 0 AND xidtocom2 IS NOT NULL
                     THEN
                        error :=
                           pac_adm.f_instmpdetrec (pnrecibo,
                                                   10,
                                                   xidtocom2,
                                                   xploccoa,
                                                   xcgarant,
                                                   xnriesgo,
                                                   xctipcoa,
                                                   xcageven_gar,
                                                   xnmovima_gar
                                                  );

                        IF error = 0
                        THEN
                           ha_grabat := TRUE;
                        ELSE
                           -- CLOSE cur_garanseg;
                           CLOSE curgaran;

                           RETURN error;
                        END IF;
                     END IF;

                     -- ******* Prima Devengada ********
                     IF ptipomovimiento IN (0, 6)
                     THEN
                        xiprianu2 :=
                             f_round (xiprianu * facdev * xnasegur, decimals);

                        -- Si te ctipreb = 4 (per aportant) la prima s'ha de repartir
                        -- segons pctipapo = 1 ( Aplicar el porcentatge = ppimpapo)
                        --        pctipapo = 1 (import fixe = piimpapo)
                        IF xctipreb = 4
                        THEN
                           -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                           -- Bug 7854 y 8745 Eliminamos esta condiciona 'w_pargaranpro = 3'
                           --IF w_pargaranpro = 3 THEN
                           /*
                           IF pctipapo = 1 THEN
                              xiprianu2 :=
                                 f_round (xiprianu2 * ppimpapo / 100,
                                          decimals
                                         );
                           ELSIF pctipapo = 2 THEN
                              xiprianu2 :=
                                 f_round (piimpapo * facdev * xnasegur,
                                          decimals
                                         );
                           END IF;
                           */

                           -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                           IF pctipapo = 1
                           THEN
                              FOR vapor IN cur_aportaseg (psseguro,
                                                          pfefecto,
                                                          xnriesgo
                                                         )
                              LOOP
                                 IF vapor.ctipimp = 1
                                 THEN
                                    xiprianu2 :=
                                       f_round (xiprianu2 * vapor.pimport
                                                / 100,
                                                decimals
                                               );
                                 ELSIF vapor.ctipimp = 2
                                 THEN
                                    --xiprianu2 := f_round (vapor.iimport * facnet * xnasegur, decimals);
                                    xiprianu2 :=
                                             LEAST (xiprianu2, vapor.iimport);
                                 END IF;
                              END LOOP;
                           ELSIF pctipapo = 2
                           THEN
                              FOR vapor IN cur_aportaseg (psseguro,
                                                          pfefecto,
                                                          xnriesgo
                                                         )
                              LOOP
                                 IF vapor.ctipimp = 1
                                 THEN
                                    xiprianu2 :=
                                       f_round (  xiprianu2
                                                * (1 - (vapor.pimport / 100)
                                                  ),
                                                decimals
                                               );
                                 ELSIF vapor.ctipimp = 2
                                 THEN
                                    --xiprianu2 := f_round (vapor.iimport * facnet * xnasegur, decimals);
                                    xiprianu2 :=
                                       GREATEST (0,
                                                 xiprianu2 - vapor.iimport);
                                 END IF;
                              END LOOP;
                           END IF;
                        --ELSE
                        --   xiprianu2 := 0;
                        --END IF;
                        END IF;

                        IF NVL (xiprianu2, 0) <> 0
                        THEN
                           -- Comprovar si ha de generar venda, segons el paràmetre per garantia GENVENTA
                           error :=
                              f_pargaranpro (xcramo,
                                             xcmodali,
                                             xctipseg,
                                             xccolect,
                                             xcactivi,
                                             xcgarant,
                                             'GENVENTA',
                                             lcvalpar
                                            );

                           IF error <> 0
                           THEN
                              RETURN error;
                           ELSE
                              IF NVL (lcvalpar, 1) = 1
                              THEN
                                 -- La garantia genera venda
                                 error :=
                                    pac_adm.f_instmpdetrec (pnrecibo,
                                                            21,
                                                            xiprianu2,
                                                            xploccoa,
                                                            xcgarant,
                                                            xnriesgo,
                                                            xctipcoa,
                                                            xcageven_gar,
                                                            xnmovima_gar
                                                           );

                                 IF error = 0
                                 THEN
                                    ha_grabat := TRUE;
                                 ELSE
                                    CLOSE curgaran;

                                    RETURN error;
                                 END IF;
                              END IF;
                           END IF;
---------------
                        END IF;
                     END IF;
-- ***********************************************************
-- ********************Suplementos ***************************
-- ***********************************************************
                  ELSIF ptipomovimiento = 1
                  THEN
                     BEGIN
                        xxcgarant := NULL;
                        xxnriesgo := NULL;
                        xxfiniefe := NULL;
                        xxiprianu := NULL;
                        xxffinefe := NULL;
                        xxidtocom := NULL;

                        SELECT cgarant, nriesgo, finiefe, ipritot,
                               ffinefe, idtocom, cageven,
                               nmovima
                          INTO xxcgarant, xxnriesgo, xxfiniefe, xxiprianu,
                               xxffinefe, xxidtocom, xxcageven_gar,
                               xxnmovima_gar
                          FROM garanseg
                         WHERE sseguro = psseguro
                           AND cgarant = xcgarant
                           AND nriesgo = xnriesgo
                           AND nmovimi = xnmovimiant
                           AND nmovima = xnmovima_gar;
                     EXCEPTION
                        WHEN NO_DATA_FOUND
                        THEN
                           NULL;                -- No hi ha garantia anterior
                        WHEN TOO_MANY_ROWS
                        THEN
                           CLOSE curgaran;

                           error := 102310;
                           -- Garantia-Risc repetida en GARANSEG
                           RETURN error;
                        WHEN OTHERS
                        THEN
                           CLOSE curgaran;

                           error := 103500;    -- Error al llegir de GARANSEG
                           RETURN error;
                     END;

                     xxidtocom := 0 - NVL (xxidtocom, 0);
                     difiprianu :=
                         (xiprianu * xnasegur) - NVL (xxiprianu * xnasegur, 0);
                     difidtocom :=
                          NVL (xidtocom * xnasegur, 0)
                        - NVL (xxidtocom * xnasegur, 0);
                     xinsert := TRUE;
                     xpprorata := facnetsup;

                     IF xaltarisc
                     THEN
                        IF xnmovima = pnmovimi
                        THEN
                           xinsert := TRUE;
                        ELSE
                           xinsert := FALSE;
                        END IF;
                     END IF;

                     --mirem si s'ha donat d'alta una campanya.
                     IF f_parinstalacion_n ('CAMPANYA') = 1
                     THEN
                        IF NVL (xxcampanya, -2) <> NVL (xcampanya, -2)
                        THEN
                           v_tecamp := 1;
                        ELSE
                           v_tecamp := 0;
                        END IF;
                     ELSE
                        v_tecamp := 0;
                     END IF;

                     IF xinsert OR v_tecamp = 1
                     THEN
                        -- ****** Prima Neta ******
                        xiconcep :=
                                   f_round (difiprianu * facnetsup, decimals);
                        xpprorata := facnetsup;

                        -- Si te ctipreb = 4 (per aportant) la prima s'ha de repartir
                        -- segons pctipapo = 1 ( Aplicar el porcentatge = ppimpapo)
                        --        pctipapo = 1 (import fixe = piimpapo)
                        IF xctipreb = 4
                        THEN
                           -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                           -- Bug 7854 y 8745 Eliminamos esta condiciona 'w_pargaranpro = 3'
                           --IF w_pargaranpro = 3 THEN
                           /*
                           IF pctipapo = 1 THEN
                              xiconcep :=
                                 f_round (xiconcep * ppimpapo / 100,
                                          decimals);
                           ELSIF pctipapo = 2 THEN
                              -- Apliquem la proporció del fixe sobre l'anual
                              xiconcep :=
                                 f_round ((xiconcep * piimpapo / xiprianu),
                                          decimals
                                         );
                           END IF;
                           */

                           -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                           IF pctipapo = 1
                           THEN
                              FOR vapor IN cur_aportaseg (psseguro,
                                                          pfefecto,
                                                          xnriesgo
                                                         )
                              LOOP
                                 IF vapor.ctipimp = 1
                                 THEN
                                    xiconcep :=
                                       f_round (xiconcep * vapor.pimport / 100,
                                                decimals
                                               );
                                 ELSIF vapor.ctipimp = 2
                                 THEN
                                    xiconcep :=
                                              LEAST (xiconcep, vapor.iimport);
                                 END IF;
                              END LOOP;
                           ELSIF pctipapo = 2
                           THEN
                              FOR vapor IN cur_aportaseg (psseguro,
                                                          pfefecto,
                                                          xnriesgo
                                                         )
                              LOOP
                                 IF vapor.ctipimp = 1
                                 THEN
                                    xiconcep :=
                                       f_round (  xiconcep
                                                * (1 - (vapor.pimport / 100)
                                                  ),
                                                decimals
                                               );
                                 ELSIF vapor.ctipimp = 2
                                 THEN
                                    xiconcep :=
                                       GREATEST (0, xiconcep - vapor.iimport);
                                 END IF;
                              END LOOP;
                           END IF;
                        --ELSE
                        --   xiconcep := 0;
                        --END IF;
                        END IF;

                        IF NVL (xiconcep, 0) <> 0
                        THEN
                           error :=
                              pac_adm.f_instmpdetrec (pnrecibo,
                                                      0,
                                                      xiconcep,
                                                      xploccoa,
                                                      xcgarant,
                                                      xnriesgo,
                                                      xctipcoa,
                                                      xcageven_gar,
                                                      xnmovima_gar
                                                     );

                           IF error = 0
                           THEN
                              ha_grabat := TRUE;

                              IF sw_aln = 1
                              THEN
                                 w_importe_aux :=
                                               f_round (difiprianu, decimals);
                                 error :=
                                    fl_grabar_calcomisprev (psseguro,
                                                            pnrecibo,
                                                            xcgarant,
                                                            xnriesgo,
                                                            xcageven_gar,
                                                            xnmovima_gar,
                                                            w_importe_aux,
                                                            pfefecto,
                                                            pfvencim,
                                                            pmodo,
                                                            pnproces
                                                           );

                                 IF error <> 0
                                 THEN
                                    CLOSE curgaran;

                                    RETURN error;
                                 END IF;
                              END IF;
                           ELSE
                              CLOSE curgaran;

                              RETURN error;
                           END IF;
                        END IF;

                        -- ******* Descuento comercial *********
                        xiconcep := f_round (difidtocom * facnetsup, decimals);

                        -- Si te ctipreb = 4 (per aportant) la prima s'ha de repartir
                        -- segons pctipapo = 1 ( Aplicar el porcentatge = ppimpapo)
                        --        pctipapo = 1 (import fixe = piimpapo)
                        IF xctipreb = 4
                        THEN
                           -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                           -- Bug 7854 y 8745 Eliminamos esta condiciona 'w_pargaranpro = 3'
                           --IF w_pargaranpro = 3 THEN
                           /*
                           IF pctipapo = 1 THEN
                              xiconcep :=
                                 f_round (xiconcep * ppimpapo / 100,
                                          decimals);
                           ELSIF pctipapo = 2 THEN
                              -- Apliquem la proporció del fixe sobre l'anual
                              xiconcep :=
                                 f_round ((xiconcep * piimpapo / xiprianu),
                                          decimals
                                         );
                           END IF;
                           */

                           -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                           IF pctipapo = 1
                           THEN
                              FOR vapor IN cur_aportaseg (psseguro,
                                                          pfefecto,
                                                          xnriesgo
                                                         )
                              LOOP
                                 IF vapor.ctipimp = 1
                                 THEN
                                    xiconcep :=
                                       f_round (xiconcep * vapor.pimport / 100,
                                                decimals
                                               );
                                 ELSIF vapor.ctipimp = 2
                                 THEN
                                    xiconcep :=
                                              LEAST (xiconcep, vapor.iimport);
                                 END IF;
                              END LOOP;
                           ELSIF pctipapo = 2
                           THEN
                              FOR vapor IN cur_aportaseg (psseguro,
                                                          pfefecto,
                                                          xnriesgo
                                                         )
                              LOOP
                                 IF vapor.ctipimp = 1
                                 THEN
                                    xiconcep :=
                                       f_round (  xiconcep
                                                * (1 - (vapor.pimport / 100)
                                                  ),
                                                decimals
                                               );
                                 ELSIF vapor.ctipimp = 2
                                 THEN
                                    xiconcep :=
                                       GREATEST (0, xiconcep - vapor.iimport);
                                 END IF;
                              END LOOP;
                           END IF;
                        --ELSE
                        --   xiconcep := 0;
                        --END IF;
                        END IF;

                        IF xiconcep <> 0 AND xiconcep IS NOT NULL
                        THEN
                           error :=
                              pac_adm.f_instmpdetrec (pnrecibo,
                                                      10,
                                                      xiconcep,
                                                      xploccoa,
                                                      xcgarant,
                                                      xnriesgo,
                                                      xctipcoa,
                                                      xcageven_gar,
                                                      xnmovima_gar
                                                     );

                           IF error = 0
                           THEN
                              ha_grabat := TRUE;
                           ELSE
                              CLOSE curgaran;

                              RETURN error;
                           END IF;
                        END IF;

                        -- ****** Prima Devengada *******
                        xiconcep := f_round (difiprianu * facdevsup, decimals);

                        -- Si te ctipreb = 4 (per aportant) la prima s'ha de repartir
                        -- segons pctipapo = 1 ( Aplicar el porcentatge = ppimpapo)
                        --        pctipapo = 1 (import fixe = piimpapo)
                        IF xctipreb = 4
                        THEN
                           -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                           -- Bug 7854 y 8745 Eliminamos esta condiciona 'w_pargaranpro = 3'
                           --IF w_pargaranpro = 3 THEN
                           /*
                           IF pctipapo = 1 THEN
                              xiconcep :=
                                 f_round (xiconcep * ppimpapo / 100,
                                          decimals);
                           ELSIF pctipapo = 2 THEN
                              -- Apliquem la proporció del fixe sobre l'anual
                              xiconcep :=
                                 f_round ((xiconcep * piimpapo / xiprianu),
                                          decimals
                                         );
                           END IF;
                           */

                           -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                           IF pctipapo = 1
                           THEN
                              FOR vapor IN cur_aportaseg (psseguro,
                                                          pfefecto,
                                                          xnriesgo
                                                         )
                              LOOP
                                 IF vapor.ctipimp = 1
                                 THEN
                                    xiconcep :=
                                       f_round (xiconcep * vapor.pimport / 100,
                                                decimals
                                               );
                                 ELSIF vapor.ctipimp = 2
                                 THEN
                                    xiconcep :=
                                              LEAST (xiconcep, vapor.iimport);
                                 END IF;
                              END LOOP;
                           ELSIF pctipapo = 2
                           THEN
                              FOR vapor IN cur_aportaseg (psseguro,
                                                          pfefecto,
                                                          xnriesgo
                                                         )
                              LOOP
                                 IF vapor.ctipimp = 1
                                 THEN
                                    xiconcep :=
                                       f_round (  xiconcep
                                                * (1 - (vapor.pimport / 100)
                                                  ),
                                                decimals
                                               );
                                 ELSIF vapor.ctipimp = 2
                                 THEN
                                    xiconcep :=
                                       GREATEST (0, xiconcep - vapor.iimport);
                                 END IF;
                              END LOOP;
                           END IF;
                        --ELSE
                        --   xiconcep := 0;
                        --END IF;
                        END IF;

                        IF NVL (xiconcep, 0) <> 0
                        THEN
                           -- Comprovar si ha de generar venda, segons el paràmetre per garantia GENVENTA
                           error :=
                              f_pargaranpro (xcramo,
                                             xcmodali,
                                             xctipseg,
                                             xccolect,
                                             xcactivi,
                                             xcgarant,
                                             'GENVENTA',
                                             lcvalpar
                                            );

                           IF error <> 0
                           THEN
                              RETURN error;
                           ELSE
                              IF NVL (lcvalpar, 1) = 1
                              THEN
                                 -- La garantia genera venda
                                 error :=
                                    pac_adm.f_instmpdetrec (pnrecibo,
                                                            21,
                                                            xiconcep,
                                                            xploccoa,
                                                            xcgarant,
                                                            xnriesgo,
                                                            xctipcoa,
                                                            xcageven_gar,
                                                            xnmovima_gar
                                                           );

                                 IF error = 0
                                 THEN
                                    ha_grabat := TRUE;
                                 ELSE
                                    CLOSE curgaran;

                                    RETURN error;
                                 END IF;
                              END IF;
                           END IF;
---------------
                        END IF;
                     END IF;
                  END IF;

                  FETCH curgaran
                   INTO xcgarant, xnriesgo, xfiniefe, xnorden, xctarifa,
                        xicapital, xprecarg, xiprianu, xfinefe, xcformul,
                        xiextrap, xctipfra, xifranqu, xnmovimi, xidtocom,
                        xcageven_gar, xnmovima_gar, xcampanya, xpdtocom;
               END LOOP;

               CLOSE curgaran;

-- ********************************************************************
-- Ara buscarem les garanties que estaven en (fefecto-1) i ara no estan
-- ********************************************************************
               IF ptipomovimiento = 1
               THEN
                  OPEN cur_garansegant;

                  FETCH cur_garansegant
                   INTO xcgarant, xnriesgo, xfiniefe, xnorden, xctarifa,
                        xicapital, xprecarg, xiprianu, xfinefe, xcformul,
                        xiextrap, xctipfra, xifranqu, xnmovimi, xidtocom,
                        xcageven_gar, xnmovima_gar, xcampanya, xpdtocom,
                        xitarrea;                -- BUG: 12993 AVT 09-02-2010

                  WHILE cur_garansegant%FOUND
                  LOOP
                     xnasegur := NULL;
                     xnasegur1 := NULL;

                     IF pttabla = 'SOL'
                     THEN
                        BEGIN
                           SELECT DECODE (nasegur, NULL, 1, nasegur)
                             INTO xnasegur1
                             FROM solriesgos
                            WHERE ssolicit = psseguro AND nriesgo = xnriesgo;
                        EXCEPTION
                           WHEN NO_DATA_FOUND
                           THEN
                              CLOSE cur_garansegant;

                              RETURN 103836;
                           WHEN OTHERS
                           THEN
                              CLOSE cur_garansegant;

                              RETURN 103509;
                        END;
                     ELSIF pttabla = 'EST'
                     THEN
                        BEGIN
                           SELECT DECODE (nasegur, NULL, 1, nasegur)
                             INTO xnasegur1
                             FROM estriesgos
                            WHERE sseguro = psseguro AND nriesgo = xnriesgo;
                        EXCEPTION
                           WHEN NO_DATA_FOUND
                           THEN
                              CLOSE cur_garansegant;

                              RETURN 103836;
                           WHEN OTHERS
                           THEN
                              CLOSE cur_garansegant;

                              RETURN 103509;
                        END;
                     ELSE
                        BEGIN
                           SELECT DECODE (nasegur, NULL, 1, nasegur)
                             INTO xnasegur1
                             FROM riesgos
                            WHERE sseguro = psseguro AND nriesgo = xnriesgo;
                        EXCEPTION
                           WHEN NO_DATA_FOUND
                           THEN
                              CLOSE cur_garansegant;

                              RETURN 103836;
                           WHEN OTHERS
                           THEN
                              CLOSE cur_garansegant;

                              RETURN 103509;
                        END;
                     END IF;

                     xidtocom := 0 - NVL (xidtocom, 0);

                     BEGIN
                        grabar := 0;
                        xxcgarant := NULL;
                        xxnriesgo := NULL;
                        xxfiniefe := NULL;
                        xxiprianu := NULL;
                        xxffinefe := NULL;
                        xxidtocom := NULL;

                        SELECT cgarant, nriesgo, finiefe, ipritot,
                               ffinefe, idtocom, cageven,
                               nmovima
                          INTO xxcgarant, xxnriesgo, xxfiniefe, xxiprianu,
                               xxffinefe, xxidtocom, xxcageven_gar,
                               xxnmovima_gar
                          FROM garanseg
                         WHERE sseguro = psseguro
                           AND cgarant = xcgarant
                           AND nriesgo = xnriesgo
                           AND nmovimi = pnmovimi
                           AND nmovima = xnmovima_gar;

                        xxidtocom := 0 - NVL (xxidtocom, 0);
                     EXCEPTION
                        WHEN NO_DATA_FOUND
                        THEN
                           grabar := 1;       -- És una garantia desapareguda
                        WHEN TOO_MANY_ROWS
                        THEN
                           CLOSE cur_garansegant;

                           error := 102310;
                           -- Garantia-Risc repetida en GARANSEG
                           RETURN error;
                        WHEN OTHERS
                        THEN
                           CLOSE cur_garansegant;

                           error := 103500;    -- Error al llegir de GARANSEG
                           RETURN error;
                     END;

                     IF grabar = 1
                     THEN
                        difiprianu := 0 - (xiprianu * xnasegur1);

                        IF difiprianu <> 0
                        THEN
                           -- ****** Prima Neta *******
                           xiconcep :=
                                   f_round (difiprianu * facnetsup, decimals);
                           xpprorata := facnetsup;

                           -- Si te ctipreb = 4 (per aportant) la prima s'ha de repartir
                           -- segons pctipapo = 1 ( Aplicar el porcentatge = ppimpapo)
                           --        pctipapo = 1 (import fixe = piimpapo)
                           IF xctipreb = 4
                           THEN
                              -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                              -- Bug 7854 y 8745 Eliminamos esta condiciona 'w_pargaranpro = 3'
                              --IF w_pargaranpro = 3 THEN
                              /*
                              IF pctipapo = 1 THEN
                                 xiconcep :=
                                    f_round (xiconcep * ppimpapo / 100,
                                             decimals
                                            );
                              ELSIF pctipapo = 2 THEN
                                 -- Apliquem la proporció del fixe sobre l'anual
                                 xiconcep :=
                                    f_round ((xiconcep * piimpapo / xiprianu
                                             ),
                                             decimals
                                            );
                              END IF;
                              */

                              -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                              IF pctipapo = 1
                              THEN
                                 FOR vapor IN cur_aportaseg (psseguro,
                                                             pfefecto,
                                                             xnriesgo
                                                            )
                                 LOOP
                                    IF vapor.ctipimp = 1
                                    THEN
                                       xiconcep :=
                                          f_round (  xiconcep
                                                   * vapor.pimport
                                                   / 100,
                                                   decimals
                                                  );
                                    ELSIF vapor.ctipimp = 2
                                    THEN
                                       xiconcep :=
                                              LEAST (xiconcep, vapor.iimport);
                                    END IF;
                                 END LOOP;
                              ELSIF pctipapo = 2
                              THEN
                                 FOR vapor IN cur_aportaseg (psseguro,
                                                             pfefecto,
                                                             xnriesgo
                                                            )
                                 LOOP
                                    IF vapor.ctipimp = 1
                                    THEN
                                       xiconcep :=
                                          f_round (  xiconcep
                                                   * (  1
                                                      - (vapor.pimport / 100
                                                        )
                                                     ),
                                                   decimals
                                                  );
                                    ELSIF vapor.ctipimp = 2
                                    THEN
                                       xiconcep :=
                                          GREATEST (0,
                                                    xiconcep - vapor.iimport
                                                   );
                                    END IF;
                                 END LOOP;
                              END IF;
                           --ELSE
                           --   xiconcep := 0;
                           --END IF;
                           END IF;

                           IF NVL (xiconcep, 0) <> 0
                           THEN
                              error :=
                                 pac_adm.f_instmpdetrec (pnrecibo,
                                                         0,
                                                         xiconcep,
                                                         xploccoa,
                                                         xcgarant,
                                                         xnriesgo,
                                                         xctipcoa,
                                                         xcageven_gar,
                                                         xnmovima_gar
                                                        );

                              IF error = 0
                              THEN
                                 ha_grabat := TRUE;

                                 IF sw_aln = 1
                                 THEN
                                    w_importe_aux :=
                                               f_round (difiprianu, decimals);
                                    error :=
                                       fl_grabar_calcomisprev (psseguro,
                                                               pnrecibo,
                                                               xcgarant,
                                                               xnriesgo,
                                                               xcageven_gar,
                                                               xnmovima_gar,
                                                               w_importe_aux,
                                                               pfefecto,
                                                               pfvencim,
                                                               pmodo,
                                                               pnproces
                                                              );

                                    IF error <> 0
                                    THEN
                                       CLOSE cur_garanseg;

                                       RETURN error;
                                    END IF;
                                 END IF;
                              ELSE
                                 CLOSE cur_garansegant;

                                 RETURN error;
                              END IF;
                           END IF;

                           -- ***** Prima Devengada *******
                           xiconcep :=
                                    f_round (difiprianu * facdevsup, decimals);

                           -- Si te ctipreb = 4 (per aportant) la prima s'ha de repartir
                           -- segons pctipapo = 1 ( Aplicar el porcentatge = ppimpapo)
                           --        pctipapo = 1 (import fixe = piimpapo)
                           IF xctipreb = 4
                           THEN
                              -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                              -- Bug 7854 y 8745 Eliminamos esta condiciona 'w_pargaranpro = 3'
                              --IF w_pargaranpro = 3 THEN
                              /*
                              IF pctipapo = 1 THEN
                                 xiconcep :=
                                    f_round (xiconcep * ppimpapo / 100,
                                             decimals
                                            );
                              ELSIF pctipapo = 2 THEN
                                 -- Apliquem la proporció del fixe sobre l'anual
                                 xiconcep :=
                                    f_round ((xiconcep * piimpapo / xiprianu
                                             ),
                                             decimals
                                            );
                              END IF;
                              */

                              -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                              IF pctipapo = 1
                              THEN
                                 FOR vapor IN cur_aportaseg (psseguro,
                                                             pfefecto,
                                                             xnriesgo
                                                            )
                                 LOOP
                                    IF vapor.ctipimp = 1
                                    THEN
                                       xiconcep :=
                                          f_round (  xiconcep
                                                   * vapor.pimport
                                                   / 100,
                                                   decimals
                                                  );
                                    ELSIF vapor.ctipimp = 2
                                    THEN
                                       xiconcep :=
                                              LEAST (xiconcep, vapor.iimport);
                                    END IF;
                                 END LOOP;
                              ELSIF pctipapo = 2
                              THEN
                                 FOR vapor IN cur_aportaseg (psseguro,
                                                             pfefecto,
                                                             xnriesgo
                                                            )
                                 LOOP
                                    IF vapor.ctipimp = 1
                                    THEN
                                       xiconcep :=
                                          f_round (  xiconcep
                                                   * (  1
                                                      - (vapor.pimport / 100
                                                        )
                                                     ),
                                                   decimals
                                                  );
                                    ELSIF vapor.ctipimp = 2
                                    THEN
                                       xiconcep :=
                                          GREATEST (0,
                                                    xiconcep - vapor.iimport
                                                   );
                                    END IF;
                                 END LOOP;
                              END IF;
                           --ELSE
                           --   xiconcep := 0;
                           --END IF;
                           END IF;

                           IF NVL (xiconcep, 0) <> 0
                           THEN
                              -- Comprovar si ha de generar venda, segons el paràmetre per garantia GENVENTA
                              error :=
                                 f_pargaranpro (xcramo,
                                                xcmodali,
                                                xctipseg,
                                                xccolect,
                                                xcactivi,
                                                xcgarant,
                                                'GENVENTA',
                                                lcvalpar
                                               );

                              IF error <> 0
                              THEN
                                 RETURN error;
                              ELSE
                                 IF NVL (lcvalpar, 1) = 1
                                 THEN
                                    -- La garantia genera venda
                                    error :=
                                       pac_adm.f_instmpdetrec (pnrecibo,
                                                               1,
                                                               xiconcep,
                                                               xploccoa,
                                                               xcgarant,
                                                               xnriesgo,
                                                               xctipcoa,
                                                               xcageven_gar,
                                                               xnmovima_gar
                                                              );

                                    IF error = 0
                                    THEN
                                       ha_grabat := TRUE;
                                    ELSE
                                       CLOSE cur_garansegant;

                                       RETURN error;
                                    END IF;
                                 END IF;
                              END IF;
---------------
                           END IF;
                        END IF;

                        -- ******* Descuento Comercial ********
                        difidtocom := 0 - NVL (xidtocom * xnasegur1, 0);

                        IF difidtocom <> 0 AND difidtocom IS NOT NULL
                        THEN
                           xiconcep :=
                                   f_round (difidtocom * facnetsup, decimals);

                           -- Si te ctipreb = 4 (per aportant) la prima s'ha de repartir
                           -- segons pctipapo = 1 ( Aplicar el porcentatge = ppimpapo)
                           --        pctipapo = 1 (import fixe = piimpapo)
                           IF xctipreb = 4
                           THEN
                              -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                              -- Bug 7854 y 8745 Eliminamos esta condiciona 'w_pargaranpro = 3'
                              --IF w_pargaranpro = 3 THEN
                              /*
                              IF pctipapo = 1 THEN
                                 xiconcep :=
                                    f_round (xiconcep * ppimpapo / 100,
                                             decimals
                                            );
                              ELSIF pctipapo = 2 THEN
                                 -- Apliquem la proporció del fixe sobre l'anual
                                 xiconcep :=
                                    f_round ((xiconcep * piimpapo / xiprianu
                                             ),
                                             decimals
                                            );
                              END IF;
                              */

                              -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                              IF pctipapo = 1
                              THEN
                                 FOR vapor IN cur_aportaseg (psseguro,
                                                             pfefecto,
                                                             xnriesgo
                                                            )
                                 LOOP
                                    IF vapor.ctipimp = 1
                                    THEN
                                       xiconcep :=
                                          f_round (  xiconcep
                                                   * vapor.pimport
                                                   / 100,
                                                   decimals
                                                  );
                                    ELSIF vapor.ctipimp = 2
                                    THEN
                                       xiconcep :=
                                              LEAST (xiconcep, vapor.iimport);
                                    END IF;
                                 END LOOP;
                              ELSIF pctipapo = 2
                              THEN
                                 FOR vapor IN cur_aportaseg (psseguro,
                                                             pfefecto,
                                                             xnriesgo
                                                            )
                                 LOOP
                                    IF vapor.ctipimp = 1
                                    THEN
                                       xiconcep :=
                                          f_round (  xiconcep
                                                   * (  1
                                                      - (vapor.pimport / 100
                                                        )
                                                     ),
                                                   decimals
                                                  );
                                    ELSIF vapor.ctipimp = 2
                                    THEN
                                       xiconcep :=
                                          GREATEST (0,
                                                    xiconcep - vapor.iimport
                                                   );
                                    END IF;
                                 END LOOP;
                              END IF;
                           --ELSE
                           --   xiconcep := 0;
                           --END IF;
                           END IF;

                           IF NVL (xiconcep, 0) <> 0
                           THEN
                              error :=
                                 pac_adm.f_instmpdetrec (pnrecibo,
                                                         10,
                                                         xiconcep,
                                                         xploccoa,
                                                         xcgarant,
                                                         xnriesgo,
                                                         xctipcoa,
                                                         xcageven_gar,
                                                         xnmovima_gar
                                                        );

                              IF error = 0
                              THEN
                                 ha_grabat := TRUE;
                              ELSE
                                 CLOSE cur_garansegant;

                                 RETURN error;
                              END IF;
                           END IF;
                        END IF;
                     END IF;

                     FETCH cur_garansegant
                      INTO xcgarant, xnriesgo, xfiniefe, xnorden, xctarifa,
                           xicapital, xprecarg, xiprianu, xfinefe, xcformul,
                           xiextrap, xctipfra, xifranqu, xnmovimi, xidtocom,
                           xcageven_gar, xnmovima_gar, xcampanya, xpdtocom,
                           xitarrea;              -- BUG: 12993 AVT 09-02-2010
                  END LOOP;

                  CLOSE cur_garansegant;
               END IF;
            ELSE
               error := 101901; -- Paso incorrecto de parámetros a la función
               RETURN error;
            END IF;

-- ***********************************************************
-- Ara cridarem a la funció que calcula les dades del consorci
-- ***********************************************************
            IF ptipomovimiento = 1
            THEN
               facconsor := facdevsup;
               facconsorfra := facnet;                          --JAMF  11903
            ELSE
               facconsor := facdev;
               facconsorfra := facnet;                          --JAMF  11903
            END IF;

            error :=
               pac_adm.f_consorci (pnproces,
                                   psseguro,
                                   pnrecibo,
                                   pnriesgo,
                                   pfefecto,
                                   xffinrec,
                                   pmodo,
                                   ptipomovimiento,
                                   xcramo,
                                   xcmodali,
                                   xcactivi,
                                   xccolect,
                                   xctipseg,
                                   xcduraci,
                                   xnduraci,
                                   pnmovimi,
                                   pgrabar,
                                   xnmovimiant,
                                   facconsor,
                                   facconsorfra,
                                   --JAMF 11903
                                   xaltarisc,
                                   xcapieve,
                                   pttabla,
                                   pfuncion,
                                   pctipapo
                                  );

            -- Bug 12589 - FAL - 01/04/2010 -- Añadir parametro pctipapo a f_consorci
            IF error = 0
            THEN
               IF pgrabar = 1
               THEN
                  ha_grabat := TRUE;
               END IF;
            ELSE
               RETURN error;
            END IF;

-- **********************************************************
-- FASE 3 : Càlcul descomptes, recàrrecs i impostos
-- **********************************************************
            error :=
               pac_adm.f_imprecibos (pnproces,
                                     pnrecibo,
                                     ptipomovimiento,
                                     pmodo,
                                     pnriesgo,
                                     xpdtoord,
                                     xcrecfra,
                                     xcforpag,
                                     xcramo,
                                     xcmodali,
                                     xctipseg,
                                     xccolect,
                                     xcactivi,
                                     comis_agente,
                                     reten_agente,
                                     psseguro,
                                     pcmodcom,
                                     decimals,
                                     xpprorata,
                                     pttabla,
                                     pfuncion
                                    );

            IF error <> 0
            THEN
               RETURN error;
            END IF;

-- ********************************************************************************
-- Ara mirarem si la prima neta total és negativa. Si ho és, es tracta d' un extorn
-- ********************************************************************************
            BEGIN
               SELECT   SUM (DECODE (cconcep, 0, iconcep, 50, iconcep, 0))
                      - SUM (DECODE (cconcep, 26, iconcep, 29, iconcep, 0)),
                      -- total neta
                      SUM (DECODE (cconcep, 21, iconcep, 71, iconcep, 0))
                 -- total devengada
               INTO   xtotprimaneta,
                      xtotprimadeve
                 FROM tmp_adm_detrecibos
                WHERE nrecibo = pnrecibo
                      AND cconcep IN (0, 50, 21, 71, 26, 29);
            EXCEPTION
               WHEN OTHERS
               THEN
                  RETURN 103516;             -- Error al llegir de DETRECIBOS
            END;

            IF xtotprimaneta < 0 OR xtotprimadeve < 0
            THEN
               IF xctiprec <> 10
               THEN
                  -- No és un extorn d' anul.lació
                  BEGIN
                     -- xex_pte_imp = 1 (Extorn pendent d'imprimir)
                     -- xex_pte_imp = 0 (Extorn pendent de transferir)
                     UPDATE tmp_adm_recibos
                        SET ctiprec = 9,
                            -- Si la prima és negativa,es tracta d' un extorn
                            cestimp =
                               DECODE (cestimp,
                                       4, DECODE (xex_pte_imp, 0, 7, 1),
                                       cestimp
                                      )
                      WHERE sproces = pnproces AND nrecibo = pnrecibo;
                  EXCEPTION
                     WHEN OTHERS
                     THEN
                        RETURN 103520;
                  -- Error al modificar la taula RECIBOSCAR
                  END;

                  -- BUG: 12961 AVT 22-02-2010 s'ajusta pels rebuts d'extorn
                  FOR reg IN (SELECT   cgarant, SUM (iconcep) iconcep
                                  FROM tmp_adm_detrecibos
                                 WHERE nrecibo = pnrecibo
                              GROUP BY cgarant)
                  LOOP
                     IF reg.iconcep = 0
                     THEN
                        BEGIN
                           DELETE      tmp_adm_detrecibos
                                 WHERE nrecibo = pnrecibo
                                   AND cgarant = reg.cgarant;
                        EXCEPTION
                           WHEN NO_DATA_FOUND
                           THEN
                              NULL;
                           WHEN OTHERS
                           THEN
                              RETURN 104377;
                        END;
                     END IF;
                  END LOOP;
               END IF;

               error := pac_adm.f_extornpos (pnrecibo, pmodo, pnproces);

               IF error <> 0
               THEN
                  RETURN error;
               END IF;
            END IF;

            IF ha_grabat = TRUE
            THEN
               error := pac_adm.f_tmp_vdetrecibos (pmodo, pnrecibo, pnproces);

               IF error <> 0
               THEN
                  RETURN error;
               END IF;
            -- A proves no calculem reasseguro
            ELSIF NVL (f_parinstalacion_n ('DETREC99NO'), 0) != 1
            THEN
               -- No ha grabat res a DETRECIBOS
               -- Si nasegur = 0, grabamos el concepto 99 en DETRECIBOSCAR,
               -- y generamos VDETRECIBOSCAR
               -- 26755 AVT 22/04/2013 pels conceptes que el 100% va al concepte normal no fem el concepte de coaseguro (cc: 14 i 86)
               error :=
                  pac_adm.f_instmpdetrec (pnrecibo,
                                          99,
                                          0,
                                          --xploccoa
                                          100,
                                          xcgarant,
                                          xnriesgo,
                                          xctipcoa,
                                          xcageven_gar,
                                          xnmovima_gar
                                         );

               IF error = 0
               THEN
                  error :=
                        pac_adm.f_tmp_vdetrecibos (pmodo, pnrecibo, pnproces);

                  IF error <> 0
                  THEN
                     RETURN error;
                  END IF;
               -- No calculem reasseguro pq te prima 0
               END IF;

               RETURN 105154;
            -- Error especial (que es controla a la crida de aquesta funció
            ELSE
               RETURN 103108;    -- No s' ha grabat cap registre en la funció
            --             -- de càlcul de rebuts
            --        END IF;
            -- ELSE  -- No és innominat
            --   RETURN 103108;  -- No s' ha grabat cap registre en la funció
            --                   -- de càlcul de rebuts
            -- END IF;
            END IF;
--**********************************************************************
--******* M O D O    P A R A     P R E V I O    D E  R E C I B O   *****
--**********************************************************************
         ELSIF pmodo = 'N'
         THEN
            -- Cas de crida per f_prevrecibo (Anual)
            IF ptipomovimiento IN (0, 6)
            THEN
               OPEN cur_garanseg;

               FETCH cur_garanseg
                INTO xcgarant, xnriesgo, xfiniefe, xnorden, xctarifa,
                     xicapital, xprecarg, xiprianu, xfinefe, xcformul,
                     xiextrap, xctipfra, xifranqu, xnmovimi, xidtocom,
                     xcageven_gar, xnmovima_gar, xcampanya, xpdtocom,
                     xitarrea;                   -- BUG: 12993 AVT 09-02-2010

               WHILE cur_garanseg%FOUND
               LOOP
                  xnasegur := NULL;
                  xnasegur1 := NULL;

                  BEGIN
                     SELECT DECODE (nasegur, NULL, 1, nasegur)
                       INTO xnasegur
                       FROM riesgos
                      WHERE sseguro = psseguro AND nriesgo = xnriesgo;
                  EXCEPTION
                     WHEN NO_DATA_FOUND
                     THEN
                        CLOSE cur_garanseg;

                        RETURN 103836;
                     WHEN OTHERS
                     THEN
                        CLOSE cur_garanseg;

                        RETURN 103509;
                  END;

                  xidtocom := 0 - NVL (xidtocom, 0);
                  -- Fase 1: Cálculo de la Prima Neta (cconcep = 0) y de la Prima Devengada (Fase 2).
                  -- ****** Prima Neta *******
                  xiprianu2 := f_round (xiprianu * xnasegur, decimals);

                  -- Si te ctipreb = 4 (per aportant) la prima s'ha de repartir
                  -- segons pctipapo = 1 ( Aplicar el porcentatge = ppimpapo)
                  --        pctipapo = 1 (import fixe = piimpapo)
                  IF xctipreb = 4
                  THEN
                     -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                     -- Bug 7854 y 8745 Eliminamos esta condiciona 'w_pargaranpro = 3'
                     --IF w_pargaranpro = 3 THEN
                     /*
                     IF pctipapo = 1 THEN
                        xiprianu2 :=
                               f_round (xiprianu2 * ppimpapo / 100, decimals);
                     ELSIF pctipapo = 2 THEN
                        xiprianu2 := f_round (piimpapo * xnasegur, decimals);
                     END IF;
                     */

                     -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                     IF pctipapo = 1
                     THEN
                        FOR vapor IN cur_aportaseg (psseguro,
                                                    pfefecto,
                                                    xnriesgo
                                                   )
                        LOOP
                           IF vapor.ctipimp = 1
                           THEN
                              xiprianu2 :=
                                 f_round (xiprianu2 * vapor.pimport / 100,
                                          decimals
                                         );
                           ELSIF vapor.ctipimp = 2
                           THEN
                              --xiprianu2 := f_round (vapor.iimport * facnet * xnasegur, decimals);
                              xiprianu2 := LEAST (xiprianu2, vapor.iimport);
                           END IF;
                        END LOOP;
                     ELSIF pctipapo = 2
                     THEN
                        FOR vapor IN cur_aportaseg (psseguro,
                                                    pfefecto,
                                                    xnriesgo
                                                   )
                        LOOP
                           IF vapor.ctipimp = 1
                           THEN
                              xiprianu2 :=
                                 f_round (  xiprianu2
                                          * (1 - (vapor.pimport / 100)),
                                          decimals
                                         );
                           ELSIF vapor.ctipimp = 2
                           THEN
                              --xiprianu2 := f_round (vapor.iimport * facnet * xnasegur, decimals);
                              xiprianu2 :=
                                      GREATEST (0, xiprianu2 - vapor.iimport);
                           END IF;
                        END LOOP;
                     END IF;
                  --ELSE
                  --   xiprianu2 := 0;
                  --END IF;
                  END IF;

                  IF NVL (xiprianu2, 0) <> 0
                  THEN
                     error :=
                        pac_adm.f_instmpdetrec (pnrecibo,
                                                0,
                                                xiprianu2,
                                                xploccoa,
                                                xcgarant,
                                                xnriesgo,
                                                xctipcoa,
                                                xcageven_gar,
                                                xnmovima_gar
                                               );

                     IF error = 0
                     THEN
                        ha_grabat := TRUE;

                        IF sw_aln = 1
                        THEN
                           w_importe_aux := xiprianu;
                           error :=
                              fl_grabar_calcomisprev (psseguro,
                                                      pnrecibo,
                                                      xcgarant,
                                                      xnriesgo,
                                                      xcageven_gar,
                                                      xnmovima_gar,
                                                      xiprianu,
                                                      pfefecto,
                                                      pfvencim,
                                                      pmodo,
                                                      pnproces
                                                     );

                           IF error <> 0
                           THEN
                              CLOSE cur_garanseg;

                              RETURN error;
                           END IF;
                        END IF;
                     ELSE
                        CLOSE cur_garanseg;

                        RETURN error;
                     END IF;
                  END IF;

                  -- ***** Descuento com ******
                  xidtocom2 := f_round (xidtocom * xnasegur, decimals);

                  -- Si te ctipreb = 4 (per aportant) l'import s'ha de repartir
                  -- segons pctipapo = 1 ( Aplicar el porcentatge = ppimpapo)
                  --        pctipapo = 1 (import fixe = piimpapo)
                  IF xctipreb = 4
                  THEN
                     -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                     -- Bug 7854 y 8745 Eliminamos esta condiciona 'w_pargaranpro = 3'
                     --IF w_pargaranpro = 3 THEN
                     /*
                     IF pctipapo = 1 THEN
                        xidtocom2 :=
                               f_round (xidtocom2 * ppimpapo / 100, decimals);
                     ELSIF pctipapo = 2 THEN
                        -- hen de calcular el descompte per l'import fixe xiprianu2
                        xidtocom2 :=
                           f_round (  f_round ((xiprianu2 * xpdtocom) / 100,
                                               decimals
                                              )
                                    * xnasegur,
                                    decimals
                                   );
                     END IF;
                     */

                     -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                     IF pctipapo = 1
                     THEN
                        FOR vapor IN cur_aportaseg (psseguro,
                                                    pfefecto,
                                                    xnriesgo
                                                   )
                        LOOP
                           IF vapor.ctipimp = 1
                           THEN
                              xidtocom2 :=
                                 f_round (xidtocom2 * vapor.pimport / 100,
                                          decimals
                                         );
                           ELSIF vapor.ctipimp = 2
                           THEN
                              xidtocom2 :=
                                 f_round (  f_round (  (xiprianu2 * xpdtocom
                                                       )
                                                     / 100,
                                                     decimals
                                                    )
                                          * facnet
                                          * xnasegur,
                                          decimals
                                         );

                              -- Se porratea el importe de descuento

                              --BUG11280-XVM-29092009 inici
                              IF xiprianu2 <> 0
                              THEN
                                 xidtocom2 :=
                                    LEAST (  (xidtocom2 * vapor.iimport)
                                           / xiprianu2,
                                           vapor.iimport
                                          );
                              ELSE
                                 xidtocom2 := 0;
                              END IF;
                           --BUG11280-XVM-29092009 fi
                           END IF;
                        END LOOP;
                     ELSIF pctipapo = 2
                     THEN
                        FOR vapor IN cur_aportaseg (psseguro,
                                                    pfefecto,
                                                    xnriesgo
                                                   )
                        LOOP
                           IF vapor.ctipimp = 1
                           THEN
                              xidtocom2 :=
                                 f_round (  xidtocom2
                                          * (1 - (vapor.pimport / 100)),
                                          decimals
                                         );
                           ELSIF vapor.ctipimp = 2
                           THEN
                              xidtocom2 :=
                                 f_round (  f_round (  (xiprianu2 * xpdtocom
                                                       )
                                                     / 100,
                                                     decimals
                                                    )
                                          * facnet
                                          * xnasegur,
                                          decimals
                                         );

                              --BUG11280-XVM-29092009 inici
                              IF xiprianu2 <> 0
                              THEN
                                 xidtocom2 :=
                                    GREATEST (0,
                                                (  (xidtocom2 * vapor.iimport
                                                   )
                                                 / xiprianu2
                                                )
                                              - vapor.iimport
                                             );
                              ELSE
                                 xidtocom2 := 0;
                              END IF;
                           --BUG11280-XVM-29092009 fi
                           END IF;
                        END LOOP;
                     END IF;
                  --ELSE
                  --   xidtocom2 := 0;
                  --END IF;
                  END IF;

                  IF xidtocom2 <> 0 AND xidtocom2 IS NOT NULL
                  THEN
                     error :=
                        pac_adm.f_instmpdetrec (pnrecibo,
                                                10,
                                                xidtocom2,
                                                xploccoa,
                                                xcgarant,
                                                xnriesgo,
                                                xctipcoa,
                                                xcageven_gar,
                                                xnmovima_gar
                                               );

                     IF error = 0
                     THEN
                        ha_grabat := TRUE;
                     ELSE
                        CLOSE cur_garanseg;

                        RETURN error;
                     END IF;
                  END IF;

                  -- ****** Prima Devengada ********
                  IF ptipomovimiento IN (0, 6)
                  THEN
                     xiprianu := f_round (xiprianu * xnasegur, decimals);

                     -- Si te ctipreb = 4 (per aportant) la prima s'ha de repartir
                     -- segons pctipapo = 1 ( Aplicar el porcentatge = ppimpapo)
                     --        pctipapo = 1 (import fixe = piimpapo)
                     IF xctipreb = 4
                     THEN
                        -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                        -- Bug 7854 y 8745 Eliminamos esta condiciona 'w_pargaranpro = 3'
                        --IF w_pargaranpro = 3 THEN
                        /*
                        IF pctipapo = 1 THEN
                           xiprianu2 :=
                               f_round (xiprianu2 * ppimpapo / 100, decimals);
                        ELSIF pctipapo = 2 THEN
                           xiprianu2 :=
                                      f_round (piimpapo * xnasegur, decimals);
                        END IF;
                        */

                        -- Bug 7854 y 8745 - 11/02/2009 - RSC - CRE: Desarrollo de sistema de copago
                        IF pctipapo = 1
                        THEN
                           FOR vapor IN cur_aportaseg (psseguro,
                                                       pfefecto,
                                                       xnriesgo
                                                      )
                           LOOP
                              IF vapor.ctipimp = 1
                              THEN
                                 xiprianu2 :=
                                    f_round (xiprianu2 * vapor.pimport / 100,
                                             decimals
                                            );
                              ELSIF vapor.ctipimp = 2
                              THEN
                                 --xiprianu2 := f_round (vapor.iimport * facnet * xnasegur, decimals);
                                 xiprianu2 :=
                                             LEAST (xiprianu2, vapor.iimport);
                              END IF;
                           END LOOP;
                        ELSIF pctipapo = 2
                        THEN
                           FOR vapor IN cur_aportaseg (psseguro,
                                                       pfefecto,
                                                       xnriesgo
                                                      )
                           LOOP
                              IF vapor.ctipimp = 1
                              THEN
                                 xiprianu2 :=
                                    f_round (  xiprianu2
                                             * (1 - (vapor.pimport / 100)),
                                             decimals
                                            );
                              ELSIF vapor.ctipimp = 2
                              THEN
                                 --xiprianu2 := f_round (vapor.iimport * facnet * xnasegur, decimals);
                                 xiprianu2 :=
                                      GREATEST (0, xiprianu2 - vapor.iimport);
                              END IF;
                           END LOOP;
                        END IF;
                     --ELSE
                     --   xiprianu2 := 0;
                     --END IF;
                     END IF;

                     IF NVL (xiprianu, 0) <> 0
                     THEN
                        -- Comprovar si ha de generar venda, segons el paràmetre per garantia GENVENTA
                        error :=
                           f_pargaranpro (xcramo,
                                          xcmodali,
                                          xctipseg,
                                          xccolect,
                                          xcactivi,
                                          xcgarant,
                                          'GENVENTA',
                                          lcvalpar
                                         );

                        IF error <> 0
                        THEN
                           RETURN error;
                        ELSE
                           IF NVL (lcvalpar, 1) = 1
                           THEN
                              -- La garantia genera venda
                              error :=
                                 pac_adm.f_instmpdetrec (pnrecibo,
                                                         21,
                                                         xiprianu,
                                                         xploccoa,
                                                         xcgarant,
                                                         xnriesgo,
                                                         xctipcoa,
                                                         xcageven_gar,
                                                         xnmovima_gar
                                                        );

                              IF error = 0
                              THEN
                                 ha_grabat := TRUE;
                              ELSE
                                 CLOSE cur_garanseg;

                                 RETURN error;
                              END IF;
                           END IF;
                        END IF;
---------------
                     END IF;
                  END IF;

                  FETCH cur_garanseg
                   INTO xcgarant, xnriesgo, xfiniefe, xnorden, xctarifa,
                        xicapital, xprecarg, xiprianu, xfinefe, xcformul,
                        xiextrap, xctipfra, xifranqu, xnmovimi, xidtocom,
                        xcageven_gar, xnmovima_gar, xcampanya, xpdtocom,
                        xitarrea;                 -- BUG: 12993 AVT 09-02-2010
               END LOOP;

               CLOSE cur_garanseg;
            ELSE
               error := 101901; -- Paso incorrecto de parámetros a la función
               RETURN error;
            END IF;

-- ***********************************************************
-- Ara cridarem a la funció que calcula les dades del consorci
-- ***********************************************************
            facconsor := 1;                        -- No debe prorratear nunca
            facconsorfra := facnet;                              --JAMF  11903
            error :=
               pac_adm.f_consorci (pnproces,
                                   psseguro,
                                   pnrecibo,
                                   pnriesgo,
                                   pfefecto,
                                   xffinrec,
                                   'N',
                                   ptipomovimiento,
                                   xcramo,
                                   xcmodali,
                                   xcactivi,
                                   xccolect,
                                   xctipseg,
                                   xcduraci,
                                   xnduraci,
                                   pnmovimi,
                                   pgrabar,
                                   xnmovimiant,
                                   facconsor,
                                   facconsorfra,
                                   --JAMF 11903
                                   xaltarisc,
                                   xcapieve,
                                   pttabla,
                                   pfuncion,
                                   pctipapo
                                  );

            -- Bug 12589 - FAL - 01/04/2010 -- Añadir parametro pctipapo a f_consorci
            IF error = 0
            THEN
               IF pgrabar = 1
               THEN
                  ha_grabat := TRUE;
               END IF;
            ELSE
               RETURN error;
            END IF;

            error :=
               pac_adm.f_imprecibos (pnproces,
                                     pnrecibo,
                                     ptipomovimiento,
                                     pmodo,
                                     pnriesgo,
                                     xpdtoord,
                                     xcrecfra,
                                     xcforpag,
                                     xcramo,
                                     xcmodali,
                                     xctipseg,
                                     xccolect,
                                     xcactivi,
                                     comis_agente,
                                     reten_agente,
                                     psseguro,
                                     pcmodcom,
                                     decimals,
                                     xpprorata,
                                     pttabla,
                                     pfuncion
                                    );

            IF error <> 0
            THEN
               RETURN error;
            END IF;

-- ********************************************************************************
-- Ara mirarem si la prima neta total és negativa. Si ho és, es tracta d' un extorn
-- ********************************************************************************
            BEGIN
               SELECT SUM (DECODE (cconcep, 0, iconcep, 50, iconcep, 0)),
                      -- total neta
                      SUM (DECODE (cconcep, 21, iconcep, 71, iconcep, 0))
                 -- total devengada
               INTO   xtotprimaneta,
                      xtotprimadeve
                 FROM tmp_adm_detrecibos
                WHERE nrecibo = pnrecibo AND cconcep IN (0, 50, 21, 71);
            EXCEPTION
               WHEN OTHERS
               THEN
                  RETURN 103516;             -- Error al llegir de DETRECIBOS
            END;

            IF xtotprimaneta < 0 OR xtotprimadeve < 0
            THEN
               IF xctiprec <> 10
               THEN
                  -- No és un extorn d' anul.lació
                  BEGIN
                     -- xex_pte_imp = 1 (Extorn pendent d'imprimir)
                     -- xex_pte_imp = 0 (Extorn pendent de transferir)
                     UPDATE tmp_adm_recibos
                        SET ctiprec = 9,
                            -- Si la prima és negativa,es tracta d' un extorn
                            cestimp =
                               DECODE (cestimp,
                                       4, DECODE (xex_pte_imp, 0, 7, 1),
                                       cestimp
                                      )
                      WHERE sproces = pnproces AND nrecibo = pnrecibo;
                  EXCEPTION
                     WHEN OTHERS
                     THEN
                        RETURN 103520;
                  -- Error al modificar la taula RECIBOSCAR
                  END;

                  -- BUG: 12961 AVT 22-02-2010 s'ajusta pels rebuts d'extorn
                  FOR reg IN (SELECT   cgarant, SUM (iconcep) iconcep
                                  FROM tmp_adm_detrecibos
                                 WHERE nrecibo = pnrecibo
                              GROUP BY cgarant)
                  LOOP
                     IF reg.iconcep = 0
                     THEN
                        BEGIN
                           DELETE      tmp_adm_detrecibos
                                 WHERE nrecibo = pnrecibo
                                   AND cgarant = reg.cgarant;
                        EXCEPTION
                           WHEN NO_DATA_FOUND
                           THEN
                              NULL;
                           WHEN OTHERS
                           THEN
                              RETURN 104377;
                        END;
                     END IF;
                  END LOOP;
               END IF;

               error := pac_adm.f_extornpos (pnrecibo, pmodo, pnproces);

               IF error <> 0
               THEN
                  RETURN error;
               END IF;
            END IF;

            IF ha_grabat = TRUE
            THEN
               error := pac_adm.f_tmp_vdetrecibos ('N', pnrecibo, pnproces);
               -- No fem reasseguro pq és un rebut fictici
               RETURN error;
            ELSIF NVL (f_parinstalacion_n ('DETREC99NO'), 0) != 1
            THEN
               -- No ha grabat res a DETRECIBOS
               -- 26755 AVT 22/04/2013 pels conceptes que el 100% va al concepte normal no fem el concepte de coaseguro (cc: 14 i 86)
               error :=
                  pac_adm.f_instmpdetrec (pnrecibo,
                                          99,
                                          0,
                                          -- xploccoa
                                          100,
                                          xcgarant,
                                          xnriesgo,
                                          xctipcoa,
                                          xcageven_gar,
                                          xnmovima_gar
                                         );

               IF error = 0
               THEN
                  error :=
                          pac_adm.f_tmp_vdetrecibos ('N', pnrecibo, pnproces);
                  -- No fem reasseguro pq és un rebut fictici
                  RETURN error;
               END IF;

               RETURN 105154;
            -- Error especial (que es controla a la crida de aquesta funció
            ELSE
               RETURN 103108;    -- No s' ha grabat cap registre en la funció
            END IF;
         -- Rèdit de interessos en comptes de estalvi ************************
         ELSIF pmodo = 'I'
         THEN
            IF     pnimport IS NOT NULL
               AND pnrecibo IS NOT NULL
               AND pfefecto IS NOT NULL
               AND psseguro IS NOT NULL
            THEN
               IF xctipcoa = 8 OR xctipcoa = 9
               THEN
                  /*  Si se trata de un coaseguro aceptado. Puede pasar que nosotros paguemos
                     directamente al agente con lo que pcomcoa sera nulo, y deberemos ir a
                     buscar los porcentajes por p_fcomisi.
                     Sino pcomcoa sera diferente a nulo, y tendra el porcentaje a pagar a la otra compañia y la
                     comision y retencio en vdetrecibos sera 0.
                  */
                  BEGIN
                     SELECT pcomcoa
                       INTO xpcomcoa
                       FROM coacedido
                      WHERE sseguro = psseguro AND ncuacoa = xncuacoa;
                  EXCEPTION
                     WHEN NO_DATA_FOUND
                     THEN
                        -- 23183 AVT 01/11/2012
                        xpcomcoa := NULL;
                     WHEN OTHERS
                     THEN
                        RETURN 105582; -- Error al leer de la tabla COACEDIDO
                  END;

                  IF xpcomcoa IS NULL
                  THEN
                     /*error :=
                     f_pcomisi (psseguro,
                                pcmodcom,
                                pfefecto,
                                xccomisi,
                                xcretenc,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                pttabla,
                                pfuncion
                               );*/
                     -- BUG 0020480 - 19/12/2011 - JMF
                     error :=
                        f_pcomisi (psseguro,
                                   pcmodcom,
                                   f_sysdate,
                                   xccomisi,
                                   xcretenc,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   pttabla,
                                   pfuncion
                                  );
                  ELSE
                     xccomisi := 0;
                     xcretenc := 0;
                     error := 0;
                  END IF;
               ELSE
                  NULL;
                  /*error :=
                  f_pcomisi (psseguro,
                             pcmodcom,
                             pfefecto,
                             xccomisi,
                             xcretenc,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             pttabla,
                             pfuncion
                            );*/
                  -- BUG 0020480 - 19/12/2011 - JMF
                  error :=
                     f_pcomisi (psseguro,
                                pcmodcom,
                                f_sysdate,
                                xccomisi,
                                xcretenc,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                pttabla,
                                pfuncion
                               );
               END IF;

               IF error = 0
               THEN
                  -- ******* Comision bruta ******
                  xnimpcom :=
                           f_round (((pnimport * xccomisi) / 100), decimals);
                  -- Posada la garantia 48, prima del periode
                  --  IF NVL (xnimpcom, 0) <> 0
                  -- THEN
                  error :=
                     pac_adm.f_instmpdetrec (pnrecibo,
                                             11,
                                             pnimport,
                                             xploccoa,
                                             48,
                                             pnriesgo,
                                             xctipcoa,
                                             xcageven_gar,
                                             xnmovima_gar,
                                             xccomisi,
                                             psseguro
                                            );

                  IF error = 0
                  THEN
                     ha_grabat := TRUE;
                  ELSE
                     CLOSE cur_garanseg;

                     RETURN error;
                  END IF;

                  pnimport2 := pnimport - xnimpcom;
                  -- ******* Retencion *******
                  -- Calculamos el irpf que es comun al local y al cedido
                  xnimpret :=
                            f_round (((pnimport * xcretenc) / 100), decimals);

                  IF NVL (xnimpret, 0) <> 0
                  THEN
                     error :=
                        pac_adm.f_instmpdetrec (pnrecibo,
                                                12,
                                                xnimpret,
                                                xploccoa,
                                                48,
                                                pnriesgo,
                                                xctipcoa,
                                                xcageven_gar,
                                                xnmovima_gar,
                                                xccomisi,
                                                psseguro
                                               );

                     IF error = 0
                     THEN
                        ha_grabat := TRUE;
                     ELSE
                        CLOSE cur_garanseg;

                        RETURN error;
                     END IF;
                  END IF;

                  error := pac_adm.f_tmp_vdetrecibos (pmodo, pnrecibo);

                  IF error = 0
                  THEN
                     error :=
                        pac_cesionesrea.f_cessio_det (pnproces,
                                                      psseguro,
                                                      pnrecibo,
                                                      xcactivi,
                                                      xcramo,
                                                      xcmodali,
                                                      xctipseg,
                                                      xccolect,
                                                      pfefecto,
                                                      pfvencim,
                                                      1,
                                                      decimals,
                                                      1,
                                                      'EST'
                                                     );

                     IF error <> 0
                     THEN
                        RETURN error;
                     END IF;
                  END IF;

                  RETURN error;
               --ELSE                                            -- Comissió = 0
               --   pnimport2 := NVL (pnimport, 0);
               /*
                  IF sw_aln = 1
                  THEN
                     BEGIN
                        DELETE FROM calcomisprev
                              WHERE nrecibo = pnrecibo;
                     EXCEPTION
                        WHEN OTHERS
                        THEN
                           RETURN 112182;
                     -- Error borrando registros de CALCOMISPREV
                     END;
                  END IF;

                  RETURN 0;
               END IF;
               */
               ELSE
                  RETURN error;                       -- Error en el p_comisi
               END IF;
            ELSE
               RETURN 101901;     -- Pas de paràmetres incorrecte a la funció
            END IF;
         ELSE
            RETURN 101901;        -- Pas incorrecte de paràmetres a la funció
         END IF;
      END IF;            -- IF que diferencia el cas de Ahorro dels altres dos

      RETURN 0;
   -- BUG -21546_108724- 08/02/2012 - JLTS - Cierre de posibles cursores abiertos, se adiciona EXCEPTION
   EXCEPTION
      WHEN OTHERS
      THEN
         IF cur_garanseg%ISOPEN
         THEN
            CLOSE cur_garanseg;
         END IF;

         IF cur_garansegant%ISOPEN
         THEN
            CLOSE cur_garansegant;
         END IF;

         IF cur_garancar%ISOPEN
         THEN
            CLOSE cur_garancar;
         END IF;

         IF curgaran%ISOPEN
         THEN
            CLOSE curgaran;
         END IF;

         RETURN 140999;
   END f_detrecibo;

   /****************************************************************************
      F_INSTMPDETREC : Insertar un registro en la tabla de detrecibos.
      ALLIBADM - Gestión de datos referentes a los recibos
        funcion que inserta un registro a detrecibos
                    teniendo en cuenta si es coaseguro cedido, aceptado o no.
                    Esta funcion es llamada por f_detrecibo_coa
        se añaden los parametros psseguro y poragloc
                    para el calculo especial de las comisiones y retenciones.
                    poragloc : El porcentaje del agente en nuestra compañia
       Si nos llega un nuevo importe para un concepto de ese
                    riesgo, garantía lo sumamos.
        Cambios para grabar dos campos mas de la tabla TMP_ADM_DETRECIBOS
         Modificamos las selects para que vaya por nmovima
   ****************************************************************************/
   FUNCTION f_instmpdetrec (
      precibo     IN   NUMBER,
      pconcepto   IN   NUMBER,
      pimporte    IN   NUMBER,
      pporcent    IN   NUMBER,
      pgarantia   IN   NUMBER,
      priesgo     IN   NUMBER,
      pxctipcoa   IN   NUMBER,
      pcageven    IN   NUMBER DEFAULT NULL,
      pnmovima    IN   NUMBER DEFAULT 1,
      pporagloc   IN   NUMBER DEFAULT 0,
      psseguro    IN   NUMBER DEFAULT 0,
      pccomisi    IN   NUMBER DEFAULT 1
   )
      RETURN NUMBER
   IS
      ximplocal   NUMBER;
      ximpcedid   NUMBER;
      decimals    NUMBER                            := 0;
      xcedido     NUMBER;
      xncuacoa    seguros.ncuacoa%TYPE;
      ximporte    tmp_adm_detrecibos.iconcep%TYPE;
      --       ximporte       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xconcepto   tmp_adm_detrecibos.cconcep%TYPE;
      --       xconcepto      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      --w_error        VARCHAR2(4000);
      xcageven    tmp_adm_detrecibos.cageven%TYPE;
      --       xcageven       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xnmovima    riesgos.nmovima%TYPE;
   --       xnmovima       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
   BEGIN
      IF f_parinstalacion_n ('AGTEVENTA') = 0
      THEN
         xcageven := NULL;
         xnmovima := 1;
      ELSE
         xcageven := pcageven;
         xnmovima := pnmovima;
      END IF;

      -- 23183 AVT 01/11/2012 només al coa cedit
      IF pxctipcoa IN (1, 2)
      THEN
         -- Se trata de un coaseguro
         ximplocal := ROUND ((pimporte * pporcent) / 100, decimals);

         -- ES UN PORCENTAJE
         IF f_escomision (pconcepto) = 0
         THEN
            -- No se trata de la comision bruta ni de la retencion
            ximpcedid := NVL (pimporte, 0) - NVL (ximplocal, 0);
         ELSE
            -- Se trata de la comision bruta o de la retencion
            -- Calculamos el importe total cedido
            xcedido := NVL (pimporte, 0) - NVL (ximplocal, 0);
            -- Calculamos la comision del agente
            ximplocal := (ximplocal * pporagloc) / 100;

            BEGIN
               SELECT NVL (ncuacoa, 0)
                 INTO xncuacoa
                 FROM seguros
                WHERE sseguro = psseguro;
            EXCEPTION
               WHEN OTHERS
               THEN
                  RETURN 101919;         -- Error al leer de la tabla SEGUROS
            END;

            BEGIN
               -- Calculamos la suma de las comisiones del agente por cada compañia
               SELECT SUM (NVL (  xcedido
                                * (pcesion / 100)
                                * (  DECODE (ccuacoa, 1, pporagloc, pcomcoa)
                                   / 100
                                  ),
                                0
                               )
                          )
                 INTO ximpcedid
                 FROM seguros s, agentes a, coacedido c
                WHERE s.sseguro = c.sseguro
                  AND s.cagente = a.cagente
                  AND c.sseguro = psseguro
                  AND c.ncuacoa = xncuacoa;

               ximpcedid := f_round (ximpcedid);
            EXCEPTION
               WHEN OTHERS
               THEN
                  RETURN 105582;       -- Error al leer de la tabla COACEDIDO
            END;
         END IF;
      ELSE
         -- Es un seguro normal
         IF f_escomision (pconcepto) = 0
         THEN
            -- No se trata de la comision bruta ni de la retencion
            ximplocal := NVL (pimporte, 0);
         ELSE
            -- Se trata de la comision bruta o de la retencion
            -- Calculamos la comision del agente
            ximplocal := (pimporte * pporagloc) / 100;
         END IF;
      END IF;

      -- Coaseguro aceptado o seguro normal: Grabamos un unico registro
      ximporte := NVL (ximplocal, 0);
      xconcepto := pconcepto;
      ximporte := f_round (ximporte);

      BEGIN
         INSERT INTO tmp_adm_detrecibos
                     (nrecibo, cconcep, iconcep, cgarant, nriesgo,
                      cageven, nmovima
                     )
              VALUES (precibo, xconcepto, ximporte, pgarantia, priesgo,
                      xcageven, xnmovima
                     );
      EXCEPTION
         WHEN DUP_VAL_ON_INDEX
         THEN
            BEGIN
               -- Registro ya existe. Le sumamos el nuevo importe.
               UPDATE tmp_adm_detrecibos
                  SET iconcep = iconcep + ximporte
                WHERE nrecibo = precibo
                  AND cconcep = xconcepto
                  AND cgarant = pgarantia
                  AND nriesgo = priesgo
                  AND nmovima = xnmovima;
            EXCEPTION
               WHEN OTHERS
               THEN
                  RETURN 9001960;   --Error al actualitzar TMP_ADM_DETRECIBOS
            END;
         WHEN OTHERS
         THEN
            RETURN 9001961;          --Error a l'inserir a TMP_ADM_DETRECIBOS
      END;

      -- 26755 AVT 22/04/2013 pels conceptes que el 100% va al concepte normal no fem el concepte de coaseguro (cc: 14 i 86)
      IF (pxctipcoa = 1 OR pxctipcoa = 2) AND pporcent < 100
      THEN
         -- Coaseguro cedido: Grabamos dos registros por concepto
         -- Sumamos 50 por la nomenclatura tomada de que los conceptos cedidos
         -- son el mismo codigo mas 50.
         ximporte := NVL (ximpcedid, 0);
         xconcepto := pconcepto + 50;
         ximporte := f_round (ximporte);

         BEGIN
            INSERT INTO tmp_adm_detrecibos
                        (nrecibo, cconcep, iconcep, cgarant, nriesgo,
                         cageven, nmovima
                        )
                 VALUES (precibo, xconcepto, ximporte, pgarantia, priesgo,
                         xcageven, xnmovima
                        );
         EXCEPTION
            WHEN DUP_VAL_ON_INDEX
            THEN
               BEGIN
                  -- Registro ya existe. Le sumamos el nuevo importe.
                  UPDATE tmp_adm_detrecibos
                     SET iconcep = iconcep + ximporte
                   WHERE nrecibo = precibo
                     AND cconcep = xconcepto
                     AND cgarant = pgarantia
                     AND nriesgo = priesgo
                     AND nmovima = xnmovima;
               EXCEPTION
                  WHEN OTHERS
                  THEN
                     RETURN 9001960;
               --Error al actualitzar TMP_ADM_DETRECIBOS
               END;
            WHEN OTHERS
            THEN
               RETURN 9001961;       --Error a l'inserir a TMP_ADM_DETRECIBOS
         END;
      END IF;

      RETURN 0;
   END f_instmpdetrec;

   FUNCTION f_tmp_vdetrecibos (
      pmodo      IN   VARCHAR2,
      pnrecibo   IN   NUMBER,
      psproces   IN   NUMBER DEFAULT 0
   )
      RETURN NUMBER
   IS
      /* ******************************************************************
       ALLIBADM. OMPLE LA TAULA VDETRECIBOS O
       VDETRECIBOSCAR, SEGONS EL PMODO ('P' O 'R' O 'A').
       Se añade el campo que almacena la comision de la cia (ICOMCIA).
      *************************************************************************/
      xctipcoa   tmp_adm_recibos.ctipcoa%TYPE;
   --       xctipcoa       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
   BEGIN
      -- Bug 19096 - RSC - 03/08/2011 - LCOL - Parametrización básica producto Vida Individual Pagos Permanentes (Afegim 'RRIE')
      IF pmodo IN ('R', 'A', 'ANP', 'I', 'P', 'N', 'RRIE', 'PRIE')
      THEN
         BEGIN
            SELECT ctipcoa
              INTO xctipcoa
              FROM tmp_adm_recibos
             WHERE nrecibo = pnrecibo;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               RETURN 101902;              -- RECIBO NO ENCONTRADO EN RECIBOS
            WHEN OTHERS
            THEN
               RETURN 102367;            -- ERROR AL LEER DE LA TABLA RECIBOS
         END;

         BEGIN
            INSERT INTO tmp_adm_vdetrecibos
                        (nrecibo, iprinet, irecext, iconsor, ireccon, iips,
                         idgs, iarbitr, ifng, irecfra, idtotec, idtocom,
                         icombru, icomret, ipridev, idtoom, iderreg, icomdev,
                         iretdev, iocorec,
                                          -- Se añade el campo que almacena otros conceptos recargo.
                                          it1pri, it1dto, it1con, it1imp,
                         it1totr, it1rec, icednet, icedrex, icedcon, icedrco,
                         icedips, iceddgs, icedarb, icedfng, icedrfr,
                         iceddte, iceddco, icedcbr, icedcrt, icedpdv,
                         iceddom, icedreg, icedcdv, icedrdv, it2pri, it2dto,
                         it2con, it2imp, it2totr, it2rec, itotpri, itotdto,
                         itotcon, itotimp, itotrec, itotalr, icombrui,
                         icomreti, icomdevi, icomdrti, icombruc, icomretc,
                         icomdevc, icomdrtc, icomcia
                                                    -- Se añade el campo que almacena la comision de la cia.
                         , iimp_1, iimp_2, iimp_3, iimp_4
                                                         -- 38. 27/03/2012 JGR 0020546/104206
                        )
               SELECT   nrecibo,
                        SUM (DECODE (cconcep, 0, iconcep, 0)) iprinet,

                        -- IMPORTES PARTE LOCAL
                        SUM (DECODE (cconcep, 1, iconcep, 0)) irecext,
                        SUM (DECODE (cconcep, 2, iconcep, 0)) iconsor,
                        SUM (DECODE (cconcep, 3, iconcep, 0)) ireccon,
                        SUM (DECODE (cconcep, 4, iconcep, 0)) iips,
                        SUM (DECODE (cconcep, 5, iconcep, 0)) idgs,
                        SUM (DECODE (cconcep, 6, iconcep, 0)) iarbitr,
                        SUM (DECODE (cconcep, 7, iconcep, 0)) ifng,
                        SUM (DECODE (cconcep, 8, iconcep, 0)) irecfra,
                        SUM (DECODE (cconcep, 9, iconcep, 0)) idtotec,
                        SUM (DECODE (cconcep, 10, iconcep, 0)) idtocom,
                        SUM (DECODE (cconcep, 11, iconcep, 0)) icombru,
                        SUM (DECODE (cconcep, 12, iconcep, 0)) icomret,
                        SUM (DECODE (cconcep, 21, iconcep, 0)) ipridev,
                        SUM (DECODE (cconcep, 13, iconcep, 0)) idtoom,
                        SUM (DECODE (cconcep, 14, iconcep, 0)) iderreg,
                        SUM (DECODE (cconcep, 15, iconcep, 0)) icomdev,
                        SUM (DECODE (cconcep, 16, iconcep, 0)) iretdev,
                        SUM (DECODE (cconcep, 26, iconcep, 0)) iocorec,

                        --
                        (  SUM (DECODE (cconcep, 0, iconcep, 0))
                         +                       -- CALCULO DE TOTALES LOCALES
                           SUM (DECODE (cconcep, 1, iconcep, 0))
                        ) it1pri,

                        --
                        SUM (DECODE (cconcep, 13, iconcep, 0)) it1dto,

                        --
                        (  SUM (DECODE (cconcep, 2, iconcep, 0))
                         + SUM (DECODE (cconcep, 3, iconcep, 0))
                        ) it1con,

                        --
                        (  SUM (DECODE (cconcep, 4, iconcep, 0))
                         + SUM (DECODE (cconcep, 5, iconcep, 0))
                         + SUM (DECODE (cconcep, 6, iconcep, 0))
                         + SUM (DECODE (cconcep, 7, iconcep, 0))
                        ) it1imp,

                        --
                        (  SUM (DECODE (cconcep, 0, iconcep, 0))
                         + SUM (DECODE (cconcep, 1, iconcep, 0))
                         + SUM (DECODE (cconcep, 2, iconcep, 0))
                         + SUM (DECODE (cconcep, 3, iconcep, 0))
                         + SUM (DECODE (cconcep, 4, iconcep, 0))
                         + SUM (DECODE (cconcep, 5, iconcep, 0))
                         + SUM (DECODE (cconcep, 6, iconcep, 0))
                         + SUM (DECODE (cconcep, 7, iconcep, 0))
                         + SUM (DECODE (cconcep, 8, iconcep, 0))
                         + SUM (DECODE (cconcep, 14, iconcep, 0))
                         - SUM (DECODE (cconcep, 13, iconcep, 0))
                        ) it1totr,

                        --
                        (  SUM (DECODE (cconcep, 8, iconcep, 0))
                         + SUM (DECODE (cconcep, 14, iconcep, 0))
                        ) it1rec,

                        --
                        SUM (DECODE (cconcep, 50, iconcep, 0)) icednet,

                        -- IMPORTES PARTE CEDIDA
                        SUM (DECODE (cconcep, 51, iconcep, 0)) icedrex,
                        SUM (DECODE (cconcep, 52, iconcep, 0)) icedcon,
                        SUM (DECODE (cconcep, 53, iconcep, 0)) icedrco,
                        SUM (DECODE (cconcep, 54, iconcep, 0)) icedips,
                        SUM (DECODE (cconcep, 55, iconcep, 0)) iceddgs,
                        SUM (DECODE (cconcep, 56, iconcep, 0)) icedarb,
                        SUM (DECODE (cconcep, 57, iconcep, 0)) icedfng,
                        SUM (DECODE (cconcep, 58, iconcep, 0)) icedrfr,
                        SUM (DECODE (cconcep, 59, iconcep, 0)) iceddte,
                        SUM (DECODE (cconcep, 60, iconcep, 0)) iceddco,
                        SUM (DECODE (cconcep, 61, iconcep, 0)) icedcbr,
                        SUM (DECODE (cconcep, 62, iconcep, 0)) icedcrt,
                        SUM (DECODE (cconcep, 71, iconcep, 0)) icedpdv,
                        SUM (DECODE (cconcep, 63, iconcep, 0)) iceddom,
                        SUM (DECODE (cconcep, 64, iconcep, 0)) icedreg,
                        SUM (DECODE (cconcep, 65, iconcep, 0)) icedcdv,
                        SUM (DECODE (cconcep, 66, iconcep, 0)) icedrdv,

                        --
                        (  SUM (DECODE (cconcep, 50, iconcep, 0))
                         +                  -- CALCULO DE TOTALES PARTE CEDIDA
                           SUM (DECODE (cconcep, 51, iconcep, 0))
                        ) it2pri,

                        --
                        SUM (DECODE (cconcep, 63, iconcep, 0)) it2dto,

                        --
                        (  SUM (DECODE (cconcep, 52, iconcep, 0))
                         + SUM (DECODE (cconcep, 53, iconcep, 0))
                        ) it2con,

                        --
                        (  SUM (DECODE (cconcep, 54, iconcep, 0))
                         + SUM (DECODE (cconcep, 55, iconcep, 0))
                         + SUM (DECODE (cconcep, 56, iconcep, 0))
                         + SUM (DECODE (cconcep, 57, iconcep, 0))
                        ) it2imp,

                        --
                        (  SUM (DECODE (cconcep, 50, iconcep, 0))
                         + SUM (DECODE (cconcep, 51, iconcep, 0))
                         + SUM (DECODE (cconcep, 52, iconcep, 0))
                         + SUM (DECODE (cconcep, 53, iconcep, 0))
                         + SUM (DECODE (cconcep, 54, iconcep, 0))
                         + SUM (DECODE (cconcep, 55, iconcep, 0))
                         + SUM (DECODE (cconcep, 56, iconcep, 0))
                         + SUM (DECODE (cconcep, 57, iconcep, 0))
                         + SUM (DECODE (cconcep, 58, iconcep, 0))
                         + SUM (DECODE (cconcep, 64, iconcep, 0))
                         - SUM (DECODE (cconcep, 63, iconcep, 0))
                        ) it2totr,

                        --
                        (  SUM (DECODE (cconcep, 58, iconcep, 0))
                         + SUM (DECODE (cconcep, 64, iconcep, 0))
                        ) it2rec,

                        --
                        0, 0, 0, 0, 0, 0,
                        (SUM (DECODE (cconcep, 17, iconcep, 0))) icombrui,

                        -- CALCULO DE IMPORTES DE COMISIONES INDIRECTAS
                        (SUM (DECODE (cconcep, 18, iconcep, 0))) icomreti,
                        (SUM (DECODE (cconcep, 19, iconcep, 0))) icomdevi,
                        (SUM (DECODE (cconcep, 20, iconcep, 0))) icomdrti,
                        (SUM (DECODE (cconcep, 22, iconcep, 0))) icombruc,

                        -- CALCULO DE IMPORTES DE COM. AGTE. COBRADOR
                        (SUM (DECODE (cconcep, 23, iconcep, 0))) icomretc,
                        (SUM (DECODE (cconcep, 24, iconcep, 0))) icomdevc,
                        (SUM (DECODE (cconcep, 25, iconcep, 0))) icomdrtc,
                        SUM (DECODE (cconcep, 30, iconcep, 0)) icomcia
                                                                      -- Se añade el campo que almacena la comision de la cia.
                        ,
                        SUM (DECODE (cconcep, 32, iconcep, 0)) iimp_1,

                        -- 38. 27/03/2012 JGR 0020546/104206
                        SUM (DECODE (cconcep, 40, iconcep, 0)) iimp_2,

                        -- 38. 27/03/2012 JGR 0020546/104206
                        SUM (DECODE (cconcep, 41, iconcep, 0)) iimp_3,

                        -- 38. 27/03/2012 JGR 0020546/104206
                        SUM (DECODE (cconcep, 42, iconcep, 0)) iimp_4
                   -- 38. 27/03/2012 JGR 0020546/104206
               FROM     tmp_adm_detrecibos
                  WHERE nrecibo = pnrecibo
               GROUP BY nrecibo;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               RETURN 103469;                 -- REBUT NO TROBAT A DETRECIBOS
            WHEN DUP_VAL_ON_INDEX
            THEN
               RETURN 103471;              -- REGISTRE DUPLICAT A VDETRECIBOS
            WHEN OTHERS
            THEN
               RETURN 103473;             -- ERROR A L' INSERIR A VDETRECIBOS
         END;

         IF xctipcoa = 1
         THEN
            -- RECIBO ÚNICO
            UPDATE tmp_adm_vdetrecibos
               -- TOTAL SERA PARTE LOCAL + PARTE CEDIDA
            SET itotpri = it1pri + it2pri,
                itotdto = it1dto + it2dto,
                itotcon = it1con + it2con,
                itotimp = it1imp + it2imp,
                itotalr = it1totr + it2totr + iocorec,
                itotrec = it1rec + it2rec
             WHERE nrecibo = pnrecibo;
         ELSE
            --  XCTIPCOA IS NULL O NO ES UN RECIBO UNICO
            UPDATE tmp_adm_vdetrecibos              -- TOTAL SERA PARTE LOCAL
               SET itotpri = it1pri,
                   itotdto = it1dto,
                   itotcon = it1con,
                   itotimp = it1imp,
                   itotalr = it1totr + iocorec,
                   itotrec = it1rec
             WHERE nrecibo = pnrecibo;
         END IF;

         RETURN 0;
-- ******************************
-- * CARTERA O NUEVA PRODUCCION *
-- ******************************
      ELSE
         RETURN 101901;           -- PAS DE PARÀMETRES INCORRECTE A LA FUNCIÓ
      END IF;
   END f_tmp_vdetrecibos;

   FUNCTION f_imprecibos (
      pnproces          IN   NUMBER,
      pnrecibo          IN   NUMBER,
      ptipomovimiento   IN   NUMBER,
      pmodo             IN   VARCHAR2,
      pnriesgo          IN   NUMBER,
      ppdtoord          IN   NUMBER,
      pcrecfra          IN   NUMBER,
      pcforpag          IN   NUMBER,
      pcramo            IN   NUMBER,
      pcmodali          IN   NUMBER,
      pctipseg          IN   NUMBER,
      pccolect          IN   NUMBER,
      pcactivi          IN   NUMBER,
      pcomisagente      IN   NUMBER,
      pretenagente      IN   NUMBER,
      psseguro          IN   NUMBER,
      pcmodcom          IN   NUMBER,
      pmoneda           IN   NUMBER DEFAULT 1,
      pprorata          IN   NUMBER,
      pttabla           IN   VARCHAR2 DEFAULT NULL,
      pfuncion          IN   VARCHAR2 DEFAULT 'CAR'
   )
      RETURN NUMBER
   IS
      -- CALCULA ELS IMPOSTOS DELS REBUTS.
      -- IMPLEMENTACION DEL COASEGURO EN RECIBOS TRABAJAMOS CON IMPORTES TOTALES: LOCAL + CEDIDO
      -- CANVIS PER MILLORAR RENDIMENT.
      -- Acceso a PARINSTALACION para decidir cargar o no el recargo por fraccionamiento en el calculo del IPS
      -- Calcul de la clea en el primer rebut
      -- No calcular les 10 pts d'OFESAUTO si es un suplement
      -- EL RECARREC PER FRACCIONAMENT ARA ESTA PER PRODUCTE-ACTIVITAT-GARANTIA
      -- Generamos Der. Reg con importe igual a la prima neta para las instalaciones con
      -- Parinstalacion (DER_REG) y garanpro.CDERREG=1
      -- Añadimos el modo H rehabilitacion.
      -- control del not_data_found en la funcion de f_control_cderreg.Para cuando estamos
      -- generamos un recibo de extorno devolvemos un 1.
      -- 22/4/2004 YIL. Se añade el tipomovimiento = 11 ==> Suplemento con Recibo por diferencia
      --              de prima basada en provisión matemática (prima única)

      /******************************************************************************
      NOMBRE:       F_IMPRECIBOS
      PROPÓSITO:    Procedimient per imprimir rebuts.

      REVISIONES:
      Ver        Fecha        Autor             Descripción
      ---------  ----------  ---------------  ------------------------------------
      1.0        ??/??/????  ???                1. Creación del package.
      5.0        29/05/2009  JTS                5. BUG 9658 - JTS - APR - Desarrollo PL de comisiones de adquisión.#6.
      ******************************************************************************/

      /* SMF 15/09/2004
        {Se añaden los parametros funcion y tabla para el calculo del primer recibo al tarifar,
         el parametro tabla indica a que tablas tiene que ir a buscar importes ('EST','SOL',NULLL),
         el parametro función indica si estoy tarifando (TAR) o en la cartera o previo de cartera (CAR)}
      */
      error               NUMBER                            := 0;
      dummy               segcleafrac.sseguro%TYPE;
      --       dummy          NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xcgarant            NUMBER;
      xnriesgo            NUMBER;
      xcageven            tmp_adm_detrecibos.cageven%TYPE;
      --       xcageven       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xnmovima            riesgos.nmovima%TYPE;
      --       xnmovima       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xprecarg            NUMBER;
      grabar              NUMBER;
      xiconcep            NUMBER;
      --xcimpcon       NUMBER;
      xcimpdgs            NUMBER;
      xcimpips            NUMBER;
      --xcimpcom       NUMBER;
      --xcimpces       NUMBER;
      xcimparb            NUMBER;
      xcimpfng            NUMBER;
      xcderreg            NUMBER;
      iconcep0            tmp_adm_detrecibos.iconcep%TYPE;
      --       iconcep0       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xidtocam            NUMBER;
      iconcep21           NUMBER;
      idto                NUMBER;
      idto21              NUMBER;
      tot_iconcepdgs      NUMBER;
      tot_iconcepips      NUMBER;
      tot_iconceparb      NUMBER;
      tot_iconcepfng      NUMBER;
      tot_iconcepderreg   NUMBER;
      taxadgs             NUMBER;
      taxaips             impuestos.pimpips%TYPE;
      --       taxaips        NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      --taxacon        NUMBER;
      --taxaces        NUMBER;
      taxaarb             NUMBER;
      taxafng             NUMBER;
      taxaderreg          NUMBER;
      totrecfracc         NUMBER;
      comis_calc          NUMBER;
      reten_calc          NUMBER;
      xxiconcep           NUMBER;
      xploccoa            coacuadro.ploccoa%TYPE;
      --       xploccoa       NUMBER;   -- COASEGURO --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xctipcoa            seguros.ctipcoa%TYPE;
      --       xctipcoa       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xncuacoa            seguros.ncuacoa%TYPE;
      --       xncuacoa       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xpcomcoa            coacedido.pcomcoa%TYPE;
      --       xpcomcoa       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xcrespue            NUMBER;
      porcagente          NUMBER;
      porragente          NUMBER;
      --xips_fracc     NUMBER;
      --xdgs_fracc     NUMBER;
      --xarb_frac      NUMBER;
      --ximp_boni      NUMBER;
      xfefecto            seguros.fefecto%TYPE;
      --       xfefecto       DATE;   --SMF --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xfeferec            DATE;
      --Bug 10851 - APD - 31/07/2009 -- se añade la variable xfefecrec
      xfvencim            tmp_adm_recibos.fvencim%TYPE;
      --       xfvencim       DATE;   --SM --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      totrecfracc_dgs     NUMBER;
      xicapital           garanseg.icapital%TYPE;
      --       xicapital      NUMBER;   -- DRA 27-8-08: bug mantis 7372 --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      paso                NUMBER;             -- DRA 27-8-08: bug mantis 7372
      xcempres            codiram.cempres%TYPE;
      --       xcempres       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xnmovimi            tmp_adm_recibos.nmovimi%TYPE;
      --       xnmovimi       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      vctipcon            NUMBER;
      vnvalcon            NUMBER;
      vcfracci            NUMBER;
      vcbonifi            NUMBER;
      vcrecfra            NUMBER;
      --viconcep       NUMBER;
      --vidto          NUMBER;
      oiconcep            NUMBER;
      vnerror             NUMBER;
      xccalcom            productos.ccalcom%TYPE;
      --       xccalcom       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xsproduc            productos.sproduc%TYPE;
      --Bug.: 10709 - ICV - 16/07/09
      num_err             NUMBER;              --Bug.: 10709 - ICV - 16/07/09
      nmovren             movseguro.nmovimi%TYPE;
      --Bug.: 10709 - ICV - 16/07/09
      --vfefectmov     movseguro.fefecto%TYPE;
      --Bug.: 10709 - ICV - 16/07/09
      --fefeseg        DATE;   --Bug.: 10709 - ICV - 16/07/09
      v_tipfec            NUMBER;              --Bug.: 10709 - ICV - 16/07/09
      --xfcaranu       DATE;   --Bug.: 10709 - DCT - 20/07/09
      w_climit            NUMBER;
      v_cmonimp           imprec.cmoneda%TYPE;
      -- BUG 18423 - LCOL000 - Multimoneda
      vcderreg            NUMBER;           -- Bug 0020314 - FAL - 29/11/2011

      CURSOR cur_detrecibos
      IS
         SELECT   nriesgo, cgarant, cageven, nmovima
             FROM tmp_adm_detrecibos
            WHERE nrecibo = pnrecibo
         GROUP BY nriesgo, cgarant, cageven, nmovima;

      FUNCTION f_control_cderreg (
         psseguro   IN   NUMBER,
         pnriesgo   IN   NUMBER,
         pcgarant   IN   NUMBER,
         pfefecto        DATE,
         pnmovima   IN   NUMBER,
         pttabla         VARCHAR2
      )
         RETURN NUMBER
      IS
         /*
          /FUNCIÓN QUE NOS INDICA SI ES LA PRIMERA VEZ QUE SE CONTRATA UNA GARANTIA./
           /SI ES LA PRIMERA VEZ QUE SE CONTRATA Y LA GARANTIA TIENE INFORMADO EL
         CDERREG = 1 (SI GENERA DERECHOS), Y LOS DERECHOS NO SE HAN INCLUIDO EN
         NINGÚN RECIBO EN SITUACIÓN PENDIENTE O COBRADO HASTA EL MOMENTO RETORNAMOS UN 0 */
         v_cont        NUMBER;
         v_cderreg     NUMBER;
         v_resultado   NUMBER := 0;

         CURSOR cur
         IS
            SELECT nrecibo
              FROM tmp_adm_recibos
             WHERE sseguro = psseguro
               AND f_estadorec (nrecibo, pfefecto) IN (0, 1);
      --
      BEGIN
         IF pttabla = 'SEG' OR pttabla IS NULL
         THEN
            BEGIN
               SELECT NVL (cderreg, 0)
                 INTO v_cderreg
                 FROM garanseg
                WHERE cgarant = pcgarant
                  AND sseguro = psseguro
                  AND nmovima = pnmovima
                  AND nriesgo = NVL (pnriesgo, 1)
                  AND ffinefe IS NULL;
            --si cderreg no es 1, no hay que aplicar los derechos de generación
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  RETURN 1;
            --SMF: si no se encuentra nada no hay registro de derechos.
            END;
         ELSIF pttabla = 'SOL'
         THEN
            BEGIN
               SELECT NVL (cderreg, 0)
                 INTO v_cderreg
                 FROM solgaranseg
                WHERE cgarant = pcgarant
                  AND ssolicit = psseguro
                  AND nriesgo = NVL (pnriesgo, 1);
            --si cderreg no es 1, no hay que aplicar los derechos de generación
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  RETURN 1;
            --SMF: si no se encuentra nada no hay registro de derechos.
            END;
         ELSIF pttabla = 'EST'
         THEN
            BEGIN
               SELECT NVL (cderreg, 0)
                 INTO v_cderreg
                 FROM estgaranseg
                WHERE cgarant = pcgarant
                  AND sseguro = psseguro
                  AND nmovima = pnmovima
                  AND nriesgo = NVL (pnriesgo, 1)
                  AND ffinefe IS NULL;
            --si cderreg no es 1, no hay que aplicar los derechos de generación
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  RETURN 1;
            --SMF: si no se encuentra nada no hay registro de derechos.
            END;
         END IF;

         IF v_cderreg = 1
         THEN
            FOR c IN cur
            LOOP
               SELECT COUNT (1)
                 INTO v_cont
                 FROM tmp_adm_detrecibos
                WHERE nrecibo = c.nrecibo
                  AND cgarant = pcgarant
                  AND nmovima = pnmovima
                  AND cconcep = 14
                  AND nriesgo = NVL (pnriesgo, nriesgo);

               v_resultado := NVL (v_resultado, 0) + v_cont;
            END LOOP;

            RETURN v_resultado;
         ELSE
            RETURN 1;
         --si cderreg no es 1, no hay que aplicar los derechos de generación
         END IF;
      END;
   BEGIN
      paso := 0;

      -- ACCESO A PARINSTALACION
      -- s'ha d'aplicar l'ips al recarrec de fracionament 0-No 1-Si
      --   xips_fracc := f_parinstalacion_n ('IPS_FRACC');
      -- s'ha de fraccionar els arbitris 0-No 1-Si
      --   xarb_frac := f_parinstalacion_n ('ARB_FRAC');
      -- Els impostos : clea, arbitris s'apliquen sobre la prima bonificada o no
      --   ximp_boni := f_parinstalacion_n ('IMP_BONI');
      -- s'ha d'aplicar DGS (CLEA) al recarrec de fracionament 0-No 1-Si
      --   xdgs_fracc := f_parinstalacion_n ('CLEA_FRACC');
      BEGIN
         SELECT ccalcom, sproduc
           INTO xccalcom, xsproduc
           FROM productos
          WHERE cramo = pcramo
            AND cmodali = pcmodali
            AND ctipseg = pctipseg
            AND ccolect = pccolect;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            RETURN 104347;                  -- Producte no trobat a PRODUCTOS
         WHEN OTHERS
         THEN
            RETURN 102705;                    -- Error al llegir de PRODUCTOS
      END;

      --BUSCAMOS EL PORCENTAJE LOCAL SI ES UN COASEGURO.
      IF pfuncion = 'CAR'
      THEN
         SELECT ctipcoa, ncuacoa
           INTO xctipcoa, xncuacoa
           FROM seguros
          WHERE sseguro = psseguro;
      END IF;

      IF xctipcoa != 0
      THEN
         SELECT ploccoa
           INTO xploccoa
           FROM coacuadro
          WHERE ncuacoa = xncuacoa AND sseguro = psseguro;
      END IF;

      --COASEGURO ACEPTADO NO NOS INTERESA APLICAR DOS VECES EL PORCENTAJE LOCAL
      IF xctipcoa = 8 OR xctipcoa = 9
      THEN
         xploccoa := 100;
      END IF;

      -- DESCOMPTES (CCONCEP = 13) -- CALCUL IMPOSTOS
      -- DGS, IPS, BOMBERS(ARBITRIS), FNG (CCONCEP = 5, 4, 6 I 7) I DERREG (14)
      -- Bug 19096 - RSC - 03/08/2011 - LCOL - Parametrización básica producto Vida Individual Pagos Permanentes (Afegim 'RRIE')
      IF    pmodo = 'R'
         OR pmodo = 'H'
         OR pmodo IN ('R', 'H', 'A', 'ANP', 'N', 'P', 'PRIE')
         OR pmodo = 'RRIE'
      THEN
         -- (MODE REAL PRODUCCIÓ I CARTERA)
         --SMF. (ALN) NECESSITAMOS LA FECHA DE EFECTO DEL RECIBO PARA LOS DERECHOS
         --DE REGISTRO.
         SELECT fefecto, fvencim, cempres, nmovimi
           INTO xfefecto, xfvencim, xcempres, xnmovimi
           FROM tmp_adm_recibos
          WHERE nrecibo = pnrecibo;

         --Bug 10851 - APD - 31/07/2009 - se guarda en la variable xfeferec la fecha de efecto del recibo
         -- la variable xfefecto se utiliza para guardar la fecha de efecto de la vigencia de los recargos
         -- e impuestos que se deben aplicar.
         xfeferec := xfefecto;
         --Bug.: 10709 - ICV - 16/07/09 - Se elige la fecha de impuestos dependiendo de parametro.
         -- si es del tipo 1 fecha efecto del recibo no se hace nada
         v_tipfec :=
                  pac_parametros.f_parproducto_n (xsproduc, 'FECHA_IMPUESTOS');

         IF v_tipfec = 0
         THEN
            --f_ultrenova
            num_err := f_ultrenova (psseguro, xfefecto, xfefecto, nmovren);

            IF num_err <> 0
            THEN
               p_tab_error (f_sysdate,
                            f_user,
                            'PAC_ADM.f_imprecibos',
                            1,
                            'psseguro : ' || psseguro || ' pmodo : ' || pmodo,
                            SQLERRM
                           );
               RETURN num_err;
            END IF;
         ELSIF v_tipfec = 2
         THEN
            --efecto del seguro
            SELECT fefecto
              INTO xfefecto
              FROM seguros
             WHERE sseguro = psseguro;
         END IF;

         --Fi bug.: 10709

         --
         OPEN cur_detrecibos;

         FETCH cur_detrecibos
          INTO xnriesgo, xcgarant, xcageven, xnmovima;

         WHILE cur_detrecibos%FOUND
         LOOP
            iconcep0 := 0;
            iconcep21 := 0;
            idto := 0;
            xprecarg := 0;
            taxaips := 0;
            taxadgs := 0;
            taxaarb := 0;
            taxafng := 0;
            xcimpips := 0;
            xcimparb := 0;
            xcimpdgs := 0;
            xcimpfng := 0;
            xcrespue := 1;
            totrecfracc := 0;
            totrecfracc_dgs := 0;

            IF ptipomovimiento IN (0, 1, 6, 21, 22, 11)
            THEN
               --TROBEM EL TOTAL DE ICONCEP PER CCONCEP = 0
               BEGIN
                  SELECT   NVL (SUM (iconcep), 0)
                      INTO iconcep0
                      FROM tmp_adm_detrecibos
                     WHERE nrecibo = pnrecibo
                       AND nriesgo = xnriesgo
                       AND cgarant = xcgarant
                       AND nmovima = xnmovima
                       AND cconcep IN (0, 50)                -- LOCAL + CEDIDA
                  GROUP BY nriesgo, cgarant;

                  xiconcep := iconcep0;
                  grabar := 1;
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     NULL;
                     grabar := 0;
                  WHEN OTHERS
                  THEN
                     CLOSE cur_detrecibos;

                     error := 103512;        -- ERROR AL LLEGIR DE DETRECIBOS
                     RETURN error;
               END;

               IF NVL (ppdtoord, 0) <> 0
               THEN
                  IF grabar = 1
                  THEN
                     --CALCULEM EL DESCOMPTE O.M. (CCONCEP=13)
                     xxiconcep :=
                               f_round ((xiconcep * ppdtoord) / 100, pmoneda);

                     IF NVL (xxiconcep, 0) <> 0
                     THEN
                        error :=
                           pac_adm.f_instmpdetrec (pnrecibo,
                                                   13,
                                                   xxiconcep,
                                                   xploccoa,
                                                   xcgarant,
                                                   NVL (xnriesgo, 0),
                                                   xctipcoa,
                                                   xcageven,
                                                   xnmovima
                                                  );

                        IF error != 0
                        THEN
                           CLOSE cur_detrecibos;

                           RETURN error;
                        END IF;
                     END IF;
                  END IF;
               END IF;

               --BUG9658 -- 02/04/2009 -- JTS
               --TROBEM EL TOTAL DE ICONCEP PER CCONCEP = 17
               IF error = 0
               THEN
                  DECLARE
                     v_diasvigencia   NUMBER (3);
                     v_iconcep17      comisigaranseg.icomanu%TYPE;

                     --NUMBER(15, 2);  20-03

                     -- Bug 10865 - RSC - 04/08/2009 - APR: error en comisiones de adquisición
                     CURSOR cur_comisigaranseg
                     IS
                        SELECT *
                          FROM comisigaranseg
                         WHERE sseguro = psseguro
                           --AND nmovimi = xnmovimi -- Bug 10865
                           AND finiefe <= xfeferec
                           AND ffinpg > xfeferec
                           -- Bug 13515 - 10/03/2010 - RSC - APR - Error en el calculo de comisiones
                           AND cgarant = xcgarant
                           AND itotcom > 0;
                  -- Bug 10865 - RSC - 10/08/2009 - APR: error en comisiones de adquisición
                  BEGIN
                     FOR i IN cur_comisigaranseg
                     LOOP
                        error :=
                           f_difdata (xfeferec,
                                      xfvencim,
                                      3,
                                      3,
                                      v_diasvigencia
                                     );
                        v_iconcep17 := i.icomanu * (v_diasvigencia / 360);

                        IF NVL (v_iconcep17, 0) <> 0
                        THEN
                           error :=
                              pac_adm.f_instmpdetrec (pnrecibo,
                                                      17,
                                                      v_iconcep17,
                                                      xploccoa,
                                                      xcgarant,
                                                      NVL (xnriesgo, 0),
                                                      xctipcoa,
                                                      xcageven,
                                                      xnmovima,
                                                      porcagente,
                                                      psseguro
                                                     );

                           IF error != 0
                           THEN
                              CLOSE cur_detrecibos;

                              RETURN error;
                           END IF;
                        END IF;
                     END LOOP;
                  END;
               ELSE
                  CLOSE cur_detrecibos;

                  RETURN error;
               END IF;

               --BUG9658 -- 02/04/2009 -- JTS

               --TROBEM EL TOTAL DE ICONCEP PER CCONCEP = 29
               --SMF CONCEPTO DE CAMPANYES
               --TROBEM EL TOTAL DE ICONCEP PER CCONCEP = 29
               error :=
                  pac_adm.f_calculo_dtocampanya (psseguro,
                                                 xnriesgo,
                                                 xcgarant,
                                                 xnmovima,
                                                 xfvencim,
                                                 iconcep0,
                                                 pprorata,
                                                 pttabla,
                                                 xidtocam
                                                );

               IF error = 0
               THEN
                  IF NVL (xidtocam, 0) <> 0
                  THEN
                     xidtocam := f_round (xidtocam, pmoneda);
                     error :=
                        pac_adm.f_instmpdetrec (pnrecibo,
                                                29,
                                                xidtocam,
                                                xploccoa,
                                                xcgarant,
                                                NVL (xnriesgo, 0),
                                                xctipcoa,
                                                xcageven,
                                                xnmovima,
                                                porcagente,
                                                psseguro
                                               );

                     IF error != 0
                     THEN
                        CLOSE cur_detrecibos;

                        RETURN error;
                     END IF;
                  END IF;
               ELSE
                  CLOSE cur_detrecibos;

                  RETURN error;
               END IF;

               --TROBEM EL TOTAL DE ICONCEP PER CCONCEP = 21
               BEGIN
                  SELECT   NVL (SUM (iconcep), 0)
                      INTO iconcep21
                      FROM tmp_adm_detrecibos
                     WHERE nrecibo = pnrecibo
                       AND nriesgo = xnriesgo
                       AND cgarant = xcgarant
                       AND nmovima = xnmovima
                       AND cconcep IN (21, 71)               -- LOCAL + CEDIDA
                  GROUP BY nriesgo, cgarant;
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     NULL;
                  WHEN OTHERS
                  THEN
                     CLOSE cur_detrecibos;

                     error := 103512;        -- ERROR AL LLEGIR DE DETRECIBOS
                     RETURN error;
               END;

               -- TROBEM EL CONCEPTE DE LA BONIFICACIÓ DEL REBUT
               BEGIN
                  SELECT   NVL (SUM (iconcep), 0)
                      INTO idto
                      FROM tmp_adm_detrecibos
                     WHERE nrecibo = pnrecibo
                       AND nriesgo = xnriesgo
                       AND cgarant = xcgarant
                       AND nmovima = xnmovima
                       AND cconcep IN (10 + 60)              -- LOCAL + CEDIDA
                  GROUP BY nriesgo, cgarant;
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     NULL;
                  WHEN OTHERS
                  THEN
                     CLOSE cur_detrecibos;

                     error := 103512;        -- ERROR AL LLEGIR DE DETRECIBOS
                     RETURN error;
               END;

               IF pcforpag <> 1 AND iconcep21 <> 0
               THEN
                  -- Si no és anual i és el primer rebut
                  -- necessitem la bonif. anualitzada
                  -- TROBEM EL CONCEPTE DE LA BONIFICACIÓ ANUALITZADA
                  IF pttabla = 'SEG' OR pttabla IS NULL
                  THEN
                     BEGIN
                        SELECT SUM (idtocom * -1)
                          INTO idto21
                          FROM garanseg
                         WHERE (sseguro, nmovimi) IN (
                                                      SELECT sseguro, nmovimi
                                                        FROM tmp_adm_recibos
                                                       WHERE nrecibo =
                                                                      pnrecibo)
                           AND nriesgo = xnriesgo
                           AND cgarant = xcgarant;
                     EXCEPTION
                        WHEN NO_DATA_FOUND
                        THEN
                           NULL;
                        WHEN OTHERS
                        THEN
                           CLOSE cur_detrecibos;

                           error := 107209;    -- ERROR AL LLEGIR DE GARANSEG
                           RETURN error;
                     END;
                  ELSIF pttabla = 'SOL'
                  THEN
                     BEGIN
                        SELECT SUM (idtocom * -1)
                          INTO idto21
                          FROM solgaranseg
                         WHERE (ssolicit) IN (SELECT sseguro
                                                FROM tmp_adm_recibos
                                               WHERE nrecibo = pnrecibo)
                           AND nriesgo = xnriesgo
                           AND cgarant = xcgarant;
                     EXCEPTION
                        WHEN NO_DATA_FOUND
                        THEN
                           NULL;
                        WHEN OTHERS
                        THEN
                           CLOSE cur_detrecibos;

                           error := 107209;    -- ERROR AL LLEGIR DE GARANSEG
                           RETURN error;
                     END;
                  ELSIF pttabla = 'EST'
                  THEN
                     BEGIN
                        SELECT SUM (idtocom * -1)
                          INTO idto21
                          FROM estgaranseg
                         WHERE (sseguro, nmovimi) IN (
                                                      SELECT sseguro, nmovimi
                                                        FROM tmp_adm_recibos
                                                       WHERE nrecibo =
                                                                      pnrecibo)
                           AND nriesgo = xnriesgo
                           AND cgarant = xcgarant;
                     EXCEPTION
                        WHEN NO_DATA_FOUND
                        THEN
                           NULL;
                        WHEN OTHERS
                        THEN
                           CLOSE cur_detrecibos;

                           error := 107209;    -- ERROR AL LLEGIR DE GARANSEG
                           RETURN error;
                     END;
                  END IF;
               ELSE
                  IF pcforpag = 1
                  THEN
                     -- Si és anual coincideix amb la del rebut
                     idto21 := idto;
                  ELSE
                     -- concepte 21 = 0
                     idto21 := 0;
                  END IF;
               END IF;

               -- CALCULEM EL RECARREC PER FRACCIONAMENT (CCONCEP = 8)

               -- LPS (04/08/2008), Modificado el cálculo para el nuevo módulo de impuestos.
               IF pcrecfra = 1 AND pcforpag IS NOT NULL
               THEN
                  xprecarg := NULL;
                  vctipcon := NULL;
                  vnvalcon := NULL;
                  vcfracci := NULL;
                  vcbonifi := NULL;
                  vcrecfra := NULL;
                  oiconcep := NULL;
                  totrecfracc := NULL;
                  error :=
                     f_concepto (8,
                                 xcempres,
                                 xfefecto,
                                 pcforpag,
                                 pcramo,
                                 pcmodali,
                                 pctipseg,
                                 pccolect,
                                 pcactivi,
                                 xcgarant,
                                 vctipcon,
                                 vnvalcon,
                                 vcfracci,
                                 vcbonifi,
                                 vcrecfra,
                                 w_climit,
                                 -- Bug 10864.NMM.01/08/2009.
                                 v_cmonimp,
                                 -- BUG 18423 - LCOL000 - Multimoneda
                                 vcderreg
                                );           -- Bug 0020314 - FAL - 29/11/2011
                  xprecarg :=
                     f_round
                          (NVL (vnvalcon, 0),
                           v_cmonimp,
                           NVL (pac_parametros.f_parempresa_n (xcempres,
                                                               'REDONDEO_SRI'
                                                              ),
                                0
                               )
                          );

                  -- Damos valor al procentaje de recargo para los otros conceptos.
                  IF vctipcon = 4 AND error = 0
                  THEN
                     -- Para impuesto sobre capital (no sobre prima)
                     error :=
                        pac_impuestos.f_calcula_impuestocapital (psseguro,
                                                                 xnmovimi,
                                                                 xnriesgo,
                                                                 pttabla,
                                                                 'CRECFRA',
                                                                 xicapital
                                                                );
                     xicapital := xicapital / pcforpag;
                  -- Parte que corresponde al recibo
                  END IF;

                  IF NVL (vnvalcon, 0) <> 0
                  THEN
                     error :=
                        pac_impuestos.f_calcula_impconcepto (vnvalcon,
                                                             iconcep0,
                                                             iconcep21,
                                                             idto,
                                                             idto21,
                                                             xidtocam,
                                                             xicapital,
                                                             NULL,
                                                             NULL,
                                                             vctipcon,
                                                             1,
                                                             -- Ponemos forpag = 1, ya que es un recibo
                                                             vcfracci,
                                                             vcbonifi,
                                                             vcrecfra,
                                                             oiconcep
                                                                     -- JLB - I - BUG 18423 COjo la moneda del producto
                        ,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             pmoneda
                                                            -- JLB - F - BUG 18423 COjo la moneda del producto
                                                            );
                     totrecfracc := oiconcep;

                     -- Fin LPS (04/08/2008)
                     IF NVL (totrecfracc, 0) <> 0
                     THEN
                        error :=
                           pac_adm.f_instmpdetrec (pnrecibo,
                                                   8,
                                                   totrecfracc,
                                                   xploccoa,
                                                   xcgarant,
                                                   NVL (xnriesgo, 0),
                                                   xctipcoa,
                                                   xcageven,
                                                   xnmovima
                                                  );

                        IF error != 0
                        THEN
                           CLOSE cur_detrecibos;

                           RETURN error;
                        END IF;
                     END IF;
                  END IF;
               END IF;

               BEGIN
                  SELECT NVL (cimpdgs, 0), NVL (cimpips, 0),
                         NVL (cderreg, 0), NVL (cimparb, 0), NVL (cimpfng, 0)
                    INTO xcimpdgs, xcimpips,
                         xcderreg, xcimparb, xcimpfng
                    FROM garanpro
                   WHERE cramo = pcramo
                     AND cmodali = pcmodali
                     AND ccolect = pccolect
                     AND ctipseg = pctipseg
                     AND cgarant = xcgarant
                     AND cactivi = NVL (pcactivi, 0);
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     BEGIN
                        SELECT NVL (cimpdgs, 0), NVL (cimpips, 0),
                               NVL (cderreg, 0), NVL (cimparb, 0),
                               NVL (cimpfng, 0)
                          INTO xcimpdgs, xcimpips,
                               xcderreg, xcimparb,
                               xcimpfng
                          FROM garanpro
                         WHERE cramo = pcramo
                           AND cmodali = pcmodali
                           AND ccolect = pccolect
                           AND ctipseg = pctipseg
                           AND cgarant = xcgarant
                           AND cactivi = 0;
                     EXCEPTION
                        WHEN NO_DATA_FOUND
                        THEN
                           CLOSE cur_detrecibos;

                           error := 104110;  -- PRODUCTE NO TROBAT A GARANPRO
                           RETURN error;
                        WHEN OTHERS
                        THEN
                           CLOSE cur_detrecibos;

                           error := 103503;
                           -- ERROR AL LLEGIR DE LA TAULA GARANPRO
                           RETURN error;
                     END;
                  WHEN OTHERS
                  THEN
                     CLOSE cur_detrecibos;

                     error := 103503; -- ERROR AL LLEGIR DE LA TAULA GARANPRO
                     RETURN error;
               END;

               -- LPS (04/08/2008), Modificado el cálculo para el nuevo módulo de impuestos.
               IF xcimpdgs > 0
               THEN
                  vctipcon := NULL;
                  vnvalcon := NULL;
                  vcfracci := NULL;
                  vcbonifi := NULL;
                  vcrecfra := NULL;
                  oiconcep := NULL;
                  tot_iconcepdgs := NULL;
                  error :=
                     f_concepto (5,
                                 xcempres,
                                 xfefecto,
                                 pcforpag,
                                 pcramo,
                                 pcmodali,
                                 pctipseg,
                                 pccolect,
                                 pcactivi,
                                 xcgarant,
                                 vctipcon,
                                 vnvalcon,
                                 vcfracci,
                                 vcbonifi,
                                 vcrecfra,
                                 w_climit,
                                 -- Bug 10864.NMM.01/08/2009.
                                 v_cmonimp,
                                 -- BUG 18423 - LCOL000 - Multimoneda
                                 vcderreg
                                );           -- Bug 0020314 - FAL - 29/11/2011
                  taxadgs :=
                     f_round
                          (NVL (vnvalcon, 0),
                           v_cmonimp,
                           NVL (pac_parametros.f_parempresa_n (xcempres,
                                                               'REDONDEO_SRI'
                                                              ),
                                0
                               )
                          );

                  IF vctipcon = 4 AND error = 0
                  THEN
                     -- Para impuesto sobre capital (no sobre prima)
                     error :=
                        pac_impuestos.f_calcula_impuestocapital (psseguro,
                                                                 xnmovimi,
                                                                 xnriesgo,
                                                                 pttabla,
                                                                 'CIMPDGS',
                                                                 xicapital
                                                                );
                     xicapital := xicapital / pcforpag;
                  -- Parte que corresponde al recibo
                  END IF;

                  IF error <> 0
                  THEN
                     CLOSE cur_detrecibos;

                     RETURN error;
                  END IF;

                  IF NVL (taxadgs, 0) <> 0
                  THEN
                     error :=
                        pac_impuestos.f_calcula_impconcepto (vnvalcon,
                                                             iconcep0,
                                                             iconcep21,
                                                             idto,
                                                             idto21,
                                                             xidtocam,
                                                             xicapital,
                                                             NULL,
                                                             xprecarg,
                                                             vctipcon,
                                                             1,
                                                             -- Ponemos forpag = 1, ya que es un recibo
                                                             vcfracci,
                                                             vcbonifi,
                                                             vcrecfra,
                                                             oiconcep
                                                                     -- JLB - I - BUG 18423 COjo la moneda del producto
                        ,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             pmoneda
                                                            -- JLB - F - BUG 18423 COjo la moneda del producto
                                                            );
                     tot_iconcepdgs := NVL (oiconcep, 0);
                  ELSE
                     tot_iconcepdgs := 0;
                  END IF;

                  -- Fin LPS (04/08/2008)

                  -- Miramos si aun hay que calcular la DGS prorrateada.
                  BEGIN
                     SELECT sseguro
                       INTO dummy
                       FROM segcleafrac
                      WHERE sseguro = psseguro;

                     IF ptipomovimiento = 21
                     THEN
                        DELETE FROM segcleafrac
                              WHERE sseguro = psseguro;
                     -- LPS (04/08/2008). Comentado, ya se calcula arriba.
                     /*ELSE
                     IF vctipcon = 3
                     THEN
                        tot_iconcepdgs :=
                           f_round (  NVL (iconcep0, 0)
                                    * (NVL (vnvalcon, 0) / 100),
                                    pmoneda
                                   );
                     END IF;*/
                     END IF;
                  EXCEPTION
                     WHEN NO_DATA_FOUND
                     THEN
                        NULL;
                     WHEN OTHERS
                     THEN
                        CLOSE cur_detrecibos;

                        error := 101919;
                        RETURN error;
                  END;
               ELSE
                  tot_iconcepdgs := 0;
               END IF;

               -- Fin LPS (04/09/2008)

               -- LPS (04/09/2008)
               IF xcimpips > 0
               THEN
                  vctipcon := NULL;
                  vnvalcon := NULL;
                  vcfracci := NULL;
                  vcbonifi := NULL;
                  vcrecfra := NULL;
                  oiconcep := NULL;
                  tot_iconcepips := NULL;
                  vnerror :=
                     f_concepto (4,
                                 xcempres,
                                 xfefecto,
                                 pcforpag,
                                 pcramo,
                                 pcmodali,
                                 pctipseg,
                                 pccolect,
                                 pcactivi,
                                 xcgarant,
                                 vctipcon,
                                 vnvalcon,
                                 vcfracci,
                                 vcbonifi,
                                 vcrecfra,
                                 w_climit,
                                 -- Bug 10864.NMM.01/08/2009.
                                 v_cmonimp,
                                 -- BUG 18423 - LCOL000 - Multimoneda
                                 vcderreg
                                );           -- Bug 0020314 - FAL - 29/11/2011
                  taxaips :=
                     f_round
                          (NVL (vnvalcon, 0),
                           v_cmonimp,
                           NVL (pac_parametros.f_parempresa_n (xcempres,
                                                               'REDONDEO_SRI'
                                                              ),
                                0
                               )
                          );

                  IF vctipcon = 4 AND error = 0
                  THEN
                     -- Para impuesto sobre capital (no sobre prima)
                     error :=
                        pac_impuestos.f_calcula_impuestocapital (psseguro,
                                                                 xnmovimi,
                                                                 xnriesgo,
                                                                 'TMP',
                                                                 'CIMPIPS',
                                                                 xicapital
                                                                );
                     xicapital := xicapital / pcforpag;
                  -- Parte que corresponde al recibo
                  END IF;

                  IF vnerror <> 0
                  THEN
                     CLOSE cur_detrecibos;

                     RETURN vnerror;
                  END IF;

                  IF NVL (taxaips, 0) <> 0
                  THEN
                     error :=
                        pac_impuestos.f_calcula_impconcepto (vnvalcon,
                                                             iconcep0,
                                                             iconcep21,
                                                             idto,
                                                             idto21,
                                                             xidtocam,
                                                             xicapital,
                                                             NULL,
                                                             xprecarg,
                                                             vctipcon,
                                                             1,
                                                             -- Ponemos forpag = 1, ya que es un recibo
                                                             vcfracci,
                                                             vcbonifi,
                                                             vcrecfra,
                                                             oiconcep
                                                                     -- JLB - I - BUG 18423 COjo la moneda del producto
                        ,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             pmoneda
                                                            -- JLB - F - BUG 18423 COjo la moneda del producto
                                                            );
                     tot_iconcepips := NVL (oiconcep, 0);
                  ELSE
                     tot_iconcepips := 0;
                  END IF;
               -- Fin LPS (04/08/2008)
               ELSE
                  tot_iconcepips := 0;
               END IF;

               -- Fin LPS (04/09/2008)

               -- BUG 9422 - 14/10/2009 - LCF - Se comenta
               /*IF xcderreg > 0 THEN
                  BEGIN
                     SELECT iatribu
                       INTO taxaderreg
                       FROM tarifas
                      WHERE ctarifa = 0
                        AND ncolumn = 1
                        AND nfila = xcderreg;

                     IF (NVL(f_parinstalacion_n('DER_REG'), 0) = 0) THEN
                        --adso
                        tot_iconcepderreg := f_round(NVL(iconcep0, 0) * taxaderreg, pmoneda);
                     ELSE
                        IF (f_control_cderreg(psseguro, xnriesgo, xcgarant, xfefecto, xnmovima,
                                              pttabla) = 0) THEN
                           tot_iconcepderreg := f_round(NVL(iconcep0, 0) *(pcforpag / 12),
                                                        pmoneda);
                        ELSE
                           tot_iconcepderreg := 0;
                        END IF;
                     END IF;
                  --adso
                  EXCEPTION
                     WHEN NO_DATA_FOUND THEN
                        CLOSE cur_detrecibos;

                        error := 103844;   -- TARIFA NO TROBADA A TARIFAS
                        RETURN error;
                     WHEN OTHERS THEN
                        CLOSE cur_detrecibos;

                        error := 103843;   -- ERROR AL LLEGIR DE TARIFAS
                        RETURN error;
                  END;
               ELSE
                  tot_iconcepderreg := 0;
               END IF; */
               -- Fin BUG 9422 - 14/10/2009 - LCF

               -- LPS (04/09/2008)
               IF xcimparb > 0
               THEN
                  vctipcon := NULL;
                  vnvalcon := NULL;
                  vcfracci := NULL;
                  vcbonifi := NULL;
                  vcrecfra := NULL;
                  oiconcep := NULL;
                  tot_iconceparb := NULL;
                  vnerror :=
                     f_concepto (6,
                                 xcempres,
                                 xfefecto,
                                 pcforpag,
                                 pcramo,
                                 pcmodali,
                                 pctipseg,
                                 pccolect,
                                 pcactivi,
                                 xcgarant,
                                 vctipcon,
                                 vnvalcon,
                                 vcfracci,
                                 vcbonifi,
                                 vcrecfra,
                                 w_climit,
                                 -- Bug 10864.NMM.01/08/2009.
                                 v_cmonimp,
                                 -- BUG 18423 - LCOL000 - Multimoneda
                                 vcderreg
                                );           -- Bug 0020314 - FAL - 29/11/2011
                  taxaarb :=
                     f_round
                          (NVL (vnvalcon, 0),
                           v_cmonimp,
                           NVL (pac_parametros.f_parempresa_n (xcempres,
                                                               'REDONDEO_SRI'
                                                              ),
                                0
                               )
                          );

                  IF vctipcon = 4 AND vnerror = 0
                  THEN
                     -- Para impuesto sobre capital (no sobre prima)
                     vnerror :=
                        pac_impuestos.f_calcula_impuestocapital (psseguro,
                                                                 xnmovimi,
                                                                 xnriesgo,
                                                                 pttabla,
                                                                 'CIMPARB',
                                                                 xicapital
                                                                );
                     xicapital := xicapital / pcforpag;
                  -- Parte que corresponde al recibo
                  END IF;

                  IF vnerror <> 0
                  THEN
                     CLOSE cur_detrecibos;

                     RETURN vnerror;
                  END IF;

                  IF NVL (taxaarb, 0) <> 0
                  THEN
                     error :=
                        pac_impuestos.f_calcula_impconcepto (vnvalcon,
                                                             iconcep0,
                                                             iconcep21,
                                                             idto,
                                                             idto21,
                                                             xidtocam,
                                                             xicapital,
                                                             NULL,
                                                             xprecarg,
                                                             vctipcon,
                                                             1,
                                                             -- Ponemos forpag = 1, ya que es un recibo
                                                             vcfracci,
                                                             vcbonifi,
                                                             vcrecfra,
                                                             oiconcep
                                                                     -- JLB - I - BUG 18423 COjo la moneda del producto
                        ,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             pmoneda
                                                            -- JLB - F - BUG 18423 COjo la moneda del producto
                                                            );
                     tot_iconceparb := NVL (oiconcep, 0);
                  ELSE
                     tot_iconceparb := 0;
                  END IF;
               ELSE
                  tot_iconceparb := 0;
               END IF;

               -- Fin LPS (04/09/2008)

               -- LPS (04/09/2008)
               IF xcimpfng > 0
               THEN
                  vctipcon := NULL;
                  vnvalcon := NULL;
                  vcfracci := NULL;
                  vcbonifi := NULL;
                  vcrecfra := NULL;
                  oiconcep := NULL;
                  tot_iconcepfng := NULL;
                  vnerror :=
                     f_concepto (7,
                                 xcempres,
                                 xfefecto,
                                 pcforpag,
                                 pcramo,
                                 pcmodali,
                                 pctipseg,
                                 pccolect,
                                 pcactivi,
                                 xcgarant,
                                 vctipcon,
                                 vnvalcon,
                                 vcfracci,
                                 vcbonifi,
                                 vcrecfra,
                                 w_climit,
                                 -- Bug 10864.NMM.01/08/2009.
                                 v_cmonimp,
                                 -- BUG 18423 - LCOL000 - Multimoneda
                                 vcderreg
                                );           -- Bug 0020314 - FAL - 29/11/2011
                  taxafng := NVL (vnvalcon, 0);

                  IF vctipcon = 4 AND vnerror = 0
                  THEN
                     -- Para impuesto sobre capital (no sobre prima)
                     vnerror :=
                        pac_impuestos.f_calcula_impuestocapital (psseguro,
                                                                 xnmovimi,
                                                                 xnriesgo,
                                                                 pttabla,
                                                                 'CIMPFNG',
                                                                 xicapital
                                                                );
                     xicapital := xicapital / pcforpag;
                  -- Parte que corresponde al recibo
                  END IF;

                  IF vnerror <> 0
                  THEN
                     CLOSE cur_detrecibos;

                     RETURN vnerror;
                  END IF;

                  IF NVL (taxafng, 0) <> 0
                  THEN
                     error :=
                        pac_impuestos.f_calcula_impconcepto (vnvalcon,
                                                             iconcep0,
                                                             iconcep21,
                                                             idto,
                                                             idto21,
                                                             xidtocam,
                                                             xicapital,
                                                             NULL,
                                                             xprecarg,
                                                             vctipcon,
                                                             1,
                                                             -- Ponemos forpag = 1, ya que es un recibo
                                                             vcfracci,
                                                             vcbonifi,
                                                             vcrecfra,
                                                             oiconcep
                                                                     -- JLB - I - BUG 18423 COjo la moneda del producto
                        ,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             pmoneda
                                                            -- JLB - F - BUG 18423 COjo la moneda del producto
                                                            );
                     tot_iconcepfng := NVL (oiconcep, 0);
                  ELSE
                     tot_iconcepfng := 0;
                  END IF;
               ELSE
                  tot_iconcepfng := 0;
               END IF;

               -- Fin LPS (04/09/2008)
               IF NVL (tot_iconcepdgs, 0) <> 0 AND taxadgs IS NOT NULL
               THEN
                  tot_iconcepdgs :=
                     f_round
                         (tot_iconcepdgs,
                          pmoneda,
                          NVL (pac_parametros.f_parempresa_n (xcempres,
                                                              'REDONDEO_SRI'
                                                             ),
                               0
                              )
                         );

                  IF NVL (tot_iconcepdgs, 0) <> 0
                  THEN
                     error :=
                        pac_adm.f_instmpdetrec (pnrecibo,
                                                5,
                                                tot_iconcepdgs,
                                                xploccoa,
                                                xcgarant,
                                                NVL (xnriesgo, 0),
                                                xctipcoa,
                                                xcageven,
                                                xnmovima
                                               );

                     IF error != 0
                     THEN
                        CLOSE cur_detrecibos;

                        RETURN error;
                     END IF;
                  END IF;
               END IF;

               IF NVL (iconcep0, 0) <> 0
               THEN
                  --JRH Sólo calculamos el ISI para prima <>0
                  --JRH Solución temporal para el ISI. Lo calculamos y substiruimosel valor del IPS por el ISI.
                  DECLARE
                     isiform      NUMBER;
                     vsproduc     seguros.sproduc%TYPE;
                     --                      vsproduc       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
                     vcactivi     seguros.cactivi%TYPE;
                     --                      vcactivi       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
                     vcapgaran    estgaranseg.cgarant%TYPE;
                     --                      vcapgaran      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
                     a            NUMBER;
                     vfefecto     tmp_adm_recibos.fefecto%TYPE;
                     --                      vfefecto       DATE; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
                     importeisi   NUMBER;
                     wicapital    estgaranseg.icapital%TYPE;
                     --                      wicapital      NUMBER;   -- DRA 27-8-08: bug mantis 7372 --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
                     xftarifa     garanseg.ftarifa%TYPE;
                  --                      xftarifa       DATE;   -- jramiro 27-8-08: bug mantis 7372 --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
                  BEGIN
                     paso := 1;

                     SELECT sproduc, cactivi
                       INTO vsproduc, vcactivi
                       FROM seguros
                      WHERE sseguro = psseguro;

                     paso := 2;
                     error :=
                        f_pargaranpro (pcramo,
                                       pcmodali,
                                       pctipseg,
                                       pccolect,
                                       vcactivi,
                                       xcgarant,
                                       'ISI_FORMULA',
                                       isiform
                                      );
                     paso := 3;
                     isiform := NVL (isiform, 0);

                     IF isiform <> 0
                     THEN
                        paso := 4;

                        IF pttabla = 'SEG' OR pttabla IS NULL
                        THEN
                           --XVM-Bug 9028-28/07/09
                           BEGIN
                              SELECT g.icapital, g.ftarifa
                                INTO xicapital, xftarifa
                                FROM garanseg g
                               WHERE g.sseguro = psseguro
                                 AND g.nriesgo = NVL (pnriesgo, 1)
                                 AND g.cgarant = xcgarant
                                 AND g.nmovimi =
                                        (SELECT MAX (g1.nmovimi)
                                           FROM garanseg g1
                                          WHERE g1.sseguro = g.sseguro
                                            AND g1.nriesgo = g.nriesgo
                                            AND g1.cgarant = g.cgarant);
                           EXCEPTION
                              WHEN NO_DATA_FOUND
                              THEN
                                 CLOSE cur_detrecibos;

                                 RETURN 103500;
                           END;

                           paso := 5;

                           SELECT cgarant, icapital
                             INTO vcapgaran, wicapital
                             FROM garanseg
                            WHERE sseguro = psseguro
                              AND f_pargaranpro_v (pcramo,
                                                   pcmodali,
                                                   pctipseg,
                                                   pccolect,
                                                   vcactivi,
                                                   cgarant,
                                                   'TIPO'
                                                  ) = 5
                              AND ffinefe IS NULL;

                           paso := 6;
                        ELSIF pttabla = 'SOL'
                        THEN
                           BEGIN
                              SELECT g.icapital, f_sysdate
                                INTO xicapital, xftarifa
                                FROM solgaranseg g
                               WHERE g.ssolicit = psseguro
                                 AND g.nriesgo = NVL (pnriesgo, 1)
                                 AND g.cgarant = xcgarant;
                           EXCEPTION
                              WHEN NO_DATA_FOUND
                              THEN
                                 CLOSE cur_detrecibos;

                                 RETURN 103500;
                           END;

                           paso := 5;

                           SELECT cgarant, icapital
                             INTO vcapgaran, wicapital
                             FROM solgaranseg
                            WHERE ssolicit = psseguro
                              AND f_pargaranpro_v (pcramo,
                                                   pcmodali,
                                                   pctipseg,
                                                   pccolect,
                                                   vcactivi,
                                                   cgarant,
                                                   'TIPO'
                                                  ) = 5;

                           paso := 6;
                        ELSIF pttabla = 'EST'
                        THEN
                           BEGIN
                              SELECT g.icapital, g.ftarifa
                                INTO xicapital, xftarifa
                                FROM estgaranseg g
                               WHERE g.sseguro = psseguro
                                 AND g.nriesgo = NVL (pnriesgo, 1)
                                 AND g.cgarant = xcgarant
                                 AND g.nmovimi =
                                        (SELECT MAX (g1.nmovimi)
                                           FROM estgaranseg g1
                                          WHERE g1.sseguro = g.sseguro
                                            AND g1.nriesgo = g.nriesgo
                                            AND g1.cgarant = g.cgarant);
                           EXCEPTION
                              WHEN NO_DATA_FOUND
                              THEN
                                 CLOSE cur_detrecibos;

                                 RETURN 103500;
                           END;

                           paso := 5;

                           SELECT cgarant, icapital
                             INTO vcapgaran, wicapital
                             FROM estgaranseg
                            WHERE sseguro = psseguro
                              AND f_pargaranpro_v (pcramo,
                                                   pcmodali,
                                                   pctipseg,
                                                   pccolect,
                                                   vcactivi,
                                                   cgarant,
                                                   'TIPO'
                                                  ) = 5
                              AND ffinefe IS NULL;

                           paso := 6;
                        END IF;

                        SELECT fefecto
                          INTO vfefecto
                          FROM tmp_adm_recibos
                         WHERE nrecibo = pnrecibo;

                        paso := 7;
                        a :=
                           pac_calculo_formulas.calc_formul (vfefecto,
                                                             vsproduc,
                                                             vcactivi,
                                                             vcapgaran,
                                                             NVL (pnriesgo, 1),
                                                             psseguro,
                                                             1000 + isiform,
                                                             importeisi,
                                                             NULL,
                                                             NULL,
                                                             2,
                                                             xftarifa,
                                                             'R'
                                                            );
                        tot_iconcepips := NVL (importeisi, tot_iconcepips);
                        paso := 8;

                        -- DRA 27-8-08: bug mantis 7372
                        IF NVL (xicapital, 0) <> 0 AND NVL (importeisi, 0) = 0
                        THEN
                           CLOSE cur_detrecibos;

                           p_tab_error
                                 (f_sysdate,
                                  f_user,
                                  'PAC_ADM.impuestos recibos',
                                  paso,
                                     'error al insertar impuestos. pmodo = '
                                  || pmodo,
                                     '(sseguro = '
                                  || psseguro
                                  || ') - '
                                  || '(xcgarant = '
                                  || xcgarant
                                  || ') - '
                                  || '(vcapgaran = '
                                  || vcapgaran
                                  || ') - '
                                  || '(isiform = '
                                  || isiform
                                  || ') - '
                                  || '(vfefecto = '
                                  || vfefecto
                                  || ') - '
                                  || '(pnriesgo = '
                                  || pnriesgo
                                  || ') - '
                                  || '(vcactivi = '
                                  || vcactivi
                                  || ') - '
                                  || '(vsproduc = '
                                  || vsproduc
                                  || ') - '
                                  || '(wicapital = '
                                  || wicapital
                                  || ') - '
                                  || '(xicapital = '
                                  || xicapital
                                  || ') - '
                                  || '(pnrecibo = '
                                  || pnrecibo
                                  || ') - '
                                 );
                           RETURN 180880;
                        END IF;

                        paso := 9;

                        SELECT pimpips
                          INTO taxaips
                          FROM impuestos
                         WHERE cimpues = 1;

                        --JRH 11/12 Bug 8064: Problemas con el redondeo de los recibos de PPJ
                        --Restamos a la prima el impuesto directamente del recibo
                        IF NVL (tot_iconcepips, 0) <> 0
                           AND taxaips IS NOT NULL
                        THEN
                           tot_iconcepips :=
                              f_round
                                 (tot_iconcepips,
                                  pmoneda,
                                  NVL
                                     (pac_parametros.f_parempresa_n
                                                               (xcempres,
                                                                'REDONDEO_SRI'
                                                               ),
                                      0
                                     )
                                 );

                           --Nos aseguramos, vamos por PK
                           UPDATE tmp_adm_detrecibos
                              SET iconcep =
                                     f_round
                                        (iconcep - tot_iconcepips,
                                         pmoneda,
                                         NVL
                                            (pac_parametros.f_parempresa_n
                                                               (xcempres,
                                                                'REDONDEO_SRI'
                                                               ),
                                             0
                                            )
                                        )
                            WHERE nrecibo = pnrecibo
                              AND cconcep = 0                          --prima
                              AND cgarant = xcgarant
                              AND nriesgo = NVL (xnriesgo, 0);

                           SELECT iconcep
                             INTO iconcep0
                             -- JRH Bug 9011  actualizo iconcep0 parra el calculo de la comision.
                           FROM   tmp_adm_detrecibos
                            WHERE nrecibo = pnrecibo
                              AND cconcep = 0                          --prima
                              AND cgarant = xcgarant
                              AND nriesgo = NVL (xnriesgo, 0);
                        END IF;
                     END IF;
                  EXCEPTION
                     WHEN OTHERS
                     THEN
                        CLOSE cur_detrecibos;

                        p_tab_error
                                 (f_sysdate,
                                  f_user,
                                  'PAC_ADM.impuestos recibos',
                                  paso,
                                     'error al insertar impuestos. pmodo = '
                                  || pmodo,
                                  SQLERRM || ' (sseguro = ' || psseguro || ')'
                                 );
                        RETURN 180879;
                  END;
               ELSE
                  tot_iconcepips := 0;
               END IF;

               -- JRH
               IF NVL (tot_iconcepips, 0) <> 0 AND taxaips IS NOT NULL
               THEN
                  tot_iconcepips :=
                     f_round
                         (tot_iconcepips,
                          pmoneda,
                          NVL (pac_parametros.f_parempresa_n (xcempres,
                                                              'REDONDEO_SRI'
                                                             ),
                               0
                              )
                         );

                  IF NVL (tot_iconcepips, 0) <> 0
                  THEN
                     error :=
                        pac_adm.f_instmpdetrec (pnrecibo,
                                                4,
                                                tot_iconcepips,
                                                xploccoa,
                                                xcgarant,
                                                NVL (xnriesgo, 0),
                                                xctipcoa,
                                                xcageven,
                                                xnmovima
                                               );

                     IF error != 0
                     THEN
                        CLOSE cur_detrecibos;

                        RETURN error;
                     END IF;
                  END IF;
               END IF;

               IF NVL (tot_iconcepderreg, 0) <> 0 AND taxaderreg IS NOT NULL
               THEN
                  tot_iconcepderreg :=
                     f_round
                         (tot_iconcepderreg,
                          pmoneda,
                          NVL (pac_parametros.f_parempresa_n (xcempres,
                                                              'REDONDEO_SRI'
                                                             ),
                               0
                              )
                         );

                  IF NVL (tot_iconcepderreg, 0) <> 0
                  THEN
                     error :=
                        pac_adm.f_instmpdetrec (pnrecibo,
                                                14,
                                                tot_iconcepderreg,
                                                -- 26755 AVT 22/04/2013 pels conceptes que el 100% va al concepte normal no fem el concepte de coaseguro (cc: 14 i 86)
                                                -- xploccoa
                                                100,
                                                xcgarant,
                                                NVL (xnriesgo, 0),
                                                xctipcoa,
                                                xcageven,
                                                xnmovima
                                               );

                     IF error != 0
                     THEN
                        CLOSE cur_detrecibos;

                        RETURN error;
                     END IF;
                  END IF;
               END IF;

               IF NVL (tot_iconceparb, 0) <> 0 AND taxaarb IS NOT NULL
               THEN
                  tot_iconceparb :=
                     f_round
                         (tot_iconceparb,
                          pmoneda,
                          NVL (pac_parametros.f_parempresa_n (xcempres,
                                                              'REDONDEO_SRI'
                                                             ),
                               0
                              )
                         );

                  IF NVL (tot_iconceparb, 0) <> 0
                  THEN
                     error :=
                        pac_adm.f_instmpdetrec (pnrecibo,
                                                6,
                                                tot_iconceparb,
                                                xploccoa,
                                                xcgarant,
                                                NVL (xnriesgo, 0),
                                                xctipcoa,
                                                xcageven,
                                                xnmovima
                                               );

                     IF error != 0
                     THEN
                        CLOSE cur_detrecibos;

                        RETURN error;
                     END IF;
                  END IF;
               END IF;

               IF NVL (tot_iconcepfng, 0) <> 0 AND taxafng IS NOT NULL
               THEN
                  tot_iconcepfng :=
                     f_round
                         (tot_iconcepfng,
                          pmoneda,
                          NVL (pac_parametros.f_parempresa_n (xcempres,
                                                              'REDONDEO_SRI'
                                                             ),
                               0
                              )
                         );

                  IF NVL (tot_iconcepfng, 0) <> 0
                  THEN
                     error :=
                        pac_adm.f_instmpdetrec (pnrecibo,
                                                7,
                                                tot_iconcepfng,
                                                xploccoa,
                                                xcgarant,
                                                NVL (xnriesgo, 0),
                                                xctipcoa,
                                                xcageven,
                                                xnmovima
                                               );

                     IF error != 0
                     THEN
                        CLOSE cur_detrecibos;

                        RETURN error;
                     END IF;
                  END IF;
               END IF;

               --CALCUL COMISIONS I RETENCIONS (MODE 'R': REAL)
               --SI SE TRATA DE UN COASEGURO ACEPTADO. PUEDE PASAR QUE NOSOTROS PAGUEMOS DIRECTAMENTE AL
               --AGENTE CON LO QUE PCOMCOA SERA NULO, Y DEBEREMOS IR A BUSCAR LOS PORCENTAJES POR P_FCOMISI.
               --SINO PCOMCOA SERA DIFERENTE A NULO, Y TENDRA EL PORCENTAJE A PAGAR A LA OTRA COMPAÑIA Y LA
               --COMISION Y RETENCIO EN VDETRECIBOS SERA 0.
               IF xctipcoa = 8 OR xctipcoa = 9
               THEN
                  BEGIN
                     SELECT pcomcoa
                       INTO xpcomcoa
                       FROM coacedido
                      WHERE sseguro = psseguro AND ncuacoa = xncuacoa;
                  EXCEPTION
                     WHEN NO_DATA_FOUND
                     THEN
                        -- 23183 AVT 01/11/2012
                        xpcomcoa := NULL;
                     WHEN OTHERS
                     THEN
                        RETURN 105582; -- ERROR AL LEER DE LA TABLA COACEDIDO
                  END;

                  IF xpcomcoa IS NULL
                  THEN
                     porcagente := pcomisagente;
                     porragente := pretenagente;
                  ELSE
                     porcagente := 0;
                     porragente := 0;
                  END IF;
               ELSE
                  porcagente := pcomisagente;
                  porragente := pretenagente;
               END IF;

               --
               -- Calculo de comisiones
               --
               IF xccalcom = 1
               THEN
                  -- Sobre prima
                  error :=
                     f_pcomisi (psseguro,
                                pcmodcom,
                                f_sysdate,
                                porcagente,
                                porragente,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                xcgarant,
                                pttabla,
                                pfuncion
                               );

                  IF error <> 0
                  THEN
                     RETURN error;
                  END IF;
               END IF;

               comis_calc :=
                        f_round (NVL (iconcep0, 0) * porcagente / 100,
                                 pmoneda);

               IF NVL (comis_calc, 0) <> 0 AND NVL (porcagente, 0) <> 0
               THEN
                  --INSERTEM LA COMISIO
                  error :=
                     pac_adm.f_instmpdetrec (pnrecibo,
                                             11,
                                             comis_calc,
                                             xploccoa,
                                             xcgarant,
                                             NVL (xnriesgo, 0),
                                             xctipcoa,
                                             xcageven,
                                             xnmovima,
                                             porcagente,
                                             psseguro
                                            );

                  IF error != 0
                  THEN
                     CLOSE cur_detrecibos;

                     RETURN error;
                  END IF;

                  reten_calc :=
                         f_round (((comis_calc * porragente) / 100), pmoneda);

                  IF NVL (reten_calc, 0) <> 0
                  THEN
                     -- INSERTEM LA RETENCIO
                     error :=
                        pac_adm.f_instmpdetrec (pnrecibo,
                                                12,
                                                reten_calc,
                                                xploccoa,
                                                xcgarant,
                                                NVL (xnriesgo, 0),
                                                xctipcoa,
                                                xcageven,
                                                xnmovima,
                                                porcagente,
                                                psseguro
                                               );

                     IF error != 0
                     THEN
                        CLOSE cur_detrecibos;

                        RETURN error;
                     END IF;
                  END IF;
               END IF;

               --CALCUL COMISIO I RETENCIO DEVENGADES(CCONCEP = 15 I 16)(MODE 'R' : REAL)
               --COMIS_CALC := ROUND(((COMIS_CALC * PORCAGENTE) / 100), 0);
               comis_calc :=
                       f_round (NVL (iconcep21, 0) * porcagente / 100,
                                pmoneda);

               IF NVL (comis_calc, 0) <> 0 AND NVL (porcagente, 0) <> 0
               THEN
                  --INSERTEM LA COMISIO DEVENGADA
                  error :=
                     pac_adm.f_instmpdetrec (pnrecibo,
                                             15,
                                             comis_calc,
                                             xploccoa,
                                             xcgarant,
                                             NVL (xnriesgo, 0),
                                             xctipcoa,
                                             xcageven,
                                             xnmovima,
                                             porcagente,
                                             psseguro
                                            );

                  IF error != 0
                  THEN
                     CLOSE cur_detrecibos;

                     RETURN error;
                  END IF;

                  reten_calc :=
                         f_round (((comis_calc * porragente) / 100), pmoneda);

                  IF NVL (reten_calc, 0) <> 0
                  THEN
                     -- INSERTEM LA RETENCIO DEVENGADA
                     error :=
                        pac_adm.f_instmpdetrec (pnrecibo,
                                                16,
                                                reten_calc,
                                                xploccoa,
                                                xcgarant,
                                                NVL (xnriesgo, 0),
                                                xctipcoa,
                                                xcageven,
                                                xnmovima,
                                                porcagente,
                                                psseguro
                                               );

                     IF error != 0
                     THEN
                        CLOSE cur_detrecibos;

                        RETURN error;
                     END IF;
                  END IF;
               END IF;

               IF error != 0
               THEN
                  CLOSE cur_detrecibos;

                  RETURN error;
               END IF;
            END IF;               -- IF DE SELECCIO DELS TIPUS 00, 01, 21 I 22

            FETCH cur_detrecibos
             INTO xnriesgo, xcgarant, xcageven, xnmovima;
         END LOOP;

         CLOSE cur_detrecibos;

         RETURN 0;
      ELSE
         RETURN 101901;           -- PAS INCORRECTE DE PARÀMETRES A LA FUNCIÓ
      END IF;
   -- BUG -21546_108724- 08/02/2012 - JLTS - Cierre de posibles cursores abiertos, se adiciona EXCEPTION
   EXCEPTION
      WHEN OTHERS
      THEN
         IF cur_detrecibos%ISOPEN
         THEN
            CLOSE cur_detrecibos;
         END IF;

         RETURN 140999;
   END f_imprecibos;

   FUNCTION f_calculo_dtocampanya (
      psseguro   IN       NUMBER,
      pnriesgo   IN       NUMBER,
      pcgarant   IN       NUMBER,
      pnmovima   IN       NUMBER,
      pfefecto   IN       DATE,
      piprinet   IN       NUMBER,
      pprorata   IN       NUMBER,
      pttabla    IN       VARCHAR2,
      pidtocam   OUT      NUMBER
   )
      RETURN NUMBER
   IS
      /********************************************************************
        Calcula el dato a una campaña aplicada a una
       garantia
      Se añade un nuevo parametro a la llamada a f_duracion_campanya
      *********************************************************************/
      vfefecto     movseguro.fefecto%TYPE;
      --       vfefecto       DATE; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      vcactivi     seguros.cactivi%TYPE;
      --       vcactivi       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      vcforpag     NUMBER;
      vccampanya   NUMBER;
      vnversio     NUMBER;
      vsproduc     seguros.sproduc%TYPE;
      --       vsproduc       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      --
      vmeses       NUMBER;
      vmesdurac    NUMBER;
      num_err      NUMBER;
      vx_nmovimi   NUMBER;
      v_iprianu    garanseg.nversio%TYPE;
      --       v_iprianu      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      vx_iprinet   NUMBER;

      --/*funcion añadida para mirar las campanya del movimiento anterior*/
      FUNCTION f_moviantgar (
         psseguro   IN   NUMBER,
         pnriesgo   IN   NUMBER,
         pcgarant   IN   NUMBER,
         pnmovima   IN   NUMBER,
         pttabla    IN   VARCHAR2
      )
         RETURN NUMBER
      IS
         v_nmovimi   garanseg.nmovimi%TYPE;
      --          v_nmovimi      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      BEGIN
         IF pttabla = 'SEG' OR pttabla IS NULL
         THEN
            SELECT MAX (nmovimi)
              INTO v_nmovimi
              FROM garanseg
             WHERE sseguro = psseguro
               AND nriesgo = pnriesgo
               AND cgarant = pcgarant
               AND nmovima = pnmovima
               AND nmovimi <
                      (SELECT nmovimi
                         FROM garanseg
                        WHERE sseguro = psseguro
                          AND nriesgo = pnriesgo
                          AND cgarant = pcgarant
                          AND nmovima = pnmovima
                          AND ffinefe IS NULL);

            RETURN v_nmovimi;
         ELSIF pttabla = 'SOL'
         THEN
            SELECT NULL
              INTO v_nmovimi
              FROM solgaranseg
             WHERE ssolicit = psseguro
               AND nriesgo = pnriesgo
               AND cgarant = pcgarant;

            RETURN v_nmovimi;
         ELSIF pttabla = 'EST'
         THEN
            SELECT MAX (nmovimi)
              INTO v_nmovimi
              FROM estgaranseg
             WHERE sseguro = psseguro
               AND nriesgo = pnriesgo
               AND cgarant = pcgarant
               AND nmovima = pnmovima
               AND nmovimi <
                      (SELECT nmovimi
                         FROM estgaranseg
                        WHERE sseguro = psseguro
                          AND nriesgo = pnriesgo
                          AND cgarant = pcgarant
                          AND nmovima = pnmovima
                          AND ffinefe IS NULL);

            RETURN v_nmovimi;
         END IF;
      END;
   --
   BEGIN
      --buscamos los datos del seguro
      IF pttabla = 'SEG' OR pttabla IS NULL
      THEN
         --XVM-BUG9028-28/07/09
         BEGIN
            SELECT s.sproduc,
                   pac_seguros.ff_get_actividad (s.sseguro, pnriesgo),
                   DECODE (s.cforpag, 0, 1, s.cforpag), g.ccampanya,
                   g.nversio, g.iprianu
              INTO vsproduc,
                   vcactivi,
                   vcforpag, vccampanya,
                   vnversio, v_iprianu
              FROM seguros s, garanseg g, detcampanya d
             WHERE s.sseguro = psseguro
               AND g.sseguro = s.sseguro
               AND g.cgarant = pcgarant
               AND g.nmovima = pnmovima
               AND g.ffinefe IS NULL
               AND g.nriesgo = pnriesgo
               AND d.ccampanya = g.ccampanya
               AND d.nversio = g.nversio
               AND d.sproduc = s.sproduc
               AND d.cactivi =
                           pac_seguros.ff_get_actividad (s.sseguro, g.nriesgo)
               AND d.cgarant = g.cgarant
               AND d.caplidto = 2;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               BEGIN
                  --  : recibos_campanya
                  -- si existia en el movimiento anterior
                  -- si existia calculamos el dto normalmente sino
                  -- el dto es cero.
                  vx_nmovimi :=
                     f_moviantgar (psseguro,
                                   pnriesgo,
                                   pcgarant,
                                   pnmovima,
                                   pttabla
                                  );

                  SELECT s.sproduc,
                         pac_seguros.ff_get_actividad (s.sseguro, pnriesgo),
                         DECODE (s.cforpag, 0, 1, s.cforpag), g.ccampanya,
                         g.nversio, -g.iprianu
                    INTO vsproduc,
                         vcactivi,
                         vcforpag, vccampanya,
                         vnversio, v_iprianu
                    FROM seguros s, garanseg g, detcampanya d
                   WHERE s.sseguro = psseguro
                     AND g.sseguro = s.sseguro
                     AND g.cgarant = pcgarant
                     AND g.nmovima = pnmovima
                     AND g.nriesgo = pnriesgo
                     AND d.ccampanya = g.ccampanya
                     AND d.nversio = g.nversio
                     AND d.sproduc = s.sproduc
                     AND d.cactivi =
                            pac_seguros.ff_get_actividad (s.sseguro, pnriesgo)
                     AND d.cgarant = g.cgarant
                     AND d.caplidto = 2
                     AND g.nmovimi = vx_nmovimi;
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     pidtocam := 0;
                  WHEN OTHERS
                  THEN
                     RETURN 111078;
               END;
            WHEN OTHERS
            THEN
               RETURN 111078;
         END;
      ELSIF pttabla = 'SOL'
      THEN
         BEGIN
            SELECT s.sproduc,
                   pac_seguros.ff_get_actividad (s.sseguro, pnriesgo),
                   DECODE (s.cforpag, 0, 1, s.cforpag), g.ccampanya,
                   g.nversio, g.iprianu
              INTO vsproduc,
                   vcactivi,
                   vcforpag, vccampanya,
                   vnversio, v_iprianu
              FROM seguros s, solgaranseg g, detcampanya d
             WHERE s.sseguro = psseguro
               AND g.ssolicit = s.sseguro
               AND g.cgarant = pcgarant
               AND g.nriesgo = pnriesgo
               AND d.ccampanya = g.ccampanya
               AND d.nversio = g.nversio
               AND d.sproduc = s.sproduc
               AND d.cactivi =
                           pac_seguros.ff_get_actividad (s.sseguro, g.nriesgo)
               AND d.cgarant = g.cgarant
               AND d.caplidto = 2;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               BEGIN
                  --  : recibos_campanya
                  -- si existia en el movimiento anterior
                  -- si existia calculamos el dto normalmente sino
                  -- el dto es cero.
                  vx_nmovimi :=
                     f_moviantgar (psseguro,
                                   pnriesgo,
                                   pcgarant,
                                   pnmovima,
                                   pttabla
                                  );

                  SELECT s.sproduc,
                         pac_seguros.ff_get_actividad (s.sseguro, pnriesgo),
                         DECODE (s.cforpag, 0, 1, s.cforpag), g.ccampanya,
                         g.nversio, -g.iprianu
                    INTO vsproduc,
                         vcactivi,
                         vcforpag, vccampanya,
                         vnversio, v_iprianu
                    FROM seguros s, solgaranseg g, detcampanya d
                   WHERE s.sseguro = psseguro
                     AND g.ssolicit = s.sseguro
                     AND g.cgarant = pcgarant
                     AND g.nriesgo = pnriesgo
                     AND d.ccampanya = g.ccampanya
                     AND d.nversio = g.nversio
                     AND d.sproduc = s.sproduc
                     AND d.cactivi =
                            pac_seguros.ff_get_actividad (s.sseguro, pnriesgo)
                     AND d.cgarant = g.cgarant
                     AND d.caplidto = 2;
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     pidtocam := 0;
                  WHEN OTHERS
                  THEN
                     RETURN 111078;
               END;
            WHEN OTHERS
            THEN
               RETURN 111078;
         END;
      ELSIF pttabla = 'EST'
      THEN
         BEGIN
            SELECT s.sproduc,
                   pac_seguros.ff_get_actividad (s.sseguro, pnriesgo),
                   DECODE (s.cforpag, 0, 1, s.cforpag), g.ccampanya,
                   g.nversio, g.iprianu
              INTO vsproduc,
                   vcactivi,
                   vcforpag, vccampanya,
                   vnversio, v_iprianu
              FROM seguros s, estgaranseg g, detcampanya d
             WHERE s.sseguro = psseguro
               AND g.sseguro = s.sseguro
               AND g.cgarant = pcgarant
               AND g.nmovima = pnmovima
               AND g.ffinefe IS NULL
               AND g.nriesgo = pnriesgo
               AND d.ccampanya = g.ccampanya
               AND d.nversio = g.nversio
               AND d.sproduc = s.sproduc
               AND d.cactivi =
                           pac_seguros.ff_get_actividad (s.sseguro, g.nriesgo)
               AND d.cgarant = g.cgarant
               AND d.caplidto = 2;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               BEGIN
                  --  : recibos_campanya
                  -- si existia en el movimiento anterior
                  -- si existia calculamos el dto normalmente sino
                  -- el dto es cero.
                  vx_nmovimi :=
                     f_moviantgar (psseguro,
                                   pnriesgo,
                                   pcgarant,
                                   pnmovima,
                                   pttabla
                                  );

                  SELECT s.sproduc,
                         pac_seguros.ff_get_actividad (s.sseguro, pnriesgo),
                         DECODE (s.cforpag, 0, 1, s.cforpag), g.ccampanya,
                         g.nversio, -g.iprianu
                    INTO vsproduc,
                         vcactivi,
                         vcforpag, vccampanya,
                         vnversio, v_iprianu
                    FROM seguros s, estgaranseg g, detcampanya d
                   WHERE s.sseguro = psseguro
                     AND g.sseguro = s.sseguro
                     AND g.cgarant = pcgarant
                     AND g.nmovima = pnmovima
                     AND g.nriesgo = pnriesgo
                     AND d.ccampanya = g.ccampanya
                     AND d.nversio = g.nversio
                     AND d.sproduc = s.sproduc
                     AND d.cactivi =
                            pac_seguros.ff_get_actividad (s.sseguro, pnriesgo)
                     AND d.cgarant = g.cgarant
                     AND d.caplidto = 2
                     AND g.nmovimi = vx_nmovimi;
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     pidtocam := 0;
                  WHEN OTHERS
                  THEN
                     RETURN 111078;
               END;
            WHEN OTHERS
            THEN
               RETURN 111078;
         END;
      END IF;

      IF vccampanya IS NOT NULL
      THEN
         BEGIN
            SELECT fefecto
              INTO vfefecto
              FROM movseguro m
             WHERE sseguro = psseguro AND nmovimi = pnmovima;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               RETURN 104394;                    --Error al leer de movseguro
         END;

         IF vfefecto > pfefecto
         THEN
            RETURN 109632;                      --Las fechas no són correctas
         END IF;

         vmeses :=
            MONTHS_BETWEEN (TO_DATE (TO_CHAR (pfefecto, 'mmyyyy'), 'mmyyyy'),
                            TO_DATE (TO_CHAR (vfefecto, 'mmyyyy'), 'mmyyyy')
                           );
         num_err :=
            f_duracion_campanya (vccampanya,
                                 vnversio,
                                 vsproduc,
                                 vcactivi,
                                 pcgarant,
                                 psseguro,
                                 pnriesgo,
                                 pnmovima,
                                 vfefecto,
                                 vmesdurac
                                );

         --DBMS_OUTPUT.put_line(' duarcion campanya ' || num_err);
         IF num_err <> 0
         THEN
            RETURN num_err;
         END IF;

         IF piprinet = 0
         THEN
            vx_iprinet := v_iprianu * pprorata;
         ELSE
            vx_iprinet := piprinet;
         END IF;

         IF vmeses <= vmesdurac
         THEN
            pidtocam := vx_iprinet;
         ELSE
            IF (vmeses - vmesdurac) >= (12 / vcforpag)
            THEN
               pidtocam := 0;
            ELSE
               pidtocam :=
                    ((12 / vcforpag) - (vmeses - vmesdurac))
                  * (vx_iprinet / (12 / vcforpag));
            END IF;
         END IF;
      END IF;

      RETURN 0;
   EXCEPTION
      WHEN OTHERS
      THEN
         --DBMS_OUTPUT.put_line(SQLERRM);
         RETURN 112147;
   END f_calculo_dtocampanya;

   FUNCTION f_extornpos (
      pnrecibo   IN   NUMBER,
      pmodo      IN   VARCHAR2,
      psproces   IN   NUMBER
   )
      RETURN NUMBER
   IS
      /********************************************************************************************
      --
      -- CANVIA EL SIGNE DE TOTS ELS IMPORTS,
      -- EN CAS DE QUÈ EL REBUT SIGUI UN EXTORN.
      --
         24/5/2004 YIL. Se mira si hay que aplicar penalización en un extorno. Se mira con la función
                        f_penalizacion y sólo se palica si la penalización es tipo porcentaje.

        24/5/2004 YIL. Si está informado el parámetro EXTORN_SIN_COMISIO se borrarán los registros
                       de comisiones.
      *********************************************************************************************/
      v_sproduc       seguros.sproduc%TYPE;
      --       v_sproduc      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      v_tipus         NUMBER;
      npenalizacion   NUMBER;
      v_sseguro       seguros.sseguro%TYPE;
      --       v_sseguro      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      v_fefecto       tmp_adm_recibos.fefecto%TYPE;
      --       v_fefecto      DATE; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      num_err         NUMBER;
   BEGIN
      -- Bug 19096 - RSC - 03/08/2011 - LCOL - Parametrización básica producto Vida Individual Pagos Permanentes (Afegim 'RRIE')
      IF pmodo IN ('R', 'A', 'ANP', 'RRIE')
      THEN
         BEGIN
            -- miramos si hay que aplicar penalizacion
            SELECT s.sproduc, s.sseguro, r.fefecto
              INTO v_sproduc, v_sseguro, v_fefecto
              FROM seguros s, tmp_adm_recibos r
             WHERE s.sseguro = r.sseguro AND r.nrecibo = pnrecibo;

            num_err :=
               f_penalizacion (7,
                               0,
                               v_sproduc,
                               v_sseguro,
                               v_fefecto,
                               npenalizacion,
                               v_tipus
                              );

            IF num_err <> 0
            THEN
               RETURN num_err;
            ELSE
               IF NVL (npenalizacion, 0) <> 0 AND v_tipus = 2
               THEN
                  --(sólo lo aplicamos si es tpo porcentaje)
                  UPDATE tmp_adm_detrecibos
                     SET iconcep =
                                 f_round (iconcep * (1 - npenalizacion / 100))
                   WHERE nrecibo = pnrecibo;
               END IF;
            END IF;

            UPDATE tmp_adm_detrecibos
               SET iconcep = (0 - iconcep)
             WHERE nrecibo = pnrecibo;

            -- Miramos si se aplica comisión en extornos
            IF NVL (f_parproductos_v (v_sproduc, 'EXTORN_SIN_COMISIO'), 0) = 1
            THEN
               DELETE FROM tmp_adm_detrecibos
                     WHERE nrecibo = pnrecibo
                       AND cconcep IN
                              (11, 12, 15, 16, 17, 18, 19, 20, 22, 23, 24, 25,
                               61, 62, 65, 66);
            END IF;
         EXCEPTION
            WHEN OTHERS
            THEN
               p_tab_error (f_sysdate,
                            f_user,
                            'PAC_ADM.F_extornpos',
                            NULL,
                            'nrecibo' || pnrecibo,
                            SQLERRM
                           );
               RETURN 104377;        -- ERROR AL MODIFICAR LA TAULA DETRECIBOS
         END;

         RETURN 0;
      ELSIF pmodo = 'P' OR pmodo = 'N' OR pmodo = 'PRIE'
      THEN
         IF psproces IS NOT NULL
         THEN
            BEGIN
               -- miramos si hay que aplicar penalizacion
               SELECT s.sproduc, s.sseguro, r.fefecto
                 INTO v_sproduc, v_sseguro, v_fefecto
                 FROM seguros s, tmp_adm_recibos r
                WHERE s.sseguro = r.sseguro AND r.nrecibo = pnrecibo;

               num_err :=
                  f_penalizacion (7,
                                  0,
                                  v_sproduc,
                                  v_sseguro,
                                  v_fefecto,
                                  npenalizacion,
                                  v_tipus
                                 );

               IF num_err <> 0
               THEN
                  RETURN num_err;
               ELSE
                  IF NVL (npenalizacion, 0) <> 0 AND v_tipus = 2
                  THEN
                     --(sólo lo aplicamos si es tpo porcentaje)
                     UPDATE tmp_adm_detrecibos
                        SET iconcep =
                                 f_round (iconcep * (1 - npenalizacion / 100))
                      WHERE nrecibo = pnrecibo;
                  END IF;
               END IF;

               UPDATE tmp_adm_detrecibos
                  SET iconcep = (0 - iconcep)
                WHERE nrecibo = pnrecibo;

               -- Miramos si se aplica comisión en extornos
               IF NVL (f_parproductos_v (v_sproduc, 'EXTORN_SIN_COMISIO'), 0) =
                                                                             1
               THEN
                  DELETE FROM tmp_adm_detrecibos
                        WHERE nrecibo = pnrecibo
                          AND cconcep IN
                                 (11, 12, 15, 16, 17, 18, 19, 20, 22, 23, 24,
                                  25, 61, 62, 65, 66);
               END IF;
            EXCEPTION
               WHEN OTHERS
               THEN
                  p_tab_error (f_sysdate,
                               f_user,
                               'PAC_ADM.F_extornpos',
                               NULL,
                               'nrecibo' || pnrecibo || ' modo = P',
                               SQLERRM
                              );
                  RETURN 9001975;
            -- Error al modificar la taula TMP_ADM_DETRECIBOS
            END;

            RETURN 0;
         ELSE
            RETURN 101901;        -- PAS DE PARÀMETRES INCORRECTE A LA FUNCIÓ
         END IF;
      ELSE
         RETURN 101901;           -- PAS DE PARÀMETRES INCORRECTE A LA FUNCIÓ
      END IF;
   END f_extornpos;

   -- BUG : 13038 - 22-02-2010 - JMC - Se añade funcion.
   /***************************************************************************
      FUNCTION f_get_last_rec
      Dado un sseguro, obtenemos la fecha de efecto del último recibo que cumpla
      ciertas condiciones.
         param in  psseguro:  Código seguro.
         param in  pcestrec:  Estado del recibo 0-Pendiente 1-Cobrado 2-Anulado.
         param in  pcestimp:  Estado de impresión del recibo.
         return:              Record Recibo.
   ***************************************************************************/
   FUNCTION f_get_last_rec (
      psseguro   IN   NUMBER,
      pcestrec   IN   NUMBER DEFAULT NULL,
      pcestimp   IN   NUMBER DEFAULT NULL
   )
      RETURN rrecibo
   IS
      v_rrecibo   rrecibo;
      v_cestrec   tmp_adm_movrecibo.cestrec%TYPE;
   --       v_cestrec      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
   BEGIN
      v_rrecibo := NULL;

      FOR x IN (SELECT   *
                    FROM recibos
                   WHERE sseguro = psseguro
                ORDER BY nrecibo DESC)
      LOOP
         IF pcestimp = pcestimp OR pcestimp IS NULL
         THEN
            -- 30/06/2010 JGR 15. 15211: CRE800 - Modificación de recibos / f_cestrec(r.nrecibo, f_sysdate) -> NULL
            v_cestrec := NVL (f_cestrec (x.nrecibo, NULL), 3);

            IF v_cestrec = pcestrec OR pcestrec IS NULL
            THEN
               v_rrecibo.nrecibo := x.nrecibo;
               v_rrecibo.fefecto := x.fefecto;
               v_rrecibo.cestrec := v_cestrec;
               v_rrecibo.cestimp := x.cestimp;

               BEGIN
                  SELECT iprinet,
                         itotalr                    -- BUG14061:DRA:19/05/2010
                    INTO v_rrecibo.iprinet,
                         v_rrecibo.itotalr          -- BUG14061:DRA:19/05/2010
                    FROM vdetrecibos
                   WHERE nrecibo = x.nrecibo;
               EXCEPTION
                  WHEN OTHERS
                  THEN
                     v_rrecibo.iprinet := NULL;
                     v_rrecibo.itotalr := NULL;
               END;

               RETURN v_rrecibo;
            END IF;
         END IF;
      END LOOP;

      RETURN v_rrecibo;
   END f_get_last_rec;

   -- FIN BUG : 13038 - 22-02-2010 - JMC

   /***************************************************************************
       FUNCTION f_consorci
       Funciones para el cálculo del consorcio.
   ***************************************************************************/
   FUNCTION f_consorci (
      psproces          IN       NUMBER,
      psseguro          IN       NUMBER,
      pnrecibo          IN       NUMBER,
      pnriesgo          IN       NUMBER,
      pfefecto          IN       DATE,
      pfvencim          IN       DATE,
      pcmodo            IN       VARCHAR2,
      ptipomovimiento   IN       NUMBER,
      pcramo            IN       NUMBER,
      pcmodali          IN       NUMBER,
      pcactivi          IN       NUMBER,
      pccolect          IN       NUMBER,
      pctipseg          IN       NUMBER,
      pcduraci          IN       NUMBER,
      pnduraci          IN       NUMBER,
      pnmovimi          IN       NUMBER,
      pgrabar           OUT      NUMBER,
      pnmovimiant       IN       NUMBER,
      pfacconsor        IN       NUMBER,
      pfacconsorfra     IN       NUMBER,
      --JAMF 11903 - Factor de prorrateo para el consorcio fraccionado
      paltarisc         IN       BOOLEAN,
      pcapieve          IN       NUMBER DEFAULT NULL,
      pttabla           IN       VARCHAR2 DEFAULT NULL,
      pfuncion          IN       VARCHAR2 DEFAULT 'CAR',
      pctipapo          IN       NUMBER DEFAULT NULL
   )
      RETURN NUMBER
   IS
      -- ALLIBADM. AQUESTA FUNCIÓ ÉS CRIDADA PER LA FUNCIÓ F_DETRECIBO, I S' ENCARREGA NOMÉS D' OMPLIR LA TAULA
      -- DETRECIBOS AMB LES DADES DEL CONSORCI.
      -- NOMÉS S' HA CREAT PER PROBLEMES D' ESPAI DE LA FUNCIÓ ORIGINAL F_DETRECIBO EN LA BD.
      -- ALLIBADM. CANVIA COMPLETAMENT.
      -- DARRERA MODIFICACIÓ = DRA 19-05-1999.
      -- ALLIBADM. SE IMPLEMENTA EL COASEGURO
      -- SE IMPLEMENTA EL TRATAMIENTO DEL CAPITAL A PRIMER RIESGO.
      -- SI SE HA DEFINIDO EL VALOR DEL CONSORCIO EN LA TABLA CONSORSEGU COGEMOS ÉSTE.
      -- NOTA: ESTE VALOR ES EL IMPORTE DEL CONSORCIO QUE TENDRÁ LA GARANTÍA PARA ESE RIESGO.
      --       EN EL CASO DE QUE HAYA UN CAPITAL A PRIMER RIESGO, A LOS IMPORTES DEFINIDOS
      --       EN ESTA TABLA SE APLICARÁ POSTERIORMENTE LOS COEFICIENTES DE LA TABLA DE LÍMITES.
      -- SI LA GARANTÍA NO ES CONSORCIABLE NO SE CALCULA EL CONSORCIO PARA ESA
      -- GARANTÍA AUNQUE LA TUVIERA FIJA.
      -- PARA CONSORCIOS DE CAPITAL EVENTUAL SE CALCULA LOS DÍAS QUE HA DURADO ESE EXCESO.
      -- PARA DURACIONES SUPERIORES AL AÑO SE PRORRATEARÁ POR EL TIEMPO QUE CORRESPONDA
      -- Tratamiento especial para AUTOS. Acceso a PARGARANPRO para obtener un CCLARIE
      --                 alternativo o para decidir si se debe grabar una garantía o no dependiendo de otras.
      -- Modificación para consorciar diferentes consorcios xctipcla=1 o xctipcla=2
      --                          o xctipcla = 3. Si existe un extorno no debe devolver el consorcio.
      -- Se añade el tipomovimiento = 11 ==> Suplemento con Recibo por diferencia
      --              de prima basada en provisión matemática (prima única)
      -- Sólo se considera de temporada si cduraci = 3 y cforpag = 0 (única).
      /*
        {Se añaden los parametros funcion y tabla para el calculo del primer recibo al tarifar,
         el parametro tabla indica a que tablas tiene que ir a buscar importes ('EST','SOL',NULLL),
         el parametro función indica si estoy tarifando (TAR) o en la cartera o previo de cartera (CAR)
        }
      */
      -- Se añaden los campos CAGEVEN y NMOVIMA en los cursores para poder grabar correctamente
      -- en DETRECIBOS o DETRECIBOSCAR. Ahora siempre graba NULL.

      /******************************************************************************
         NOMBRE:      F_CONSORCI
         PROPÓSITO:   FUNCIÓ QUE S' ENCARREGA NOMÉS D' OMPLIR LA TAULA DETRECIBOS AMB LES DADES DEL CONSORCI.

         REVISIONES:
         Ver        Fecha        Autor             Descripción
         ---------  ----------  ---------------  ------------------------------------
         1.0        28/04/2009    DCT            1. Modificación Selects pargaranpro.
                                                    Si para actividad en concreto no DATA_FOUND
                                                    buscar para actividad 0. Bug:0009783
         2.0        01/08/2009    NMM            2. 10864: CEM - Taxa aplicable Consorci.
         3.0        11/11/2009    JAMF           3. 11903: CEM - Consorcio fraccionable
         4.0        31/03/2010    FAL            4. 0012589: CEM - Recibos con copago y consorcio
         5.0        18/04/2011    JMF            5. 0018135 CCAT701 - Paquetes propios y Consorcio de CTV en iAXIS
      ******************************************************************************/
      error             NUMBER                            := 0;
      xmeses            NUMBER;
      xresult           NUMBER;
      xcclarie          NUMBER;
      xsegtemporada     BOOLEAN;
      xsegtemp1         NUMBER;
      xctipcla          NUMBER;
      xivalnor          NUMBER;
      xvalorconsorcio   NUMBER;
      xcapitaltrobat    NUMBER;
      --xcapitaltotal  NUMBER;
      --xpercent       NUMBER;
      xtotcapital       NUMBER;
      --xnvalor1       NUMBER;
      --xnvalor2       NUMBER;
      iconcep0          tmp_adm_detrecibos.iconcep%TYPE;
      --       iconcep0       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xcgarant          NUMBER;
      xnriesgo          NUMBER;
      xcgarantant       garanseg.cgarant%TYPE;
      --       xcgarantant    NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xtotcapitalant    NUMBER;
      --xcapitaltotalant NUMBER;
      xnriesgoant       garanseg.nriesgo%TYPE;
      --       xnriesgoant    NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xcgarantseg       garanseg.cgarant%TYPE;
      --       xcgarantseg    NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xnriesgoseg       garanseg.nriesgo%TYPE;
      --       xnriesgoseg    NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xgrabar           NUMBER                            := 0;
      xnmovimiant       garanseg.nmovimi%TYPE;
      --       xnmovimiant    NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xnmovimiseg       garanseg.nmovimi%TYPE;
      --       xnmovimiseg    NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      --xfefectoant    DATE;
      xfefectoseg       garanseg.finiefe%TYPE;
      --       xfefectoseg    DATE; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      decimals          NUMBER                            := 0;
      existant          BOOLEAN                           := TRUE;
      xinnomin          BOOLEAN;
      xnasegur1         NUMBER;
      xnasegur2         NUMBER;
      xcobjase          productos.cobjase%TYPE;
      --       xcobjase       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xinsert           BOOLEAN;
      xnmovima          riesgos.nmovima%TYPE;
      --       xnmovima       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xicapital         garanseg.icapital%TYPE;
      --       xicapital      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xicapitalant      garanseg.icapital%TYPE;
      --       xicapitalant   NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xicapitalseg      garanseg.icapital%TYPE;
      --       xicapitalseg   NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xctipcoa          seguros.ctipcoa%TYPE;
      --       xctipcoa       NUMBER;   -- COASEGURO --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xncuacoa          seguros.ncuacoa%TYPE;
      --       xncuacoa       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xploccoa          coacuadro.ploccoa%TYPE;
      --       xploccoa       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      --xsumaneta      NUMBER;
      --xiconsor       NUMBER;
      xcimpcon          NUMBER;
      xfiniefe          DATE;
      xfiniefeant       garanseg.finiefe%TYPE;
      --       xfiniefeant    DATE; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xffinefe          DATE;
      xdifdiaseve       NUMBER;
      xcforpag          solseguros.cforpag%TYPE;
      --       xcforpag       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xorden            pargaranpro.cvalpar%TYPE;
      --       xorden         NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      vselect           VARCHAR2 (2000);
      xcageven          tmp_adm_detrecibos.cageven%TYPE;
      --       xcageven       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xxnmovima         NUMBER;
      xcempres          codiram.cempres%TYPE;
      --       xcempres       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xcons             NUMBER;
      vcfracci          NUMBER;
      vcbonifi          NUMBER;
      vcrecfra          NUMBER;
      --
      w_climit          NUMBER;
      v_cmonimp         imprec.cmoneda%TYPE;
      -- BUG 18423 - LCOL000 - Multimoneda
      w_resultat        NUMBER;
      w_cduraci         seguros.cduraci%TYPE;
      --       w_cduraci      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      w_nduraci         seguros.nduraci%TYPE;
      --       w_nduraci      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xctipreb          seguros.ctipreb%TYPE;
      --       xctipreb       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      -- ini Bug 0018135 - JMF - 18/04/2011
      v_sproduc         seguros.sproduc%TYPE;
      v_conspup         parproductos.cvalpar%TYPE;
      v_origenpup       NUMBER;
      v_clavepup        garanformula.clave%TYPE;
      -- fin Bug 0018135 - JMF - 18/04/2011
      vcderreg          NUMBER;             -- Bug 0020314 - FAL - 29/11/2011

      TYPE tcursor IS REF CURSOR;

      curgaran          tcursor;

      -- AUTOS. Para recoger el cod. retorno de F_ORDENCONSORCIO
      CURSOR cur_garansegxrisc
      IS
         SELECT nriesgo, cgarant, finiefe, ffinefe, cageven, nmovima,
                icapital
           FROM garanseg
          WHERE sseguro = psseguro
            AND nriesgo = NVL (pnriesgo, nriesgo)
            AND nmovimi = pnmovimi;

      CURSOR cur_garansegant
      IS
         SELECT cgarant, nriesgo, finiefe, ffinefe, cageven, nmovima,
                icapital
           FROM garanseg
          WHERE sseguro = psseguro
            AND nriesgo = NVL (pnriesgo, nriesgo)
            AND nmovimi = pnmovimiant;

      CURSOR cur_garancarxrisc
      IS
         SELECT nriesgo, cgarant, finiefe, ffinefe, cageven, nmovima,
                icapital
           FROM garancar
          WHERE sproces = psproces
            AND sseguro = psseguro
            AND nriesgo = NVL (pnriesgo, nriesgo);

      -- Bug 12589 - FAL - 31/03/2010 -- 0012589: CEM - Recibos con copago y consorcio
      CURSOR cur_aportaseg (psseguro NUMBER, pfefecto DATE, pnorden NUMBER)
      IS
         SELECT ctipimp, pimport, iimport
           FROM aportaseg
          WHERE sseguro = psseguro
            AND finiefe <= pfefecto
            AND (ffinefe IS NULL OR ffinefe > pfefecto)
            AND (norden = pnorden OR pnorden IS NULL);

      FUNCTION f_esconsorciable (
         pfcgarant   IN       NUMBER,
         pfcramo     IN       NUMBER,
         pfcmodali   IN       NUMBER,
         pfccolect   IN       NUMBER,
         pfctipseg   IN       NUMBER,
         pfcactivi   IN       NUMBER,
         pfnerror    OUT      NUMBER
      )
         RETURN NUMBER
      IS
         --
         -- COMPROBACIÓN DE SI UNA GARANTÍA ES CONSORCIABLE
         --
         xfcimpcon   garanpro.cimpcon%TYPE;
      --          xfcimpcon      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      BEGIN
         BEGIN
            SELECT cimpcon
              INTO xfcimpcon
              FROM garanpro
             WHERE cramo = pfcramo
               AND cmodali = pfcmodali
               AND ccolect = pfccolect
               AND ctipseg = pfctipseg
               AND cgarant = pfcgarant
               AND cactivi = NVL (pfcactivi, 0);
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               BEGIN
                  SELECT NVL (cimpcon, 0)
                    INTO xfcimpcon
                    FROM garanpro
                   WHERE cramo = pfcramo
                     AND cmodali = pfcmodali
                     AND ccolect = pfccolect
                     AND ctipseg = pfctipseg
                     AND cgarant = pfcgarant
                     AND cactivi = 0;
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     pfnerror := 104110;     -- PRODUCTE NO TROBAT A GARANPRO
                     RETURN 0;
                  WHEN OTHERS
                  THEN
                     pfnerror := 103503;
                     -- ERROR AL LLEGIR DE LA TAULA GARANPRO
                     RETURN 0;
               END;
            WHEN OTHERS
            THEN
               pfnerror := 103503;    -- ERROR AL LLEGIR DE LA TAULA GARANPRO
               RETURN 0;
         END;

         pfnerror := 0;
         RETURN xfcimpcon;
      END f_esconsorciable;

      FUNCTION f_ordenconsorcio (
         pftablas    IN       NUMBER,
         pfcgarant   IN       NUMBER,
         pfcramo     IN       NUMBER,
         pfcmodali   IN       NUMBER,
         pfccolect   IN       NUMBER,
         pfctipseg   IN       NUMBER,
         pfcactivi   IN       NUMBER,
         pfsseguro   IN       NUMBER,
         pfnriesgo   IN       NUMBER,
         pfnmovimi   IN       NUMBER,
         pfnerror    OUT      NUMBER
      )
         RETURN NUMBER
      IS
         xorden    pargaranpro.cvalpar%TYPE;
         --          xorden         NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
         retorno   NUMBER;
      -- Varias garantias de la misma actividad son alternativas: solo se calcula el consorcio
      -- para una de ellas, segun la prioridad en PARGARANPRO.
      -- Si se ha contratado otra garantia con prioridad superior devolveremos '1' (para no grabar)
      -- Si no hay que hacer nada devolveremos 0.
      BEGIN
         --  Primero obtenemos el orden/prioridad de la garantia que estamos 'consorciando'
         BEGIN
            SELECT cvalpar
              INTO xorden
              FROM pargaranpro
             WHERE cpargar = 'ORDEN_CONSORCIO'
               AND cramo = pfcramo
               AND cmodali = pfcmodali
               AND ctipseg = pfctipseg
               AND ccolect = pfccolect
               AND cgarant = pfcgarant
               AND cactivi = pcactivi;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               --BUG 9783 - 29/04/2009 - DCT - Añadir select por cactivi = 0
               BEGIN
                  SELECT cvalpar
                    INTO xorden
                    FROM pargaranpro
                   WHERE cpargar = 'ORDEN_CONSORCIO'
                     AND cramo = pfcramo
                     AND cmodali = pfcmodali
                     AND ctipseg = pfctipseg
                     AND ccolect = pfccolect
                     AND cgarant = pfcgarant
                     AND cactivi = 0;
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     NULL;
                  WHEN OTHERS
                  THEN
                     pfnerror := SQLCODE;
                     RETURN 1;
               END;
            --FI BUG 9783 - 29/04/2009 - DCT - Añadir select por cactivi = 0
            WHEN OTHERS
            THEN
               pfnerror := SQLCODE;
               RETURN 1;
         END;

         retorno := 0;

         -- Ahora miramos si hay otra con prioridad superior (orden:1-max, orden:9-min)
         IF xorden IS NOT NULL
         THEN
            IF pftablas = 1
            THEN
               BEGIN
                  SELECT '1'
                    INTO retorno
                    FROM pargaranpro
                   WHERE cpargar = 'ORDEN_CONSORCIO'
                     AND cramo = pfcramo
                     AND cmodali = pfcmodali
                     AND ctipseg = pfctipseg
                     AND ccolect = pfccolect
                     AND cactivi = pfcactivi
                     AND cvalpar < xorden
                     AND cgarant IN (
                            SELECT cgarant
                              FROM garanseg
                             WHERE sseguro = pfsseguro
                               AND nriesgo = NVL (pfnriesgo, nriesgo)
                               AND nmovimi = pfnmovimi);
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     BEGIN
                        SELECT '1'
                          INTO retorno
                          FROM pargaranpro
                         WHERE cpargar = 'ORDEN_CONSORCIO'
                           AND cramo = pfcramo
                           AND cmodali = pfcmodali
                           AND ctipseg = pfctipseg
                           AND ccolect = pfccolect
                           AND cactivi = 0
                           AND cvalpar < xorden
                           AND cgarant IN (
                                  SELECT cgarant
                                    FROM garanseg
                                   WHERE sseguro = pfsseguro
                                     AND nriesgo = NVL (pfnriesgo, nriesgo)
                                     AND nmovimi = pfnmovimi);
                     EXCEPTION
                        WHEN NO_DATA_FOUND
                        THEN
                           NULL;
                        WHEN TOO_MANY_ROWS
                        THEN
                           retorno := 1;
                        WHEN OTHERS
                        THEN
                           pfnerror := SQLCODE;
                           RETURN 1;
                     END;
                  WHEN TOO_MANY_ROWS
                  THEN
                     retorno := 1;
                  WHEN OTHERS
                  THEN
                     pfnerror := SQLCODE;
                     RETURN 1;
               END;
            ELSE
               -- CARTERA
               BEGIN
                  SELECT '1'
                    INTO retorno
                    FROM pargaranpro
                   WHERE cpargar = 'ORDEN_CONSORCIO'
                     AND cramo = pfcramo
                     AND cmodali = pfcmodali
                     AND ctipseg = pfctipseg
                     AND ccolect = pfccolect
                     AND cactivi = pfcactivi
                     AND cvalpar < xorden
                     AND cgarant IN (
                            SELECT cgarant
                              FROM garancar
                             WHERE sseguro = pfsseguro
                               AND nriesgo = NVL (pfnriesgo, nriesgo));
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     BEGIN
                        SELECT '1'
                          INTO retorno
                          FROM pargaranpro
                         WHERE cpargar = 'ORDEN_CONSORCIO'
                           AND cramo = pfcramo
                           AND cmodali = pfcmodali
                           AND ctipseg = pfctipseg
                           AND ccolect = pfccolect
                           AND cactivi = 0
                           AND cvalpar < xorden
                           AND cgarant IN (
                                  SELECT cgarant
                                    FROM garancar
                                   WHERE sseguro = pfsseguro
                                     AND nriesgo = NVL (pfnriesgo, nriesgo));
                     EXCEPTION
                        WHEN NO_DATA_FOUND
                        THEN
                           NULL;
                        WHEN TOO_MANY_ROWS
                        THEN
                           retorno := 1;
                        WHEN OTHERS
                        THEN
                           pfnerror := SQLCODE;
                           RETURN 1;
                     END;
                  WHEN TOO_MANY_ROWS
                  THEN
                     retorno := 1;
                  WHEN OTHERS
                  THEN
                     pfnerror := SQLCODE;
                     RETURN 1;
               END;
            END IF;
         END IF;

         RETURN retorno;
      END f_ordenconsorcio;

-----------------------------------------------------------------------------
      PROCEDURE p_tracta_limit (
         p_climit         IN       NUMBER,
         p_cduraci        IN       seguros.cduraci%TYPE,
         p_nduraci        IN       seguros.nduraci%TYPE,
         p_cforpag        IN       NUMBER,
         p_fvencim        IN       DATE,
         p_fefecto        IN       DATE,
         p_segtemporada   OUT      BOOLEAN,
         p_mesos          OUT      NUMBER,
         p_nvalor1        OUT      NUMBER,
         p_resultat       OUT      NUMBER
      )
      IS
--
-----------------------------------------------------------------------------
      BEGIN
         IF p_climit IS NOT NULL
         THEN
            p_segtemporada := TRUE;

            IF p_cduraci = 1
            THEN
               p_mesos := p_nduraci * 12;
            ELSIF p_cduraci = 2
            THEN
               p_mesos := p_nduraci;
            ELSIF p_cduraci = 3 AND p_cforpag = 0
            THEN
               p_mesos := CEIL (MONTHS_BETWEEN (p_fvencim, p_fefecto));
            END IF;

            BEGIN
               SELECT MIN (nvalor1)
                 INTO p_nvalor1
                 FROM limites
                WHERE climite = p_climit
                  AND p_mesos >= nminimo
                  AND (p_mesos <= nmaximo OR nmaximo IS NULL);

               p_resultat := 0;
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  -- LÍMIT NO TROBAT A LA TAULA LIMITES
                  p_resultat := 103834;
               WHEN OTHERS
               THEN
                  -- ERROR AL LLEGIR DE LA TAULA LIMITES
                  p_resultat := 103514;
            END;
         END IF;
-----------------------------------------------------------------------------
      END p_tracta_limit;
-----------------------------------------------------------------------------

   --------------------------------------------------------------------------------
--                    F_CONSORCI
--------------------------------------------------------------------------------
   BEGIN
-- ********************************************************************
-- *************  FASE 3  DE F_DETRECIBO ******************************
-- ********************************************************************
-- CÀLCUL DEL CONSORCI (CCONCEP 2) (TAULA GARANSEG)
      pgrabar := 0;                      -- EN UN PRINCIPI, NO HEM GRABAT RES

      BEGIN
         SELECT cobjase,
                        -- JLB - I - BUG 18423 COjo la moneda del producto
                        --DECODE (cdivisa, 2, 2, 3, 1)
                        pac_monedas.f_moneda_producto (sproduc)
           -- JLB - f - BUG 18423 COjo la moneda del producto
         INTO   xcobjase, decimals
           FROM productos
          WHERE cramo = pcramo
            AND cmodali = pcmodali
            AND ctipseg = pctipseg
            AND ccolect = pccolect;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            RETURN 104347;                  -- PRODUCTE NO TROBAT A PRODUCTOS
         WHEN OTHERS
         THEN
            RETURN 102705;                    -- ERROR AL LLEGIR DE PRODUCTOS
      END;

      IF xcobjase = 4
      THEN
         -- PRODUCTE INNOMINAT
         xinnomin := TRUE;
      ELSE
         xinnomin := FALSE;
      END IF;

      -- BUSCAMOS EL PORCENTAJE LOCAL SI ES UN COASEGURO.
      -- Añadimos la empresa, para los cálculos del concepto (para f_concepto)
      IF pttabla = 'EST'
      THEN
         SELECT cempres, ctipcoa, ncuacoa, cforpag, cduraci,
                nduraci, ctipreb, sproduc
           INTO xcempres, xctipcoa, xncuacoa, xcforpag, w_cduraci,
                w_nduraci, xctipreb, v_sproduc
           FROM estseguros
          WHERE sseguro = psseguro;
      ELSIF pttabla = 'SOL'
      THEN
         SELECT cr.cempres, s.cforpag, cduraci, nduraci, sproduc
           INTO xcempres, xcforpag, w_cduraci, w_nduraci, v_sproduc
           FROM solseguros s, codiram cr
          WHERE s.cramo = cr.cramo AND ssolicit = psseguro;
      ELSE
         SELECT cempres, ctipcoa, ncuacoa, cforpag, cduraci,
                nduraci, ctipreb, sproduc
           INTO xcempres, xctipcoa, xncuacoa, xcforpag, w_cduraci,
                w_nduraci, xctipreb, v_sproduc
           FROM seguros
          WHERE sseguro = psseguro;
      END IF;

      -- Cerquem el percentatge local si és coassegurança.
      IF xctipcoa != 0
      THEN
         SELECT ploccoa
           INTO xploccoa
           FROM coacuadro
          WHERE ncuacoa = xncuacoa AND sseguro = psseguro;
      END IF;

      -- bug 10864.NMM.01/08/2009. S'elimina un troç de codi.

      -- Bug 0018135 - JMF - 18/04/2011
      v_conspup :=
           NVL (pac_parametros.f_parproducto_n (v_sproduc, 'CONSORCI_PUP'), 0);

      -- *********** ACTUEM DEPENENT DEL PCMODO (REAL O PROVES) *******************
      -- Bug 19096 - RSC - 03/08/2011 - LCOL - Parametrización básica producto Vida Individual Pagos Permanentes (Afegim 'RRIE')
      IF pcmodo IN ('R', 'RRIE')
      THEN
         IF    ptipomovimiento = 0
            OR ptipomovimiento = 6
            OR ptipomovimiento = 21
            OR ptipomovimiento = 22
         --JAMF 11903 - Añadimos el cálculo para carteras no anuales
         THEN
            OPEN cur_garansegxrisc;

            FETCH cur_garansegxrisc
             INTO xnriesgo, xcgarant, xfiniefe, xffinefe, xcageven,
                  xxnmovima, xicapital;

            WHILE cur_garansegxrisc%FOUND
            LOOP
               xnasegur1 := 0;
               xnasegur2 := 0;
               xcclarie := NULL;
               xcimpcon :=
                  f_esconsorciable (xcgarant,
                                    pcramo,
                                    pcmodali,
                                    pccolect,
                                    pctipseg,
                                    pcactivi,
                                    error
                                   );

               IF error <> 0
               THEN
                  CLOSE cur_garansegxrisc;

                  RETURN error;
               END IF;

               IF xcimpcon = 1
               THEN
                  -- SI LA GARANTÍA ES CONSORCIABLE
                  -- bug 10864.NMM.01/08/2009. S'afegeix una variable.
                  error :=
                     f_concepto (2,
                                 xcempres,
                                 pfefecto,
                                 --NULL,
                                 xcforpag,
                                 --JAMF 11903 - Puede depender de la forma de pago
                                 pcramo,
                                 pcmodali,
                                 pctipseg,
                                 pccolect,
                                 pcactivi,
                                 xcgarant,
                                 xctipcla,
                                 xivalnor,
                                 vcfracci,
                                 vcbonifi,
                                 vcrecfra,
                                 w_climit,
                                 v_cmonimp,
                                 -- BUG 18423 - LCOL000 - Multimoneda
                                 vcderreg
                                );           -- Bug 0020314 - FAL - 29/11/2011
                  --
                  p_tracta_limit (w_climit,
                                  w_cduraci,
                                  w_nduraci,
                                  xcforpag,
                                  pfvencim,
                                  pfefecto,
                                  xsegtemporada,
                                  xmeses,
                                  xsegtemp1,
                                  w_resultat
                                 );

                  IF w_resultat = 103834
                  THEN
                     -- LÍMIT NO TROBAT A LA TAULA LIMITES
                     RETURN (103834);
                  ELSIF w_resultat = 103514
                  THEN
                     -- ERROR AL LLEGIR DE LA TAULA LIMITES
                     RETURN (103514);
                  END IF;

                  -- bug 10864.f.
                  IF error <> 0
                  THEN
                     -- Si da error la función.
                     CLOSE cur_garansegxrisc;

                     RETURN error;
                  ELSE
                     BEGIN
                        SELECT DECODE (nasegur, NULL, 1, nasegur)
                          INTO xnasegur1
                          FROM riesgos
                         WHERE sseguro = psseguro
                           AND nriesgo = NVL (xnriesgo, 1);
                     EXCEPTION
                        WHEN NO_DATA_FOUND
                        THEN
                           CLOSE cur_garansegxrisc;

                           RETURN 103836;         -- RISC NO TROBAT A RIESGOS
                        WHEN OTHERS
                        THEN
                           CLOSE cur_garansegxrisc;

                           RETURN 103509;       -- ERROR AL LLEGIR DE RIESGOS
                     END;

                     -- ini Bug 0018135 - JMF - 18/04/2011
                     IF v_conspup = 1 AND xctipcla = 1
                     THEN
                        -- CONSORCI SOBRE EL CAPITAL
                        -- AVT 26-03-2007 El càlcul del consorci del producte: Prima Única Protecció és formulat
                        IF pttabla IS NULL
                        THEN
                           v_origenpup := 2;
                        ELSIF pttabla = 'SOL'
                        THEN
                           v_origenpup := 1;
                        ELSIF pttabla = 'EST'
                        THEN
                           v_origenpup := 0;
                        END IF;

                        BEGIN
                           SELECT clave
                             INTO v_clavepup
                             FROM garanformula
                            WHERE cramo = pcramo
                              AND cmodali = pcmodali
                              AND ctipseg = pctipseg
                              AND ccolect = pccolect
                              AND cactivi = pcactivi
                              AND cgarant = xcgarant
                              AND ccampo = 'ICONPUP';
                        EXCEPTION
                           WHEN OTHERS
                           THEN
                              p_tab_error (f_sysdate,
                                           f_user,
                                           'PAC_ADM.f_consorci',
                                           1,
                                           'Error al llegir de GARANFORMULA',
                                           SQLERRM
                                          );
                              error := 110087;
                              -- Error al insertar en GARANFORMULA
                              RETURN (error);
                        END;

                        --(JAS)05.06.07 - Modifico la fòrmula del càlcul del consorci, perquè ens retorni el capital consorciable.
                        --Anteriorment retornava l'import final del consorci directement, de manera que ara caldrà aplicar la taxa
                        --de consorci corresponent sobre el capital consorciable calculat, per obtenir l'import final del consorci
                        --(com ja es feia amb els altres productes). Es realitza aquest canvi perquè la formulació aplicava la taxa
                        --de consorci a partir de la classe de risc (CODICLARIE), quan en realitat s'ha d'aplicar la taxa d'impost
                        --definit en la taula d'impostos (IMPREC) que ja tenim calculat a "xivalnor".
                        error :=
                           pac_calculo_formulas.calc_formul (pfefecto,
                                                             v_sproduc,
                                                             pcactivi,
                                                             xcgarant,
                                                             xnriesgo,
                                                             psseguro,
                                                             v_clavepup,
                                                             xcons,
                                                             NULL,
                                                             NULL,
                                                             v_origenpup,
                                                             xfiniefe,
                                                             NULL
                                                            );

                        IF NVL (error, -1) <> 0
                        THEN
                           CLOSE cur_garansegxrisc;

                           RETURN error;
                        END IF;
                     -- AVT 26-03-2007 El càlcul del consorci del producte: Prima Única Protecció és formulat
                     -- fin Bug 0018135 - JMF - 18/04/2011
                     ELSE
                        -- Obtenemos la prima, para consorcio sobre prima
                        BEGIN
                           SELECT   SUM (iconcep)
                               INTO iconcep0
                               FROM tmp_adm_detrecibos
                              WHERE nrecibo = pnrecibo
                                AND nriesgo = xnriesgo
                                AND cgarant = xcgarant
                                AND (cconcep = 0 OR cconcep = 50
                                    )                       -- LOCAL +  CEDIDA
                           GROUP BY nriesgo, cgarant;
                        EXCEPTION
                           WHEN NO_DATA_FOUND
                           THEN
                              NULL;
                           WHEN OTHERS
                           THEN
                              CLOSE cur_garansegxrisc;

                              error := 103512;
                              -- ERROR AL LLEGIR DE DETRECIBOS
                              RETURN error;
                        END;

                        error :=
                           pac_impuestos.f_calcula_impconcepto (xivalnor,
                                                                iconcep0,
                                                                iconcep0,
                                                                NULL,
                                                                NULL,
                                                                NULL,
                                                                xicapital,
                                                                NULL,
                                                                NULL,
                                                                xctipcla,
                                                                xcforpag,
                                                                vcfracci,
                                                                vcbonifi,
                                                                vcrecfra,
                                                                xcons
                                                                     -- JLB - I - BUG 18423 COjo la moneda del producto
                           ,
                                                                NULL,
                                                                NULL,
                                                                NULL,
                                                                NULL,
                                                                NULL,
                                                                NULL,
                                                                NULL,
                                                                decimals
                                                               -- JLB - F - BUG 18423 COjo la moneda del producto
                                                               );

                        IF error <> 0
                        THEN
                           -- Si da error la función.
                           CLOSE cur_garansegxrisc;

                           RETURN error;
                        END IF;
                     END IF;

                     -- bug 10864.NMM.01/08/2009. S'elimina un troç de codi.
                     IF xinnomin AND xctipcla = 4
                     THEN
                        xvalorconsorcio := NVL (xcons, 0) * xnasegur1;
                     ELSE
                        xvalorconsorcio := NVL (xcons, 0);
                     END IF;

                     IF xvalorconsorcio IS NOT NULL AND xvalorconsorcio <> 0
                     THEN
                        IF xsegtemporada
                        THEN
                           xvalorconsorcio := xvalorconsorcio * xsegtemp1;
                        -- bug 10864.NMM.01/08/2009. S'elimina un troç de codi.
                        ELSE
                           --JAMF 11903 - Se aplica el fraccionamiento si no es una regularización (6)
                           IF vcfracci = 1 AND ptipomovimiento NOT IN (6)
                           THEN
                              xvalorconsorcio :=
                                              xvalorconsorcio * pfacconsorfra;
                           ELSIF vcfracci = 0 AND ptipomovimiento = 22
                           THEN
                              xvalorconsorcio := 0;
                           ELSE
                              xvalorconsorcio := xvalorconsorcio * pfacconsor;
                           END IF;
                        END IF;

                        IF pcapieve = 1
                        THEN
                           -- APLIQUEM EL TEMPS EN CAPITAL EVENTUAL
                           error :=
                              f_difdata (xfiniefe,
                                         xffinefe,
                                         3,
                                         3,
                                         xdifdiaseve
                                        );

                           IF error = 0
                           THEN
                              xvalorconsorcio :=
                                          xvalorconsorcio * xdifdiaseve / 360;
                           ELSE
                              RETURN (error);
                           END IF;
                        END IF;

                        xorden :=
                           f_ordenconsorcio (1,
                                             xcgarant,
                                             pcramo,
                                             pcmodali,
                                             pccolect,
                                             pctipseg,
                                             pcactivi,
                                             psseguro,
                                             xnriesgo,
                                             pnmovimi,
                                             error
                                            );

                        IF xorden <> 0
                        THEN
                           xvalorconsorcio := 0;
                        END IF;

                        IF NVL (xvalorconsorcio, 0) <> 0
                        THEN
                           -- Bug 12589 - FAL - 31/03/2010 -- 0012589: CEM - Recibos con copago y consorcio
                           IF xctipreb = 4
                           THEN
                              IF pctipapo = 1
                              THEN
                                 FOR vapor IN cur_aportaseg (psseguro,
                                                             pfefecto,
                                                             xnriesgo
                                                            )
                                 LOOP
                                    IF vapor.ctipimp = 1
                                    THEN
                                       xvalorconsorcio :=
                                          f_round (  xvalorconsorcio
                                                   * vapor.pimport
                                                   / 100,
                                                   decimals
                                                  );
                                    ELSIF vapor.ctipimp = 2
                                    THEN
                                       xvalorconsorcio :=
                                          LEAST (xvalorconsorcio,
                                                 vapor.iimport
                                                );
                                    END IF;
                                 END LOOP;
                              ELSIF pctipapo = 2
                              THEN
                                 FOR vapor IN cur_aportaseg (psseguro,
                                                             pfefecto,
                                                             xnriesgo
                                                            )
                                 LOOP
                                    IF vapor.ctipimp = 1
                                    THEN
                                       xvalorconsorcio :=
                                          f_round (  xvalorconsorcio
                                                   * (  1
                                                      - (vapor.pimport / 100
                                                        )
                                                     ),
                                                   decimals
                                                  );
                                    ELSIF vapor.ctipimp = 2
                                    THEN
                                       xvalorconsorcio :=
                                          GREATEST (0,
                                                      xvalorconsorcio
                                                    - vapor.iimport
                                                   );
                                    END IF;
                                 END LOOP;
                              END IF;
                           END IF;

                           -- Fi Bug 12589
                           xvalorconsorcio := f_round (xvalorconsorcio);

                           IF NVL (xvalorconsorcio, 0) <> 0
                           THEN
                              -- Bug 12589 - FAL - 31/03/2010 -- 0012589: CEM - Recibos con copago y consorcio
                              error :=
                                 pac_adm.f_instmpdetrec (pnrecibo,
                                                         2,
                                                         xvalorconsorcio,
                                                         xploccoa,
                                                         xcgarant,
                                                         xnriesgo,
                                                         xctipcoa,
                                                         xcageven,
                                                         xxnmovima
                                                        );

                              IF error = 0
                              THEN
                                 pgrabar := 1;
                              ELSE
                                 CLOSE cur_garansegxrisc;

                                 RETURN error;
                              END IF;
                           END IF;                             -- Fi Bug 12589
                        END IF;
                     END IF;
                  END IF;
               END IF;

               FETCH cur_garansegxrisc
                INTO xnriesgo, xcgarant, xfiniefe, xffinefe, xcageven,
                     xxnmovima, xicapital;
            END LOOP;

            CLOSE cur_garansegxrisc;

            -- bug 10864.NMM.01/08/2009. S'elimina un troç de codi.
            RETURN (0);
-- ********************************************************************************************
         ELSIF ptipomovimiento IN (1, 11)
         THEN
-- SUPLEMENTS MODUS 'R'
-- ********************************************************************************************
            OPEN cur_garansegxrisc;

            FETCH cur_garansegxrisc
             INTO xnriesgo, xcgarant, xfiniefe, xffinefe, xcageven,
                  xxnmovima, xicapital;

            WHILE cur_garansegxrisc%FOUND
            LOOP
               xnasegur1 := 0;
               xnasegur2 := 0;
               xtotcapital := 0;
               xtotcapitalant := 0;
               xcclarie := NULL;
               xcimpcon :=
                  f_esconsorciable (xcgarant,
                                    pcramo,
                                    pcmodali,
                                    pccolect,
                                    pctipseg,
                                    pcactivi,
                                    error
                                   );

               IF error <> 0
               THEN
                  CLOSE cur_garansegxrisc;

                  RETURN error;
               END IF;

               IF xcimpcon = 1
               THEN
                  -- LA GARANTÍA ES CONSORCIABLE
                  --   message('la garantia si tiene consorcio: estamos en suplements');pause;
                  BEGIN
                     SELECT DECODE (nasegur, NULL, 1, nasegur)
                       INTO xnasegur1
                       FROM riesgos
                      WHERE sseguro = psseguro AND nriesgo = NVL (xnriesgo, 1);
                  EXCEPTION
                     WHEN NO_DATA_FOUND
                     THEN
                        CLOSE cur_garansegxrisc;

                        RETURN 103836;            -- RISC NO TROBAT A RIESGOS
                     WHEN OTHERS
                     THEN
                        CLOSE cur_garansegxrisc;

                        RETURN 103509;          -- ERROR AL LLEGIR DE RIESGOS
                  END;

                  existant := TRUE;
                  -- bug 10864.NMM.01/08/2009. S'afegeix una variable.
                  error :=
                     f_concepto (2,
                                 xcempres,
                                 pfefecto,
                                 --NULL,
                                 xcforpag,
                                 --JAMF 11903 - Puede depender de la forma de pago
                                 pcramo,
                                 pcmodali,
                                 pctipseg,
                                 pccolect,
                                 pcactivi,
                                 xcgarant,
                                 xctipcla,
                                 xivalnor,
                                 vcfracci,
                                 vcbonifi,
                                 vcrecfra,
                                 w_climit,
                                 v_cmonimp,
                                 -- BUG 18423 - LCOL000 - Multimoneda
                                 vcderreg
                                );           -- Bug 0020314 - FAL - 29/11/2011
                  --
                  p_tracta_limit (w_climit,
                                  w_cduraci,
                                  w_nduraci,
                                  xcforpag,
                                  pfvencim,
                                  pfefecto,
                                  xsegtemporada,
                                  xmeses,
                                  xsegtemp1,
                                  w_resultat
                                 );

                  IF w_resultat = 103834
                  THEN
                     -- LÍMIT NO TROBAT A LA TAULA LIMITES
                     RETURN (103834);
                  ELSIF w_resultat = 103514
                  THEN
                     -- ERROR AL LLEGIR DE LA TAULA LIMITES
                     RETURN (103514);
                  END IF;

                  -- bug 10864.f.
                  IF error <> 0
                  THEN
                     -- Si da error la función.
                     CLOSE cur_garansegxrisc;

                     RETURN error;
                  ELSE
                     -- Obtenemos la prima, para cuando consorcio sobre prima
                     BEGIN
                        SELECT   SUM (iconcep)
                            INTO iconcep0
                            FROM tmp_adm_detrecibos
                           WHERE nrecibo = pnrecibo
                             AND nriesgo = xnriesgo
                             AND cgarant = xcgarant
                             AND (cconcep = 0 OR cconcep = 50
                                 )                          -- LOCAL +  CEDIDA
                        GROUP BY nriesgo, cgarant;
                     EXCEPTION
                        WHEN NO_DATA_FOUND
                        THEN
                           NULL;
                        WHEN OTHERS
                        THEN
                           CLOSE cur_garansegxrisc;

                           error := 103512;
                           -- ERROR AL LLEGIR DE DETRECIBOS
                           RETURN error;
                     END;

                     -- OBTENIM LA GARANTIA ANTERIOR
                     xcgarantant := NULL;
                     xnriesgoant := NULL;
                     xnmovimiant := NULL;

                     BEGIN
                        SELECT cgarant, nriesgo, nmovimi,
                               finiefe, icapital
                          INTO xcgarantant, xnriesgoant, xnmovimiant,
                               xfiniefeant, xicapitalant
                          FROM garanseg
                         WHERE sseguro = psseguro
                           AND nriesgo = NVL (xnriesgo, nriesgo)
                           AND cgarant = NVL (xcgarant, cgarant)
                           AND nmovimi = pnmovimiant;
                     --  message('ha encontrado garantias anteriores:');pause;
                     --  message('garanant:'||xcgarantant||'riesgoant: '||XNRIESGOANT||'nmovimiant: '||xnmovimiant);pause;
                     EXCEPTION
                        WHEN NO_DATA_FOUND
                        THEN
                           --  message('no existe garantia anterior');pause;
                           existant := FALSE;   -- NO TENIM GARANTIA ANTERIOR
                        WHEN OTHERS
                        THEN
                           CLOSE cur_garansegxrisc;

                           RETURN 103500;      -- ERROR AL LLEGIR DE GARANSEG
                     END;

                     IF xctipcla = 4 AND existant
                     THEN
                        --xicapital := xicapitalant;
                        xicapital := xicapital - xicapitalant;
                     END IF;

                     error :=
                        pac_impuestos.f_calcula_impconcepto (xivalnor,
                                                             iconcep0,
                                                             iconcep0,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             xicapital,
                                                             NULL,
                                                             NULL,
                                                             xctipcla,
                                                             xcforpag,
                                                             vcfracci,
                                                             vcbonifi,
                                                             vcrecfra,
                                                             xcons
                                                                  -- JLB - I - BUG 18423 COjo la moneda del producto
                        ,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             decimals
                                                            -- JLB - F - BUG 18423 COjo la moneda del producto
                                                            );

                     IF error <> 0
                     THEN
                        -- Si da error la función.
                        CLOSE cur_garansegxrisc;

                        RETURN error;
                     END IF;

                     IF xctipcla = 2 AND existant
                     THEN
                        xcons := 0;
                     END IF;

                     -- bug 10864.NMM.01/08/2009. S'elimina un troç de codi.
                     IF xinnomin
                     THEN
                        xvalorconsorcio := NVL (xcons, 0) * xnasegur1;
                     ELSE
                        xvalorconsorcio := NVL (xcons, 0);
                     END IF;

                     IF xvalorconsorcio IS NOT NULL AND xvalorconsorcio <> 0
                     THEN
                        --  MESSAGE('ENTREM AL PRORRATEO DEL CONSORCI. VALOR CONSORCI: '||XVALORCONSORCIO);PAUSE;
                        IF xsegtemporada
                        THEN
                           xvalorconsorcio := xvalorconsorcio * xsegtemp1;

                           IF xmeses > 12
                           THEN
                              -- ES HASTA EL VENCIMIENTO Y SUPERIOR AL AÑO
                              error :=
                                 f_difdata (pfefecto, pfvencim, 3, 3,
                                            xresult);

                              IF error = 0
                              THEN
                                 IF xctipcla = 2
                                 THEN
                                    -- ES IMPORTE FIJO
                                    xvalorconsorcio :=
                                       xvalorconsorcio * CEIL (xresult / 360);
                                 ELSIF xctipcla = 4
                                 THEN
                                    -- ES SOBRE EL CAPITAL
                                    xvalorconsorcio :=
                                              xvalorconsorcio * xresult / 360;
                                 ELSE
                                    NULL;
                                 END IF;
                              ELSE
                                 RETURN error;
                              END IF;
                           END IF;
                        ELSE
                           --JAMF 11903 - Dejamos las diferencias de provisión como estaban
                           IF vcfracci = 1 AND ptipomovimiento NOT IN (11)
                           THEN
                              xvalorconsorcio :=
                                      NVL (xvalorconsorcio, 0)
                                      * pfacconsorfra;
                           ELSE
                              xvalorconsorcio :=
                                         NVL (xvalorconsorcio, 0)
                                         * pfacconsor;
                           END IF;
                        END IF;

                        IF NVL (xvalorconsorcio, 0) <> 0
                        THEN
                           xinsert := TRUE;

                           IF paltarisc
                           THEN
                              -- ES UN SUPLEMENT DE ALTA
                              BEGIN
                                 SELECT nmovima
                                   INTO xnmovima
                                   FROM riesgos
                                  WHERE sseguro = psseguro
                                    AND nriesgo = xnriesgo
                                    AND nmovima = pnmovimi;

                                 xinsert := TRUE;
                              EXCEPTION
                                 WHEN NO_DATA_FOUND
                                 THEN
                                    xinsert := FALSE;
                                 WHEN OTHERS
                                 THEN
                                    CLOSE cur_garansegxrisc;

                                    RETURN 103509;
                              -- ERROR AL LLEGIR DE RIESGOS
                              END;
                           END IF;

                           xorden :=
                              f_ordenconsorcio (1,
                                                xcgarant,
                                                pcramo,
                                                pcmodali,
                                                pccolect,
                                                pctipseg,
                                                pcactivi,
                                                psseguro,
                                                xnriesgo,
                                                pnmovimi,
                                                error
                                               );

                           IF xorden <> 0
                           THEN
                              xvalorconsorcio := 0;
                           END IF;

                           IF xinsert
                           THEN
                              -- Bug 12589 - FAL - 31/03/2010 -- 0012589: CEM - Recibos con copago y consorcio
                              IF xctipreb = 4
                              THEN
                                 IF pctipapo = 1
                                 THEN
                                    FOR vapor IN cur_aportaseg (psseguro,
                                                                pfefecto,
                                                                xnriesgo
                                                               )
                                    LOOP
                                       IF vapor.ctipimp = 1
                                       THEN
                                          xvalorconsorcio :=
                                             f_round (  xvalorconsorcio
                                                      * vapor.pimport
                                                      / 100,
                                                      decimals
                                                     );
                                       ELSIF vapor.ctipimp = 2
                                       THEN
                                          xvalorconsorcio :=
                                             LEAST (xvalorconsorcio,
                                                    vapor.iimport
                                                   );
                                       END IF;
                                    END LOOP;
                                 ELSIF pctipapo = 2
                                 THEN
                                    FOR vapor IN cur_aportaseg (psseguro,
                                                                pfefecto,
                                                                xnriesgo
                                                               )
                                    LOOP
                                       IF vapor.ctipimp = 1
                                       THEN
                                          xvalorconsorcio :=
                                             f_round (  xvalorconsorcio
                                                      * (  1
                                                         - (vapor.pimport
                                                            / 100
                                                           )
                                                        ),
                                                      decimals
                                                     );
                                       ELSIF vapor.ctipimp = 2
                                       THEN
                                          xvalorconsorcio :=
                                             GREATEST (0,
                                                         xvalorconsorcio
                                                       - vapor.iimport
                                                      );
                                       END IF;
                                    END LOOP;
                                 END IF;
                              END IF;

                              -- Fi Bug 12589
                              xvalorconsorcio := f_round (xvalorconsorcio);

                              IF NVL (xvalorconsorcio, 0) <> 0
                              THEN
                                 -- Bug 12589 - FAL - 31/03/2010 -- 0012589: CEM - Recibos con copago y consorcio
                                 error :=
                                    f_insdetrec (pnrecibo,
                                                 2,
                                                 xvalorconsorcio,
                                                 xploccoa,
                                                 xcgarant,
                                                 xnriesgo,
                                                 xctipcoa,
                                                 xcageven,
                                                 xxnmovima,
                                                 0,
                                                 0,
                                                 1,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 decimals
                                                );

                                 -- BUG 18423 - 27/12/2011 - JLB - LCOL000 - Multimoneda
                                 IF error = 0
                                 THEN
                                    pgrabar := 1;
                                 ELSE
                                    CLOSE cur_garansegxrisc;

                                    RETURN error;
                                 END IF;
                              END IF;                          -- Fi Bug 12589
                           END IF;
                        END IF;
                     END IF;
                  END IF;
               END IF;

               FETCH cur_garansegxrisc
                INTO xnriesgo, xcgarant, xfiniefe, xffinefe, xcageven,
                     xxnmovima, xicapital;
            END LOOP;

            CLOSE cur_garansegxrisc;

            -- ARA BUSCAREM LES GARANTIES QUE ESTAVEN EN (FEFECTO-1) I ARA NO ESTAN
            OPEN cur_garansegant;

            FETCH cur_garansegant
             INTO xcgarant, xnriesgo, xfiniefe, xffinefe, xcageven, xxnmovima,
                  xicapital;

            WHILE cur_garansegant%FOUND
            LOOP
               xnasegur1 := 0;
               xnasegur2 := 0;
               xtotcapital := 0;
               xtotcapitalant := 0;
               xcclarie := NULL;
               xcimpcon :=
                  f_esconsorciable (xcgarant,
                                    pcramo,
                                    pcmodali,
                                    pccolect,
                                    pctipseg,
                                    pcactivi,
                                    error
                                   );

               IF error <> 0
               THEN
                  CLOSE cur_garansegant;

                  RETURN error;
               END IF;

               IF xcimpcon = 1
               THEN
                  -- LA GARANTÍA ES CONSORCIABLE
                  --MESSAGE('GARANTIA CONSORCIABLE');
                  -- bug 10864.NMM.01/08/2009. S'afegeix una variable.
                  error :=
                     f_concepto (2,
                                 xcempres,
                                 pfefecto,
                                 --NULL,
                                 xcforpag,
                                 --JAMF 11903 - Puede depender de la forma de pago
                                 pcramo,
                                 pcmodali,
                                 pctipseg,
                                 pccolect,
                                 pcactivi,
                                 xcgarant,
                                 xctipcla,
                                 xivalnor,
                                 vcfracci,
                                 vcbonifi,
                                 vcrecfra,
                                 w_climit,
                                 v_cmonimp,
                                 -- BUG 18423 - LCOL000 - Multimoneda
                                 vcderreg
                                );           -- Bug 0020314 - FAL - 29/11/2011
                  --
                  p_tracta_limit (w_climit,
                                  w_cduraci,
                                  w_nduraci,
                                  xcforpag,
                                  pfvencim,
                                  pfefecto,
                                  xsegtemporada,
                                  xmeses,
                                  xsegtemp1,
                                  w_resultat
                                 );

                  IF w_resultat = 103834
                  THEN
                     -- LÍMIT NO TROBAT A LA TAULA LIMITES
                     RETURN (103834);
                  ELSIF w_resultat = 103514
                  THEN
                     -- ERROR AL LLEGIR DE LA TAULA LIMITES
                     RETURN (103514);
                  END IF;

                  -- bug 10864.f.
                  IF error <> 0
                  THEN
                     CLOSE cur_garansegant;

                     RETURN error;
                  END IF;

                  -- MIREM SI EXISTEIX LA GARANTIA ACTUALMENT
                  xcgarantseg := NULL;
                  xnriesgoseg := NULL;
                  xnmovimiseg := NULL;

                  BEGIN
                     SELECT cgarant, nriesgo, nmovimi,
                            xicapital
                       INTO xcgarantseg, xnriesgoseg, xnmovimiseg,
                            xicapitalseg
                       FROM garanseg
                      WHERE sseguro = psseguro
                        AND nriesgo = NVL (xnriesgo, nriesgo)
                        AND cgarant = NVL (xcgarant, cgarant)
                        AND nmovimi = pnmovimi;

                     xgrabar := 0;                             -- QUE NO GRABI
                  EXCEPTION
                     WHEN NO_DATA_FOUND
                     THEN
                        xgrabar := 1;   -- NO EXISTEIX LA GARANTIA ACTUALMENT
                     WHEN OTHERS
                     THEN
                        CLOSE cur_garansegant;

                        RETURN 103500;         -- ERROR AL LLEGIR DE GARANSEG
                  END;

                  IF xgrabar = 1
                  THEN
                     -- NO EXISTEIX LA GARANTIA ACTUALMENT
                     -- Obtenemos la prima, para consorcio sobre prima
                     BEGIN
                        SELECT   SUM (iconcep)
                            INTO iconcep0
                            FROM detrecibos
                           WHERE nrecibo = pnrecibo
                             AND nriesgo = xnriesgo
                             AND cgarant = xcgarant
                             AND (cconcep = 0 OR cconcep = 50
                                 )                          -- LOCAL +  CEDIDA
                        GROUP BY nriesgo, cgarant;
                     EXCEPTION
                        WHEN NO_DATA_FOUND
                        THEN
                           NULL;
                        WHEN OTHERS
                        THEN
                           CLOSE cur_garansegxrisc;

                           error := 103512;
                           -- ERROR AL LLEGIR DE DETRECIBOS
                           RETURN error;
                     END;

                     error :=
                        pac_impuestos.f_calcula_impconcepto (xivalnor,
                                                             iconcep0,
                                                             iconcep0,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             xicapital,
                                                             -- Capital anterior.
                                                             NULL,
                                                             NULL,
                                                             xctipcla,
                                                             xcforpag,
                                                             vcfracci,
                                                             vcbonifi,
                                                             vcrecfra,
                                                             xcons
                                                                  -- JLB - I - BUG 18423 COjo la moneda del producto
                        ,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             decimals
                                                            -- JLB - F - BUG 18423 COjo la moneda del producto
                                                            );

                     IF error <> 0
                     THEN
                        -- Si da error la función.
                        CLOSE cur_garansegxrisc;

                        RETURN error;
                     END IF;

                     -- bug 10864.NMM.01/08/2009. S'elimina un troç de codi.
                     IF xinnomin AND xctipcla = 4
                     THEN
                        xvalorconsorcio := NVL (xcons, 0) * xnasegur1;
                     ELSE
                        xvalorconsorcio := NVL (xcons, 0);
                     END IF;

                     IF xvalorconsorcio IS NOT NULL AND xvalorconsorcio <> 0
                     THEN
                        IF xsegtemporada
                        THEN
                           xvalorconsorcio := xvalorconsorcio * xsegtemp1;

                           IF xmeses > 12
                           THEN
                              -- ES HASTA EL VENCIMIENTO Y SUPERIOR AL AÑO
                              error :=
                                 f_difdata (pfefecto, pfvencim, 3, 3,
                                            xresult);

                              IF error = 0
                              THEN
                                 IF xctipcla = 2
                                 THEN
                                    -- ES IMPORTE FIJO
                                    xvalorconsorcio :=
                                       xvalorconsorcio * CEIL (xresult / 360);
                                 ELSIF xctipcla = 4
                                 THEN
                                    -- ES SOBRE EL CAPITAL
                                    xvalorconsorcio :=
                                              xvalorconsorcio * xresult / 360;
                                 ELSE
                                    NULL;
                                 END IF;
                              ELSE
                                 RETURN error;
                              END IF;
                           END IF;
                        ELSE
                           --JAMF 11903 - Dejamos las diferencias de provisión como estaban
                           IF vcfracci = 1 AND ptipomovimiento NOT IN (11)
                           THEN
                              xvalorconsorcio :=
                                      NVL (xvalorconsorcio, 0)
                                      * pfacconsorfra;
                           ELSE
                              xvalorconsorcio :=
                                         NVL (xvalorconsorcio, 0)
                                         * pfacconsor;
                           END IF;
                        END IF;

                        xorden :=
                           f_ordenconsorcio (1,
                                             xcgarant,
                                             pcramo,
                                             pcmodali,
                                             pccolect,
                                             pctipseg,
                                             pcactivi,
                                             psseguro,
                                             xnriesgo,
                                             pnmovimiant,
                                             error
                                            );

                        IF xorden <> 0
                        THEN
                           xvalorconsorcio := 0;
                        END IF;

                        IF NVL (xvalorconsorcio, 0) <> 0
                        THEN
                           -- Bug 12589 - FAL - 31/03/2010 -- 0012589: CEM - Recibos con copago y consorcio
                           IF xctipreb = 4
                           THEN
                              IF pctipapo = 1
                              THEN
                                 FOR vapor IN cur_aportaseg (psseguro,
                                                             pfefecto,
                                                             xnriesgo
                                                            )
                                 LOOP
                                    IF vapor.ctipimp = 1
                                    THEN
                                       xvalorconsorcio :=
                                          f_round (  xvalorconsorcio
                                                   * vapor.pimport
                                                   / 100,
                                                   decimals
                                                  );
                                    ELSIF vapor.ctipimp = 2
                                    THEN
                                       xvalorconsorcio :=
                                          LEAST (xvalorconsorcio,
                                                 vapor.iimport
                                                );
                                    END IF;
                                 END LOOP;
                              ELSIF pctipapo = 2
                              THEN
                                 FOR vapor IN cur_aportaseg (psseguro,
                                                             pfefecto,
                                                             xnriesgo
                                                            )
                                 LOOP
                                    IF vapor.ctipimp = 1
                                    THEN
                                       xvalorconsorcio :=
                                          f_round (  xvalorconsorcio
                                                   * (  1
                                                      - (vapor.pimport / 100
                                                        )
                                                     ),
                                                   decimals
                                                  );
                                    ELSIF vapor.ctipimp = 2
                                    THEN
                                       xvalorconsorcio :=
                                          GREATEST (0,
                                                      xvalorconsorcio
                                                    - vapor.iimport
                                                   );
                                    END IF;
                                 END LOOP;
                              END IF;
                           END IF;

                           -- Fi Bug 12589
                           xvalorconsorcio := f_round (xvalorconsorcio);

                           IF NVL (xvalorconsorcio, 0) <> 0
                           THEN
                              -- Bug 12589 - FAL - 31/03/2010 -- 0012589: CEM - Recibos con copago y consorcio
                              error :=
                                 pac_adm.f_instmpdetrec (pnrecibo,
                                                         2,
                                                         xvalorconsorcio,
                                                         xploccoa,
                                                         xcgarant,
                                                         xnriesgo,
                                                         xctipcoa,
                                                         xcageven,
                                                         xxnmovima
                                                        );

                              IF error = 0
                              THEN
                                 pgrabar := 1;
                              ELSE
                                 CLOSE cur_garansegant;

                                 RETURN error;
                              END IF;
                           END IF;                             -- Fi Bug 12589
                        END IF;
                     END IF;
                  END IF;                                    -- IF DEL XGRABAR
               END IF;

               FETCH cur_garansegant
                INTO xcgarant, xnriesgo, xfiniefe, xffinefe, xcageven,
                     xxnmovima, xicapital;
            END LOOP;

            CLOSE cur_garansegant;

            -- bug 10864.NMM.01/08/2009. S'elimina un troç de codi.
            RETURN (0);
--*****************************************************************
-- FI SUPLEMENTS PER MODUS 'R'
--*****************************************************************

         --JAMF 11903 - Ahora sí que se calcula consorcio en la cartera no anual si el consorcio es fraccionado
         --ELSIF ptipomovimiento = 22 THEN   -- RENOVACIONS NO ANUALS
         --   RETURN 0;   -- AQUÍ NO ES CALCULA EL CONSORCI
         ELSE
            RETURN 101901;        -- PAS DE PARÀMETRES INCORRECTE A LA FUNCIÓ
         END IF;
      /* ***** */
      -- FINS AQUÍ HEM TRACTAT SI EL PCMODO ÉS 'R'
      /* ***** */
      ELSIF pcmodo IN ('P', 'N', 'PRIE')
      THEN
         IF ptipomovimiento IN (0, 6)
         THEN
            IF pfuncion = 'CAR'
            THEN
               vselect :=
                     'SELECT nriesgo, cgarant, finiefe, ffinefe, icapital'
                  || ' FROM garanseg'
                  || ' WHERE sseguro = '
                  || psseguro
                  || '  AND nmovimi = '
                  || pnmovimi;

               IF pnriesgo IS NOT NULL
               THEN
                  vselect := vselect || ' AND nriesgo = ' || pnriesgo;
               END IF;
            ELSIF pfuncion = 'TAR'
            THEN
               vselect :=
                     'SELECT nriesgo, cgarant, finiefe, ffinefe, icapital'
                  || ' FROM tmp_garancar'
                  || ' WHERE sseguro = '
                  || psseguro;

               IF pnriesgo IS NOT NULL
               THEN
                  vselect := vselect || ' AND nriesgo = ' || pnriesgo;
               END IF;
            END IF;

            OPEN curgaran FOR vselect;

            --         OPEN cur_garansegxrisc;

            --         FETCH cur_garansegxrisc
            FETCH curgaran
             INTO xnriesgo, xcgarant, xfiniefe, xffinefe, xicapital;

            WHILE curgaran%FOUND
            LOOP
               xnasegur1 := 0;
               xnasegur2 := 0;
               xcclarie := NULL;
               xcimpcon :=
                  f_esconsorciable (xcgarant,
                                    pcramo,
                                    pcmodali,
                                    pccolect,
                                    pctipseg,
                                    pcactivi,
                                    error
                                   );

               IF error <> 0
               THEN
                  CLOSE curgaran;

                  RETURN error;
               END IF;

               IF xcimpcon = 1
               THEN
                  -- LA GARANTÍA ES CONSORCIABLE
                  -- bug 10864.NMM.01/08/2009. S'afegeix una variable.
                  error :=
                     f_concepto (2,
                                 xcempres,
                                 pfefecto,
                                 --NULL,
                                 xcforpag,
                                 --JAMF 11903 - Puede depender de la forma de pago
                                 pcramo,
                                 pcmodali,
                                 pctipseg,
                                 pccolect,
                                 pcactivi,
                                 xcgarant,
                                 xctipcla,
                                 xivalnor,
                                 vcfracci,
                                 vcbonifi,
                                 vcrecfra,
                                 w_climit,
                                 v_cmonimp,
                                 -- BUG 18423 - LCOL000 - Multimoneda
                                 vcderreg
                                );           -- Bug 0020314 - FAL - 29/11/2011
                  --
                  p_tracta_limit (w_climit,
                                  w_cduraci,
                                  w_nduraci,
                                  xcforpag,
                                  pfvencim,
                                  pfefecto,
                                  xsegtemporada,
                                  xmeses,
                                  xsegtemp1,
                                  w_resultat
                                 );

                  IF w_resultat = 103834
                  THEN
                     -- LÍMIT NO TROBAT A LA TAULA LIMITES
                     RETURN (103834);
                  ELSIF w_resultat = 103514
                  THEN
                     -- ERROR AL LLEGIR DE LA TAULA LIMITES
                     RETURN (103514);
                  END IF;

                  -- bug 10864.f.
                  IF error <> 0
                  THEN
                     CLOSE curgaran;

                     RETURN error;
                  END IF;

                  BEGIN
                     SELECT   SUM (iconcep)
                         INTO iconcep0
                         FROM tmp_adm_detrecibos
                        WHERE nrecibo = pnrecibo
                          AND nriesgo = xnriesgo
                          AND cgarant = xcgarant
                          AND (cconcep IN (0, 50))          -- LOCAL +  CEDIDA
                     GROUP BY nriesgo, cgarant;
                  EXCEPTION
                     WHEN NO_DATA_FOUND
                     THEN
                        NULL;
                     WHEN OTHERS
                     THEN
                        CLOSE curgaran;

                        error := 103516;
                        -- ERROR AL LLEGIR DE DETRECIBOSCAR
                        RETURN error;
                  END;

                  error :=
                     pac_impuestos.f_calcula_impconcepto (xivalnor,
                                                          iconcep0,
                                                          iconcep0,
                                                          NULL,
                                                          NULL,
                                                          NULL,
                                                          xicapital,
                                                          -- Capital anterior.
                                                          NULL,
                                                          NULL,
                                                          xctipcla,
                                                          xcforpag,
                                                          vcfracci,
                                                          vcbonifi,
                                                          vcrecfra,
                                                          xcons
                                                               -- JLB - I - BUG 18423 COjo la moneda del producto
                     ,
                                                          NULL,
                                                          NULL,
                                                          NULL,
                                                          NULL,
                                                          NULL,
                                                          NULL,
                                                          NULL,
                                                          decimals
                                                         -- JLB - F - BUG 18423 COjo la moneda del producto
                                                         );

                  -- bug 10864.NMM.01/08/2009. S'elimina un troç de codi.
                  IF xinnomin AND xctipcla IN (2, 4)
                  THEN
                     xvalorconsorcio := NVL (xcons, 0) * xnasegur1;
                  ELSE
                     xvalorconsorcio := NVL (xcons, 0);
                  END IF;

                  IF pttabla = 'SOL'
                  THEN
                     BEGIN
                        SELECT DECODE (nasegur, NULL, 1, nasegur)
                          INTO xnasegur1
                          FROM solriesgos
                         WHERE ssolicit = psseguro
                           AND nriesgo = NVL (xnriesgo, 1);
                     EXCEPTION
                        WHEN NO_DATA_FOUND
                        THEN
                           CLOSE curgaran;

                           RETURN 103836;         -- RISC NO TROBAT A RIESGOS
                        WHEN OTHERS
                        THEN
                           CLOSE curgaran;

                           RETURN 103509;       -- ERROR AL LLEGIR DE RIESGOS
                     END;
                  ELSIF pttabla = 'EST'
                  THEN
                     BEGIN
                        SELECT DECODE (nasegur, NULL, 1, nasegur)
                          INTO xnasegur1
                          FROM estriesgos
                         WHERE sseguro = psseguro
                           AND nriesgo = NVL (xnriesgo, 1);
                     EXCEPTION
                        WHEN NO_DATA_FOUND
                        THEN
                           CLOSE curgaran;

                           RETURN 103836;         -- RISC NO TROBAT A RIESGOS
                        WHEN OTHERS
                        THEN
                           CLOSE curgaran;

                           RETURN 103509;       -- ERROR AL LLEGIR DE RIESGOS
                     END;
                  ELSE
                     BEGIN
                        SELECT DECODE (nasegur, NULL, 1, nasegur)
                          INTO xnasegur1
                          FROM riesgos
                         WHERE sseguro = psseguro
                           AND nriesgo = NVL (xnriesgo, 1);
                     EXCEPTION
                        WHEN NO_DATA_FOUND
                        THEN
                           CLOSE curgaran;

                           RETURN 103836;         -- RISC NO TROBAT A RIESGOS
                        WHEN OTHERS
                        THEN
                           CLOSE curgaran;

                           RETURN 103509;       -- ERROR AL LLEGIR DE RIESGOS
                     END;
                  END IF;

                  IF xvalorconsorcio IS NOT NULL AND xvalorconsorcio <> 0
                  THEN
                     IF xsegtemporada
                     THEN
                        xvalorconsorcio := xvalorconsorcio * xsegtemp1;

                        IF xmeses > 12
                        THEN
                           -- ES HASTA EL VENCIMIENTO Y SUPERIOR AL AÑO
                           error :=
                                f_difdata (pfefecto, pfvencim, 3, 3, xresult);

                           IF error = 0
                           THEN
                              IF xctipcla = 2
                              THEN
                                 -- ES IMOPORTE FIJO
                                 xvalorconsorcio :=
                                       xvalorconsorcio * CEIL (xresult / 360);
                              ELSIF xctipcla = 4
                              THEN
                                 -- ES SOBRE EL CAPITAL
                                 xvalorconsorcio :=
                                              xvalorconsorcio * xresult / 360;
                              ELSE
                                 NULL;
                              END IF;
                           ELSE
                              RETURN error;
                           END IF;
                        END IF;
                     ELSE
                        --JAMF 11903 - Se aplica el fraccionamiento si no es una regularización (6)
                        IF vcfracci = 1 AND ptipomovimiento NOT IN (6)
                        THEN
                           xvalorconsorcio := xvalorconsorcio * pfacconsorfra;
                        ELSE
                           xvalorconsorcio := xvalorconsorcio * pfacconsor;
                        END IF;
                     END IF;

                     IF pcapieve = 1
                     THEN
                        -- APLIQUEM EL TEMPS EN CAPITAL EVENTUAL
                        error :=
                            f_difdata (xfiniefe, xffinefe, 3, 3, xdifdiaseve);

                        IF error = 0
                        THEN
                           xvalorconsorcio :=
                                          xvalorconsorcio * xdifdiaseve / 360;
                        ELSE
                           RETURN error;
                        END IF;
                     END IF;

                     xorden :=
                        f_ordenconsorcio (1,
                                          xcgarant,
                                          pcramo,
                                          pcmodali,
                                          pccolect,
                                          pctipseg,
                                          pcactivi,
                                          psseguro,
                                          xnriesgo,
                                          pnmovimi,
                                          error
                                         );

                     IF xorden <> 0
                     THEN
                        xvalorconsorcio := 0;
                     END IF;

                     IF NVL (xvalorconsorcio, 0) <> 0
                     THEN
                        -- Bug 12589 - FAL - 31/03/2010 -- 0012589: CEM - Recibos con copago y consorcio
                        IF xctipreb = 4
                        THEN
                           IF pctipapo = 1
                           THEN
                              FOR vapor IN cur_aportaseg (psseguro,
                                                          pfefecto,
                                                          xnriesgo
                                                         )
                              LOOP
                                 IF vapor.ctipimp = 1
                                 THEN
                                    xvalorconsorcio :=
                                       f_round (  xvalorconsorcio
                                                * vapor.pimport
                                                / 100,
                                                decimals
                                               );
                                 ELSIF vapor.ctipimp = 2
                                 THEN
                                    xvalorconsorcio :=
                                       LEAST (xvalorconsorcio, vapor.iimport);
                                 END IF;
                              END LOOP;
                           ELSIF pctipapo = 2
                           THEN
                              FOR vapor IN cur_aportaseg (psseguro,
                                                          pfefecto,
                                                          xnriesgo
                                                         )
                              LOOP
                                 IF vapor.ctipimp = 1
                                 THEN
                                    xvalorconsorcio :=
                                       f_round (  xvalorconsorcio
                                                * (1 - (vapor.pimport / 100)
                                                  ),
                                                decimals
                                               );
                                 ELSIF vapor.ctipimp = 2
                                 THEN
                                    xvalorconsorcio :=
                                       GREATEST (0,
                                                   xvalorconsorcio
                                                 - vapor.iimport
                                                );
                                 END IF;
                              END LOOP;
                           END IF;
                        END IF;

                        -- Fi Bug 12589
                        xvalorconsorcio := f_round (xvalorconsorcio);

                        IF NVL (xvalorconsorcio, 0) <> 0
                        THEN
                           -- Bug 12589 - FAL - 31/03/2010 -- 0012589: CEM - Recibos con copago y consorcio
                           error :=
                              pac_adm.f_instmpdetrec (pnrecibo,
                                                      2,
                                                      xvalorconsorcio,
                                                      xploccoa,
                                                      xcgarant,
                                                      xnriesgo,
                                                      xctipcoa,
                                                      xcageven,
                                                      xxnmovima
                                                     );

                           IF error = 0
                           THEN
                              pgrabar := 1;
                           ELSE
                              CLOSE curgaran;

                              RETURN error;
                           END IF;
                        END IF;                                -- Fi Bug 12589
                     END IF;
                  END IF;
               END IF;

               FETCH curgaran
                INTO xnriesgo, xcgarant, xfiniefe, xffinefe, xicapital;
            END LOOP;

            CLOSE curgaran;

            -- bug 10864.NMM.01/08/2009. S'elimina un troç de codi.
            RETURN (0);
         ELSIF ptipomovimiento = 1
         THEN
            -- SUPLEMENTS
            OPEN cur_garansegxrisc;

            FETCH cur_garansegxrisc
             INTO xnriesgo, xcgarant, xfiniefe, xffinefe, xcageven,
                  xxnmovima, xicapital;

            WHILE cur_garansegxrisc%FOUND
            LOOP
               xnasegur1 := 0;
               xnasegur2 := 0;
               xtotcapital := 0;
               xtotcapitalant := 0;
               existant := TRUE;
               xcclarie := NULL;
               xcimpcon :=
                  f_esconsorciable (xcgarant,
                                    pcramo,
                                    pcmodali,
                                    pccolect,
                                    pctipseg,
                                    pcactivi,
                                    error
                                   );

               IF error <> 0
               THEN
                  CLOSE cur_garansegxrisc;

                  RETURN error;
               END IF;

               IF xcimpcon = 1
               THEN
                  -- LA GARANTÍA ES CONSORCIABLE
                  -- bug 10864.NMM.01/08/2009. S'afegeix una variable.
                  error :=
                     f_concepto (2,
                                 xcempres,
                                 pfefecto,
                                 --NULL,
                                 xcforpag,
                                 --JAMF 11903 - Puede depender de la forma de pago
                                 pcramo,
                                 pcmodali,
                                 pctipseg,
                                 pccolect,
                                 pcactivi,
                                 xcgarant,
                                 xctipcla,
                                 xivalnor,
                                 vcfracci,
                                 vcbonifi,
                                 vcrecfra,
                                 w_climit,
                                 v_cmonimp,
                                 -- BUG 18423 - LCOL000 - Multimoneda
                                 vcderreg
                                );           -- Bug 0020314 - FAL - 29/11/2011
                  --
                  p_tracta_limit (w_climit,
                                  w_cduraci,
                                  w_nduraci,
                                  xcforpag,
                                  pfvencim,
                                  pfefecto,
                                  xsegtemporada,
                                  xmeses,
                                  xsegtemp1,
                                  w_resultat
                                 );

                  IF w_resultat = 103834
                  THEN
                     -- LÍMIT NO TROBAT A LA TAULA LIMITES
                     RETURN (103834);
                  ELSIF w_resultat = 103514
                  THEN
                     -- ERROR AL LLEGIR DE LA TAULA LIMITES
                     RETURN (103514);
                  END IF;

                  -- bug 10864.f.
                  IF error <> 0
                  THEN
                     CLOSE cur_garansegxrisc;

                     RETURN error;
                  END IF;

                  -- OBTENIM LA GARANTIA ANTERIOR
                  xcgarantant := NULL;
                  xnriesgoant := NULL;
                  xnmovimiant := NULL;

                  BEGIN
                     SELECT cgarant, nriesgo, nmovimi,
                            finiefe, icapital
                       INTO xcgarantant, xnriesgoant, xnmovimiant,
                            xfiniefeant, xicapitalant
                       FROM garanseg
                      WHERE sseguro = psseguro
                        AND nriesgo = NVL (xnriesgo, nriesgo)
                        AND cgarant = NVL (xcgarant, cgarant)
                        AND nmovimi = pnmovimiant;
                  EXCEPTION
                     WHEN NO_DATA_FOUND
                     THEN
                        existant := FALSE;      -- NO TENIM GARANTIA ANTERIOR
                     WHEN OTHERS
                     THEN
                        CLOSE cur_garansegxrisc;

                        RETURN 103500;         -- ERROR AL LLEGIR DE GARANSEG
                  END;

                  -- Obtenemos la prima, para cuando consorcio sobre prima
                  BEGIN
                     SELECT   NVL (SUM (iconcep), 0)
                         INTO iconcep0
                         FROM tmp_adm_detrecibos
                        WHERE nrecibo = pnrecibo
                          AND nriesgo = xnriesgo
                          AND cgarant = xcgarant
                          AND (cconcep = 0 OR cconcep = 50
                              )                             -- LOCAL +  CEDIDA
                     GROUP BY nriesgo, cgarant;
                  EXCEPTION
                     WHEN NO_DATA_FOUND
                     THEN
                        NULL;
                     WHEN OTHERS
                     THEN
                        CLOSE cur_garansegxrisc;

                        error := 103516;
                        -- ERROR AL LLEGIR DE DETRECIBOSCAR
                        RETURN error;
                  END;

                  IF xctipcla = 4
                  THEN
                     IF xinnomin
                     THEN
                        -- ES INNOMINAT
                        BEGIN
                           SELECT DECODE (nasegur, NULL, 1, nasegur)
                             INTO xnasegur1
                             FROM riesgos
                            WHERE sseguro = psseguro
                              AND nriesgo = NVL (xnriesgo, 1);
                        EXCEPTION
                           WHEN NO_DATA_FOUND
                           THEN
                              CLOSE cur_garansegxrisc;

                              RETURN 103836;      -- RISC NO TROBAT A RIESGOS
                           WHEN OTHERS
                           THEN
                              CLOSE cur_garansegxrisc;

                              RETURN 103509;    -- ERROR AL LLEGIR DE RIESGOS
                        END;

                        xtotcapital := NVL (xicapital, 0) * xnasegur1;
                     ELSE
                        xtotcapital := NVL (xicapital, 0);
                     END IF;

                     IF existant
                     THEN
                        BEGIN
                           SELECT DECODE (nasegur, NULL, 1, nasegur)
                             INTO xnasegur2
                             FROM riesgos
                            WHERE sseguro = psseguro
                              AND nriesgo = NVL (xnriesgoant, 1);
                        EXCEPTION
                           WHEN NO_DATA_FOUND
                           THEN
                              CLOSE cur_garansegxrisc;

                              RETURN 103836;      -- RISC NO TROBAT A RIESGOS
                           WHEN OTHERS
                           THEN
                              CLOSE cur_garansegxrisc;

                              RETURN 103509;    -- ERROR AL LLEGIR DE RIESGOS
                        END;

                        IF xinnomin
                        THEN
                           -- ES INNOMINAT
                           xtotcapitalant := NVL (xicapitalant, 0)
                                             * xnasegur2;
                        ELSE
                           xtotcapitalant := NVL (xicapitalant, 0);
                        END IF;
                     END IF;
                  ELSE
                     xcapitaltrobat := xicapital;
                  END IF;

                  IF xctipcla = 4 AND existant
                  THEN
                     xcapitaltrobat := xtotcapital - xtotcapitalant;
                  ELSE
                     xcapitaltrobat := xicapital;
                  END IF;

                  error :=
                     pac_impuestos.f_calcula_impconcepto (xivalnor,
                                                          iconcep0,
                                                          iconcep0,
                                                          NULL,
                                                          NULL,
                                                          NULL,
                                                          xcapitaltrobat,
                                                          NULL,
                                                          NULL,
                                                          xctipcla,
                                                          xcforpag,
                                                          vcfracci,
                                                          vcbonifi,
                                                          vcrecfra,
                                                          xcons
                                                               -- JLB - I - BUG 18423 COjo la moneda del producto
                     ,
                                                          NULL,
                                                          NULL,
                                                          NULL,
                                                          NULL,
                                                          NULL,
                                                          NULL,
                                                          NULL,
                                                          decimals
                                                         -- JLB - F - BUG 18423 COjo la moneda del producto
                                                         );

                  IF error <> 0
                  THEN
                     CLOSE cur_garansegxrisc;

                     RETURN error;
                  END IF;

                  IF xctipcla = 2 AND existant
                  THEN
                     xcons := 0;
                  END IF;

                  -- bug 10864.NMM.01/08/2009. S'elimina un troç de codi.
                  xvalorconsorcio := NVL (xcons, 0);

                  IF xvalorconsorcio IS NOT NULL AND xvalorconsorcio <> 0
                  THEN
                     IF xsegtemporada
                     THEN
                        xvalorconsorcio := xvalorconsorcio * xsegtemp1;

                        IF xmeses > 12
                        THEN
                           -- ES HASTA EL VENCIMIENTO Y SUPERIOR AL AÑO
                           error :=
                                f_difdata (pfefecto, pfvencim, 3, 3, xresult);

                           IF error = 0
                           THEN
                              IF xctipcla = 2
                              THEN
                                 -- ES IMPORTE FIJO
                                 xvalorconsorcio :=
                                       xvalorconsorcio * CEIL (xresult / 360);
                              ELSIF xctipcla = 4
                              THEN
                                 -- ES SOBRE EL CAPITAL
                                 xvalorconsorcio :=
                                              xvalorconsorcio * xresult / 360;
                              ELSE
                                 NULL;
                              END IF;
                           ELSE
                              RETURN error;
                           END IF;
                        END IF;
                     ELSE
                        --JAMF 11903
                        IF vcfracci = 1
                        THEN
                           xvalorconsorcio :=
                                      NVL (xvalorconsorcio, 0)
                                      * pfacconsorfra;
                        ELSE
                           xvalorconsorcio :=
                                         NVL (xvalorconsorcio, 0)
                                         * pfacconsor;
                        END IF;
                     END IF;

                     IF NVL (xvalorconsorcio, 0) <> 0
                     THEN
                        xinsert := TRUE;

                        IF paltarisc
                        THEN
                           -- ES UN SUPLEMENT DE ALTA
                           BEGIN
                              SELECT nmovima
                                INTO xnmovima
                                FROM riesgos
                               WHERE sseguro = psseguro
                                 AND nriesgo = xnriesgo
                                 AND nmovima = pnmovimi;

                              xinsert := TRUE;
                           EXCEPTION
                              WHEN NO_DATA_FOUND
                              THEN
                                 xinsert := FALSE;
                              WHEN OTHERS
                              THEN
                                 CLOSE cur_garansegxrisc;

                                 RETURN 103509;
                           -- ERROR AL LLEGIR DE RIESGOS
                           END;
                        END IF;

                        IF xinsert
                        THEN
                           xorden :=
                              f_ordenconsorcio (1,
                                                xcgarant,
                                                pcramo,
                                                pcmodali,
                                                pccolect,
                                                pctipseg,
                                                pcactivi,
                                                psseguro,
                                                xnriesgo,
                                                pnmovimi,
                                                error
                                               );

                           IF xorden <> 0
                           THEN
                              xvalorconsorcio := 0;
                           END IF;

                           -- Bug 12589 - FAL - 31/03/2010 -- 0012589: CEM - Recibos con copago y consorcio
                           IF xctipreb = 4
                           THEN
                              IF pctipapo = 1
                              THEN
                                 FOR vapor IN cur_aportaseg (psseguro,
                                                             pfefecto,
                                                             xnriesgo
                                                            )
                                 LOOP
                                    IF vapor.ctipimp = 1
                                    THEN
                                       xvalorconsorcio :=
                                          f_round (  xvalorconsorcio
                                                   * vapor.pimport
                                                   / 100,
                                                   decimals
                                                  );
                                    ELSIF vapor.ctipimp = 2
                                    THEN
                                       xvalorconsorcio :=
                                          LEAST (xvalorconsorcio,
                                                 vapor.iimport
                                                );
                                    END IF;
                                 END LOOP;
                              ELSIF pctipapo = 2
                              THEN
                                 FOR vapor IN cur_aportaseg (psseguro,
                                                             pfefecto,
                                                             xnriesgo
                                                            )
                                 LOOP
                                    IF vapor.ctipimp = 1
                                    THEN
                                       xvalorconsorcio :=
                                          f_round (  xvalorconsorcio
                                                   * (  1
                                                      - (vapor.pimport / 100
                                                        )
                                                     ),
                                                   decimals
                                                  );
                                    ELSIF vapor.ctipimp = 2
                                    THEN
                                       xvalorconsorcio :=
                                          GREATEST (0,
                                                      xvalorconsorcio
                                                    - vapor.iimport
                                                   );
                                    END IF;
                                 END LOOP;
                              END IF;
                           END IF;

                           -- Fi Bug 12589
                           xvalorconsorcio := f_round (xvalorconsorcio);

                           IF NVL (xvalorconsorcio, 0) <> 0
                           THEN
                              -- Bug 12589 - FAL - 31/03/2010 -- 0012589: CEM - Recibos con copago y consorcio
                              error :=
                                 pac_adm.f_instmpdetrec (pnrecibo,
                                                         2,
                                                         xvalorconsorcio,
                                                         xploccoa,
                                                         xcgarant,
                                                         xnriesgo,
                                                         xctipcoa,
                                                         xcageven,
                                                         xxnmovima
                                                        );

                              IF error = 0
                              THEN
                                 pgrabar := 1;
                              ELSE
                                 CLOSE cur_garansegxrisc;

                                 RETURN error;
                              END IF;
                           END IF;                             -- Fi Bug 12589
                        END IF;
                     END IF;
                  END IF;
               END IF;

               FETCH cur_garansegxrisc
                INTO xnriesgo, xcgarant, xfiniefe, xffinefe, xcageven,
                     xxnmovima, xicapital;
            END LOOP;

            CLOSE cur_garansegxrisc;

            -- ARA BUSCAREM LES GARANTIES QUE ESTAVEN EN (FEFECTO-1) I ARA NO ESTAN
            OPEN cur_garansegant;

            FETCH cur_garansegant
             INTO xcgarant, xnriesgo, xfiniefe, xffinefe, xcageven, xxnmovima,
                  xicapital;

            WHILE cur_garansegant%FOUND
            LOOP
               xnasegur1 := 0;
               xnasegur2 := 0;
               xtotcapital := 0;
               xtotcapitalant := 0;
               xcclarie := NULL;
               xcimpcon :=
                  f_esconsorciable (xcgarant,
                                    pcramo,
                                    pcmodali,
                                    pccolect,
                                    pctipseg,
                                    pcactivi,
                                    error
                                   );

               IF error <> 0
               THEN
                  CLOSE cur_garansegant;

                  RETURN error;
               END IF;

               IF xcimpcon = 1
               THEN
                  -- LA GARANTÍA ES CONSORCIABLE
                  -- bug 10864.NMM.01/08/2009. S'afegeix una variable.
                  error :=
                     f_concepto (2,
                                 xcempres,
                                 pfefecto,
                                 --NULL,
                                 xcforpag,
                                 --JAMF 11903 - Puede depender de la forma de pago
                                 pcramo,
                                 pcmodali,
                                 pctipseg,
                                 pccolect,
                                 pcactivi,
                                 xcgarant,
                                 xctipcla,
                                 xivalnor,
                                 vcfracci,
                                 vcbonifi,
                                 vcrecfra,
                                 w_climit,
                                 v_cmonimp,
                                 -- BUG 18423 - LCOL000 - Multimoneda
                                 vcderreg
                                );           -- Bug 0020314 - FAL - 29/11/2011
                  --
                  p_tracta_limit (w_climit,
                                  w_cduraci,
                                  w_nduraci,
                                  xcforpag,
                                  pfvencim,
                                  pfefecto,
                                  xsegtemporada,
                                  xmeses,
                                  xsegtemp1,
                                  w_resultat
                                 );

                  IF w_resultat = 103834
                  THEN
                     -- LÍMIT NO TROBAT A LA TAULA LIMITES
                     RETURN (103834);
                  ELSIF w_resultat = 103514
                  THEN
                     -- ERROR AL LLEGIR DE LA TAULA LIMITES
                     RETURN (103514);
                  END IF;

                  -- bug 10864.f.
                  IF error <> 0
                  THEN
                     CLOSE cur_garansegant;

                     RETURN error;
                  END IF;

                  -- MIREM SI EXISTEIX LA GARANTIA ACTUALMENT
                  xcgarantseg := NULL;
                  xnriesgoseg := NULL;
                  xnmovimiseg := NULL;
                  xfefectoseg := NULL;

                  BEGIN
                     SELECT cgarant, nriesgo, nmovimi,
                            finiefe, icapital
                       INTO xcgarantseg, xnriesgoseg, xnmovimiseg,
                            xfefectoseg, xicapitalseg
                       FROM garanseg
                      WHERE sseguro = psseguro
                        AND nriesgo = NVL (xnriesgo, nriesgo)
                        AND cgarant = NVL (xcgarant, cgarant)
                        AND nmovimi = pnmovimi;

                     xgrabar := 0;                             -- QUE NO GRABI
                  EXCEPTION
                     WHEN NO_DATA_FOUND
                     THEN
                        xgrabar := 1;            -- NO TENIM GARANTIA SEGUENT
                     WHEN OTHERS
                     THEN
                        CLOSE cur_garansegant;

                        RETURN 103500;         -- ERROR AL LLEGIR DE GARANSEG
                  END;

                  IF xgrabar = 1
                  THEN
                     -- Obtenemos la prima, para cuando consorcio sobre prima
                     BEGIN
                        SELECT   NVL (SUM (iconcep), 0)
                            INTO iconcep0
                            FROM tmp_adm_detrecibos
                           WHERE nrecibo = pnrecibo
                             AND nriesgo = xnriesgo
                             AND cgarant = xcgarant
                             AND (cconcep = 0 OR cconcep = 50
                                 )                          -- LOCAL +  CEDIDA
                        GROUP BY nriesgo, cgarant;
                     EXCEPTION
                        WHEN NO_DATA_FOUND
                        THEN
                           NULL;
                        WHEN OTHERS
                        THEN
                           CLOSE cur_garansegant;

                           error := 103512;
                           -- ERROR AL LLEGIR DE DETRECIBOS
                           RETURN error;
                     END;

                     BEGIN
                        SELECT DECODE (nasegur, NULL, 1, nasegur)
                          INTO xnasegur1
                          FROM riesgos
                         WHERE sseguro = psseguro
                           AND nriesgo = NVL (xnriesgo, 1);
                     EXCEPTION
                        WHEN NO_DATA_FOUND
                        THEN
                           CLOSE cur_garansegant;

                           RETURN 103836;
                        -- RISC NO TROBAT A RIESGOS
                        WHEN OTHERS
                        THEN
                           CLOSE cur_garansegant;

                           RETURN 103509;
                     -- ERROR AL LLEGIR DE RIESGOS
                     END;

                     error :=
                        pac_impuestos.f_calcula_impconcepto (xivalnor,
                                                             iconcep0,
                                                             iconcep0,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             xicapital,
                                                             NULL,
                                                             NULL,
                                                             xctipcla,
                                                             xcforpag,
                                                             vcfracci,
                                                             vcbonifi,
                                                             vcrecfra,
                                                             xcons
                                                                  -- JLB - I - BUG 18423 COjo la moneda del producto
                        ,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             decimals
                                                            -- JLB - F - BUG 18423 COjo la moneda del producto
                                                            );

                     IF error <> 0
                     THEN
                        CLOSE cur_garansegxrisc;

                        RETURN error;
                     END IF;

                     -- bug 10864.NMM.01/08/2009. S'elimina un troç de codi.
                     IF xctipcla = 4
                     THEN
                        -- Hem de retornar el consorci.
                        IF xinnomin
                        THEN
                           xvalorconsorcio := NVL (xcons, 0) * xnasegur1;
                        ELSE
                           xvalorconsorcio := NVL (xcons, 0);
                        END IF;
                     ELSE
                        xvalorconsorcio := 0;
                     -- No hem de retornar el consorci.
                     END IF;

                     IF xvalorconsorcio IS NOT NULL AND xvalorconsorcio <> 0
                     THEN
                        IF xsegtemporada
                        THEN
                           xvalorconsorcio := xvalorconsorcio * xsegtemp1;

                           IF xmeses > 12
                           THEN
                              -- ES HASTA EL VENCIMIENTO Y SUPERIOR AL AÑO
                              error :=
                                 f_difdata (pfefecto, pfvencim, 3, 3,
                                            xresult);

                              IF error = 0
                              THEN
                                 IF xctipcla = 2
                                 THEN
                                    -- ES IMPORTE FIJO
                                    xvalorconsorcio :=
                                       xvalorconsorcio * CEIL (xresult / 360);
                                 ELSIF xctipcla = 4
                                 THEN
                                    -- ES SOBRE EL CAPITAL
                                    xvalorconsorcio :=
                                              xvalorconsorcio * xresult / 360;
                                 ELSE
                                    NULL;
                                 END IF;
                              ELSE
                                 RETURN error;
                              END IF;
                           END IF;
                        ELSE
                           --JAMF 11903
                           IF vcfracci = 1
                           THEN
                              xvalorconsorcio :=
                                      NVL (xvalorconsorcio, 0)
                                      * pfacconsorfra;
                           ELSE
                              xvalorconsorcio :=
                                         NVL (xvalorconsorcio, 0)
                                         * pfacconsor;
                           END IF;
                        END IF;

                        xorden :=
                           f_ordenconsorcio (1,
                                             xcgarant,
                                             pcramo,
                                             pcmodali,
                                             pccolect,
                                             pctipseg,
                                             pcactivi,
                                             psseguro,
                                             xnriesgo,
                                             pnmovimiant,
                                             error
                                            );

                        IF xorden <> 0
                        THEN
                           xvalorconsorcio := 0;
                        END IF;

                        IF NVL (xvalorconsorcio, 0) <> 0
                        THEN
                           -- Bug 12589 - FAL - 31/03/2010 -- 0012589: CEM - Recibos con copago y consorcio
                           IF xctipreb = 4
                           THEN
                              IF pctipapo = 1
                              THEN
                                 FOR vapor IN cur_aportaseg (psseguro,
                                                             pfefecto,
                                                             xnriesgo
                                                            )
                                 LOOP
                                    IF vapor.ctipimp = 1
                                    THEN
                                       xvalorconsorcio :=
                                          f_round (  xvalorconsorcio
                                                   * vapor.pimport
                                                   / 100,
                                                   decimals
                                                  );
                                    ELSIF vapor.ctipimp = 2
                                    THEN
                                       xvalorconsorcio :=
                                          LEAST (xvalorconsorcio,
                                                 vapor.iimport
                                                );
                                    END IF;
                                 END LOOP;
                              ELSIF pctipapo = 2
                              THEN
                                 FOR vapor IN cur_aportaseg (psseguro,
                                                             pfefecto,
                                                             xnriesgo
                                                            )
                                 LOOP
                                    IF vapor.ctipimp = 1
                                    THEN
                                       xvalorconsorcio :=
                                          f_round (  xvalorconsorcio
                                                   * (  1
                                                      - (vapor.pimport / 100
                                                        )
                                                     ),
                                                   decimals
                                                  );
                                    ELSIF vapor.ctipimp = 2
                                    THEN
                                       xvalorconsorcio :=
                                          GREATEST (0,
                                                      xvalorconsorcio
                                                    - vapor.iimport
                                                   );
                                    END IF;
                                 END LOOP;
                              END IF;
                           END IF;

                           -- Fi Bug 12589
                           xvalorconsorcio := f_round (xvalorconsorcio);

                           IF NVL (xvalorconsorcio, 0) <> 0
                           THEN
                              -- Bug 12589 - FAL - 31/03/2010 -- 0012589: CEM - Recibos con copago y consorcio
                              error :=
                                 pac_adm.f_instmpdetrec (pnrecibo,
                                                         2,
                                                         xvalorconsorcio,
                                                         xploccoa,
                                                         xcgarant,
                                                         xnriesgo,
                                                         xctipcoa,
                                                         xcageven,
                                                         xxnmovima
                                                        );

                              IF error = 0
                              THEN
                                 pgrabar := 1;
                              ELSE
                                 CLOSE cur_garansegant;

                                 RETURN error;
                              END IF;
                           END IF;                             -- Fi Bug 12589
                        END IF;
                     END IF;
                  END IF;
               END IF;

               FETCH cur_garansegant
                INTO xcgarant, xnriesgo, xfiniefe, xffinefe, xcageven,
                     xxnmovima, xicapital;
            END LOOP;

            CLOSE cur_garansegant;

            -- bug 10864.NMM.01/08/2009. S'elimina un troç de codi.
            RETURN (0);
         --JAMF 11903 - Ahora sí que se calcula consorcio en la cartera no anual si el consorcio es fraccionado
         --ELSIF ptipomovimiento = 22 THEN   -- RENOVACIONS NO ANUALS
         --   RETURN 0;   -- AQUÍ NO ES CALCULA EL CONSORCI
         ELSIF ptipomovimiento IN (21, 22)
         THEN
            -- RENOVACIONS ANUALS --JAMF 11903 añadimos carteras no anuales
            OPEN cur_garancarxrisc;

            FETCH cur_garancarxrisc
             INTO xnriesgo, xcgarant, xfiniefe, xffinefe, xcageven,
                  xxnmovima, xicapital;

            WHILE cur_garancarxrisc%FOUND
            LOOP
               xnasegur1 := 0;
               xnasegur2 := 0;
               xcclarie := NULL;
               xcimpcon :=
                  f_esconsorciable (xcgarant,
                                    pcramo,
                                    pcmodali,
                                    pccolect,
                                    pctipseg,
                                    pcactivi,
                                    error
                                   );

               IF error <> 0
               THEN
                  CLOSE cur_garancarxrisc;

                  RETURN error;
               END IF;

               IF xcimpcon = 1
               THEN
                  -- LA GARANTÍA ES CONSORCIABLE
                  -- bug 10864.NMM.01/08/2009. S'afegeix una variable.
                  error :=
                     f_concepto (2,
                                 xcempres,
                                 pfefecto,
                                 --NULL,
                                 xcforpag,
                                 --JAMF 11903 - Puede depender de la forma de pago
                                 pcramo,
                                 pcmodali,
                                 pctipseg,
                                 pccolect,
                                 pcactivi,
                                 xcgarant,
                                 xctipcla,
                                 xivalnor,
                                 vcfracci,
                                 vcbonifi,
                                 vcrecfra,
                                 w_climit,
                                 v_cmonimp,
                                 -- BUG 18423 - LCOL000 - Multimoneda
                                 vcderreg
                                );           -- Bug 0020314 - FAL - 29/11/2011
                  --
                  p_tracta_limit (w_climit,
                                  w_cduraci,
                                  w_nduraci,
                                  xcforpag,
                                  pfvencim,
                                  pfefecto,
                                  xsegtemporada,
                                  xmeses,
                                  xsegtemp1,
                                  w_resultat
                                 );

                  IF w_resultat = 103834
                  THEN
                     -- LÍMIT NO TROBAT A LA TAULA LIMITES
                     RETURN (103834);
                  ELSIF w_resultat = 103514
                  THEN
                     -- ERROR AL LLEGIR DE LA TAULA LIMITES
                     RETURN (103514);
                  END IF;

                  -- bug 10864.f.
                  IF error <> 0
                  THEN
                     CLOSE cur_garancarxrisc;

                     RETURN error;
                  END IF;

                  -- Obtenemos la prima, para cuando consorcio sobre prima
                  BEGIN
                     SELECT   NVL (SUM (iconcep), 0)
                         INTO iconcep0
                         FROM tmp_adm_detrecibos
                        WHERE nrecibo = pnrecibo
                          AND nriesgo = xnriesgo
                          AND cgarant = xcgarant
                          AND (cconcep = 0 OR cconcep = 50
                              )                             -- LOCAL +  CEDIDA
                     GROUP BY nriesgo, cgarant;
                  EXCEPTION
                     WHEN NO_DATA_FOUND
                     THEN
                        NULL;
                     WHEN OTHERS
                     THEN
                        CLOSE cur_garansegant;

                        error := 103512;
                        -- ERROR AL LLEGIR DE DETRECIBOS
                        RETURN error;
                  END;

                  BEGIN
                     SELECT DECODE (nasegur, NULL, 1, nasegur)
                       INTO xnasegur1
                       FROM riesgos
                      WHERE sseguro = psseguro AND nriesgo = NVL (xnriesgo, 1);
                  EXCEPTION
                     WHEN NO_DATA_FOUND
                     THEN
                        CLOSE cur_garansegant;

                        RETURN 103836;
                     -- RISC NO TROBAT A RIESGOS
                     WHEN OTHERS
                     THEN
                        CLOSE cur_garansegant;

                        RETURN 103509;
                  -- ERROR AL LLEGIR DE RIESGOS
                  END;

                  error :=
                     pac_impuestos.f_calcula_impconcepto (xivalnor,
                                                          iconcep0,
                                                          iconcep0,
                                                          NULL,
                                                          NULL,
                                                          NULL,
                                                          xicapital,
                                                          NULL,
                                                          NULL,
                                                          xctipcla,
                                                          xcforpag,
                                                          vcfracci,
                                                          vcbonifi,
                                                          vcrecfra,
                                                          xcons
                                                               -- JLB - I - BUG 18423 COjo la moneda del producto
                     ,
                                                          NULL,
                                                          NULL,
                                                          NULL,
                                                          NULL,
                                                          NULL,
                                                          NULL,
                                                          NULL,
                                                          decimals
                                                         -- JLB - F - BUG 18423 COjo la moneda del producto
                                                         );

                  IF error <> 0
                  THEN
                     CLOSE cur_garansegxrisc;

                     RETURN error;
                  END IF;

                  -- bug 10864.NMM.01/08/2009. S'elimina un troç de codi.
                  IF xinnomin AND xctipcla IN (2, 4)
                  THEN
                     xvalorconsorcio := NVL (xcons, 0) * xnasegur1;
                  ELSE
                     xvalorconsorcio := NVL (xcons, 0);
                  END IF;

                  IF xvalorconsorcio IS NOT NULL AND xvalorconsorcio <> 0
                  THEN
                     IF xsegtemporada
                     THEN
                        xvalorconsorcio := xvalorconsorcio * xsegtemp1;

                        IF xmeses > 12
                        THEN
                           -- ES HASTA EL VENCIMIENTO Y SUPERIOR AL AÑO
                           error :=
                                f_difdata (pfefecto, pfvencim, 3, 3, xresult);

                           IF error = 0
                           THEN
                              IF xctipcla = 2
                              THEN
                                 -- ES IMPORTE FIJO
                                 xvalorconsorcio :=
                                       xvalorconsorcio * CEIL (xresult / 360);
                              ELSIF xctipcla = 4
                              THEN
                                 -- ES SOBRE EL CAPITAL
                                 xvalorconsorcio :=
                                              xvalorconsorcio * xresult / 360;
                              ELSE
                                 NULL;
                              END IF;
                           ELSE
                              RETURN error;
                           END IF;
                        END IF;
                     ELSE
                        --JAMF 11903 - No hay consorcio si no es fracionado (sólo en ptipomovimiento =0 o 21)
                        IF vcfracci = 1
                        THEN
                           xvalorconsorcio := xvalorconsorcio * pfacconsorfra;
                        ELSIF vcfracci = 0 AND ptipomovimiento = 22
                        THEN
                           xvalorconsorcio := 0;
                        ELSE
                           xvalorconsorcio := xvalorconsorcio * pfacconsor;
                        END IF;
                     END IF;

                     xorden :=
                        f_ordenconsorcio (2,
                                          xcgarant,
                                          pcramo,
                                          pcmodali,
                                          pccolect,
                                          pctipseg,
                                          pcactivi,
                                          psseguro,
                                          xnriesgo,
                                          pnmovimi,
                                          error
                                         );

                     IF xorden <> 0
                     THEN
                        xvalorconsorcio := 0;
                     END IF;

                     IF NVL (xvalorconsorcio, 0) <> 0
                     THEN
                        -- ******* CONSORCIO *******

                        -- Bug 12589 - FAL - 31/03/2010 -- 0012589: CEM - Recibos con copago y consorcio
                        IF xctipreb = 4
                        THEN
                           IF pctipapo = 1
                           THEN
                              FOR vapor IN cur_aportaseg (psseguro,
                                                          pfefecto,
                                                          xnriesgo
                                                         )
                              LOOP
                                 IF vapor.ctipimp = 1
                                 THEN
                                    xvalorconsorcio :=
                                       f_round (  xvalorconsorcio
                                                * vapor.pimport
                                                / 100,
                                                decimals
                                               );
                                 ELSIF vapor.ctipimp = 2
                                 THEN
                                    xvalorconsorcio :=
                                       LEAST (xvalorconsorcio, vapor.iimport);
                                 END IF;
                              END LOOP;
                           ELSIF pctipapo = 2
                           THEN
                              FOR vapor IN cur_aportaseg (psseguro,
                                                          pfefecto,
                                                          xnriesgo
                                                         )
                              LOOP
                                 IF vapor.ctipimp = 1
                                 THEN
                                    xvalorconsorcio :=
                                       f_round (  xvalorconsorcio
                                                * (1 - (vapor.pimport / 100)
                                                  ),
                                                decimals
                                               );
                                 ELSIF vapor.ctipimp = 2
                                 THEN
                                    xvalorconsorcio :=
                                       GREATEST (0,
                                                   xvalorconsorcio
                                                 - vapor.iimport
                                                );
                                 END IF;
                              END LOOP;
                           END IF;
                        END IF;

                        -- Fi Bug 12589
                        xvalorconsorcio := f_round (xvalorconsorcio);

                        IF NVL (xvalorconsorcio, 0) <> 0
                        THEN
                           -- Bug 12589 - FAL - 31/03/2010 -- 0012589: CEM - Recibos con copago y consorcio
                           error :=
                              pac_adm.f_instmpdetrec (pnrecibo,
                                                      2,
                                                      xvalorconsorcio,
                                                      xploccoa,
                                                      xcgarant,
                                                      xnriesgo,
                                                      xctipcoa,
                                                      xcageven,
                                                      xxnmovima
                                                     );

                           IF error = 0
                           THEN
                              pgrabar := 1;
                           ELSE
                              CLOSE cur_garancarxrisc;

                              RETURN error;
                           END IF;
                        END IF;                                -- Fi Bug 12589
                     END IF;
                  END IF;
               END IF;

               FETCH cur_garancarxrisc
                INTO xnriesgo, xcgarant, xfiniefe, xffinefe, xcageven,
                     xxnmovima, xicapital;
            END LOOP;

            CLOSE cur_garancarxrisc;

            -- bug 10864.NMM.01/08/2009. S'elimina un troç de codi.
            RETURN (0);
         ELSE
            RETURN 101901;        -- PAS DE PARÀMETRES INCORRECTE A LA FUNCIÓ
         END IF;
      ELSE
         RETURN 101901;          -- PAS DE PARÀMETRES INCORRECTES A LA FUNCIÓ
      END IF;
   -- BUG -21546_108724- 08/02/2012 - JLTS - Cierre de posibles cursores abiertos, se adiciona EXCEPTION
   EXCEPTION
      WHEN OTHERS
      THEN
         IF cur_garansegxrisc%ISOPEN
         THEN
            CLOSE cur_garansegxrisc;
         END IF;

         IF cur_garansegant%ISOPEN
         THEN
            CLOSE cur_garansegant;
         END IF;

         IF curgaran%ISOPEN
         THEN
            CLOSE curgaran;
         END IF;

         IF cur_garancarxrisc%ISOPEN
         THEN
            CLOSE cur_garancarxrisc;
         END IF;

         RETURN 140999;
   END f_consorci;

   /*************************************************************************
       Se encarga de recuperar la información de un recibo en concreto
       param in pnrecibo   :   numero de recibo.
   *************************************************************************/
   FUNCTION f_get_datostmprecibo (pnrecibo IN NUMBER, pcidioma IN NUMBER)
      RETURN VARCHAR2
   IS
      --vnumerr        NUMBER(8) := 0;
      squery     VARCHAR2 (4000);
      vpasexec   NUMBER (8)      := 1;
      vparam     VARCHAR2 (500)
         := 'parámetros - pnrecibo: ' || pnrecibo || ', pcidioma: '
            || pcidioma;
      vobject    VARCHAR2 (200)  := 'PAC_ADM.F_Get_DatosTmpRecibo';
      numrecs    NUMBER;
   BEGIN
      SELECT COUNT (*)
        INTO numrecs
        FROM recibos
       WHERE nrecibo = pnrecibo;

      IF numrecs <> 1
      THEN
         RAISE NO_DATA_FOUND;
      END IF;

      vpasexec := 3;
      squery :=
            'SELECT nrecibo, cagente, cempres, nmovimi, sseguro, femisio, fefecto, fvencim,'
         || ' ctiprec,  ff_desvalorfijo( 8,'
         || pcidioma
         || ', ctiprec) ttiprec, cdelega, ccobban, cestaux, nanuali, nfracci, cestimp, ff_desvalorfijo( 75,'
         || pcidioma
         || ', cestimp)   testimp , festimp, nriesgo, cforpag, ff_desvalorfijo( 17,'
         || pcidioma
         || ', cforpag)  TFORPAG, ctipban, cbancar, nmovanu, cretenc, pretenc, ncuacoa, ctipcoa, ff_desvalorfijo( 59,'
         || pcidioma
         || ', ctipcoa) ttipcoa, cestsop, nperven, ctransf, cgescob,  ff_desvalorfijo( 694,'
         || pcidioma
         || ', cgescob) tgescob, cmanual, decode( cmanual, 1, f_axis_literales( 101327,'
         || pcidioma
         || '), null) tmanual, f_cestrec(nrecibo, f_sysdate)  cestrec, ff_desvalorfijo( 1 ,'
         || pcidioma
         || ',f_cestrec(nrecibo, f_sysdate)) testrec, esccero'
         || ' FROM tmp_adm_recibos WHERE nrecibo ='
         || pnrecibo;
      RETURN squery;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      vobject,
                      vpasexec,
                      vparam,
                      SQLCODE || ' - ' || SQLERRM
                     );
         RETURN NULL;
   END f_get_datostmprecibo;

   /*************************************************************************
       Se encarga de recuperar la lista de movrecibos de un recibo en concreto
       param in pnrecibo   :   numero de recibo.
   *************************************************************************/
   FUNCTION f_get_tmpdetrecibos (pnrecibo IN NUMBER)
      RETURN VARCHAR2
   IS
      --vnumerr        NUMBER(8) := 0;
      squery     VARCHAR2 (2000);
      vpasexec   NUMBER (8)      := 1;
      vparam     VARCHAR2 (500)  := 'parámetros - pnrecibo: ' || pnrecibo;
      vobject    VARCHAR2 (200)  := 'PAC_ADM.F_Get_TmpDetrecibos';
   --numrecs        NUMBER;
   BEGIN
      -- falta la búsqueda del tconcep --
      squery :=
            'SELECT cconcep, sum (nvl( iconcep, 0)) iconcep
          FROM tmp_adm_detrecibos
         WHERE nrecibo = '
         || pnrecibo
         || ' GROUP BY cconcep';
      RETURN squery;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      vobject,
                      vpasexec,
                      vparam,
                      SQLCODE || ' - ' || SQLERRM
                     );
         RETURN NULL;
   END f_get_tmpdetrecibos;

   /*************************************************************************
       Se encarga de recuperar la lista de movrecibos de un recibo en concreto
       param in pnrecibo   :   numero de recibo.
   *************************************************************************/
   FUNCTION f_get_tmpdetrecibos_det (pnrecibo IN NUMBER, pconcep IN NUMBER)
      RETURN VARCHAR2
   IS
      --vnumerr        NUMBER(8) := 0;
      squery     VARCHAR2 (2000);
      vpasexec   NUMBER (8)      := 1;
      vparam     VARCHAR2 (500)
         := 'parámetros - pnrecibo: ' || pnrecibo || ', pconcep: ' || pconcep;
      vobject    VARCHAR2 (200)  := 'PAC_ADM.F_Get_TmpDetrecibos_det';
   --numrecs        NUMBER;
   --v_error        NUMBER;
   BEGIN
      squery :=
            'SELECT cgarant, nriesgo, iconcep, cageven , nmovima
            FROM tmp_adm_detrecibos
           WHERE nrecibo = '
         || pnrecibo
         || ' AND cconcep =  '
         || pconcep;
      vpasexec := 3;
      RETURN squery;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      vobject,
                      vpasexec,
                      vparam,
                      SQLCODE || ' - ' || SQLERRM
                     );
         RETURN NULL;
   END f_get_tmpdetrecibos_det;

   /*************************************************************************
       Se encarga de recuperar la lista de movrecibos de un recibo en concreto
       param in pnrecibo   :   numero de recibo.
   *************************************************************************/
   FUNCTION f_get_tmpmovrecibos (pnrecibo IN NUMBER, pcidioma IN NUMBER)
      RETURN VARCHAR2
   IS
      --vnumerr        NUMBER(8) := 0;
      squery     VARCHAR2 (2000);
      vpasexec   NUMBER (8)      := 1;
      vparam     VARCHAR2 (500)
         := 'parámetros - pnrecibo: ' || pnrecibo || ', pcidioma: '
            || pcidioma;
      vobject    VARCHAR2 (200)  := 'PAC_ADM.F_Get_TmpMovrecibos';
   --numrecs        NUMBER;
   BEGIN
      squery :=
            'SELECT   smovrec, cusuari,
                   smovagr, cestrec, cestant,
                   fmovini, fmovfin, fcontab,
                   fmovdia, cmotmov, ccobban,
                   cdelega, ctipcob, fefeadm,
                   ff_desvalorfijo( 1 , '
         || pcidioma
         || ',cestrec) testrec
                FROM tmp_adm_movrecibo
                Where nrecibo ='
         || pnrecibo
         || ' order by smovrec desc';
      RETURN squery;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      vobject,
                      vpasexec,
                      vparam,
                      SQLCODE || ' - ' || SQLERRM
                     );
         RETURN NULL;
   END f_get_tmpmovrecibos;

   /*************************************************************************
       Se encarga de recuperar el vmovrecibo de un recibo en concreto
       param in pnrecibo   :   numero de recibo.
   *************************************************************************/
   FUNCTION f_get_tmpvdetrecibos (pnrecibo IN NUMBER, pcidioma IN NUMBER)
      RETURN VARCHAR2
   IS
      --vnumerr        NUMBER(8) := 0;
      squery     VARCHAR2 (2000);
      vpasexec   NUMBER (8)      := 1;
      vparam     VARCHAR2 (500)
         := 'parámetros - pnrecibo: ' || pnrecibo || ', pcidioma: '
            || pcidioma;
      vobject    VARCHAR2 (200)  := 'PAC_ADM.F_Get_TmpVDetrecibos';
   --numrecs        NUMBER;
   BEGIN
      -- 38. 27/03/2012 JGR 0020546/104206 (añadidos los campos IIMP_1, IIMP_2, IIMP_3, IIMP_4)
      squery :=
            '
            SELECT
               iprinet, irecext,
               iconsor, ireccon,
               iips,   ff_desvalorfijo( 27,'
         || pcidioma
         || ', 4) tiips,
               idgs,   ff_desvalorfijo( 27,'
         || pcidioma
         || ', 5) tidgs,
               iarbitr,ff_desvalorfijo( 27,'
         || pcidioma
         || ', 6) tiarbitr,
               ifng,   ff_desvalorfijo( 27,'
         || pcidioma
         || ', 7) tifng,
               irecfra, idtotec, idtocom,
               icombru, icomret, idtoom,
               ipridev, itotpri, itotdto,
               itotcon, itotimp, itotalr,
               iderreg, itotrec, icomdev,
               iretdev, icednet, icedrex,
               icedcon, icedrco, icedips,
               iceddgs, icedarb, icedfng,
               icedrfr, iceddte, iceddco,
               icedcbr, icedcrt, iceddom,
               icedpdv, icedreg, icedcdv,
               icedrdv, it1pri,  it1dto,
               it1con,  it1imp,  it1rec,
               it1totr, it2pri,  it2dto,
               it2con,  it2imp,  it2rec,
               it2totr, icomcia, icombrui,
               icomreti, icomdevi, icomdrti,
               icombruc, icomretc, icomdevc,
               icomdrtc, iocorec
              ,IIMP_1, IIMP_2, IIMP_3, IIMP_4
            FROM tmp_adm_vdetrecibos
            where nrecibo = '
         || pnrecibo;
      RETURN squery;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      vobject,
                      vpasexec,
                      vparam,
                      SQLCODE || ' - ' || SQLERRM
                     );
         RETURN NULL;
   END f_get_tmpvdetrecibos;

   /*************************************************************************
       Se encarga de generar el primer movimiento de recibo.
   *************************************************************************/
   FUNCTION f_tmpmovrecibo (
      pnrecibo    IN       NUMBER,
      pcestrec    IN       NUMBER,
      psmovagr    IN OUT   NUMBER,
      pfmovini    IN       DATE,
      pccobban    IN       NUMBER,
      pcdelega    IN       NUMBER,
      pcmotmov    IN       NUMBER,
      pnomovrec   IN       NUMBER DEFAULT NULL,
      pctipcob    IN       NUMBER DEFAULT NULL
   )
      RETURN NUMBER
   IS
      --xsseguro       NUMBER;
      xfmovini   tmp_adm_movrecibo.fmovini%TYPE;
      --       xfmovini       DATE; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xsmovrec   tmp_adm_movrecibo.smovrec%TYPE;
      --       xsmovrec       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xsmovagr   NUMBER;
      v_error    NUMBER                           := 0;
      anterior   NUMBER                           := 1;
      xcestrec   tmp_adm_movrecibo.cestrec%TYPE;
      --       xcestrec       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xrowid     ROWID;                            -- optimizacion del tiempo
      vpasexec   NUMBER                           := 0;
   BEGIN
      vpasexec := 1;

      -- Mirem si existeixen moviments anteriors
      BEGIN
         SELECT ROWID, fmovini, cestrec, smovrec
           INTO xrowid, xfmovini, xcestrec, xsmovrec
           FROM tmp_adm_movrecibo
          WHERE nrecibo = pnrecibo AND fmovfin IS NULL;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            anterior := 0;
         WHEN OTHERS
         THEN
            RETURN 104043;                    -- Error al llegir de MOVRECIBO
      END;

      vpasexec := 2;

      IF TRUNC (xfmovini) > TRUNC (pfmovini)
      THEN
         RETURN 100531;           -- No se puede crear un movimiento anterior
      ELSE
         IF xcestrec > 3
         THEN
            -- tratamiento asesoría jurídica
            RETURN 101915;          -- Valor incorrecto del estado del recibo
         ELSE
            IF pcestrec = 0
            THEN
               IF xcestrec = 0
               THEN
                  RETURN 101909;                  -- El recibo está pendiente
               END IF;
            ELSIF pcestrec = 1
            THEN
               IF xcestrec IN (1, 3)
               THEN
                  IF NVL
                        (pac_parametros.f_parempresa_n
                                              (pac_md_common.f_get_cxtempresa,
                                               'PAGAR_REB_PAGADOS'
                                              ),
                         0
                        ) = 0
                  THEN
                     RETURN 101126;   -- El recibo no está pendiente de cobro
                  ELSIF xcestrec = 1
                  THEN
                     RETURN 0;
                  END IF;
               ELSIF xcestrec = 2
               THEN
                  RETURN 101910;                    -- El recibo está anulado
               END IF;
            ELSIF pcestrec = 2
            THEN
               IF xcestrec = 2
               THEN
                  RETURN 101910;                    -- El recibo está anulado
               ELSIF xcestrec = 1
               THEN
                  RETURN 101911;                   -- El recibo está cobrado.
               ELSIF xcestrec = 3
               THEN
                  IF NVL
                        (pac_parametros.f_parempresa_n
                                              (pac_md_common.f_get_cxtempresa,
                                               'PAGAR_REB_PAGADOS'
                                              ),
                         0
                        ) = 0
                  THEN
                     RETURN 101126;            -- El recibo no está pendiente
                  ELSIF xcestrec = 1
                  THEN
                     RETURN 0;
                  END IF;
               END IF;
            END IF;
         END IF;
      END IF;

      vpasexec := 3;

      BEGIN
         SELECT smovrec_tmp.NEXTVAL
           INTO xsmovrec
           FROM DUAL;
      EXCEPTION
         WHEN OTHERS
         THEN
            RETURN 104060;    -- Error al llegir la seqüència (smovrec) de BD
      END;

      vpasexec := 4;

      IF psmovagr = 0
      THEN
         BEGIN
            SELECT smovagr_tmp.NEXTVAL
              INTO xsmovagr
              FROM DUAL;
         EXCEPTION
            WHEN OTHERS
            THEN
               RETURN 104061; -- Error al llegir la seqüència (smovagr) de BD
         END;

         psmovagr := xsmovagr;
      ELSE
         xsmovagr := psmovagr;
      END IF;

      vpasexec := 5;

      IF v_error = 0
      THEN
         IF anterior = 1 AND pnomovrec IS NULL
         THEN
            --> No se ha modificar la tabla MOVRECIBO
            BEGIN
               UPDATE tmp_adm_movrecibo
                  SET fmovfin =
                          TO_DATE (TO_CHAR (pfmovini, 'ddmmyyyy'), 'ddmmyyyy')
                WHERE ROWID = xrowid;
            EXCEPTION
               WHEN OTHERS
               THEN
                  RETURN 100532;     -- Error al modificar la taula MOVRECIBO
            END;
         END IF;

         vpasexec := 6;

         BEGIN
            IF pnomovrec IS NULL
            THEN
               --> No se ha modificar la tabla MOVRECIBO
               INSERT INTO tmp_adm_movrecibo
                           (smovrec, cestrec, fmovini, fcontab,
                            fmovfin, nrecibo, cestant, cusuari,
                            smovagr, fmovdia, cmotmov, ccobban,
                            cdelega, ctipcob
                           )
                    VALUES (xsmovrec, pcestrec, TRUNC (pfmovini), NULL,
                            NULL, pnrecibo, NVL (xcestrec, 0), f_user,
                            xsmovagr, f_sysdate, pcmotmov, pccobban,
                            pcdelega, pctipcob
                           );
            END IF;

            vpasexec := 7;

            -- Si el recibo está pendiente de imprimir o pendiente de domiciliar se pone a
            -- no imprimible para las anulaciones.
            UPDATE tmp_adm_recibos
               SET cestimp =
                      DECODE (pcestrec,
                              2, DECODE (cestimp, 1, 0, 4, 0, cestimp),
                              cestimp
                             )
             WHERE nrecibo = pnrecibo;
         EXCEPTION
            WHEN DUP_VAL_ON_INDEX
            THEN
               RETURN 104062;                -- Registre duplicat a MOVRECIBO
            WHEN OTHERS
            THEN
               RETURN 100533;               -- Error a l' inserir a MOVRECIBO
         END;

         RETURN 0;
      ELSE
         RETURN v_error;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         -- BUG8757:DRA:23-01-2009:Que devuelva un error controlado si hay algun incontrolado
         p_tab_error (f_sysdate,
                      f_user,
                      'PAC_ADM.F_TMPMOVRECIBO',
                      vpasexec,
                      'pnrecibo: ' || pnrecibo || ' pcestrec: ' || pcestrec,
                      SQLCODE || '-' || SQLERRM
                     );
         v_error := 104043;             -- Error al llegir de la taula RECIBOS
         RETURN v_error;
   END f_tmpmovrecibo;

   FUNCTION f_tmprebnoimprim (
      pnrecibo   IN       NUMBER,
      pfmovini   IN       DATE,
      pcimprim   OUT      NUMBER,
      pcestaux   IN       NUMBER
   )
      RETURN NUMBER
   IS
      --xcimprim       NUMBER;
      xsmovagr   NUMBER                             := 0;
      --xnliqmen       NUMBER;
      --xnliqlin       NUMBER;
      xcdelega   tmp_adm_recibos.cdelega%TYPE;
      --       xcdelega       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xitotalr   tmp_adm_vdetrecibos.itotalr%TYPE;
      --       xitotalr       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xitotpri   tmp_adm_vdetrecibos.itotpri%TYPE;
      --       xitotpri       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      error      NUMBER;
   --
   -- ALLIBADM. Si importe = 0, recibo no imprimible y cobrado.
   --
   -- Retorna (como parámetro) = pcimprim (0 - No imprimible, 1 - Imprimible)
   --
   BEGIN
      BEGIN
         SELECT itotalr, itotpri
           INTO xitotalr, xitotpri
           FROM tmp_adm_vdetrecibos
          WHERE nrecibo = pnrecibo;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            RETURN 103936;                   -- Rebut no trobat a VDETRECIBOS
         WHEN OTHERS
         THEN
            RETURN 103920;                  -- Error al llegir de VDETRECIBOS
      END;

      IF xitotpri = 0
      THEN
         -- Prima neta cero
         BEGIN
            UPDATE tmp_adm_recibos
               SET cestimp = 0                                -- No imprimible
             WHERE nrecibo = pnrecibo;
         EXCEPTION
            WHEN OTHERS
            THEN
               RETURN 102358;                   -- Error al modificar RECIBOS
         END;

         IF xitotalr = 0 AND NVL (pcestaux, 0) = 0
         THEN
            -- Si total recibo 0 lo cobramos
            BEGIN
               SELECT cdelega
                 INTO xcdelega
                 FROM tmp_adm_recibos
                WHERE nrecibo = pnrecibo;
            EXCEPTION
               WHEN OTHERS
               THEN
                  xcdelega := NULL;
            END;

            --error := PAC_ADM.f_tmpmovrecibo(pnrecibo, 1, null, null, xsmovagr, xnliqmen,
            --                     xnliqlin, pfmovini,null,xcdelega,null,null);
            --IF error <> 0 THEN
            --   RETURN error;
            --END IF;
            error :=
               pac_adm.f_tmpmovrecibo (pnrecibo,
                                       1,
                                       xsmovagr,
                                       pfmovini,
                                       NULL,
                                       xcdelega,
                                       NULL
                                      );

            IF error <> 0
            THEN
               RETURN error;
            END IF;
         END IF;

         pcimprim := 0;                                       -- No imprimible
      ELSE
         pcimprim := 1;                                         -- Imprimible
      END IF;

      RETURN 0;
   END f_tmprebnoimprim;

   FUNCTION f_tmpprima_minima_extorn (
      psseguro   IN   NUMBER,
      pnrecibo   IN   NUMBER,
      pcestrec   IN   NUMBER,
      pfvalmov   IN   DATE,
      pccobban   IN   NUMBER,
      pcmotmov   IN   NUMBER,
      pcagente   IN   NUMBER,
      pfmovini        DATE,
      sproduc         NUMBER DEFAULT NULL
   )
      RETURN NUMBER
   IS
      xsproduc   seguros.sproduc%TYPE;
      --       xsproduc       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      ximinext   NUMBER;
      xnum_err   NUMBER;
      xiprinet   NUMBER;
      xcdelega   tmp_adm_recibos.cdelega%TYPE;
      --       xcdelega       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      dummy1     NUMBER;
      --dummy2         NUMBER;
      --dummy3         NUMBER;
      lctiprec   tmp_adm_recibos.ctiprec%TYPE;
   --       lctiprec       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
   BEGIN
      BEGIN
         SELECT ctiprec
           INTO lctiprec
           FROM tmp_adm_recibos
          WHERE nrecibo = pnrecibo;

         -- Si no és un extorn, no te sentit mirar la prima mínima
         IF lctiprec <> 9
         THEN
            RETURN 0;
         END IF;
      EXCEPTION
         WHEN OTHERS
         THEN
            RETURN 102367;
      END;

      IF sproduc IS NULL
      THEN
         BEGIN
            SELECT sproduc
              INTO xsproduc
              FROM seguros
             WHERE sseguro = psseguro;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               RETURN 101903;
         END;
      ELSE
         xsproduc := sproduc;
      END IF;

      BEGIN
         --trobem el import mínim del extorn
         SELECT NVL (iminext, 0)
           INTO ximinext
           FROM productos
          WHERE sproduc = xsproduc;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            RETURN 104347;
      END;

      BEGIN
         SELECT NVL (iprinet, 0)
           INTO xiprinet
           FROM tmp_adm_vdetrecibos
          WHERE nrecibo = pnrecibo;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            RETURN 103936;
      END;

      IF xiprinet < ximinext
      THEN
         --trobem la delegació
         xcdelega := f_delega (psseguro, pfmovini);
         --anul·lacio del rebut per que no arriba al mínim.
         dummy1 := 0;
         xnum_err :=
            pac_adm.f_tmpmovrecibo (pnrecibo,
                                    pcestrec,
                                    dummy1,
                                    pfmovini,
                                    pccobban,
                                    xcdelega,
                                    7
                                   );

         IF xnum_err <> 0
         THEN
            RETURN xnum_err;
         END IF;

         -- Retrocedir les cessions generades per l'anul.lació de rebut
         xnum_err := pac_cesionesrea.f_borra_cesdet_anu (pnrecibo, 'EST');

         IF xnum_err <> 0
         THEN
            RETURN xnum_err;
         END IF;
      END IF;

      RETURN 0;
   EXCEPTION
      WHEN OTHERS
      THEN
         RETURN 111097;
   END f_tmpprima_minima_extorn;

   FUNCTION f_tmpfusionsupcar (
      psseguro   IN   NUMBER,
      pnreccar   IN   NUMBER,
      pfefecar   IN   DATE,
      pfemicar   IN   DATE,
      pmodo      IN   VARCHAR2,
      psproces   IN   NUMBER
   )
      RETURN NUMBER
   IS
      --xctiprec       tmp_adm_recibos.ctiprec%TYPE;   --       xctiprec       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xcestrec   tmp_adm_movrecibo.cestrec%TYPE;
      --       xcestrec       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xcestant   tmp_adm_movrecibo.cestant%TYPE;
      --       xcestant       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      ximporte   tmp_adm_detrecibos.iconcep%TYPE;
      --       ximporte       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xtotrcar   tmp_adm_vdetrecibos.itotalr%TYPE;
      --       xtotrcar       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xnumconc   NUMBER;
      error      NUMBER;
      xsmovagr   NUMBER                             := 0;
      --xnliqmen       NUMBER;
      --xnliqlin       NUMBER;
      xfmovimi   DATE;

      CURSOR c_detrecibos (recibo IN NUMBER)
      IS
         SELECT *
           FROM tmp_adm_detrecibos
          WHERE nrecibo = recibo AND cconcep NOT IN (15, 16, 21, 65, 66, 71);

      -- Conceptos que no sean de ventas
      CURSOR c_recibos
      IS
         SELECT r.nrecibo rec, v.itotalr tot, r.ctiprec tip, r.cdelega
           FROM tmp_adm_movrecibo m, tmp_adm_vdetrecibos v,
                tmp_adm_recibos r
          WHERE r.sseguro = psseguro
            AND v.nrecibo = r.nrecibo
            AND m.nrecibo = r.nrecibo
            AND m.fmovfin IS NULL                            -- Está pendiente
            AND m.cestrec = 0
            AND v.itotpri = 0                           -- Su prima era 0 pero
            AND v.itotalr <> 0                                 -- su totalr no
            AND r.cestimp = 0                                 -- no imprimible
            AND r.ctiprec IN (1, 9);                 -- suplemento (o extorno)
   BEGIN
      -- Buscamos el total del recibo de cartera
      BEGIN
         SELECT itotalr
           INTO xtotrcar
           FROM tmp_adm_vdetrecibos
          WHERE nrecibo = pnreccar;
      EXCEPTION
         WHEN OTHERS
         THEN
            RETURN 103920;                    -- error al leer de vdetrecibos
      END;

      -- Si el total recibo no es 0
      IF xtotrcar <> 0
      THEN
         -- Iniciamos la fusión de los recibos
         FOR re IN c_recibos
         LOOP
            -- Validamos que el total del recibo fusionado no sea 0
            IF re.tip = 9 AND xtotrcar < re.tot
            THEN
               -- El extorno es superior al total
               -- del recibo de cartera
               IF pmodo = 'R'
               THEN
                  -- Dejamos el extorno pendiente de imprimir y no lo fusionamos
                  BEGIN
                     UPDATE tmp_adm_recibos
                        SET ctiprec = 1
                      WHERE nrecibo = re.rec;
                  EXCEPTION
                     WHEN OTHERS
                     THEN
                        RETURN 102358;
                  -- Error al actualizar la tabla recibos
                  END;
               END IF;
            ELSE
               -- Verificamos que no se haya hecho ningún movimiento de recibo.
               BEGIN
                  SELECT cestrec, cestant
                    INTO xcestrec, xcestant
                    FROM tmp_adm_movrecibo
                   WHERE nrecibo = re.rec;

                  IF xcestrec <> 0 OR xcestant <> 0
                  THEN
                     RETURN 101947;       -- Error de consistencia en la B.D.
                  END IF;
               EXCEPTION
                  WHEN TOO_MANY_ROWS
                  THEN
                     RETURN 105886;
                  WHEN OTHERS
                  THEN
                     RETURN 104043;
               END;

               -- Hemos localizado recibos de suplemento con fecha de efecto coincidente con
               -- la del que estamos generando y que hay que fusionar.
               FOR d IN c_detrecibos (re.rec)
               LOOP
                  IF re.tip = 9
                  THEN
                     -- El suplemento era un extorno
                     ximporte := 0 - d.iconcep;
                  ELSE
                     ximporte := d.iconcep;
                  END IF;

                  BEGIN
                     INSERT INTO tmp_adm_detrecibos
                                 (nrecibo, cconcep, iconcep, cgarant,
                                  nriesgo
                                 )
                          VALUES (pnreccar, d.cconcep, ximporte, d.cgarant,
                                  d.nriesgo
                                 );
                  EXCEPTION
                     WHEN DUP_VAL_ON_INDEX
                     THEN
                        BEGIN
                           UPDATE tmp_adm_detrecibos
                              SET iconcep = iconcep + ximporte
                            WHERE nrecibo = pnreccar
                              AND cconcep = d.cconcep
                              AND cgarant = d.cgarant
                              AND nriesgo = d.nriesgo;
                        EXCEPTION
                           WHEN OTHERS
                           THEN
                              RETURN 104377;
                        -- Error al actualizar DETRECIBOS
                        END;
                     WHEN OTHERS
                     THEN
                        RETURN 103513;     -- Error a l' inserir a DETRECIBOS
                  END;
               END LOOP;

               -- Borramos vdetrecibos del recibo de cartera para recalcularlo.
               BEGIN
                  DELETE      tmp_adm_vdetrecibos
                        WHERE nrecibo = pnreccar;

                  error :=
                        pac_adm.f_tmp_vdetrecibos (pmodo, pnreccar, psproces);

                  IF error <> 0
                  THEN
                     RETURN error;
                  END IF;
               EXCEPTION
                  WHEN OTHERS
                  THEN
                     RETURN 105157;    -- Fallo al borrar el recibo absorvido
               END;

               IF pmodo = 'R'
               THEN
                  -- Borramos el recibo de suplemento.
                  BEGIN
                     SELECT COUNT ('x')
                       INTO xnumconc
                       FROM tmp_adm_detrecibos
                      WHERE nrecibo = re.rec
                        AND cconcep IN (15, 16, 21, 65, 66, 71);
                  EXCEPTION
                     WHEN OTHERS
                     THEN
                        RETURN 103512;         -- error al leer de detrecibos
                  END;

                  IF xnumconc = 0
                  THEN
                     -- Podemos borrar el recibo porque se han fusionado todos sus conceptos
                     BEGIN
                        INSERT INTO borraproces
                           (SELECT re.rec, f_sysdate, sseguro, f_user,
                                   'FUSIONADO A ' || pnreccar
                              -- BUG 0041482 - FAL - 08/04/2016
                            FROM   tmp_adm_recibos
                             WHERE nrecibo = re.rec);

                        DELETE      tmp_adm_vdetrecibos
                              WHERE nrecibo = re.rec;

                        DELETE      tmp_adm_recibosredcom
                              WHERE nrecibo = re.rec;

                        DELETE      tmp_adm_movrecibo
                              WHERE nrecibo = re.rec;

                        DELETE      tmp_adm_detrecibos
                              WHERE nrecibo = re.rec;

                        DELETE      tmp_adm_recibos
                              WHERE nrecibo = re.rec;
                     EXCEPTION
                        WHEN OTHERS
                        THEN
                           RETURN 105115;
                     -- Fallo al borrar el recibo absorvido
                     END;
                  ELSE
                     -- Borramos los conceptos que no sean de ventas y dejamos el recibo cobrado
                     BEGIN
                        DELETE      tmp_adm_detrecibos
                              WHERE nrecibo = re.rec
                                AND cconcep NOT IN (15, 16, 21, 65, 66, 71);

                        DELETE      tmp_adm_vdetrecibos
                              WHERE nrecibo = re.rec;

                        error :=
                           pac_adm.f_tmp_vdetrecibos (pmodo, re.rec, psproces);

                        IF error <> 0
                        THEN
                           RETURN error;
                        END IF;

                        IF pfefecar > pfemicar
                        THEN
                           xfmovimi := pfefecar;
                        ELSE
                           xfmovimi := pfemicar;
                        END IF;

                        error :=
                           pac_adm.f_tmpmovrecibo (re.rec,
                                                   1,
                                                   xsmovagr,
                                                   xfmovimi,
                                                   NULL,
                                                   re.cdelega,
                                                   NULL
                                                  );

                        IF error <> 0
                        THEN
                           RETURN error;
                        END IF;
                     EXCEPTION
                        WHEN OTHERS
                        THEN
                           RETURN 105885;
                     -- error al leer la informacion del recibo
                     END;
                  END IF;
               END IF;
            END IF;
         END LOOP;
      END IF;

      RETURN 0;
   END f_tmpfusionsupcar;

   FUNCTION f_tmpinsrecibor (
      pnrecibo   IN   NUMBER,
      pcempres   IN   NUMBER,
      pcagente   IN   NUMBER,
      pfemisio   IN   DATE
   )
      RETURN NUMBER
   IS
      xmaxnivel   NUMBER (3) := 0;
   BEGIN
      BEGIN
         INSERT INTO tmp_adm_recibosredcom
                     (nrecibo, cempres, cagente, ctipage, nnivel)
            SELECT     pnrecibo, pcempres, cagente, ctipage, LEVEL
                  FROM redcomercial
                 WHERE cempres = pcempres
                   AND cpadre IS NOT NULL
                   AND (TRUNC (pfemisio) >= TRUNC (fmovini))
                   AND (TRUNC (pfemisio) <
                                   NVL (TRUNC (fmovfin), TRUNC (pfemisio + 1))
                       )
            CONNECT BY PRIOR cpadre = cagente
                   AND PRIOR cempres = cempres
                   AND (TRUNC (pfemisio) >= TRUNC (fmovini))
                   AND (TRUNC (pfemisio) <
                                   NVL (TRUNC (fmovfin), TRUNC (pfemisio + 1))
                       )
            START WITH cagente = pcagente
                   AND cempres = pcempres
                   AND (TRUNC (pfemisio) >= TRUNC (fmovini))
                   AND (TRUNC (pfemisio) <
                                   NVL (TRUNC (fmovfin), TRUNC (pfemisio + 1))
                       );
      EXCEPTION
         WHEN DUP_VAL_ON_INDEX
         THEN
            RETURN 103907;               -- REGISTRE DUPLICAT A RECIBOSREDCOM
         WHEN NO_DATA_FOUND
         THEN
            RETURN 103908;       -- NO S' HAN TROBAT REGISTRES A REDCOMERCIAL
         WHEN OTHERS
         THEN
            RETURN 103354;              -- ERROR A L' INSERIR A RECIBOSREDCOM
      END;

      BEGIN
         SELECT MAX (nnivel)
           INTO xmaxnivel
           FROM tmp_adm_recibosredcom
          WHERE nrecibo = pnrecibo;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            xmaxnivel := 0;
         WHEN OTHERS
         THEN
            RETURN 103909;          -- ERROR AL LLEGIR DADES DE RECIBOSREDCOM
      END;

      BEGIN
         UPDATE tmp_adm_recibosredcom
            SET nnivel = xmaxnivel - nnivel + 1
          WHERE nrecibo = pnrecibo;
      EXCEPTION
         WHEN OTHERS
         THEN
            RETURN 103910;                -- ERROR AL MODIFICAR RECIBOSREDCOM
      END;

      RETURN 0;
   END f_tmpinsrecibor;

   -- Bug 14775 - RSC - 13/08/2010- AGA003 - Error en dades rebut plantilla Condicionat Particular AGA012
   FUNCTION f_tmp_genera_prerecibos (
      p_sseguro   IN   NUMBER,
      p_idioma    IN   NUMBER,
      psproces    IN   NUMBER
   )
      RETURN VARCHAR2
   IS
      --   v_prima_anual  NUMBER(15, 2) := 0; sin usoo 20-03
      v_fcaranu        seguros.fcaranu%TYPE;
      v_mes            VARCHAR2 (2);
      v_anyo           VARCHAR2 (4);
      v_npoliza        seguros.npoliza%TYPE;
      v_ncertif        seguros.ncertif%TYPE;
      v_cempres        seguros.cempres%TYPE;
      --v_error        NUMBER;
      v_cramo          seguros.cramo%TYPE;
      v_cmodali        seguros.cramo%TYPE;
      v_ctipseg        seguros.cramo%TYPE;
      v_ccolect        seguros.cramo%TYPE;
      v_indice         NUMBER;
      v_indice_error   NUMBER;
      vsproces         NUMBER;
      -- JLB - 17/10/2013 -- bloqueo de la cartera
      vnerror          NUMBER;
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      SELECT fcaranu, npoliza, ncertif, cempres, cramo, cmodali,
             ctipseg, ccolect
        INTO v_fcaranu, v_npoliza, v_ncertif, v_cempres, v_cramo, v_cmodali,
             v_ctipseg, v_ccolect
        FROM seguros
       WHERE sseguro = p_sseguro;

----------------------------------------------------
-- Sumatorio/simulación de recibos restantes del año
----------------------------------------------------
      IF TO_CHAR (v_fcaranu, 'mm') = '01'
      THEN
         v_mes := '12';
         v_anyo := TO_CHAR (TO_NUMBER (TO_CHAR (v_fcaranu, 'yyyy')) - 1);
      ELSE
         v_mes := TO_CHAR (TO_NUMBER (TO_CHAR (v_fcaranu, 'mm')) - 1);
         v_anyo := TO_CHAR (v_fcaranu, 'yyyy');
      END IF;

      -- JLB - I - 17/10/2013 -- bloqueo de la cartera
      --INSERT INTO carteraaux
      --            (sproces, cramo, cmodali, ctipseg, ccolect, cactivi, npoliza,
      --             ncertif, cbloqueo, fcartera)
      --     VALUES (psproces, v_cramo, v_cmodali, v_ctipseg, v_ccolect, NULL, v_npoliza,
      --             v_ncertif, 0, f_sysdate);
      vnerror :=
         pac_dincartera.f_insert_carteraaux (psproces,
                                             v_cramo,
                                             v_cmodali,
                                             v_ctipseg,
                                             v_ccolect,
                                             NULL,
                                             v_npoliza,
                                             v_ncertif,
                                             0,
                                             f_sysdate
                                            );
      -- JLB - F - 17/10/2013 -- bloqueo de la cartera
      pac_dincartera.previ_cartera_tar (v_cempres,
                                        v_mes,
                                        v_anyo,
                                        v_npoliza,
                                        v_ncertif,
                                        p_idioma,
                                        psproces,
                                        v_indice,
                                        v_indice_error
                                       );
      -- JLB - I - 17/10/2013 -- bloqueo de la cartera
      --  DELETE      carteraaux
      --        WHERE sproces = vsproces;
      vnerror := pac_dincartera.f_delete_carteraaux (psproces);
      -- JLB - F- 17/10/2013 -- bloqueo de la cartera
      RETURN (0);
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         -- JLB - I - 17/10/2013 -- bloqueo de la cartera
         vnerror := pac_dincartera.f_delete_carteraaux (psproces);
         -- JLB - F- 17/10/2013 -- bloqueo de la cartera
         RETURN 0;
      WHEN OTHERS
      THEN
         -- JLB - I - 17/10/2013 -- bloqueo de la cartera
         vnerror := pac_dincartera.f_delete_carteraaux (psproces);
         -- JLB - F- 17/10/2013 -- bloqueo de la cartera
         RETURN NULL;
   END f_tmp_genera_prerecibos;

   /*************************************************************************
      --BUG 16325 - ICV - 04/11/2010
      Función que para actualizar los importes de los recibos
      param in out mensajes  : Mensajes de error
      return                 : 0.- OK
                               1.- error
   *************************************************************************/
   FUNCTION f_set_imprecibo (
      pnrecibo     IN   NUMBER,
      pnriesgo     IN   NUMBER,
      pit1dto      IN   NUMBER,
      piprinet     IN   NUMBER,
      pit1rec      IN   NUMBER,
      pit1con      IN   NUMBER,
      piips        IN   NUMBER,
      pidgs        IN   NUMBER,
      piarbitr     IN   NUMBER,
      pifng        IN   NUMBER,
      pfefecto     IN   DATE,
      pfvencim     IN   DATE,
      pcreccia     IN   VARCHAR2,
      picombru     IN   NUMBER,
      pcvalidado   IN   NUMBER
   )
      RETURN NUMBER
   IS
      --vobjectname    VARCHAR2(500) := 'PAC_ADM.f_set_imprecibo';
      --vparam         VARCHAR2(2000)
      --:= 'parámetros - pnrecibo: ' || pnrecibo || ', pit1dto: ' || pit1dto
      --      || ', piprinet: ' || piprinet || ', pit1rec: ' || pit1rec || ', pit1con: '
      --     || pit1con || ', piips: ' || piips || ', pidgs: ' || pidgs || ', piarbitr: '
      --     || piarbitr || ', pifng: ' || pifng || ', pFEFECTO: ' || pfefecto
      --      || ', pFVENCIM: ' || pfvencim || ', pCRECCIA: ' || pcreccia;
      --vpasexec       NUMBER(5) := 1;
      vnumerr     NUMBER (8)                := 0;
      vnriesgo    NUMBER;
      vcgarant    detrecibos.cgarant%TYPE;
      --       vcgarant       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      vnmovima    NUMBER;
      nproceso    NUMBER;
      vcestrec    movrecibo.cestrec%TYPE;
      --       vcestrec       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      v_cmodifi   recibos.cmodifi%TYPE      := 0;

      --       v_cmodifi      NUMBER := 0; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      PROCEDURE p_actu_detrecibo (
         pcgarant   IN   NUMBER,
         pcconcep   IN   NUMBER,
         pimporte   IN   NUMBER,
         pnmovima   IN   NUMBER
      )
      IS
      --vnrisc         NUMBER;
      BEGIN
         --Borramos el concepto
         --Lo dejamos a cero para el resto de garantias
         --Lo insertamos todo en la nueva garantia
         --De momento como las garantias, si hay mas de un riesgo se carga todo al primer riesgo
         --vnrisc := NVL(pnriesgo, 1);
         DELETE FROM detrecibos
               WHERE nrecibo = pnrecibo
                 AND nriesgo = 1
                 --AGG 30/10/13 Bug:0028706: CRT904-Errores en recibos
                 AND (vcgarant IS NULL OR cgarant = vcgarant)
                 AND cconcep = pcconcep;

         UPDATE detrecibos
            SET iconcep = 0
          WHERE nrecibo = pnrecibo
                                  --  AND nriesgo = vnrisc
                AND cconcep = pcconcep;

         IF pimporte <> 0
         THEN
            INSERT INTO detrecibos
                        (nrecibo, cconcep, cgarant, nriesgo, iconcep, nmovima
                        )
                 VALUES (pnrecibo, pcconcep, vcgarant, 1, pimporte, pnmovima
                        );
         END IF;
      END p_actu_detrecibo;
   BEGIN
      vnriesgo := NVL (pnriesgo, 1);

      IF pnrecibo IS NULL
      THEN
         RETURN 103135;
      END IF;

      SELECT cestrec
        INTO vcestrec
        FROM movrecibo
       WHERE nrecibo = pnrecibo AND fmovfin IS NULL;

      -- POdemos modificar en cualquier estado
      --IF vcestrec <> 0 THEN   --Si el recibo no está pendiente no se puede modificar
      -- RETURN 101126;
      --END IF;
      SELECT cmodifi
        INTO v_cmodifi
        FROM recibos
       WHERE nrecibo = pnrecibo;

      --Si el recibo no esta modificado, o se le ha hecho una modificación de importes se marca como modificación de improtes
      IF NVL (v_cmodifi, 0) IN (0, 1)
      THEN
         v_cmodifi := 1;
      ELSE
         --Si el recibo tiene una modificación diferente a la que vamos a realizar, se marca como varias modificaciones.
         v_cmodifi := 9;
      END IF;

      UPDATE recibos
         SET fefecto = pfefecto,
             fvencim = pfvencim,
             creccia = pcreccia,
             cvalidado = pcvalidado,
             cmodifi = v_cmodifi
       WHERE nrecibo = pnrecibo;

      --Modificamos detrecibos y lo cargamos todo a la primera garantia
      SELECT MIN (cgarant), MAX (nmovima)
        INTO vcgarant, vnmovima
        FROM detrecibos
       WHERE nrecibo = pnrecibo AND nriesgo = vnriesgo;

      --Creamos o modificamos los conceptos
      IF pit1dto IS NOT NULL
      THEN
         p_actu_detrecibo (vcgarant, 13, pit1dto, vnmovima);
      END IF;

      IF piprinet IS NOT NULL
      THEN
         p_actu_detrecibo (vcgarant, 0, piprinet, vnmovima);
      END IF;

      IF pit1rec IS NOT NULL
      THEN
         p_actu_detrecibo (vcgarant, 8, pit1rec, vnmovima);
      END IF;

      IF pit1con IS NOT NULL
      THEN
         p_actu_detrecibo (vcgarant, 2, pit1con, vnmovima);
      END IF;

      IF piips IS NOT NULL
      THEN
         p_actu_detrecibo (vcgarant, 4, piips, vnmovima);
      END IF;

      IF pidgs IS NOT NULL
      THEN
         p_actu_detrecibo (vcgarant, 5, pidgs, vnmovima);
      END IF;

      IF piarbitr IS NOT NULL
      THEN
         p_actu_detrecibo (vcgarant, 6, piarbitr, vnmovima);
      END IF;

      IF pifng IS NOT NULL
      THEN
         p_actu_detrecibo (vcgarant, 7, pifng, vnmovima);
      END IF;

      IF picombru IS NOT NULL
      THEN
         p_actu_detrecibo (vcgarant, 11, picombru, vnmovima);
      END IF;

      --Borramos vdetrecibos y la volvemos a recrear
      -- BUG 18423 - 21/11/2011 - JMP - LCOL000 - Multimoneda
      DELETE FROM vdetrecibos_monpol
            WHERE nrecibo = pnrecibo;

      -- FIN BUG 18423 - 21/11/2011 - JMP - LCOL000 - Multimoneda
      DELETE FROM vdetrecibos
            WHERE nrecibo = pnrecibo;

      vnumerr := f_vdetrecibos ('R', pnrecibo, nproceso);

      IF vnumerr <> 0
      THEN
         RETURN vnumerr;
      END IF;

      RETURN 0;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      'pac_adm.f_set_imprecibo',
                      1,
                      'error no controlado',
                      SQLERRM
                     );
         RETURN 108468;
   END f_set_imprecibo;

   PROCEDURE p_emitir_propuesta_col (
      pcempres    IN       NUMBER,
      pnpoliza    IN       NUMBER,
      pncertif    IN       NUMBER,
      pcramo      IN       NUMBER,
      pcmodali    IN       NUMBER,
      pctipseg    IN       NUMBER,
      pccolect    IN       NUMBER,
      pcactivi    IN       NUMBER,
      pmoneda     IN       NUMBER,
      pcidioma    IN       NUMBER,
      pindice     OUT      NUMBER,
      pindice_e   OUT      NUMBER,
      pcmotret    OUT      NUMBER,                   -- BUG9640:DRA:16/04/2009
      psproces    IN       NUMBER DEFAULT NULL,
      pnordapo    IN       NUMBER DEFAULT NULL,
      pcommit     IN       NUMBER DEFAULT NULL
   )
   IS
      TYPE t_cursor IS REF CURSOR;

      c_pol               t_cursor;
      v_sel               VARCHAR2 (4000);
      v_pol               seguros%ROWTYPE;
      lnmovimi            movseguro.nmovimi%TYPE;
      --       lnmovimi       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      lcmotmov            movseguro.cmotmov%TYPE;
      --       lcmotmov       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      --lcmovseg       NUMBER;
      --lcdomper       NUMBER;
      lctiprec            tmp_adm_recibos.ctiprec%TYPE;
      --       lctiprec       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      lctipmov            NUMBER;
      lcforpag            NUMBER;
      lfcanua             seguros.fcaranu%TYPE;
      --       lfcanua        DATE; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      lcrevfpg            productos.crevfpg%TYPE;
      --       lcrevfpg       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      lndiaspro           productos.ndiaspro%TYPE;
      --       lndiaspro      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      lcprprod            productos.cprprod%TYPE;
      --       lcprprod       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      --Indica si un producto es de rentas.
      lfaux               DATE;
      lfcapro             seguros.fcarpro%TYPE;
      --       lfcapro        DATE; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      lmeses              NUMBER;
      lfvencim            DATE;
      lsproces            NUMBER;
      lgenrec             codimotmov.cgenrec%TYPE;
      --       lgenrec        NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      lnumrec             NUMBER;
      lmensaje            VARCHAR2 (500)                 := NULL;
      ltexto              VARCHAR2 (400);
      --ltexto2        VARCHAR2(400);
      ltarjet_aln         VARCHAR2 (2);
      lgesdoc             VARCHAR2 (10);
      ddmm                VARCHAR2 (4);
      dd                  VARCHAR2 (2);
      lfefecto            movseguro.fefecto%TYPE;
      --       lfefecto       DATE; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      nprolin             NUMBER;
      num_err             NUMBER                         := 0;
      --num_err2       NUMBER := 0;
      xcimpres            movseguro.cimpres%TYPE;
      --       xcimpres       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      lprimera            NUMBER;
      lnomesextra         NUMBER;
      lctipefe            productos.ctipefe%TYPE;
      --       lctipefe       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      fecha_aux           DATE;
      l_fefecto_1         DATE;
      lcsubpro            productos.csubpro%TYPE;
      --       lcsubpro       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      v_ncertif           seguros.ncertif%TYPE;
      --       v_ncertif      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      v_npoliza           seguros.npoliza%TYPE           := NULL;
      --       v_npoliza      NUMBER := NULL; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      -- Bug 5467 - 10/02/2009 - RSC - CRE - Desarrollo de sistema de copago
      v_npoliza_prefijo   NUMBER;
   BEGIN
      --lnordapo := pnordapo;  --eliminar
      pindice := 0;
      pindice_e := 0;
      pcmotret := NULL;                             -- BUG9640:DRA:16/04/2009
      -- Obtenció de paràmetres per instal.lació
      ltarjet_aln := NVL (f_parinstalacion_t ('TARJET_ALN'), 'NO');
      lgesdoc := NVL (f_parinstalacion_t ('GESTDOC'), 'NO');
      -- Selecció dinàmica de les pòlisses a emetre
      v_sel :=
            'SELECT  * '
         || ' FROM seguros '
         || ' WHERE creteni = 0 '
         || '   AND (csituac = 4 OR csituac = 5)'
         || '   AND f_produsu(cramo, cmodali, ctipseg, ccolect, 2) = 1 ';

      IF pcempres IS NOT NULL
      THEN
         v_sel := v_sel || ' AND cempres = ' || pcempres;
      END IF;

      IF pnpoliza IS NOT NULL
      THEN
         v_sel := v_sel || ' AND npoliza = ' || pnpoliza;
      END IF;

      IF pncertif IS NOT NULL
      THEN
         v_sel := v_sel || ' AND ncertif = ' || pncertif;
      END IF;

      IF pcramo IS NOT NULL
      THEN
         v_sel := v_sel || ' AND cramo   = ' || pcramo;
      END IF;

      IF pcmodali IS NOT NULL
      THEN
         v_sel := v_sel || ' AND cmodali = ' || pcmodali;
      END IF;

      IF pctipseg IS NOT NULL
      THEN
         v_sel := v_sel || ' AND ctipseg = ' || pctipseg;
      END IF;

      IF pccolect IS NOT NULL
      THEN
         v_sel := v_sel || ' AND ccolect = ' || pccolect;
      END IF;

      -- Bug 9164 - 30/03/2009 - svj - Permitir en nueva producción escoger la actividad.
      --IF pcactivi IS NOT NULL THEN
      --   v_sel := v_sel || ' AND cactivi = ' || pcactivi;
      --END IF;
      BEGIN
         lprimera := 1;

         OPEN c_pol FOR v_sel;

         LOOP
            FETCH c_pol
             INTO v_pol;

            EXIT WHEN c_pol%NOTFOUND;
            -- Parproducto = NOMESEXTRA
            -- El producte diu si a la nova producció només tenim extra
            -- i grava el rebut amb ctiprec = 0 i no ctiprec = 4
            num_err :=
                    f_parproductos (v_pol.sproduc, 'NOMESEXTRA', lnomesextra);
            lnomesextra := NVL (lnomesextra, 0);

            -- la primera vegada cridem a procesini per l'empresa de la pòlissa
            IF lprimera = 1
            THEN
               lprimera := 0;

               IF psproces IS NULL
               THEN
                  num_err :=
                     f_procesini (f_user,
                                  v_pol.cempres,
                                  'EMISION',
                                  'Emisión de propuestas',
                                  lsproces
                                 );
               ELSE
                  lsproces := psproces;
               END IF;
            END IF;

            SELECT DECODE (v_pol.csituac, 4, 0, 5, 1, NULL)
              INTO v_pol.csituac
              FROM DUAL;

            pindice := pindice + 1;

            -- Miramos el movim. de seg. de ese seguro
            BEGIN
               SELECT nmovimi, fefecto, cmotmov
                 INTO lnmovimi, lfefecto, lcmotmov
                 FROM movseguro
                WHERE sseguro = v_pol.sseguro AND femisio IS NULL;
            EXCEPTION
               WHEN TOO_MANY_ROWS
               THEN
                  ROLLBACK;
                  num_err := 1;
                  lmensaje := 103106;               --Más de 1 mov. de seguro
                  p_tab_error (f_sysdate,
                               f_user,
                               'PAC_ADM.p_emitir_propuesta',
                               1,
                                  'pcempres = '
                               || pcempres
                               || ' pnpoliza = '
                               || pnpoliza
                               || ' pncertif = '
                               || pncertif
                               || ' pcramo = '
                               || pcramo
                               || ' pcmodali = '
                               || pcmodali
                               || ' pctipseg = '
                               || pctipseg
                               || ' pccolect = '
                               || pccolect
                               || ' pcactivi = '
                               || pcactivi
                               || ' pmoneda = '
                               || pmoneda
                               || 'pcidioma = '
                               || pcidioma,
                               SQLERRM
                              );
               WHEN NO_DATA_FOUND
               THEN
                  ROLLBACK;
                  num_err := 1;
                  lmensaje := 103107;          --No hay movimientos de seguro
                  p_tab_error (f_sysdate,
                               f_user,
                               'PAC_ADM.p_emitir_propuesta',
                               2,
                                  'pcempres = '
                               || pcempres
                               || ' pnpoliza = '
                               || pnpoliza
                               || ' pncertif = '
                               || pncertif
                               || ' pcramo = '
                               || pcramo
                               || ' pcmodali = '
                               || pcmodali
                               || ' pctipseg = '
                               || pctipseg
                               || ' pccolect = '
                               || pccolect
                               || ' pcactivi = '
                               || pcactivi
                               || ' pmoneda = '
                               || pmoneda
                               || 'pcidioma = '
                               || pcidioma,
                               SQLERRM
                              );
               WHEN OTHERS
               THEN
                  lmensaje := SQLCODE;
                  ROLLBACK;
                  num_err := 1;                   --Error en la base de datos
                  p_tab_error (f_sysdate,
                               f_user,
                               'PAC_ADM.p_emitir_propuesta',
                               3,
                                  'pcempres = '
                               || pcempres
                               || ' pnpoliza = '
                               || pnpoliza
                               || ' pncertif = '
                               || pncertif
                               || ' pcramo = '
                               || pcramo
                               || ' pcmodali = '
                               || pcmodali
                               || ' pctipseg = '
                               || pctipseg
                               || ' pccolect = '
                               || pccolect
                               || ' pcactivi = '
                               || pcactivi
                               || ' pmoneda = '
                               || pmoneda
                               || 'pcidioma = '
                               || pcidioma,
                               SQLERRM
                              );
            END;

            -- Miramos si se ha de generar recibo (según el lmotivo de mov.)
            BEGIN
               SELECT cgenrec
                 INTO lgenrec
                 FROM codimotmov
                WHERE cmotmov = lcmotmov;
            EXCEPTION
               WHEN OTHERS
               THEN
                  num_err := 1;
                  lgenrec := 0;
                  p_tab_error (f_sysdate,
                               f_user,
                               'PAC_ADM.p_emitir_propuesta',
                               31,
                                  'pcempres = '
                               || pcempres
                               || ' pnpoliza = '
                               || pnpoliza
                               || ' pncertif = '
                               || pncertif
                               || ' pcramo = '
                               || pcramo
                               || ' pcmodali = '
                               || pcmodali
                               || ' pctipseg = '
                               || pctipseg
                               || ' pccolect = '
                               || pccolect
                               || ' pcactivi = '
                               || pcactivi
                               || ' pmoneda = '
                               || pmoneda
                               || 'pcidioma = '
                               || pcidioma,
                               SQLERRM
                              );
            END;

            IF num_err = 0
            THEN
               IF lnmovimi = 1
               THEN
                  lctiprec := 0;                                 --Producción
                  lctipmov := 00;                                        -- "
               ELSIF lnmovimi > 1
               THEN
                  lctiprec := 1;                                 --Suplemento
                  lctipmov := 01;                                        -- "

                  IF lcmotmov = 298
                  THEN
                     -- Suspensió de pòlissa
                     UPDATE seguros
                        SET csituac = 1,
                            ccartera = NULL
                      WHERE sseguro = v_pol.sseguro;
                  END IF;
               END IF;

               BEGIN
                  SELECT crevfpg, ndiaspro,
                                           --Se recupera ndiaspro para utilizarlo en el cálculo de fcarpro.
                                           cprprod,
                                                   -- Indica si un producto es de rentas.
                                                   ctipefe, csubpro
                    -- Para saber qué tipo de renovación (calcular fcaranu)
                  INTO   lcrevfpg, lndiaspro,
                                             -- Para el cálculo de fcarpro.
                                             lcprprod,
                                                      -- Indica si un producto es de rentas.
                                                      lctipefe, lcsubpro
                    FROM productos
                   WHERE cramo = v_pol.cramo
                     AND cmodali = v_pol.cmodali
                     AND ctipseg = v_pol.ctipseg
                     AND ccolect = v_pol.ccolect;
               EXCEPTION
                  WHEN OTHERS
                  THEN
                     lmensaje := SQLCODE;
                     num_err := 1;
                     p_tab_error (f_sysdate,
                                  f_user,
                                  'PAC_ADM.p_emitir_propuesta',
                                  4,
                                     'pcempres = '
                                  || pcempres
                                  || ' pnpoliza = '
                                  || pnpoliza
                                  || ' pncertif = '
                                  || pncertif
                                  || ' pcramo = '
                                  || pcramo
                                  || ' pcmodali = '
                                  || pcmodali
                                  || ' pctipseg = '
                                  || pctipseg
                                  || ' pccolect = '
                                  || pccolect
                                  || ' pcactivi = '
                                  || pcactivi
                                  || ' pmoneda = '
                                  || pmoneda
                                  || 'pcidioma = '
                                  || pcidioma,
                                  SQLERRM
                                 );
               END;

               IF num_err = 0
               THEN
                  --Forma de pago no única o forma de pago única con renovación,
                  --Nueva producción
                  IF     (   v_pol.cforpag <> 0
                          OR (v_pol.cforpag = 0 AND lcrevfpg = 1)
                         )
                     AND v_pol.csituac = 0
                  THEN
                     IF v_pol.cforpag = 0 AND lcrevfpg = 1
                     THEN
                        lcforpag := 1;
                     -- que calcule las fechas como si fuera pago anual
                     ELSE
                        lcforpag := v_pol.cforpag;
                     END IF;

                     lmeses := 12 / lcforpag;
                     dd := SUBSTR (LPAD (v_pol.nrenova, 4, 0), 3, 2);
                     ddmm := dd || SUBSTR (LPAD (v_pol.nrenova, 4, 0), 1, 2);

                     IF    TO_CHAR (v_pol.fefecto, 'DDMM') = ddmm
                        OR LPAD (v_pol.nrenova, 4, 0) IS NULL
                     THEN
                        --lfcanua     := ADD_MONTHS(v_pol.fefecto, 12);
                        lfcanua := f_summeses (v_pol.fefecto, 12, dd);
                     ELSE
                        IF lctipefe = 2
                        THEN
                           -- a día 1/mes por exceso
                           fecha_aux := ADD_MONTHS (v_pol.fefecto, 13);
                           lfcanua :=
                              TO_DATE (ddmm || TO_CHAR (fecha_aux, 'YYYY'),
                                       'DDMMYYYY'
                                      );
                        ELSE
                           BEGIN
                              lfcanua :=
                                 TO_DATE (   ddmm
                                          || TO_CHAR (v_pol.fefecto, 'YYYY'),
                                          'DDMMYYYY'
                                         );
                           EXCEPTION
                              WHEN OTHERS
                              THEN
                                 IF ddmm = 2902
                                 THEN
                                    ddmm := 2802;
                                    lfcanua :=
                                       TO_DATE (   ddmm
                                                || TO_CHAR (v_pol.fefecto,
                                                            'YYYY'
                                                           ),
                                                'DDMMYYYY'
                                               );
                                 ELSE
                                    lmensaje := 104510;
                                    --Fecha de renovación (mmdd) incorrecta
                                    num_err := 1;
                                    p_tab_error
                                               (f_sysdate,
                                                f_user,
                                                'PAC_ADM.p_emitir_propuesta',
                                                5,
                                                   'pcempres = '
                                                || pcempres
                                                || ' pnpoliza = '
                                                || pnpoliza
                                                || ' pncertif = '
                                                || pncertif
                                                || ' pcramo = '
                                                || pcramo
                                                || ' pcmodali = '
                                                || pcmodali
                                                || ' pctipseg = '
                                                || pctipseg
                                                || ' pccolect = '
                                                || pccolect
                                                || ' pcactivi = '
                                                || pcactivi
                                                || ' pmoneda = '
                                                || pmoneda
                                                || 'pcidioma = '
                                                || pcidioma,
                                                SQLERRM
                                               );
                                 END IF;
                           END;
                        END IF;

                        IF lfcanua <= v_pol.fefecto
                        THEN
                           --lfcanua     := ADD_MONTHS(lfcanua, 12);
                           lfcanua := f_summeses (lfcanua, 12, dd);
                        END IF;
                     END IF;

                     -- Se calcula la próx. cartera partiendo de la cartera de renovación (fcaranu)
                     -- y restándole periodos de pago
                     -- Calculem la data de propera cartera
                     IF     lctipefe = 2
                        AND TO_CHAR (v_pol.fefecto, 'dd') <> 1
                        AND lcforpag <> 12
                     THEN
                        l_fefecto_1 :=
                              '01/'
                           || TO_CHAR (ADD_MONTHS (v_pol.fefecto, 1),
                                       'mm/yyyy'
                                      );
                     ELSE
                        l_fefecto_1 := v_pol.fefecto;
                     END IF;

                     lfaux := lfcanua;

                     WHILE TRUE
                     LOOP
                        --lfaux        := ADD_MONTHS(lfaux, -lmeses);
                        lfaux := f_summeses (lfaux, -lmeses, dd);

                        IF lfaux <= l_fefecto_1
                        THEN
                           lfcapro := f_summeses (lfaux, lmeses, dd);
                           --lfcapro      := ADD_MONTHS(lfaux, lmeses);
                           EXIT;
                        END IF;
                     END LOOP;

                     IF (lndiaspro IS NOT NULL)
                     THEN
                        IF     TO_NUMBER (TO_CHAR (v_pol.fefecto, 'dd')) >=
                                                                    lndiaspro
                           AND TO_NUMBER (TO_CHAR (lfcapro, 'mm')) =
                                  TO_NUMBER
                                         (TO_CHAR (ADD_MONTHS (v_pol.fefecto,
                                                               1
                                                              ),
                                                   'mm'
                                                  )
                                         )
                        THEN
                           -- és a dir , que el dia sigui > que el dia 15 de l'ultim més del periode
                           lfcapro := ADD_MONTHS (lfcapro, lmeses);

                           IF lfcapro > lfcanua
                           THEN
                              lfcapro := lfcanua;
                           END IF;
                        END IF;
                     END IF;

                     IF v_pol.cforpag = 0 AND lcrevfpg = 1
                     THEN
                        lfvencim := NVL (v_pol.fvencim, lfefecto + 1);
                     ELSE
                        lfvencim := lfcapro;
                     END IF;

                     BEGIN
                        IF lcmotmov <> 298
                        THEN
                           -- No es suspensió de pòlissa
                           -- pot tenir data d'anulació si és una regularització
                           -- feta després d'anular la pòlissa.
                           -- Bug 16768 - APD - 25/11/2010 - no se deben actualizar las fechas
                           -- fcaranu y fcarpro para las polizas colectivas, ya que se quiere que
                           -- no entren ni puedan entrar en ningun caso en el proceso de cartera
                           UPDATE seguros
                              SET csituac = DECODE (fanulac, NULL, 0, 2),
                                  femisio = f_sysdate,
                                  --fcaranu = lfcanua,
                                  --fcarpro = lfcapro,
                                  ccartera = NULL
                            WHERE sseguro = v_pol.sseguro;

                           -- fin Bug 16768 - APD - 25/11/2010

                           -- BUG 0019627: GIP102 - Reunificación de recibos - FAL - 10/11/2011. Informar fcaranu,fcarpro para renovar poliza madre del colectivo transportes GIP
                           IF NVL
                                 (f_parproductos_v
                                               (f_sproduc_ret (v_pol.cramo,
                                                               v_pol.cmodali,
                                                               v_pol.ctipseg,
                                                               v_pol.ccolect
                                                              ),
                                                'RECUNIF'
                                               ),
                                  0
                                 ) = 3
                           THEN
                              UPDATE seguros
                                 SET csituac = DECODE (fanulac, NULL, 0, 2),
                                     femisio = f_sysdate,
                                     fcaranu = lfcanua,
                                     fcarpro = lfcapro,
                                     ccartera = NULL
                               WHERE sseguro = v_pol.sseguro;
                           END IF;
                        -- Fi BUG 0019627
                        END IF;
                     EXCEPTION
                        WHEN OTHERS
                        THEN
                           lmensaje := SQLCODE;
                           num_err := 1;
                           p_tab_error (f_sysdate,
                                        f_user,
                                        'PAC_ADM.p_emitir_propuesta',
                                        6,
                                           'pcempres = '
                                        || pcempres
                                        || ' pnpoliza = '
                                        || pnpoliza
                                        || ' pncertif = '
                                        || pncertif
                                        || ' pcramo = '
                                        || pcramo
                                        || ' pcmodali = '
                                        || pcmodali
                                        || ' pctipseg = '
                                        || pctipseg
                                        || ' pccolect = '
                                        || pccolect
                                        || ' pcactivi = '
                                        || pcactivi
                                        || ' pmoneda = '
                                        || pmoneda
                                        || 'pcidioma = '
                                        || pcidioma,
                                        SQLERRM
                                       );
                     END;
                  ELSIF v_pol.cforpag <> 0 AND v_pol.csituac = 1
                  THEN
                     -- Suplement i forma de pagament no única
                     lfcanua := v_pol.fcaranu;
                     lfcapro := v_pol.fcarpro;
                     lfvencim := lfcapro;

                     BEGIN
                        IF lcmotmov <> 298
                        THEN
                           -- No es suspensió de pòlissa
                           -- pot tenir data d'anulació si és una regularització
                           -- feta després d'anular la pòlissa.
                           UPDATE seguros
                              SET csituac = DECODE (fanulac, NULL, 0, 2),
                                  femisio = f_sysdate,
                                  ccartera = NULL
                            WHERE sseguro = v_pol.sseguro;
                        END IF;
                     EXCEPTION
                        WHEN OTHERS
                        THEN
                           lmensaje := SQLCODE;
                           num_err := 1;
                           p_tab_error (f_sysdate,
                                        f_user,
                                        'PAC_ADM.p_emitir_propuesta',
                                        7,
                                           'pcempres = '
                                        || pcempres
                                        || ' pnpoliza = '
                                        || pnpoliza
                                        || ' pncertif = '
                                        || pncertif
                                        || ' pcramo = '
                                        || pcramo
                                        || ' pcmodali = '
                                        || pcmodali
                                        || ' pctipseg = '
                                        || pctipseg
                                        || ' pccolect = '
                                        || pccolect
                                        || ' pcactivi = '
                                        || pcactivi
                                        || ' pmoneda = '
                                        || pmoneda
                                        || 'pcidioma = '
                                        || pcidioma,
                                        SQLERRM
                                       );
                     END;
                  ELSIF v_pol.cforpag = 0 AND lcrevfpg = 0
                  THEN
                     lfcanua := v_pol.fcaranu;
                     lfcapro := v_pol.fcarpro;
                     lfvencim := NVL (v_pol.fvencim, lfefecto + 1);

                     --lfvencim := v_pol.fvencim;
                     BEGIN
                        IF lcmotmov <> 298
                        THEN
                           -- No es suspensió de pòlissa
                           -- pot tenir data d'anulació si és una regularització
                           -- feta després d'anular la pòlissa.
                           UPDATE seguros
                              SET csituac = DECODE (fanulac, NULL, 0, 2),
                                  femisio = f_sysdate,
                                  ccartera = NULL
                            WHERE sseguro = v_pol.sseguro;
                        END IF;
                     EXCEPTION
                        WHEN OTHERS
                        THEN
                           lmensaje := SQLCODE;
                           num_err := 1;
                           p_tab_error (f_sysdate,
                                        f_user,
                                        'PAC_ADM.p_emitir_propuesta',
                                        8,
                                           'pcempres = '
                                        || pcempres
                                        || ' pnpoliza = '
                                        || pnpoliza
                                        || ' pncertif = '
                                        || pncertif
                                        || ' pcramo = '
                                        || pcramo
                                        || ' pcmodali = '
                                        || pcmodali
                                        || ' pctipseg = '
                                        || pctipseg
                                        || ' pccolect = '
                                        || pccolect
                                        || ' pcactivi = '
                                        || pcactivi
                                        || ' pmoneda = '
                                        || pmoneda
                                        || 'pcidioma = '
                                        || pcidioma,
                                        SQLERRM
                                       );
                     END;
                  ELSE
                     -- Si es un suplemento
                     lfcanua := v_pol.fcaranu;
                     lfcapro := v_pol.fcarpro;

                     IF v_pol.cforpag = 0 AND lcrevfpg = 1
                     THEN
                        lfvencim := NVL (v_pol.fvencim, lfefecto + 1);
                     ELSE
                        lfvencim := lfcapro;
                     END IF;

                     BEGIN
                        IF lcmotmov <> 298
                        THEN
                           -- No es suspensió de pòlissa
                           -- pot tenir data d'anulació si és una regularització
                           -- feta després d'anular la pòlissa.
                           UPDATE seguros
                              SET csituac = DECODE (fanulac, NULL, 0, 2),
                                  femisio = f_sysdate,
                                  ccartera = NULL
                            WHERE sseguro = v_pol.sseguro;
                        END IF;
                     EXCEPTION
                        WHEN OTHERS
                        THEN
                           lmensaje := SQLCODE;
                           num_err := 1;
                           p_tab_error (f_sysdate,
                                        f_user,
                                        'PAC_ADM.p_emitir_propuesta',
                                        9,
                                           'pcempres = '
                                        || pcempres
                                        || ' pnpoliza = '
                                        || pnpoliza
                                        || ' pncertif = '
                                        || pncertif
                                        || ' pcramo = '
                                        || pcramo
                                        || ' pcmodali = '
                                        || pcmodali
                                        || ' pctipseg = '
                                        || pctipseg
                                        || ' pccolect = '
                                        || pccolect
                                        || ' pcactivi = '
                                        || pcactivi
                                        || ' pmoneda = '
                                        || pmoneda
                                        || 'pcidioma = '
                                        || pcidioma,
                                        SQLERRM
                                       );
                     END;
                  END IF;
               END IF;
            END IF;

            IF num_err = 0
            THEN
               BEGIN
                  SELECT DECODE (cimpres, 1, 0,
                                 --Se imprime
                                 0, 1,
                                 --No se imprime
                                 1)                                  --Tampoco
                    INTO xcimpres
                    FROM codimotmov
                   WHERE cmotmov = lcmotmov;

                  UPDATE movseguro
                     SET cimpres = xcimpres,
                         femisio = f_sysdate
                   WHERE sseguro = v_pol.sseguro AND femisio IS NULL;
               EXCEPTION
                  WHEN OTHERS
                  THEN
                     lmensaje := SQLCODE;
                     num_err := 1;
                     ROLLBACK;
                     p_tab_error (f_sysdate,
                                  f_user,
                                  'PAC_ADM.p_emitir_propuesta_col',
                                  17,
                                     'pcempres = '
                                  || pcempres
                                  || ' pnpoliza = '
                                  || pnpoliza
                                  || ' pncertif = '
                                  || pncertif
                                  || ' pcramo = '
                                  || pcramo
                                  || ' pcmodali = '
                                  || pcmodali
                                  || ' pctipseg = '
                                  || pctipseg
                                  || ' pccolect = '
                                  || pccolect
                                  || ' pcactivi = '
                                  || pcactivi
                                  || ' pmoneda = '
                                  || pmoneda
                                  || 'pcidioma = '
                                  || pcidioma,
                                  SQLERRM
                                 );
               END;
            END IF;

            IF num_err = 0
            THEN
               -- Si se asigna el numero de póliza en la emisión
               IF
                  /*-- INI--BUG18631--ETM-----NVL(f_parproductos_v(v_pol.sproduc, 'NPOLIZA_EN_EMISION'), 0) = 1 AND   --FIN--*/
                  lctipmov = 0
               THEN
                  -- solo en Nueva Producción
                  -- Bug 7854 y 8745 - 12/02/2008 - RSC - Adaptación iAxis a productos colectivos con certificados
                  /*IF lcsubpro = 3
                  OR NVL(f_parproductos_v(v_pol.sproduc, 'ADMITE_CERTIFICADOS'), 0) = 1 THEN   -- colectivos*/
                  v_ncertif := 0;
                  v_npoliza_prefijo :=
                          f_parproductos_v (v_pol.sproduc, 'NPOLIZA_PREFIJO');

                  IF v_npoliza_prefijo IS NOT NULL
                  THEN
                     v_pol.cramo := v_npoliza_prefijo;
                  END IF;

                  -- Bug 16768 - APD - 22/11/2010 - se le pasa el valor 3 al parametro
                  -- pexp ya que se quiere que la poliza se a de 5 cifras
                  -- Ademas se sustituye la llamada f_contador por pac_propio.f_contador
                  --v_npoliza := f_contador('02', v_pol.cramo, 3);
                  v_npoliza :=
                     pac_propio.f_contador2 (v_pol.cempres,
                                             '02',
                                             v_pol.cramo,
                                             3
                                            );

                  -- fin Bug 16768 - APD - 22/11/2010
                  --INI--bug 18631--ETM--31/05/2011
                  IF NVL (f_parproductos_v (v_pol.sproduc, 'DETALLE_GARANT'),
                          0
                         ) IN (1, 2)
                  THEN
                     v_npoliza :=
                        pac_propio.f_contador2 (v_pol.cempres,
                                                '02',
                                                v_pol.cramo,
                                                3
                                               );
                  ELSE
                     v_npoliza :=
                        pac_propio.f_contador2 (v_pol.cempres,
                                                '02',
                                                v_pol.cramo
                                               );
                  END IF;

                  --fin-bug 18631--ETM--31/05/2011
                  --END IF;
                  BEGIN
                     UPDATE seguros
                        SET npoliza = NVL (v_npoliza, npoliza),
                            ncertif = NVL (v_ncertif, ncertif)
                      WHERE sseguro = v_pol.sseguro;
                  EXCEPTION
                     WHEN OTHERS
                     THEN
                        num_err := 1;
                        ROLLBACK;
                        p_tab_error (f_sysdate,
                                     f_user,
                                     'PAC_ADM.p_emitir_propuesta',
                                     22,
                                        'pcempres = '
                                     || pcempres
                                     || ' pnpoliza = '
                                     || pnpoliza
                                     || ' pncertif = '
                                     || pncertif
                                     || ' pcramo = '
                                     || pcramo
                                     || ' pcmodali = '
                                     || pcmodali
                                     || ' pctipseg = '
                                     || pctipseg
                                     || ' pccolect = '
                                     || pccolect
                                     || ' pcactivi = '
                                     || pcactivi
                                     || ' pmoneda = '
                                     || pmoneda
                                     || 'pcidioma = '
                                     || pcidioma,
                                     SQLERRM
                                    );
                  END;
               END IF;
            END IF;

            IF num_err = 1
            THEN
               pindice_e := pindice_e + 1;
               ltexto := f_axis_literales (lmensaje, pcidioma);
               num_err :=
                       f_proceslin (lsproces, ltexto, v_pol.sseguro, nprolin);
               p_tab_error (f_sysdate,
                            f_user,
                            'PAC_ADM.p_emitir_propuesta',
                            23,
                               'pcempres = '
                            || pcempres
                            || ' pnpoliza = '
                            || pnpoliza
                            || ' pncertif = '
                            || pncertif
                            || ' pcramo = '
                            || pcramo
                            || ' pcmodali = '
                            || pcmodali
                            || ' pctipseg = '
                            || pctipseg
                            || ' pccolect = '
                            || pccolect
                            || ' pcactivi = '
                            || pcactivi
                            || ' pmoneda = '
                            || pmoneda
                            || 'pcidioma = '
                            || pcidioma,
                            f_axis_literales (lmensaje, pcidioma)
                           );
               COMMIT;

               --Posem el creteni = 1 si esta a 6
               UPDATE seguros
                  SET creteni = 1,
                      ccartera = NULL
                WHERE sseguro = v_pol.sseguro AND creteni = 99;
            ELSE
               -- Si todo ha ido bien que calcule un nuevo numrec
               lnumrec := NULL;

               UPDATE estseguros
                  SET csituac = 2                                    --Emitido
                WHERE sseguro = v_pol.sseguro;
            END IF;
         END LOOP;                                            -- Cursor Poliza

         CLOSE c_pol;

         IF psproces IS NULL
         THEN
            IF f_procesfin (lsproces, num_err) = 0
            THEN
               NULL;
            END IF;
         END IF;
      EXCEPTION
         WHEN OTHERS
         THEN
            -- BUG -21546_108724- 08/02/2012 - JLTS - Cierre de posibles cursores abiertos
            IF c_pol%ISOPEN
            THEN
               CLOSE c_pol;
            END IF;

            ROLLBACK;

            CLOSE c_pol;

            pindice_e := pindice_e + 1;
            p_tab_error (f_sysdate,
                         f_user,
                         'PAC_ADM.p_emitir_propuesta_col',
                         25,
                            'pcempres = '
                         || pcempres
                         || ' pnpoliza = '
                         || pnpoliza
                         || ' pncertif = '
                         || pncertif
                         || ' pcramo = '
                         || pcramo
                         || ' pcmodali = '
                         || pcmodali
                         || ' pctipseg = '
                         || pctipseg
                         || ' pccolect = '
                         || pccolect
                         || ' pcactivi = '
                         || pcactivi
                         || ' pmoneda = '
                         || pmoneda
                         || 'pcidioma = '
                         || pcidioma,
                         SQLERRM
                        );
      END;
   --
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      'PAC_ADM.p_emitir_propuesta_col',
                      0,
                         'pcempres = '
                      || pcempres
                      || ' pnpoliza = '
                      || pnpoliza
                      || ' pncertif = '
                      || pncertif
                      || ' pcramo = '
                      || pcramo
                      || ' pcmodali = '
                      || pcmodali
                      || ' pctipseg = '
                      || pctipseg
                      || ' pccolect = '
                      || pccolect
                      || ' pcactivi = '
                      || pcactivi
                      || ' pmoneda = '
                      || pmoneda
                      || 'pcidioma = '
                      || pcidioma,
                      SQLERRM
                     );
   END p_emitir_propuesta_col;

   -- BUG18054:DRA:23/03/2011:Inici
   FUNCTION f_get_seq_cont (pcempres IN NUMBER)
      RETURN NUMBER
   IS
      --
      v_select        VARCHAR2 (1000);
      v_nrecibo       tmp_adm_movrecibo.nrecibo%TYPE;
      --       v_nrecibo      NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      ex_nodeclared   EXCEPTION;
      PRAGMA EXCEPTION_INIT (ex_nodeclared, -2289);
   -- ORA-02289: no existe la secuencia
   BEGIN
      BEGIN
         v_select :=
               'SELECT seq_cont_'
            || LPAD (pcempres, 2, '00')
            || '.NEXTVAL FROM DUAL';

         EXECUTE IMMEDIATE v_select
                      INTO v_nrecibo;
      EXCEPTION
         WHEN ex_nodeclared
         THEN
            -- ORA-02289: no existe la secuencia
            -- Usamos la secuencia por defecto que hacía servir la F_INSRECIBO
            SELECT seq_cont_09.NEXTVAL
              INTO v_nrecibo
              FROM DUAL;
      END;

      RETURN v_nrecibo;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      'PAC_ADM.f_get_seq_cont',
                      0,
                      'pcempres = ' || pcempres,
                      SQLCODE || ' : ' || SQLERRM
                     );
         RETURN 0;
   END f_get_seq_cont;

   -- BUG18054:DRA:23/03/2011:Fi

   /***************************************************************************
      FUNCTION f_es_recibo_solo_ahorro
      Comprueba si el recibo es solo de ahorro.
         param in  pnrecibo: numero de recibo.
         return:  0-No, 1-Si
   ***************************************************************************/
   FUNCTION f_es_recibo_ahorro (pnrecibo IN NUMBER)
      RETURN NUMBER
   IS
      vobject     VARCHAR2 (200)          := 'PAC_ADM.f_es_recibo_ahorro';
      vpasexec    NUMBER                  := 0;
      vparam      VARCHAR2 (100)          := 'r=' || pnrecibo;
      v_cgarant   garanseg.cgarant%TYPE;
   BEGIN
      vpasexec := 1;

      BEGIN
         SELECT DISTINCT d.cgarant
                    INTO v_cgarant
                    FROM recibos r, seguros s, detrecibos d
                   WHERE r.nrecibo = pnrecibo
                     AND r.sseguro = s.sseguro
                     AND r.nrecibo = d.nrecibo
                     AND EXISTS (
                            SELECT 1
                              FROM detrecibos
                             WHERE nrecibo = r.nrecibo
                               AND f_pargaranpro_v (s.cramo,
                                                    s.cmodali,
                                                    s.ctipseg,
                                                    s.ccolect,
                                                    s.cactivi,
                                                    cgarant,
                                                    'TIPO'
                                                   ) IN (3, 4));

         RETURN 1;
      EXCEPTION
         WHEN TOO_MANY_ROWS
         THEN
            RETURN 0;
         WHEN NO_DATA_FOUND
         THEN
            RETURN 0;
      END;

      RETURN 0;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      vobject,
                      vpasexec,
                      vparam,
                      SQLCODE || ' ' || SQLERRM
                     );
         RETURN NULL;
   END f_es_recibo_ahorro;

   /***************************************************************************
      FUNCTION f_es_recibo_riesgo
      Comprueba si el recibo es solo de ahorro.
         param in  pnrecibo: numero de recibo.
         return:  0-No, 1-Si
   ***************************************************************************/
   FUNCTION f_es_recibo_riesgo (pnrecibo IN NUMBER)
      RETURN NUMBER
   IS
      vobject     VARCHAR2 (200)             := 'PAC_ADM.f_es_recibo_riesgo';
      vpasexec    NUMBER                     := 0;
      vparam      VARCHAR2 (100)             := 'r=' || pnrecibo;
      v_cvalpar   pargaranpro.cvalpar%TYPE;
   BEGIN
      vpasexec := 1;

      BEGIN
         SELECT DISTINCT p.cvalpar
                    INTO v_cvalpar
                    FROM recibos r, seguros s, detrecibos d, pargaranpro p
                   WHERE r.nrecibo = pnrecibo
                     AND r.sseguro = s.sseguro
                     AND r.nrecibo = d.nrecibo
                     AND s.sproduc = p.sproduc
                     AND d.cgarant = p.cgarant
                     AND p.cpargar = 'TIPO';

         IF v_cvalpar IN (6)
         THEN
            RETURN 1;
         END IF;
      EXCEPTION
         WHEN TOO_MANY_ROWS
         THEN
            RETURN 0;
         WHEN NO_DATA_FOUND
         THEN
            RETURN 0;
      END;

      RETURN 0;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      vobject,
                      vpasexec,
                      vparam,
                      SQLCODE || ' ' || SQLERRM
                     );
         RETURN NULL;
   END f_es_recibo_riesgo;

   /**********************************************************************************************
      Duplica un rebut.
      pmodali      IN Modalitat: 1- deixa el nou rebut amb estat Pendent, 2- Crea el rebut com a cobrat.
      pnrecibo     IN Recibo anterior a duplicar.
      pnreciboclon OUT : Nuevo número de recibo.
      psmovagr     IN OUT : Secuencial de agrupación recibos.
      pfefecto     IN Fecha efecto nuevo recibo, sino asigna la del recibo anterior.
      porigen      IN Origen peticion de clonar (1-Rehabilitacion).
      pctiprecclon IN Tipo de recibo con el que ha de quedar el clon (1- Suplemento, 9-Extorno) -- IAXIS-4926 23/10/2019     
   ************************************************************************************************/
   -- BUG 0021028 - 07/02/2012 - JMF
   FUNCTION f_clonrecibo (
      pmodali        IN       NUMBER,
      pnrecibo       IN       NUMBER,
      pnreciboclon   OUT      NUMBER,
      psmovagr       IN OUT   NUMBER,
      pfefecto       IN       DATE DEFAULT NULL,
      porigen        IN       NUMBER DEFAULT 0,
      pctiprecclon   IN       NUMBER DEFAULT NULL, -- IAXIS-4926 23/10/2019     
      pcsubtiprecclon IN      NUMBER DEFAULT NULL  -- IAXIS-7627 18/11/2019
   )
      RETURN NUMBER
   IS
      vobject      VARCHAR2 (200)              := 'PAC_ADM.f_clonrecibo';
      vpasexec     NUMBER                      := 0;
      vparam       VARCHAR2 (100)
         :=    ' m='
            || pmodali
            || ' r='
            || pnrecibo
            || ' a='
            || psmovagr
            || ' e='
            || pfefecto
            || ' o='
            || porigen;
      w_nrecclon   recibos.nrecibo%TYPE        := 0;
      w_fechaux    recibosclon.frecclon%TYPE   := f_sysdate;
      --       w_fechaux      DATE := f_sysdate; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      w_cagente    recibos.cagente%TYPE;
      w_sseguro    recibos.sseguro%TYPE;
      w_cdelega    recibos.cdelega%TYPE;
      w_sproduc    seguros.sproduc%TYPE;
      w_nliqmen    NUMBER                      := NULL;
      w_nliqlin    NUMBER                      := NULL;
      n_error      NUMBER;
      xccobban     recibos.ccobban%TYPE;
      --       xccobban       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      xcempres     recibos.cempres%TYPE;
      --       xcempres       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      -- 60.0 - 25/11/2013 - MMM - 0028986: LCOL_A004-Qtracker: 10043, 10046, 10051 - Inicio
      xctipcoa     NUMBER;
      xsmovrec     NUMBER;
      xfmovim      DATE;
      xfemisio     DATE;
      xfefecto     DATE;
      xnmovimi     NUMBER;
      vfmovdia     DATE; -- IAXIS-4926 23/10/2019
   -- 60.0 - 25/11/2013 - MMM - 0028986: LCOL_A004-Qtracker: 10043, 10046, 10051 - Fin
   BEGIN
      vpasexec := 1000;
      n_error := 0;

      --
      -- Recuperamos datos del recibo original
      --
      BEGIN
         vpasexec := 1010;

         -- 60.0 - 25/11/2013 - MMM - 0028986: LCOL_A004-Qtracker: 10043, 10046, 10051 - Inicio
         --SELECT r.sseguro, r.cagente, r.cdelega, r.ccobban, r.cempres
         --  INTO w_sseguro, w_cagente, w_cdelega, xccobban, xcempres
         SELECT r.sseguro, r.cagente, r.cdelega, r.ccobban, r.cempres,
                r.femisio, r.fefecto, r.ctipcoa, s.sproduc
           INTO w_sseguro, w_cagente, w_cdelega, xccobban, xcempres,
                xfemisio, xfefecto, xctipcoa, w_sproduc
           -- 60.0 - 25/11/2013 - MMM - 0028986: LCOL_A004-Qtracker: 10043, 10046, 10051 - Fin
         FROM   recibos r, seguros s
          WHERE r.nrecibo = pnrecibo AND s.sseguro = r.sseguro;
      EXCEPTION
         WHEN OTHERS
         THEN
            -- Recibo no encontrado en la tabla RECIBOS
            RETURN 101902;
      END;

      vpasexec := 1020;
      pnreciboclon := NULL;
      w_nrecclon := pac_adm.f_get_seq_cont (xcempres);

      IF NVL (w_nrecclon, 0) = 0
      THEN
         -- Devuelto número de recibo incorrecto
         RETURN 102876;
      END IF;

      --
      -- Inserción de recibos en tabla RECIBOS
      --
      vpasexec := 1030;

      BEGIN
         INSERT INTO recibos
                     (nrecibo, cagente, cempres, nmovimi, sseguro, femisio,
                      fefecto, fvencim, ctiprec, cdelega, ccobban, cestaux,
                      nanuali, nfracci, cestimp, nriesgo, cforpag, cbancar,
                      nmovanu, cretenc, pretenc, ncuacoa, ctipcoa, cestsop,
                      cmanual, nperven, ctransf, cgescob, festimp, ctipban,
                      esccero, ctipcob, creccia, cvalidado, sperson,
                      ctipapor, ctipaportante, cmodifi, ncuotar, csubtiprec) -- IAXIS-4926 23/10/2019
            SELECT w_nrecclon, cagente, cempres, nmovimi, sseguro, w_fechaux,

                   -- femisio -- bug: 29068
                   NVL (pfefecto, fefecto), fvencim, NVL(pctiprecclon, ctiprec), cdelega,
                   xccobban, cestaux, nanuali, nfracci, cestimp, nriesgo,
                   cforpag, cbancar, nmovanu, cretenc, pretenc, ncuacoa,
                   ctipcoa, cestsop, cmanual, nperven, ctransf, cgescob,
                   festimp, ctipban, esccero, ctipcob, creccia, cvalidado,
                   sperson, ctipapor, ctipaportante, cmodifi, ncuotar, NVL(pcsubtiprecclon, csubtiprec) -- IAXIS-4926 23/10/2019 -- IAXIS-7627 18/11/2019
              FROM recibos
             WHERE nrecibo = pnrecibo;
      EXCEPTION
         WHEN OTHERS
         THEN
            -- Error al insertar en RECIBOS
            RETURN 103847;
      END;

      --
      -- Duplicación del recibo clonado en la tabla DETRECIBOS.
      --
      vpasexec := 1040;

      BEGIN
         INSERT INTO detrecibos
                     (nrecibo, cconcep, cgarant, nriesgo, iconcep, cageven,
                      nmovima, fcambio) -- IAXIS-4926 23/10/2019 
            SELECT w_nrecclon, cconcep, cgarant, nriesgo, iconcep, cageven,
                   nmovima, DECODE(porigen, 2, fcambio, NULL) -- IAXIS-4926 23/10/2019 En caso de anulación, devolvemos a la fecha de cambio del recibo original 
              FROM detrecibos
             WHERE nrecibo = pnrecibo;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            RETURN 103469;                 -- Registre no trobat a DETRECIBOS
         WHEN DUP_VAL_ON_INDEX
         THEN
            RETURN 102311;                 -- Registre duplicat en DETRECIBOS
         WHEN OTHERS
         THEN
            RETURN 103513;                 -- Error a l' inserir a DETRECIBOS
      END;

      --
      -- Duplicación del recibo clonado en la tabla RECIBOSREDCOM.
      --
      vpasexec := 1050;

      BEGIN
         INSERT INTO recibosredcom
                     (nrecibo, cempres, cagente, ctipage, nnivel)
            SELECT w_nrecclon, cempres, cagente, ctipage, nnivel
              FROM recibosredcom
             WHERE nrecibo = pnrecibo;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            RETURN 103909;              -- Registre no trobat a RECIBOSREDCOM
         WHEN DUP_VAL_ON_INDEX
         THEN
            RETURN 103907;              -- Registre duplicat en RECIBOSREDCOM
         WHEN OTHERS
         THEN
            RETURN 103354;              -- Error a l' inserir a RECIBOSREDCOM
      END;

      --
      -- Duplicación del recibo clonado en la tabla VDETRECIBOS.
      --
      vpasexec := 1060;

      BEGIN
         INSERT INTO vdetrecibos
                     (nrecibo, iprinet, irecext, iconsor, ireccon, iips,
                      idgs, iarbitr, ifng, irecfra, idtotec, idtocom,
                      icombru, icomret, idtoom, ipridev, itotpri, itotdto,
                      itotcon, itotimp, itotalr, iderreg, itotrec, icomdev,
                      iretdev, icednet, icedrex, icedcon, icedrco, icedips,
                      iceddgs, icedarb, icedfng, icedrfr, iceddte, iceddco,
                      icedcbr, icedcrt, iceddom, icedpdv, icedreg, icedcdv,
                      icedrdv, it1pri, it1dto, it1con, it1imp, it1rec,
                      it1totr, it2pri, it2dto, it2con, it2imp, it2rec,
                      it2totr, icomcia, icombrui, icomreti, icomdevi,
                      icomdrti, icombruc, icomretc, icomdevc, icomdrtc,
                      iocorec, iimp_1, iimp_2, iimp_3, iimp_4
                                                             -- 38. 27/03/2012 JGR 0020546/104206
                     )
            SELECT w_nrecclon, iprinet, irecext, iconsor, ireccon, iips,
                   idgs, iarbitr, ifng, irecfra, idtotec, idtocom, icombru,
                   icomret, idtoom, ipridev, itotpri, itotdto, itotcon,
                   itotimp, itotalr, iderreg, itotrec, icomdev, iretdev,
                   icednet, icedrex, icedcon, icedrco, icedips, iceddgs,
                   icedarb, icedfng, icedrfr, iceddte, iceddco, icedcbr,
                   icedcrt, iceddom, icedpdv, icedreg, icedcdv, icedrdv,
                   it1pri, it1dto, it1con, it1imp, it1rec, it1totr, it2pri,
                   it2dto, it2con, it2imp, it2rec, it2totr, icomcia,
                   icombrui, icomreti, icomdevi, icomdrti, icombruc,
                   icomretc, icomdevc, icomdrtc, iocorec, iimp_1, iimp_2,
                   iimp_3, iimp_4        -- 38. 27/03/2012 JGR 0020546/104206
              FROM vdetrecibos
             WHERE nrecibo = pnrecibo;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            RETURN 103936;                -- Registre no trobat a VDETRECIBOS
         WHEN DUP_VAL_ON_INDEX
         THEN
            RETURN 103471;                -- Registre duplicat en VDETRECIBOS
         WHEN OTHERS
         THEN
            RETURN 103473;                -- Error a l' inserir a VDETRECIBOS
      END;

      -- AFM Inicio 0029068
      --
      --Insertem els registres necessaris a movrecibo
      --
      vpasexec := 1070;
      n_error :=
         f_movrecibo (w_nrecclon,
                      0,
                      NULL,
                      NULL,
                      psmovagr,
                      w_nliqmen,
                      w_nliqlin,
                      w_fechaux,
                      xccobban,
                      w_cdelega,
                      NULL,
                      w_cagente
                     );
      -- ini Multimoneda
      vpasexec := 1062;

      IF NVL (pac_parametros.f_parempresa_n (xcempres, 'MULTIMONEDA'), 0) = 1
      THEN
         vpasexec := 1064;
         n_error := pac_oper_monedas.f_contravalores_recibo (w_nrecclon, 'R');

         IF n_error <> 0
         THEN
            RAISE NO_DATA_FOUND;
         END IF;

         vpasexec := 1066;
         n_error := pac_oper_monedas.f_vdetrecibos_monpol (w_nrecclon, 'R');

         IF n_error <> 0
         THEN
            RAISE NO_DATA_FOUND;
         END IF;
      END IF;

      -- fin Multimoneda
      -- AFM Final 0029068
      --------- INI BUG: 29068- 27/11/2013
      IF NVL (f_parproductos_v (w_sproduc, 'HAYCTACLIENTE'), 0) = 1
      THEN
         n_error :=
            pac_ctacliente.f_ins_movrecctacli (xcempres,
                                               w_sseguro,
                                               NULL,
                                               w_nrecclon
                                              );

         IF n_error <> 0
         THEN
            RETURN n_error;
         END IF;
      ELSIF NVL (f_parproductos_v (w_sproduc, 'HAYCTACLIENTE'), 0) = 2
      THEN
         SELECT nmovimi
           INTO xnmovimi
           FROM recibos
          WHERE nrecibo = w_nrecclon;

         n_error :=
            pac_ctacliente.f_apunte_spl (xcempres,
                                         w_sseguro,
                                         xnmovimi,
                                         w_nrecclon
                                        );

         IF n_error <> 0
         THEN
            RETURN n_error;
         END IF;
      END IF;

      --
      IF pmodali = 2
      THEN
         vpasexec := 1080;
         n_error :=
            f_movrecibo (w_nrecclon,
                         1,
                         NULL,
                         NULL,
                         psmovagr,
                         w_nliqmen,
                         w_nliqlin,
                         w_fechaux,
                         xccobban,
                         w_cdelega,
                         NULL,
                         w_cagente
                        );
      END IF;

      --------- FIN BUG: 29068- 27/11/2013
      --
      -- Inserción del recibo clonado en la tabla RECIBOSCLON.
      --
      vpasexec := 1090;

      BEGIN
         INSERT INTO recibosclon
                     (sseguro, nreciboant, nreciboact, frecclon, corigen
                     )
              VALUES (w_sseguro, pnrecibo, w_nrecclon, w_fechaux, porigen
                     );
      END;

      vpasexec := 1100;
      pnreciboclon := w_nrecclon;

      -- 60.0 - 25/11/2013 - MMM - 0028986: LCOL_A004-Qtracker: 10043, 10046, 10051 - Inicio
      IF NVL (xctipcoa, 0) > 0
      THEN
         BEGIN
            SELECT smovrec
              INTO xsmovrec
              FROM movrecibo
             WHERE nrecibo = pnreciboclon AND fmovfin IS NULL;
         EXCEPTION
            WHEN OTHERS
            THEN
               p_tab_error (f_sysdate,
                            f_user,
                               'PAC_ADM.f_clonrecibo  num_recibo = '
                            || pnreciboclon,
                            NULL,
                            'WHEN OTHERS RETURN 104043',
                            SQLERRM
                           );
               RETURN 104043;
         END;

         xfefecto := NVL (pfefecto, xfefecto);

         IF xfemisio < xfefecto
         THEN
            xfmovim := xfefecto;
         ELSE
            xfmovim := xfemisio;
         END IF;

         n_error :=
                   f_insctacoas (pnreciboclon, 0, xcempres, xsmovrec, xfmovim);

         IF n_error <> 0
         THEN
            RETURN n_error;
         END IF;
      END IF;                            -- Del IF que mira si tiene coaseguro

      -- 60.0 - 25/11/2013 - MMM - 0028986: LCOL_A004-Qtracker: 10043, 10046, 10051 - Fin

      --ini Bug 0029068 - 13/12/2010 - JMF
      vpasexec := 1100;

      DECLARE
         xcactivi   seguros.cactivi%TYPE;
         xcramo     seguros.cramo%TYPE;
         xcmodali   seguros.cmodali%TYPE;
         xctipseg   seguros.ctipseg%TYPE;
         xccolect   seguros.ccolect%TYPE;
         xfefecto   recibos.fefecto%TYPE;
         xfvencim   recibos.fvencim%TYPE;
         xcmoneda   codidivisa.cmoneda%TYPE;
         xnproces   procesoscab.sproces%TYPE;
      BEGIN
         vpasexec := 1110;
         n_error :=
            f_procesini (f_user,
                         xcempres,
                         'CLONRECIBO',
                         'Ant=' || pnrecibo || ' Act=' || w_nrecclon,
                         xnproces
                        );

         SELECT b.cactivi, b.cramo, b.cmodali, b.ctipseg, b.ccolect,
                a.fefecto, a.fvencim,
                pac_monedas.f_moneda_producto (b.sproduc)
           INTO xcactivi, xcramo, xcmodali, xctipseg, xccolect,
                xfefecto, xfvencim,
                xcmoneda
           FROM recibos a, seguros b
          WHERE a.nrecibo = w_nrecclon AND b.sseguro = a.sseguro;

         vpasexec := 1120;
         n_error :=
            pac_cesionesrea.f_cessio_det (xnproces,
                                          w_sseguro,
                                          w_nrecclon,
                                          xcactivi,
                                          xcramo,
                                          xcmodali,
                                          xctipseg,
                                          xccolect,
                                          xfefecto,
                                          xfvencim,
                                          1,
                                          xcmoneda
                                         );

         IF n_error <> 0
         THEN
            RAISE NO_DATA_FOUND;
         END IF;
      END;

      --fin Bug 0029068 - 13/12/2010 - JMF
      
      --
      -- Inicio IAXIS-4926 23/10/2019                
      --
      -- Duplicación del recibo clonado en la tabla COMRECIBO.
      --
      vpasexec := 1060;

      SELECT m.fmovdia
        INTO vfmovdia
        FROM movrecibo m
       WHERE m.nrecibo = w_nrecclon
         AND m.smovrec = (SELECT MAX(m1.smovrec)
                            FROM movrecibo m1
                           WHERE m1.nrecibo = m.nrecibo);
      
      BEGIN
        INSERT INTO comrecibo
          (nrecibo,
           nnumcom,
           cagente,
           cestrec,
           fmovdia,
           fcontab,
           icombru,
           icomret,
           icomdev,
           iretdev,
           nmovimi,
           icombru_moncia,
           icomret_moncia,
           icomdev_moncia,
           iretdev_moncia,
           fcambio,
           cgarant,
           icomcedida,
           icomcedida_moncia,
           ccompan,
           ivacomisi)
          SELECT w_nrecclon,
                 nnumcom,
                 cagente,
                 cestrec,
                 vfmovdia,
                 TRUNC(f_sysdate),
                 icombru,
                 icomret,
                 icomdev,
                 iretdev,
                 nmovimi,
                 icombru_moncia,
                 icomret_moncia,
                 icomdev_moncia,
                 iretdev_moncia,
                 fcambio,
                 cgarant,
                 icomcedida,
                 icomcedida_moncia,
                 ccompan,
                 ivacomisi
            FROM comrecibo
           WHERE nrecibo = pnrecibo;
      EXCEPTION
        WHEN no_data_found THEN
          RETURN 89907067; -- Registro no encontrado en COMRECIBO
        WHEN dup_val_on_index THEN
          RETURN 89907068; -- Registro duplicado en COMRECIBO
        WHEN OTHERS THEN
          RETURN 89907069; -- Error al insertar en COMRECIBO
      END;
      --
      -- Fin IAXIS-4926 23/10/2019                
      --
      RETURN n_error;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      vobject,
                      vpasexec,
                      vparam || ' e=' || n_error,
                      SQLCODE || ' ' || SQLERRM
                     );
         RETURN 180272;
   END f_clonrecibo;

   /**********************************************************************************************
      13/06/2012 - 40. 0022512: LCOL_A001-Modificacion medio de pago de Debito a Efectivo - No se modifica el subestado
      Saber si una cuenta corriente de seguro-riesgo o recibo está validada
      Se han de informar los parámetros (sseguro+riesgo) o (nrecibo), si se informan todos lo hace por recibo.
      pcbancar     Cuenta corriente .
      psseguro     Seguro            (opcional)
      pnriesgo     Número de riesgo  (opcional)
      pnrecibo     Recibo            (opcional)
   ************************************************************************************************/
   FUNCTION f_per_ccc_cvalida (
      pcbancar   IN   VARCHAR2,
      psseguro   IN   NUMBER DEFAULT NULL,
      pnriesgo   IN   NUMBER DEFAULT NULL,
      pnrecibo   IN   NUMBER DEFAULT NULL
   )
      RETURN NUMBER
   IS
      vsseguro   recibos.sseguro%TYPE   := psseguro;
      vsperson   recibos.sperson%TYPE;
      vnriesgo   recibos.nriesgo%TYPE   := pnriesgo;
      vctipreb   seguros.ctipreb%TYPE;
      vcvalida   per_ccc.cvalida%TYPE;
      vobject    VARCHAR2 (200)         := 'PAC_ADM.f_per_ccc_cvalida';
      vpasexec   NUMBER                 := 0;
      vparam     VARCHAR2 (100)
         :=    ' pcbancar='
            || pcbancar
            || ' psseguro='
            || psseguro
            || ' pnriesgo='
            || pnriesgo
            || ' pnrecibo='
            || pnrecibo;
   BEGIN
      vpasexec := 5;

      IF pcbancar IS NOT NULL
      THEN
         IF pnrecibo IS NOT NULL
         THEN
            BEGIN
               vpasexec := 10;

               -- Pagador del recibo
               SELECT r.sperson, r.sseguro, NVL (r.nriesgo, 1), s.ctipreb
                 INTO vsperson, vsseguro, vnriesgo, vctipreb
                 FROM recibos r, seguros s
                WHERE r.nrecibo = pnrecibo AND r.sseguro = s.sseguro;
            EXCEPTION
               WHEN OTHERS
               THEN
                  vsperson := NULL;
            END;
         ELSIF psseguro IS NOT NULL
         THEN
            vpasexec := 15;

            SELECT s.ctipreb
              INTO vctipreb
              FROM seguros s
             WHERE s.sseguro = psseguro;

            -- Pagador de la póliza
            BEGIN
               vpasexec := 20;

               SELECT sperson
                 INTO vsperson
                 FROM gescobros
                WHERE sseguro = psseguro;
            EXCEPTION
               WHEN OTHERS
               THEN
                  vsperson := NULL;
            END;
         END IF;

         IF vsperson IS NULL
         THEN
            IF vctipreb = 2
            THEN
               -- Recibo por asegurado
               BEGIN
                  vpasexec := 25;

                  SELECT sperson
                    INTO vsperson
                    FROM riesgos
                   WHERE sseguro = vsseguro AND nriesgo = vnriesgo;
               EXCEPTION
                  WHEN OTHERS
                  THEN
                     vsperson := NULL;
               END;
            ELSE
               BEGIN
                  vpasexec := 30;

                  SELECT sperson
                    INTO vsperson
                    FROM tomadores a
                   WHERE sseguro = vsseguro
                     AND nordtom = (SELECT MIN (nordtom)
                                      FROM tomadores b
                                     WHERE a.sseguro = vsseguro);
               EXCEPTION
                  WHEN OTHERS
                  THEN
                     vsperson := NULL;
               END;
            END IF;
         END IF;

         IF vsperson IS NOT NULL
         THEN
            BEGIN
               vpasexec := 35;

               SELECT MAX (cvalida)
                 INTO vcvalida
                 FROM per_ccc
                WHERE cbancar = pcbancar AND sperson = vsperson;
            EXCEPTION
               WHEN OTHERS
               THEN
                  vcvalida := NULL;
            END;
         ELSE
            vcvalida := NULL;
         END IF;
      END IF;

      vpasexec := 40;
      RETURN vcvalida;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      vobject,
                      vpasexec,
                      vparam,
                      SQLCODE || ' ' || SQLERRM
                     );
         RETURN 180272;
   END f_per_ccc_cvalida;

   /**********************************************************************************************
      29/05/2012 - 41. 0022327: MDP_A001-Consulta de recibos - 0115278
      Extrae la información detallada del recibo por garantías.
      pnrecibo     IN Recibo.
      pcidioma     IN Código de idioma
      pnriesgo     IN número de riesgo (opcional)
      pcgarant     IN código de la garantía (opcional)
   ************************************************************************************************/
   FUNCTION f_get_detrecibo_gtias (
      pnrecibo   IN   NUMBER,
      pcidioma   IN   NUMBER DEFAULT NULL,
      pnriesgo   IN   NUMBER DEFAULT NULL,
      pcgarant   IN   NUMBER DEFAULT NULL
   )
      RETURN VARCHAR2
   IS
      --vnumerr        NUMBER(8) := 0;
      squery      VARCHAR2 (9000);
      vpasexec    NUMBER (8)      := 0;
      v_max_reg   NUMBER;               -- número màxim de registres mostrats
      vparam      VARCHAR2 (1500)
         :=    'parámetros - pnrecibo: '
            || pnrecibo
            || ', pnriesgo: '
            || pnriesgo
            || ', pcgarant: '
            || pcgarant;
      vobject     VARCHAR2 (200)  := 'PAC_ADM.F_GET_DETRECIBOS_GTIAS';
      vcidioma    NUMBER      := NVL (pcidioma, pac_md_common.f_get_cxtidioma);
      cont        NUMBER          := 0;
   --numrecs        NUMBER;
   BEGIN
      vpasexec := 1;

      BEGIN
         SELECT COUNT (1)
           INTO cont
           FROM detmovrecibo_parcial
          WHERE nrecibo = pnrecibo;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            cont := 0;
      END;

       -- INI IAXIS-3592 -- ECP -- 27/05/2019
      IF cont = 0
       THEN

      -- INI -IAXIS-3264.Inclusión del campo cmotmov_baja en la siguiente consulta
      squery   := ' SELECT pac_adm.f_cmotmov_baja(r.sseguro,r.nmovimi,r.nrecibo) cmotmov_baja,d.cgarant, g.TGARANT, d.nriesgo, '
      -- FIN -IAXIS-3264.
             || ' F_DESRIESGO_T (r.sseguro, d.nriesgo, f_sysdate, '
             || vcidioma
             || ',r.nmovimi'             -- Bug 26923/148935 - 11/07/2013 - AMC
             || ') triesgo, '
             || '  SUM(DECODE(cconcep,  0, iconcep, 0)) iprinet, '
             || '  SUM(DECODE(cconcep, 21, iconcep,   '
             || '                      71, DECODE(r.ctipcoa, 1, iconcep, 0), 0)) ipridev,'
             || '  SUM(DECODE(cconcep,  9, iconcep,   '
             || '                      59, DECODE(r.ctipcoa, 1, iconcep, 0), 0)) idtotec,'
             || '  SUM(DECODE(cconcep, 10, iconcep,'
             || '                      60, DECODE(r.ctipcoa, 1, iconcep, 0), 0)) idtocom,'
             || '  SUM(DECODE(cconcep, 13, iconcep,'
             || '                      63, DECODE(r.ctipcoa, 1, iconcep, 0), 0)) idtoom,'
             || '  SUM(DECODE(cconcep,  8, iconcep,'
             || '                      58, DECODE(r.ctipcoa, 1, iconcep, 0),'
             || '                      14, iconcep,'
             || '                      64, DECODE(r.ctipcoa, 1, iconcep, 0), 0)) it1rec,'
             || '  SUM(DECODE(cconcep,  2, iconcep,'
             || '                      52, DECODE(r.ctipcoa, 1, iconcep, 0), 0)) iconsor,'
             || '  SUM(DECODE(cconcep,  4, iconcep,'
             || '                      54, DECODE(r.ctipcoa, 1, iconcep, 0), 0)) iips,'
             || '  SUM(DECODE(cconcep,  5, iconcep,'
             || '                      55, DECODE(r.ctipcoa, 1, iconcep, 0), 0)) idgs,'
             || '  SUM(DECODE(cconcep,  6, iconcep,'
             || '                      56, DECODE(r.ctipcoa, 1, iconcep, 0), 0)) iarbitr,'
             || '  SUM(DECODE(cconcep,  7, iconcep,'
             || '                      57, DECODE(r.ctipcoa, 1, iconcep, 0), 0)) ifng, ';
          squery :=
                squery
             || ' SUM(DECODE(cconcep,  0, iconcep, '
             || '                      50, DECODE(r.ctipcoa, 1, iconcep, 0),'
             || '                       1, iconcep,                          '
             || '                      51, DECODE(r.ctipcoa, 1, iconcep, 0), '
             || '                       2, iconcep,                           '
             || '                      52, DECODE(r.ctipcoa, 1, iconcep, 0), '
             || '                       3, iconcep,                           '
             || '                      53, DECODE(r.ctipcoa, 1, iconcep, 0), '
             || '                       4, iconcep,                           '
             || '                      54, DECODE(r.ctipcoa, 1, iconcep, 0), '
             || '                       5, iconcep,                           '
             || '                      55, DECODE(r.ctipcoa, 1, iconcep, 0), '
             || '                       6, iconcep,                           '
             || '                      56, DECODE(r.ctipcoa, 1, iconcep, 0), '
             || '                       7, iconcep,                           '
             || '                      57, DECODE(r.ctipcoa, 1, iconcep, 0), '
             || '                       8, iconcep,                           '
             || '                      58, DECODE(r.ctipcoa, 1, iconcep, 0), '
             || '                      13, iconcep,                           '
             || '                      63, DECODE(r.ctipcoa, 1, iconcep, 0), '
             || '                      14, iconcep,                           '
             || '                      64, DECODE(r.ctipcoa, 1, iconcep, 0), '
             || '                      26, iconcep, 0) ) itotalr,'
             || '  SUM(DECODE(cconcep, 11, iconcep, 0)) icombru,  '
             || '  SUM(DECODE(cconcep, 12, iconcep, 0)) icomret,   '
             || '  SUM(DECODE(cconcep, 11, iconcep, 0)) -           '
             || '  SUM(DECODE(cconcep, 12, iconcep, 0)) icomliq,'
             || '  SUM(DECODE(cconcep, 15, iconcep, 0)) icomdev, '
             -- Inici Bug 22327/121869 - DCG 28/08/2012
             --       || '  SUM(DECODE(cconcep, 11, iconcep, 0)) * 100 / SUM(DECODE(cconcep,  0, iconcep, 0)) porc_comis,'
             -- || '  DECODE(SUM(DECODE(cconcep, 0, iconcep, 0)),0, 0,decode(SUM(DECODE(cconcep, 11, iconcep, 0)),0, 0,SUM(DECODE(cconcep, 11, iconcep, 0)) / SUM(DECODE(cconcep, 0, iconcep, 0)) * 100)) porc_comis,'
             -- Inicio Bug IAXIS-11902 - JRVG 24/02/2020
             || 'pac_adm.f_porc_comisi(r.sseguro,r.nmovimi) porc_comis,'
             -- Fin Bug IAXIS-11902 - JRVG 24/02/2020
             -- Fi Bug 22327/121869 - DCG 28/08/2012
             || '  SUM(DECODE(cconcep, 38, iconcep, 0)) ibonus_malos,'
             || '  SUM(DECODE(cconcep,  8, iconcep,'
             || '                      58, DECODE(r.ctipcoa, 1, iconcep, 0))) irecfrac, '
             || '  F_IMPGARANT(r.nrecibo,''LIQUIDO_COMISIONES'',d.cgarant,d.nriesgo) iliquido '
             || ' FROM detrecibos d, garangen g, recibos r '
             || '  WHERE r.nrecibo = '
             || pnrecibo
             || ' AND d.nrecibo = '
             || pnrecibo
             || ' AND d.cgarant = g.cgarant '
             || ' AND g.cidioma = '
             || vcidioma
             || ' ';
          vpasexec := 2;

          IF pnriesgo IS NOT NULL
          THEN
             squery := squery || ' AND d.nriesgo = ' || pnriesgo;
          END IF;

          vpasexec := 3;

          IF pcgarant IS NOT NULL
          THEN
             squery := squery || ' AND d.cgarant = ' || pcgarant;
          END IF;

          v_max_reg := pac_parametros.f_parinstalacion_n ('N_MAX_REG');

          IF v_max_reg IS NOT NULL
          THEN
             IF INSTR (squery, 'order by', -1, 1) > 0
             THEN
                -- se hace de esta manera para mantener el orden de los registros
                squery :=
                      'select * from ('
                   || squery
                   || ') where rownum <= '
                   || v_max_reg;
             ELSE
                squery := squery || ' and rownum <= ' || v_max_reg;
             END IF;
          END IF;
      -- INI -IAXIS-3264.Inclusión del campo cmotmov_baja en la siguiente consulta
      squery   := squery ||
                  ' GROUP BY pac_adm.f_cmotmov_baja(r.sseguro,r.nmovimi,r.nrecibo), d.cgarant, g.tgarant,d.nriesgo,r.sseguro,r.nmovimi, d.nriesgo,'
      -- FIN -IAXIS-3264.
             -- Bug 26923/148935 - 11/07/2013 - AMC
             || ' F_DESRIESGO_T (r.sseguro, d.nriesgo, f_sysdate, '
             || vcidioma
             || ',r.nmovimi'
             || '),'
             -- Fi Bug 26923/148935 - 11/07/2013 - AMC
             || ' F_IMPGARANT(r.nrecibo,''LIQUIDO_COMISIONES'',d.cgarant,d.nriesgo) '
             --Bug 36638-208480 24/06/2015 KJSC: ordenar por riesgo y garantia
             || ' ORDER BY d.nriesgo,d.cgarant';
          vpasexec := 4;
       ELSE
      vpasexec := 14;
      -- INI -IAXIS-3264.Inclusión del campo cmotmov_baja en la siguiente consulta
      squery   := 'SELECT pac_adm.f_cmotmov_baja(r.sseguro,r.nmovimi,r.nrecibo) cmotmov_baja, d.cgarant, g.TGARANT, d.nriesgo, '
      -- FIN -IAXIS-3264.

         || ' F_DESRIESGO_T (r.sseguro, d.nriesgo, f_sysdate, '
         || vcidioma
         || ',r.nmovimi'
         || ') triesgo, '
         || ' SUM(DECODE(d.cconcep,  0, d.iconcep - p.iconcep, 0)) iprinet, '
         || ' SUM(DECODE(d.cconcep, 21, d.iconcep - p.iconcep ,   '
         || '71, DECODE(r.ctipcoa, 1, d.iconcep - p.iconcep , 0), 0)) ipridev,'
         || '  SUM(DECODE(d.cconcep,  9, d.iconcep - p.iconcep ,   '
         || '59, DECODE(r.ctipcoa, 1, d.iconcep - p.iconcep , 0), 0)) idtotec,'
         || '  SUM(DECODE(d.cconcep, 10, d.iconcep - p.iconcep ,'
         || '60, DECODE(r.ctipcoa, 1, d.iconcep - p.iconcep , 0), 0)) idtocom,'
         || '  SUM(DECODE(d.cconcep, 13, d.iconcep - p.iconcep ,'
         || '63, DECODE(r.ctipcoa, 1, d.iconcep - p.iconcep , 0), 0)) idtoom,'
         || '  SUM(DECODE(d.cconcep,  8, d.iconcep - p.iconcep ,'
         || '58, DECODE(r.ctipcoa, 1, d.iconcep - p.iconcep , 0),'
         || '14, d.iconcep - p.iconcep ,'
         || '64, DECODE(r.ctipcoa, 1, d.iconcep - p.iconcep , 0), 0)) it1rec,'
         || ' SUM(DECODE(d.cconcep,  2, d.iconcep - p.iconcep  ,'
         || '52, DECODE(r.ctipcoa, 1, d.iconcep - p.iconcep , 0), 0)) iconsor,'
         || '  SUM(DECODE(d.cconcep,  4, d.iconcep - p.iconcep ,'
         || '54, DECODE(r.ctipcoa, 1, d.iconcep - p.iconcep , 0), 0)) iips,'
         || ' SUM(DECODE(d.cconcep,  5, d.iconcep - p.iconcep ,'
         || '55, DECODE(r.ctipcoa, 1, d.iconcep - p.iconcep , 0), 0)) idgs,'
         || '  SUM(DECODE(d.cconcep,  6, d.iconcep - p.iconcep ,'
         || '56, DECODE(r.ctipcoa, 1, d.iconcep - p.iconcep , 0), 0)) iarbitr,'
         || '  SUM(DECODE(d.cconcep,  7, d.iconcep - p.iconcep ,'
         || '57, DECODE(r.ctipcoa, 1, d.iconcep - p.iconcep  , 0), 0)) ifng, ';
      vpasexec := 15;
      squery :=
            squery
         || ' SUM(DECODE(d.cconcep,  0, d.iconcep - p.iconcep , '
         || '50, DECODE(r.ctipcoa, 1, d.iconcep - p.iconcep , 0),'
         || '1, d.iconcep ,                          '
         || '51, DECODE(r.ctipcoa, 1, d.iconcep - p.iconcep , 0), '
         || '2, d.iconcep ,                           '
         || '52, DECODE(r.ctipcoa, 1, d.iconcep - p.iconcep , 0), '
         || '3, d.iconcep ,                           '
         || '53, DECODE(r.ctipcoa, 1, d.iconcep - p.iconcep , 0), '
         || '4, d.iconcep ,                           '
         || '54, DECODE(r.ctipcoa, 1, d.iconcep - p.iconcep , 0), '
         || '5, d.iconcep ,                           '
         || '55, DECODE(r.ctipcoa, 1, d.iconcep - p.iconcep , 0), '
         || '6, d.iconcep ,                           '
         || '56, DECODE(r.ctipcoa, 1, d.iconcep - p.iconcep , 0), '
         || '7, d.iconcep , '
         || '57, DECODE(r.ctipcoa, 1, d.iconcep - p.iconcep , 0), '
         || '8, d.iconcep , ';
      vpasexec := 16;
      squery :=
            squery
         || '58, DECODE(r.ctipcoa, 1, d.iconcep - p.iconcep , 0), '
         || '13, d.iconcep ,                           '
         || '63, DECODE(r.ctipcoa, 1, d.iconcep - p.iconcep , 0), '
         || '14, d.iconcep ,                           '
         || '64, DECODE(r.ctipcoa, 1, d.iconcep - p.iconcep , 0), '
         || '26, d.iconcep - p.iconcep , 0) ) itotalr,'
         || 'SUM(DECODE(d.cconcep, 11, d.iconcep - p.iconcep , 0)) icombru,  '
         || 'SUM(DECODE(d.cconcep, 12, d.iconcep - p.iconcep , 0)) icomret,   '
         || 'SUM(DECODE(d.cconcep, 11, d.iconcep - p.iconcep , 0)) - '
         || 'SUM(DECODE(d.cconcep, 12, d.iconcep - p.iconcep , 0)) icomliq,'
         || 'SUM(DECODE(d.cconcep, 15, d.iconcep - p.iconcep , 0)) icomdev, '
         --|| 'DECODE(SUM(DECODE(d.cconcep, 0, d.iconcep- p.iconcep  , 0)),0, 0,decode(SUM(DECODE(d.cconcep, 11, d.iconcep - p.iconcep  , 0)),0, 0,SUM(DECODE(d.cconcep, 11, d.iconcep - p.iconcep , 0)) / SUM(DECODE(d.cconcep, 0, d.iconcep - p.iconcep , 0)) * 100)) porc_comis,';
         -- Inicio Bug IAXIS-11902 - JRVG 24/02/2020
         || 'pac_adm.f_porc_comisi(r.sseguro,r.nmovimi) porc_comis,';
         -- Fin Bug IAXIS-11902 - JRVG 24/02/2020
      vpasexec := 17;
      squery :=
            squery
         || '  SUM(DECODE(d.cconcep, 38, d.iconcep - p.iconcep , 0)) ibonus_malos, '
         || 'SUM(DECODE(d.cconcep,  8, d.iconcep - p.iconcep ,'
         || ' 58, DECODE(r.ctipcoa, 1, d.iconcep - p.iconcep , 0))) irecfrac, '
         || 'F_IMPGARANT(r.nrecibo,''LIQUIDO_COMISIONES'',d.cgarant,d.nriesgo) iliquido '
         || 'FROM detrecibos d, garangen g, recibos r, detmovrecibo_parcial p '
         || 'WHERE r.nrecibo = '
         || pnrecibo
         || ' AND d.nrecibo = '
         || pnrecibo
         || ' AND d.cgarant = g.cgarant and d.nrecibo = p.nrecibo and d.cconcep = p.cconcep and d.cgarant = p.cgarant and d.nriesgo = p.nriesgo '
         || ' AND g.cidioma = '
         || vcidioma
         || ' ';
      vpasexec := 18;

      IF pnriesgo IS NOT NULL
      THEN
         squery := squery || ' AND d.nriesgo = ' || pnriesgo;
      END IF;

      vpasexec := 19;

      IF pcgarant IS NOT NULL
      THEN
         squery := squery || ' AND d.cgarant = ' || pcgarant;
      END IF;

      vpasexec := 20;
      v_max_reg := pac_parametros.f_parinstalacion_n ('N_MAX_REG');

      IF v_max_reg IS NOT NULL
      THEN
         IF INSTR (squery, 'order by', -1, 1) > 0
         THEN
            squery :=
               'select * from (' || squery || ') where rownum <= '
               || v_max_reg;
         ELSE
            squery := squery || ' and rownum <= ' || v_max_reg;
         END IF;
      END IF;

      vpasexec := 21;
      -- INI -IAXIS-3264.Inclusión del campo cmotmov_baja en la siguiente consulta
      squery   := squery ||
                  ' GROUP BY pac_adm.f_cmotmov_baja(r.sseguro,r.nmovimi,r.nrecibo), d.cgarant, g.tgarant,d.nriesgo,r.sseguro,r.nmovimi,d.nriesgo,'
      -- FIN -IAXIS-3264.

         || ' F_DESRIESGO_T (r.sseguro, d.nriesgo, f_sysdate, '
         || vcidioma
         || ',r.nmovimi'
         || '),'
         || ' F_IMPGARANT(r.nrecibo,''LIQUIDO_COMISIONES'',d.cgarant,d.nriesgo) '
         || ' ORDER BY d.nriesgo,d.cgarant';
      END IF;

      -- INI IAXIS-3592 -- ECP -- 27/05/2019
      RETURN squery;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      vobject,
                      vpasexec,
                      vparam,
                      SQLCODE || ' - ' || SQLERRM
                     );
         RETURN NULL;
   END f_get_detrecibo_gtias;

   /**********************************************************************************************
      29/05/2012 - 41. 0022327: MDP_A001-Consulta de recibos - 0115278
      Extrae la información de los recibos agrupados.
      pnrecibo     IN Recibo.
      pcidioma     IN Código de idioma
   ************************************************************************************************/
   FUNCTION f_get_adm_recunif (
      pnrecibo   IN   NUMBER,
      pcidioma   IN   NUMBER DEFAULT NULL
   )
      RETURN VARCHAR2
   IS
      --vnumerr        NUMBER(8) := 0;
      squery      VARCHAR2 (4000);
      vpasexec    NUMBER (8)                  := 0;
      v_max_reg   NUMBER;               -- número màxim de registres mostrats
      vparam      VARCHAR2 (500)     := 'parámetros - pnrecibo: ' || pnrecibo;
      vobject     VARCHAR2 (200)              := 'PAC_ADM.F_GET_ADM_RECUNIF';
      --numrecs        NUMBER;
      xnrecibo    adm_recunif.nrecunif%TYPE;
   BEGIN
      vpasexec := 1;

      -- Si es un recibo agrupado, buscamos previamente el código del unificado por el que buscarlos todos.
      -- Así evitamos hacer un OR en el squery que relentiza la búsqueda,
      BEGIN
         SELECT nrecunif
           INTO xnrecibo
           FROM adm_recunif
          WHERE nrecibo = pnrecibo AND ROWNUM = 1;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            xnrecibo := pnrecibo;
      END;

      vpasexec := 2;
      squery :=
            'SELECT nrecibo, nrecunif
            FROM adm_recunif
           WHERE nrecunif = '
         || xnrecibo
         || ' ';
      vpasexec := 3;
      v_max_reg := pac_parametros.f_parinstalacion_n ('N_MAX_REG');

      IF v_max_reg IS NOT NULL
      THEN
         IF INSTR (squery, 'order by', -1, 1) > 0
         THEN
            -- se hace de esta manera para mantener el orden de los registros
            squery :=
               'select * from (' || squery || ') where rownum <= '
               || v_max_reg;
         ELSE
            squery := squery || ' and rownum <= ' || v_max_reg;
         END IF;
      END IF;

      squery := squery || ' order by nrecibo ';
      vpasexec := 4;
      RETURN squery;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      vobject,
                      vpasexec,
                      vparam,
                      SQLCODE || ' - ' || SQLERRM
                     );
         RETURN NULL;
   END f_get_adm_recunif;

   /*********************v*************************************************************************
      11/06/2012 - 41. 0022327: MDP_A001-Consulta de recibos - 0115278
      Extrae la información detallada extra del recibo.
      pnrecibo     IN Recibo.
      pcidioma     IN Código de idioma
   ************************************************************************************************/
   FUNCTION f_get_datosrecibo_det (
      pcempres   IN   NUMBER,
      pnrecibo   IN   NUMBER,
      pcidioma   IN   NUMBER DEFAULT NULL
   )
      RETURN VARCHAR2
   IS
      --vnumerr        NUMBER(8) := 0;
      squery      VARCHAR2 (4000);
      v_max_reg   NUMBER;               -- número màxim de registres mostrats
      vpasexec    NUMBER (8)      := 1;
      vparam      VARCHAR2 (500)
         :=    'parámetros - pcempres: '
            || pcempres
            || ', pnrecibo: '
            || pnrecibo
            || ', pcempres: '
            || pcempres;
      vobject     VARCHAR2 (200)  := 'PAC_ADM.F_Get_Detrecibos_det';
      --numrecs        NUMBER;
      --v_error        NUMBER;
      vcidioma    NUMBER      := NVL (pcidioma, pac_md_common.f_get_cxtidioma);
      vtabla      VARCHAR2 (100);
   BEGIN
      --Mirem si agafem la moneda del producte o la moneda de cobrament. XPL#03012011#20592
      IF NVL (pac_parametros.f_parempresa_n (pcempres, 'MONEDA_POL'), 0) = 1
      THEN
         vtabla := 'vdetrecibos_monpol';
      ELSE
         vtabla := 'vdetrecibos';
      END IF;

      squery :=
            'SELECT '
         || ' F_DESRIESGO_T (r.sseguro, NVL(r.nriesgo,1), f_sysdate, '
         || vcidioma
         || ',r.nmovimi'                -- Bug 26923/148935 - 11/07/2013 - AMC
         || ') triesgo, '
         || ' ff_desvalorfijo(800104,'
         || vcidioma
         || ' ,decode(r.cbancar, null, 2,1)) tgescob, '
         || ' decode(r.nanuali,1,1,2) CTIPNEGOC, '
         || ' ff_desvalorfijo( 884 , '
         || vcidioma
         || ', decode(r.nanuali,1,1,2)) TIPNEGOC, '
         || '  (select rl.srelacion from relaciones rl where rl.nrecibo = r.nrecibo and rl.cagente = r.cagente and rl.ffinefe is null) nrelrec, '
         || '  (select max(sproces) from domiciliaciones x1 where x1.nrecibo = r.nrecibo) nremrec, '
         || '  (select max(nliqmen) from liquidalin      x2 where x2.nrecibo = r.nrecibo) nliqmen, '
         || '  NULL nreclamsn, '
         || '  NULL njudicisn, '
         || '  NULL nreclam, '
         || '  NULL ndubrec, '
         || '  ff_desvalorfijo( 800086 , '
         || vcidioma
         || ', rc.caccpre) taccpre, '
         || '  ff_desvalorfijo( 800089 , '
         || vcidioma
         || ', rc.caccret) taccret, '
         || '  rc.tobserv, '
         || '  v.icombru, '
         || '  v.icombru - v.icomret icomliq, '
         || '  v.icomret, '
         || ' (SELECT ff_desvalorfijo( 933 , '
         || vcidioma
         || ', x5.cestado) '
         -- Bug 28081 - 05-IX-2013 - dlF - Error General al consultar RECIBOS
         || '    FROM liquidacab x5 '
         || ' WHERE x5.cagente = r.cagente AND x5.nliqmen IN '
         -- fin Bug 28081 - 05-IX-2013 - dlF -
         || '  (SELECT MAX(nliqmen) FROM liquidalin x4 '
         || '    WHERE x4.cagente = x5.cagente '
         || '      AND x4.cempres = x5.cempres '
         || '      AND x4.nrecibo = r.nrecibo)) testcom, '
         || ' (SELECT lqf.fliquid '
         || '    FROM liquidacab lqf '
         || '   WHERE lqf.cagente = r.cagente '
         || '     AND lqf.nliqmen IN (SELECT MAX(nliqmen) '
         || '                                 FROM liquidalin lql '
         || '                               WHERE lql.cagente = lqf.cagente '
         || '                                  AND lql.cempres = lqf.cempres '
         || '                                  AND lql.nrecibo = r.nrecibo)) festcom, '
         || '  NULL cdoccom, '
         || '  v.icombrui, '
         || '  v.icomdevi, '
         || '  DECODE(NVL(pac_redcomercial.f_busca_padre(r.cempres, r.cagente, NULL, NULL), 0), 0, r.cagente, '
         || '  pac_redcomercial.f_busca_padre(r.cempres, r.cagente, NULL, NULL)) cagenind, '
         || '  f_desagente_t(DECODE(NVL(pac_redcomercial.f_busca_padre(r.cempres, r.cagente, NULL, NULL), 0), 0, r.cagente, '
         || '                pac_redcomercial.f_busca_padre(r.cempres, r.cagente, NULL, NULL))) dscagenind, '
         || '  (SELECT F_DESAGENTE_T (cagente) FROM recibosredcom rr where rr.ctipage = 4 and rr.nrecibo = r.nrecibo) tinspector'
         || '  FROM RECIBOS r, RECIBOS_COMP rc, '
         || vtabla
         || ' V '
         || ' , AGENTES_COMP ac '
         || ' WHERE r.nrecibo = rc.nrecibo (+)'
         || '   AND v.nrecibo = r.nrecibo '
         || '   AND r.nrecibo = '
         || pnrecibo
         || '  AND ac.cagente (+) = r.cagente ';
      vpasexec := 3;
      v_max_reg := pac_parametros.f_parinstalacion_n ('N_MAX_REG');

      IF v_max_reg IS NOT NULL
      THEN
         IF INSTR (squery, 'order by', -1, 1) > 0
         THEN
            -- se hace de esta manera para mantener el orden de los registros
            squery :=
               'select * from (' || squery || ') where rownum <= '
               || v_max_reg;
         ELSE
            squery := squery || ' and rownum <= ' || v_max_reg;
         END IF;
      END IF;

      vpasexec := 4;
      squery := squery || ' order by r.nrecibo ';
      vpasexec := 5;
      RETURN squery;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      vobject,
                      vpasexec,
                      vparam,
                      SQLCODE || ' - ' || SQLERRM
                     );
         RETURN NULL;
   END f_get_datosrecibo_det;

   /**********************************************************************************************
      11/06/2012 - 41. 0022327: MDP_A001-Consulta de recibos - 0115278
      Extrae la información de la tala de complementos de recibos (histórico de acciones)
      pnrecibo     IN Recibo.
      pcidioma     IN Código de idioma
   ************************************************************************************************/
   FUNCTION f_get_recibos_comp (
      pnrecibo   IN   NUMBER,
      pcidioma   IN   NUMBER DEFAULT NULL
   )
      RETURN VARCHAR2
   IS
      --vnumerr        NUMBER(8) := 0;
      squery      VARCHAR2 (4000);
      vpasexec    NUMBER (8)      := 0;
      v_max_reg   NUMBER;               -- número màxim de registres mostrats
      vparam      VARCHAR2 (500)
         := 'parámetros - pnrecibo: ' || pnrecibo || ', pcidioma: '
            || pcidioma;
      vobject     VARCHAR2 (200)  := 'PAC_ADM.F_GET_RECIBOS_COMP';
      --numrecs        NUMBER;
      vcidioma    NUMBER     := NVL (pcidioma, pac_md_common.f_get_cxtidioma);
   --xnrecibo       adm_recunif.nrecunif%TYPE;
   BEGIN
      vpasexec := 1;
      squery :=
            'SELECT  ff_desvalorfijo( 800086 , '
         || vcidioma
         || ', caccpre) taccpre, '
         || '  ff_desvalorfijo( 800089 , '
         || vcidioma
         || ', caccret) taccret, '
         || '  fmodif falta, '
         || ' cusumod cusualt, '
         || '  tobserv '
         || ' FROM hisrecibos_comp '
         || 'WHERE nrecibo = '
         || pnrecibo
         || ' ';
      vpasexec := 2;
      v_max_reg := pac_parametros.f_parinstalacion_n ('N_MAX_REG');
      vpasexec := 3;

      IF v_max_reg IS NOT NULL
      THEN
         IF INSTR (squery, 'order by', -1, 1) > 0
         THEN
            -- se hace de esta manera para mantener el orden de los registros
            squery :=
               'select * from (' || squery || ') where rownum <= '
               || v_max_reg;
         ELSE
            squery := squery || ' and rownum <= ' || v_max_reg;
         END IF;
      END IF;

      squery := squery || ' order by falta desc ';
      vpasexec := 4;
      RETURN squery;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      vobject,
                      vpasexec,
                      vparam,
                      SQLCODE || ' - ' || SQLERRM
                     );
         RETURN NULL;
   END f_get_recibos_comp;

   /**********************************************************************************************
      26/06/2012 - 43. 0022082: LCOL_A003-Mantenimiento de matriculas - 0117556
      Retorna el pagador
      psseguro     IN Seguro
      pnrecibo     IN Recibo.
      Retorna el SPERSON del pagador


   ************************************************************************************************/
   FUNCTION f_get_pagador_recibo (pnrecibo IN NUMBER)
      RETURN NUMBER
   IS
      vsperson   recibos.sperson%TYPE;
      vsseguro   recibos.sseguro%TYPE;
      vpasexec   NUMBER                 := 0;
      vobject    VARCHAR2 (200)         := 'pac_adm.f_get_pagador_recibo';
      vparam     VARCHAR2 (1500)     := 'parámetros - pnrecibo: ' || pnrecibo;
   BEGIN
      vpasexec := 5;

      BEGIN
         SELECT sperson, sseguro
           INTO vsperson, vsseguro
           FROM recibos
          WHERE nrecibo = pnrecibo;

         IF vsperson IS NULL
         THEN
            vpasexec := 10;

            SELECT t.sperson
              INTO vsperson
              FROM tomadores t
             WHERE t.sseguro = vsseguro
               AND t.nordtom = (SELECT MIN (y.nordtom)
                                  FROM tomadores y
                                 WHERE y.sseguro = vsseguro);
         END IF;

         vpasexec := 15;
      EXCEPTION
         WHEN OTHERS
         THEN
            vpasexec := 20;
            vsperson := NULL;
            p_tab_error (f_sysdate,
                         f_user,
                         vobject,
                         vpasexec,
                         vparam,
                         SQLCODE || ' - ' || SQLERRM
                        );
      END;

      vpasexec := 25;
      RETURN vsperson;
   END f_get_pagador_recibo;

   /**********************************************************************************************
      26/06/2012 - 43. 0022082: LCOL_A003-Mantenimiento de matriculas - 0117556
      Extrae la información de las matrículas - para la consulta de matriculas
      pcempres     IN Empresa
      pnrecibo     IN Recibo.
      pccobban     IN Cobrador bancario
      pnmatric     IN Número de matrícula
      pfenvini     IN Fecha envío desde
      pfenvfin     IN Fecha envío hasta
      pcidioma     IN Código de idioma
   ************************************************************************************************/
   FUNCTION f_get_matriculas (
      pcempres   IN   NUMBER,
      pnpoliza   IN   NUMBER,
      pncertif   IN   NUMBER,
      pnrecibo   IN   NUMBER,
      pccobban   IN   NUMBER,
      pnmatric   IN   VARCHAR2,
      pfenvini   IN   DATE,
      pfenvfin   IN   DATE,
      psperson   IN   NUMBER,
      ptipo      IN   NUMBER,
      pcidioma   IN   NUMBER DEFAULT NULL
   )
      RETURN VARCHAR2
   IS
      --vnumerr        NUMBER(8) := 0;
      squery      VARCHAR2 (9000);
      vpasexec    NUMBER (8)      := 0;
      v_max_reg   NUMBER;               -- número màxim de registres mostrats
      vparam      VARCHAR2 (1500)
         :=    'parámetros - pcempres: '
            || pcempres
            || ', pnpoliza: '
            || pnpoliza
            || ', pncertif: '
            || pncertif
            || ', pnrecibo: '
            || pnrecibo
            || ', pccobban: '
            || pccobban
            || ', pnmatric: '
            || pnmatric
            || ', pfenvini: '
            || TO_CHAR (pfenvini, 'dd/mm/yyyy')
            || ', pfenvfin: '
            || TO_CHAR (pfenvfin, 'dd/mm/yyyy')
            || ', psperson: '
            || psperson
            || ', pcidioma: '
            || pcidioma;
      vobject     VARCHAR2 (200)  := 'PAC_ADM.F_GET_MATRICULAS';
      vcidioma    NUMBER      := NVL (pcidioma, pac_md_common.f_get_cxtidioma);
   --numrecs        NUMBER;
   BEGIN
      vpasexec := 1;
      squery :=
            'SELECT  '
         -- 51. 0025151 - 0142020 - Inicio
         || ' n.idnotif2 nmatric, '
         /*
                                                             || ' LPAD(NVL(substr((SELECT cagente FROM recibosredcom WHERE nrecibo = r.nrecibo AND cempres = r.cempres AND ctipage = 2), -3),0), 6, '
                                                             || CHR(39) || '0' || CHR(39) || ') || ' || ' LPAD(s.sproduc, 6, ' || CHR(39) || '0'
                                                             || CHR(39) || ') || '
                                                             || ' LPAD((SELECT to2.sperson FROM tomadores to2 WHERE to2.sseguro = r.sseguro AND NVL(to2.nordtom, 1) = 1), 8, '
                                                             || CHR(39) || '0' || CHR(39) || ') || '
                                                             || ' LPAD((select NVL(MAX(cnordban),0) from per_ccc where sperson in (SELECT to2.sperson FROM tomadores to2 WHERE to2.sseguro = r.sseguro AND NVL(to2.nordtom, 1) = 1) and cbancar= r.cbancar),2, '
                                                             || CHR(39) || '0' || CHR(39) || ') || ' || ' LPAD(s.npoliza, 8, ' || CHR(39) || '0'
                                                             || CHR(39) || ') nmatric, '
                                                             */
         -- 51. 0025151 - 0142020 - Inicio

         /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     || ' LPAD(SUBSTR(pac_agentes.f_get_cageliq(s.cempres, 2, n.cagente), -3), 6, '
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     || CHR(39) || '0' || CHR(39) || ') || '
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     || ' LPAD(s.sproduc, 6, ' || CHR(39)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     || '0' || CHR(39) || ') || ' || ' LPAD(NVL(n.idnotif, 0), 10, ' || CHR(39)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     || '0' || CHR(39) || ') || ' || ' LPAD(s.npoliza, 8, ' || CHR(39) || '0' || CHR(39) || ') nmatric, '
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */
         || ' s.npoliza, '
         || ' c.descripcion tcobban, '
         -- 54. MMM. 0027579: LCOL_A003-Error en campo de cuenta bancaria
         --|| ' n.cbancar, '
         || ' substr(n.cbancar,t.pos_entidad+t.long_entidad) cbancar, '
         -- 54. MMM. 0027579: LCOL_A003-Error en campo de cuenta bancaria -- FIN
         || ' d.ttipo, '
         || ' pac_domiciliaciones.ff_nombre_entidad(n.cbancar, n.ctipban) tbanco, '
         || ' ff_desvalorfijo( 75 , '
         || vcidioma
         || ', r.cestimp) testado '
         || '  FROM recibos r, tipos_cuentades d, tipos_cuenta t,  '
         || '       cobbancario c, seguros s, notificaciones n '
         || ' WHERE c.ccobban = n.ccobban '
         || '   AND s.sseguro = n.sseguro '
         || '   AND d.ctipban = n.ctipban '
         || '   AND d.cidioma = '
         || vcidioma
         || '   AND t.ctipban = n.ctipban '
         || '   AND r.nrecibo = n.nrecibo '
         -- 53. 0027049: LCOL_A003-Datos parecen duplicados en la consulta de matr?culas - QT: 0007408 - Inicio
         || '   AND r.nrecibo in (select min(x.nrecibo) from notificaciones x where x.idnotif2 = n.idnotif2) ';
      -- 53. 0027049: LCOL_A003-Datos parecen duplicados en la consulta de matr?culas - QT: 0007408 - Final
      vpasexec := 2;

      IF pcempres IS NOT NULL
      THEN
         squery := squery || '   AND r.cempres = ' || pcempres;
      END IF;

      vpasexec := 3;

      IF pnpoliza IS NOT NULL
      THEN
         squery := squery || '   AND s.npoliza = ' || pnpoliza;
      END IF;

      vpasexec := 4;

      IF pncertif IS NOT NULL
      THEN
         squery := squery || '   AND s.ncertif = ' || pncertif;
      END IF;

      vpasexec := 5;

      IF pnrecibo IS NOT NULL
      THEN
         squery := squery || '   AND n.nrecibo = ' || pnrecibo;
      END IF;

      vpasexec := 6;

      IF pccobban IS NOT NULL
      THEN
         squery := squery || '   AND n.ccobban = ' || pccobban;
      END IF;

      vpasexec := 7;

      IF pnmatric IS NOT NULL
      THEN
         /*  squery :=
         squery
         || '   AND LPAD(SUBSTR(pac_agentes.f_get_cageliq(s.cempres, 2, n.cagente), -3), 6, '
         || CHR(39) || '0' || CHR(39) || ') || ' || ' LPAD(s.sproduc, 6, ' || CHR(39)
         || '0' || CHR(39) || ') || ' || ' LPAD(NVL(n.idnotif, 0), 10, ' || CHR(39) || '0'
         || CHR(39) || ') || ' || ' LPAD(s.npoliza, 8, ' || CHR(39) || '0' || CHR(39)
         || ') LIKE ' || CHR(39) || '%' || pnmatric || '%' || CHR(39);*/
         -- bug 24672 -- ECP -- 04/12/2012

         -- 51. 0025151 - 0142020 - Inicio
         squery :=
               squery
            || ' AND n.idnotif2  LIKE '
            || CHR (39)
            || '%'
            || pnmatric
            || '%'
            || CHR (39);
      /*
         || '   AND LPAD(NVL(substr((SELECT cagente FROM recibosredcom WHERE nrecibo = r.nrecibo AND cempres = r.cempres AND ctipage = 2), -3),0), 6, '
         || CHR(39) || '0' || CHR(39) || ') || ' || ' LPAD(s.sproduc, 6, ' || CHR(39)
         || '0' || CHR(39) || ') || '
         || ' LPAD((SELECT to2.sperson FROM tomadores to2 WHERE to2.sseguro = r.sseguro AND NVL(to2.nordtom, 1) = 1), 8, '
         || CHR(39) || '0' || CHR(39) || ') || '
         || ' LPAD((select NVL(MAX(cnordban),0) from per_ccc where sperson in (SELECT to2.sperson FROM tomadores to2 WHERE to2.sseguro = r.sseguro AND NVL(to2.nordtom, 1) = 1) and cbancar= r.cbancar),2, '
         || CHR(39) || '0' || CHR(39) || ') || ' || ' LPAD(s.npoliza, 8, ' || CHR(39)
         || '0' || CHR(39) || ')  LIKE ' || CHR(39) || '%' || pnmatric || '%' || CHR(39);
      */

      -- 51. 0025151 - 0142020 - Fin
      END IF;

      vpasexec := 8;

      IF pfenvini IS NOT NULL
      THEN
         squery :=
               squery
            || '   AND n.fefecto >= to_date('
            || CHR (39)
            || TO_CHAR (pfenvini, 'ddmmyyyy')
            || CHR (39)
            || ',''ddmmyyyy'')';
      END IF;

      vpasexec := 9;

      IF pfenvfin IS NOT NULL
      THEN
         squery :=
               squery
            || '   AND n.fefecto <= to_date('
            || CHR (39)
            || TO_CHAR (pfenvfin, 'ddmmyyyy')
            || CHR (39)
            || ',''ddmmyyyy'')';
      END IF;

      vpasexec := 10;
      v_max_reg := pac_parametros.f_parinstalacion_n ('N_MAX_REG');
      vpasexec := 11;

      IF ptipo = 1 AND psperson IS NOT NULL
      THEN
         squery :=
               squery
            || ' and s.sseguro in '
            || ' (select t.sseguro from tomadores t where t.sperson = '
            || psperson
            || ')';
      END IF;

      -- Bug 25151/137983 - 06/03/2013 - AMC
      IF ptipo = 2 AND psperson IS NOT NULL
      THEN
         squery :=
               squery
            || ' and r.nrecibo in (select d.nrecibo from detrecibos d, riesgos ri'
            || ' where d.nrecibo = r.nrecibo'
            || ' and d.nriesgo = ri.nriesgo'
            || ' and ri.sseguro= s.sseguro'
            || ' and ri.sperson = '
            || psperson
            || ')';
      END IF;

      -- bug 24672 -- ECP -- 04/12/2012
      /* IF psperson IS NOT NULL THEN
         squery := squery || ' and s.sseguro in '
                   || ' (select t.sseguro from tomadores t where t.sperson = ' || psperson
                   || ')';
      END IF;*/
      -- Fi Bug 25151/137983 - 06/03/2013 - AMC
      vpasexec := 12;

      IF ptipo = 3                                             --22080 Pagador
         AND psperson IS NOT NULL
      THEN
         squery :=
               squery
            || ' and ((r.sperson is not null and r.sperson = '
            || psperson
            || ') '
            || ' or (r.sperson is null and s.sseguro in '
            || '  (select t.sseguro from tomadores t where t.sperson = '
            || psperson
            || ')))';
      END IF;

      vpasexec := 13;

      IF v_max_reg IS NOT NULL
      THEN
         IF INSTR (squery, 'order by', -1, 1) > 0
         THEN
            -- se hace de esta manera para mantener el orden de los registros
            squery :=
               'select * from (' || squery || ') where rownum <= '
               || v_max_reg;
         ELSE
            squery := squery || ' and rownum <= ' || v_max_reg;
         END IF;
      END IF;

      vpasexec := 14;
      squery := squery || ' ORDER BY 1 ';
      vpasexec := 15;
      RETURN squery;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      vobject,
                      vpasexec,
                      vparam,
                      SQLCODE || ' - ' || SQLERRM
                     );
         RETURN NULL;
   END f_get_matriculas;

   /**********************************************************************************************
      26/06/2012 - 43. 0022082: LCOL_A003-Mantenimiento de matriculas - 0117556
      Extrae la información detallada de una matrícula - para la consulta de matriculas
      pnmatric     IN Número de matrícula
      pcidioma     IN Código de idioma
   ************************************************************************************************/
   FUNCTION f_get_matriculas_det (
      pnmatric   IN   VARCHAR2,
      pcidioma   IN   NUMBER DEFAULT NULL
   )
      RETURN VARCHAR2
   IS
      --vnumerr        NUMBER(8) := 0;
      squery      VARCHAR2 (9000);
      vpasexec    NUMBER (8)      := 0;
      v_max_reg   NUMBER;               -- número màxim de registres mostrats
      vparam      VARCHAR2 (1500)
         := 'parámetros - pnmatric: ' || pnmatric || ', pcidioma: '
            || pcidioma;
      vobject     VARCHAR2 (200)  := 'PAC_ADM.F_GET_MATRICULAS_DET';
      vcidioma    NUMBER     := NVL (pcidioma, pac_md_common.f_get_cxtidioma);
   --numrecs        NUMBER;
   BEGIN
      vpasexec := 1;
      squery :=
            'SELECT  '
         || 'e.tempres, '
         || 'n.sproces, '
         || 'p.nnumnif, '
         || 'p.tapelli1 || '' '' || p.tapelli2 || '', '' || p.tnombre tpagador, '
         -- 56. 0028565: QT-9609 - Inicio
         --|| ' ff_desvalorfijo( 75 , ' || vcidioma || ', r.cestimp) testado, '
         || ' ff_desvalorfijo( 75 , '
         || vcidioma
         || ', r.cestimp) subestado, '
         -- 56. 0028565: QT-9609 - Final
         || ' c.descripcion tcobban, '
         -- 54. MMM. 0027579: LCOL_A003-Error en campo de cuenta bancaria
         --|| ' n.cbancar, '
         || ' substr(n.cbancar,t.pos_entidad+t.long_entidad) cbancar, '
         -- 54. MMM. 0027579: LCOL_A003-Error en campo de cuenta bancaria -- FIN
         || ' d.ttipo, '
         || ' pac_domiciliaciones.ff_nombre_entidad(n.cbancar, n.ctipban) tbanco, '
         || ' s.npoliza, '
         || ' n.nrecibo, '
         || ' TO_DATE(r.fefecto) fefecto, '
         -- Estado del recibo al cierre de la remesa de prenotificaciones (n.ffiledev)
         --BUG 24672:ECP 20/11/2012 en caso de prenotifcaciòn en curso el campo n.ffiledev es nulo por tanto se tendrà en cuenta la fecha del día
         || '(select ff_desvalorfijo( 383, '
         || vcidioma
         || ', m1.cestrec) '
         || '   from movrecibo m1 '
         || '  where m1.smovrec IN '
         || '  (select MAX(m.smovrec) '
         || '     from movrecibo m '
         || '    where NVL(n.ffiledev,f_sysdate) between m.fmovini and NVL(m.fmovfin, NVL(n.ffiledev, f_sysdate)) '
         || '      and m.nrecibo = r.nrecibo) '
         || ' ) testrec, '
         -- Subestado del recibo al cierre de la remesa de prenotificaciones (n.ffiledev)
         --BUG 24672:ECP 20/11/2012 en caso de prenotifcaciòn en curso el campo n.ffiledev es nulo por tanto se tendrà en cuenta la fecha del día
         -- 56. 0028565: QT-9609 - Inicio
         --|| ' (SELECT ff_desvalorfijo(75, 2, MAX(cestimp))  '
         || ' (SELECT ff_desvalorfijo(75, 2, MIN(cestimp))  '
         -- 56. 0028565: QT-9609 - Final
         || '    FROM (SELECT x1.nrecibo, x1.cestimp, f_sysdate fff '
         || '            FROM recibos x1 '
         || '           UNION '
         || '          SELECT x2.nrecibo, x2.cestimp, x2.fhist fff '
         || '            FROM his_recibos x2) y1 '
         -- 56. 0028565: QT-9609 - Inicio
         --|| '   WHERE (y1.nrecibo, y1.fff) IN(SELECT   nrecibo, MAX(ff) '
         || '   WHERE (y1.nrecibo, y1.fff) IN(SELECT   nrecibo, MIN(ff) '
         -- 56. 0028565: QT-9609 - Inicio
         || '                                  FROM (SELECT x3.nrecibo, x3.cestimp, f_sysdate ff '
         || '                                           FROM recibos x3 '
         || '                                        UNION '
         || '                                        SELECT x4.nrecibo, x4.cestimp, x4.fhist ff '
         || '                                          FROM his_recibos x4 '
         || '                                       ) y2 '
         -- 56. 0028565: QT-9609 - Inicio
         --|| '                                  WHERE ff < NVL(n.ffiledev,f_sysdate) '
         --63.0 - 02/12/2013 - MMM - 0028565: QT-9609 - LCOL_MILL-QT-9609 Error en subestado de recibo al consultar matrícula - Inicio
         --|| '                                  WHERE ff >= NVL(n.ffiledev,f_sysdate) '
         || '                                  WHERE ff > NVL(n.ffiledev,f_sysdate) '
         --63.0 - 02/12/2013 - MMM - 0028565: QT-9609 - LCOL_MILL-QT-9609 Error en subestado de recibo al consultar matrícula - Fin
         -- 56. 0028565: QT-9609 - Final
         || '                                   AND y2.nrecibo = y1.nrecibo '
         || '                              GROUP BY nrecibo) '
         --|| '  AND y1.nrecibo = n.nrecibo) subestado, '  -- 56. 0028565: QT-9609
         || '  AND y1.nrecibo = n.nrecibo) testado, '  -- 56. 0028565: QT-9609
-- ---------------------------------------------------------------------
         || ' TO_DATE(n.fefecto) fenvio, '
         || ' TO_DATE(n.fefecto) ffiledev, '
         || ' n.cnotest, '
         || ' n.cnoterr, '
         || ' n.tfileenv, '
         || ' n.tfiledev '
         || '  FROM empresas e, personas p,  '
         || '       recibos r, tipos_cuentades d, '
         || '       tipos_cuenta t, cobbancario c, seguros s, notificaciones n '
         || ' WHERE c.ccobban = n.ccobban '
         || '   AND s.sseguro = n.sseguro '
         || '   AND e.cempres = s.cempres '
         || '   AND d.ctipban = n.ctipban '
         || '   AND d.cidioma = '
         || vcidioma
         || '   AND t.ctipban = n.ctipban '
         || '   AND r.nrecibo = n.nrecibo '
         || '   AND p.sperson = pac_adm.f_get_pagador_recibo(r.nrecibo) '
         -- 51. 0025151 - 0142020 - Inicio
         || '   AND n.idnotif2 LIKE '
         || CHR (39)
         || '%'
         || pnmatric
         || '%'
         || CHR (39);
      /*
      || '   AND LPAD(NVL(substr((SELECT cagente FROM recibosredcom WHERE nrecibo = r.nrecibo AND cempres = r.cempres AND ctipage = 2), -3),0), 6, '
      || CHR(39) || '0' || CHR(39) || ') || ' || ' LPAD(s.sproduc, 6, ' || CHR(39) || '0'
      || CHR(39) || ') || '
      || ' LPAD((SELECT to2.sperson FROM tomadores to2 WHERE to2.sseguro = r.sseguro AND NVL(to2.nordtom, 1) = 1), 8, '
      || CHR(39) || '0' || CHR(39) || ') || '
      || ' LPAD((select NVL(MAX(cnordban),0) from per_ccc where sperson in (SELECT to2.sperson FROM tomadores to2 WHERE to2.sseguro = r.sseguro AND NVL(to2.nordtom, 1) = 1) and cbancar= r.cbancar),2, '
      || CHR(39) || '0' || CHR(39) || ') || ' || ' LPAD(s.npoliza, 8, ' || CHR(39) || '0'
      || CHR(39) || ')  LIKE ' || CHR(39) || '%' || pnmatric || '%' || CHR(39);
      */
      -- 51. 0025151 - 0142020 - Fin

      -- bug 24672 -- ECP -- 04/12/2012
      /*|| '   AND LPAD(SUBSTR(pac_agentes.f_get_cageliq(s.cempres, 2, n.cagente), -3), 6, '
      || CHR(39) || '0' || CHR(39) || ') || ' || ' LPAD(s.sproduc, 6, ' || CHR(39) || '0'
      || CHR(39) || ') || ' || ' LPAD(NVL(n.idnotif, 0), 10, ' || CHR(39) || '0' || CHR(39)
      || ') || ' || ' LPAD(s.npoliza, 8, ' || CHR(39) || '0' || CHR(39) || ') LIKE '
      || CHR(39) || '%' || pnmatric || '%' || CHR(39);*/ -- bug 24672 -- ECP -- 04/12/2012
      vpasexec := 5;
      v_max_reg := pac_parametros.f_parinstalacion_n ('N_MAX_REG');
      vpasexec := 10;

      IF v_max_reg IS NOT NULL
      THEN
         IF INSTR (squery, 'order by', -1, 1) > 0
         THEN
            -- se hace de esta manera para mantener el orden de los registros
            squery :=
               'select * from (' || squery || ') where rownum <= '
               || v_max_reg;
         ELSE
            squery := squery || ' and rownum <= ' || v_max_reg;
         END IF;
      END IF;

      vpasexec := 15;
      squery := squery || ' ORDER BY 1 ';
      vpasexec := 20;
      RETURN squery;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      vobject,
                      vpasexec,
                      vparam,
                      SQLCODE || ' - ' || SQLERRM
                     );
         RETURN NULL;
   END f_get_matriculas_det;

   /**********************************************************************************************
      03/04/2013 - 28. 0026069: LCOL_F003-Fase 3 - Contabilidad de Autos
      Extrae la información del Ramo de los productos de autos
      psproduc     IN Producto
      pcgarant     IN Garantía.
   ************************************************************************************************/
   FUNCTION f_cnvprodgaran_ext (psproduc IN NUMBER, pcgarant IN NUMBER)
      RETURN VARCHAR2
   IS
      vcvalpar   NUMBER;
      vpasexec   NUMBER := 0;
   --vobject        VARCHAR2(200) := 'pac_adm.f_cnvprodgaran_ext';
   --vparam         VARCHAR2(1500) := 'parámetros - psproduc: ' || psproduc || ' pcgarant: ' || pcgarant;
   BEGIN
      vpasexec := 5;

      BEGIN
         SELECT cvalpar
           INTO vcvalpar
           FROM pargaranpro
          WHERE cpargar = 'RAMO_CONTAB'
            AND sproduc = psproduc
            AND cgarant = pcgarant;
      EXCEPTION
         WHEN OTHERS
         THEN
            vpasexec := 20;
            vcvalpar := f_cnvproductos_ext (psproduc);
      END;

      vpasexec := 15;
      RETURN vcvalpar;
   END f_cnvprodgaran_ext;

   /**********************************************************************************************
      Extrae recibos recalculando en pesos a fecha del dia
      psproduc     IN Producto
      pcgarant     IN Garantía.
   ************************************************************************************************/
   FUNCTION f_get_consrecibos_multimoneda (
      pcempres   IN   NUMBER,
      pnrecibo   IN   NUMBER,
      pnpoliza   IN   NUMBER,
      pitem      IN   NUMBER,
      pcestrec   IN   NUMBER,
      pcmonpag   IN   NUMBER,
      ptipo      IN   NUMBER,
      psperson   IN   NUMBER,
      pcidioma   IN   NUMBER,
      pfemisio   IN   DATE DEFAULT NULL
   )
      RETURN VARCHAR2                                          --SYS_REFCURSOR
   IS
      vobject     VARCHAR2 (500)  := 'PAC_ADM.f_get_consrecibos_multimoneda';
      vparam      VARCHAR2 (550)
         :=    'parámetros - pcempres: '
            || pcempres
            || ', pnrecibo: '
            || pnrecibo
            || ', pnpoliza: '
            || pnpoliza
            || ', pitem: '
            || pitem
            || ', pcestrec: '
            || pcestrec
            || ', pcmonpag: '
            || pcmonpag
            || ', ptipo: '
            || ptipo
            || ', psperson: '
            || psperson
            || ', pcidioma: '
            || pcidioma
            || ', pfemisio: '
            || pfemisio;
      vpasexec    NUMBER (5)      := 1;
      vsquery     VARCHAR2 (9000);
      v_max_reg   NUMBER;              -- número maximo de registros mostrados
      vtabla      VARCHAR2 (200);
   BEGIN
      vpasexec := 1;
      --
      vsquery :=
            'SELECT   s.npoliza, s.ncertif, s.fefecto, r.nrecibo,
                f_desproducto_T(s.cramo, s.cmodali, s.ctipseg, s.ccolect, 2,'
         || pcidioma
         || ') tsproduc,
                decode(r.sperson, NULL, f_nombre(t.sperson, 1, s.cagente), f_nombre(t.sperson, 1, s.cagente)) nom_pagador,
                r.femisio, r.fefecto, r.fvencim, d.itotalr total_reb,
                (d.itotalr - (pac_adm_cobparcial.f_get_importe_cobro_parcial(r.nrecibo, NULL, NULL))) Importe_Pdte,
                pac_monedas.f_round((d.itotalr * pac_eco_tipocambio.f_cambio(pac_monedas.f_cmoneda_t(p.cdivisa),
                                               pac_monedas.f_cmoneda_t( '
         || pcmonpag
         || '), to_date('''
         || NVL (pfemisio, TRUNC (f_sysdate))
         || '''))),'
         || pcmonpag
         || ') tot_reb_MonEmp,
      pac_monedas.f_round(((d.itotalr - (pac_adm_cobparcial.f_get_importe_cobro_parcial(r.nrecibo, NULL, NULL)))* pac_eco_tipocambio.f_cambio(pac_monedas.f_cmoneda_t(p.cdivisa),
                                               pac_monedas.f_cmoneda_t( '
         || pcmonpag
         || '), to_date('''
         || NVL (pfemisio, TRUNC (f_sysdate))
         || '''))),'
         || pcmonpag
         || ') Importe_Pdte_monemp, ff_desvalorfijo( 8 , '
         || pcidioma
         || ', r.ctiprec ) ttiprec,
                f_cestrec(r.nrecibo, null) cestrec,
                ff_desvalorfijo( 1 , '
         || pcidioma
         || ',f_cestrec(r.nrecibo, null)) testrec, p.cdivisa div_prod,s.sproduc, s.sseguro
       FROM recibos r, vdetrecibos d, seguros s, tomadores t, productos p
        ';
      vsquery :=
            vsquery
         || 'WHERE r.sseguro= s.sseguro
         and p.sproduc = s.sproduc
         and t.sseguro = s.sseguro
         and t.nordtom in ( select min(tt.nordtom) from tomadores tt where tt.sseguro = t.sseguro)
         and r.nrecibo = d.nrecibo
         and r.ctiprec not in(9,13)
         and r.fefecto <= to_date('''
         || NVL (pfemisio, TRUNC (f_sysdate))
         || ''')
         and not exists (select ''1'' from adm_recunif ar where ar.nrecibo = r.nrecibo
                     AND ((NVL(f_parproductos_v(s.sproduc, ''RECUNIF''), 0) = 2 and ar.nrecibo != ar.nrecunif ) or
                           NVL(f_parproductos_v(s.sproduc, ''RECUNIF''), 0) != 2))
         ';

      --Bug 33346  Fechas futuras no se pueden cobrar  por problemas en el cobro
      --
      IF pnrecibo IS NOT NULL
      THEN
         vsquery := vsquery || ' and r.nrecibo = ' || pnrecibo;
      END IF;

      IF pnpoliza IS NOT NULL
      THEN
         vsquery := vsquery || ' and s.npoliza = ' || pnpoliza;
      END IF;

      IF pcestrec IS NOT NULL
      THEN
         IF pcestrec = 0
         THEN
            vsquery := vsquery || ' and f_cestrec(r.nrecibo, null) in (0,3)';
         ELSIF     NVL
                      (pac_parametros.f_parempresa_n
                                           (pac_md_common.f_get_cxtempresa (),
                                            'IMPAGA_CESTREC3'
                                           ),
                       0
                      ) = 1
               AND pcestrec = 1
         THEN
            vsquery := vsquery || ' and f_cestrec(r.nrecibo, null) in (1,3)';
         ELSE
            vsquery :=
                  vsquery || ' and f_cestrec(r.nrecibo, null) = ' || pcestrec;
         END IF;
      END IF;

      IF pitem IS NOT NULL
      THEN
         vsquery := vsquery || ' and s.ncertif = ' || pitem;
      END IF;

      IF ptipo = 1 AND psperson IS NOT NULL
      THEN
         vsquery := vsquery || ' and t.sperson = ' || psperson;
      END IF;

      IF ptipo = 2 AND psperson IS NOT NULL
      THEN
         vsquery :=
               vsquery
            || ' and r.nrecibo in
            (select d.nrecibo
               from detrecibos d, riesgos ri
              where d.nrecibo = r.nrecibo
                and d.nriesgo = ri.nriesgo
                and ri.sseguro= s.sseguro
                and ri.sperson = '
            || psperson
            || ')';
      END IF;

      IF ptipo = 3 AND psperson IS NOT NULL
      THEN
         vsquery :=
               vsquery
            || ' and ((r.sperson is not null and r.sperson = '
            || psperson
            || ') '
            || ' or (r.sperson is null and t.sperson = '
            || psperson
            || '))';
      END IF;

      v_max_reg := pac_parametros.f_parinstalacion_n ('N_MAX_REG');

      IF v_max_reg IS NOT NULL
      THEN
         IF INSTR (vsquery, 'order by', -1, 1) > 0
         THEN
            vsquery :=
               'select * from (' || vsquery || ') where rownum <= '
               || v_max_reg;
         ELSE
            vsquery := vsquery || ' and rownum <= ' || v_max_reg;
         END IF;
      END IF;

      --
      vsquery := vsquery || ' order by r.fefecto';
      --
      RETURN vsquery;
   --
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      vobject,
                      vpasexec,
                      vparam,
                      SQLCODE || ' - ' || SQLERRM
                     );
         RETURN NULL;
   END f_get_consrecibos_multimoneda;

   -- BUG27421:DRA:Inici
   FUNCTION f_recibos_remesados (psseguro IN NUMBER)
      RETURN NUMBER
   IS
      PRAGMA AUTONOMOUS_TRANSACTION;
      vexisterem   BOOLEAN        := FALSE;
      vobject      VARCHAR2 (500) := 'PAC_ADM.f_recibos_remesados';
      vparam       VARCHAR2 (550) := 'parámetros - psseguro: ' || psseguro;
      vpasexec     NUMBER (5)     := 0;
   BEGIN
      vpasexec := 1;

      FOR reg IN (SELECT m.nrecibo, m.smovrec
                    FROM movrecibo m, recibos r
                   WHERE r.sseguro = psseguro
                     AND m.nrecibo = r.nrecibo
                     AND m.fmovfin IS NULL
                     AND m.cestrec = 3)
      LOOP
         vexisterem := TRUE;
         vpasexec := 2;

         BEGIN
            INSERT INTO adm_rec_remesados
                        (smovrec, cusuari, nrecibo, cestrec, falta
                        )
                 VALUES (reg.smovrec, f_user, reg.nrecibo, 0, f_sysdate
                        );
         EXCEPTION
            WHEN DUP_VAL_ON_INDEX
            THEN
               NULL;
         END;
      END LOOP;

      vpasexec := 3;
      COMMIT;
      vpasexec := 4;

      IF vexisterem
      THEN
         RETURN 9906497;
      END IF;

      RETURN 0;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      vobject,
                      vpasexec,
                      vparam,
                      SQLCODE || ' - ' || SQLERRM
                     );
         RETURN NULL;
   END f_recibos_remesados;

   -- BUG27421:DRA:Fi

   /*******************************************************************************
   FUNCION F_AGRUPARECIBO
   Funci¿n que realiza la unificaci¿n de recibos desde pantalla.
   Tiene dos modalidades de ejecuci¿n:
    1.- Agrupa los recibos de cartera anterior a la fecha pasada por par¿metro.
    2.- Agrupa los recibos pasados en la colecci¿n T_LISTA_ID.

   Par¿metros:
     param in psproduc  : Codigo de producto
     param in pfecha    : Fecha de limite
     param in pfemisio  : Fecha de emisi¿n de la unificaci¿n
     param in pcempres  : C¿digo de empresa
     param in plistarec : Colecci¿n de recibos
     return: number un n¿mero con el id del error, en caso de que todo vaya OK, retornar¿ un cero.
   ********************************************************************************/
   -- --0031322/0175728:NSS;11/06/2014: Unificaci¿n de recibos
   FUNCTION f_agruparecibo_manual (
      psproduc         IN   NUMBER,
      pfecha           IN   DATE,
      pfemisio         IN   DATE,
      pcempres         IN   NUMBER,
      plistarec        IN   t_lista_id DEFAULT NULL,
      pctiprec         IN   NUMBER DEFAULT 3,
      pextornn         IN   NUMBER DEFAULT 0,
      pcommitpag       IN   NUMBER DEFAULT 1,
      pctipapor        IN   NUMBER DEFAULT NULL,
      pctipaportante   IN   NUMBER DEFAULT NULL
   )
      --Bug.: 15708 - ICV - 08/06/2011 - Se a¿ade el tipo de recibo para poder agrupar recibos que no sean de cartera)
   RETURN NUMBER
   IS
      pnrecibo             recibos_comp.nrecibo%TYPE;
      --       pnrecibo       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      vpfecha              DATE;

      TYPE assoc_array_recunif IS TABLE OF NUMBER
         --INDEX BY PLS_INTEGER;
      INDEX BY VARCHAR2 (200);               --0031322/0175728:NSS;11/06/2014

      vrecunif             assoc_array_recunif;
      vnpoliza             NUMBER;
      num_err              NUMBER;
      vsseguro             recibos.sseguro%TYPE;
      --       vsseguro       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      vcagente             seguros.cagente%TYPE;
      --       vcagente       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      vccobban             seguros.ccobban%TYPE;
      --       vccobban       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      vcbancar             seguros.cbancar%TYPE;
      --       vcbancar       VARCHAR2(34); --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      vctiprec             NUMBER;
      vnmovimi             recibos.nmovimi%TYPE;
      --       vnmovimi       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      vcestimp             recibos.cestimp%TYPE;
      --       vcestimp       NUMBER; --- BUG 25803: DECIMALES Y OTROS CAMPOS ---
      vfvencim             DATE;
      vfefecto             DATE;
      vtraza               NUMBER;
      -- Modalidad pasando un listado de recibos
      vrecibos             VARCHAR2 (8000);
      v_sel                VARCHAR2 (8000);
      v_sproduc            VARCHAR2 (20);
      --
      vfemisio             DATE;
      -- BUG22839:DRA:05/11/2012:Inici
      vnrecibo             recibos.nrecibo%TYPE;
      vcempres             recibos.cempres%TYPE;
      pcestrec             movrecibo.cestrec%TYPE;
      xcestrec             movrecibo.cestant%TYPE;
      -- ini BUG 0026035 - 12/02/2013 - JMF
      d_eferec             recibos.fefecto%TYPE;
      d_emirec             recibos.femisio%TYPE;
      n_movrec             movrecibo.smovrec%TYPE;
      d_fmovim             recibos.fefecto%TYPE;
      v_obj                VARCHAR2 (500) := 'pac_gestion_rec.f_agruparecibo';
      v_par                VARCHAR2 (500)
         :=    'pro='
            || psproduc
            || ' fec='
            || pfecha
            || ' emi='
            || pfemisio
            || ' emp='
            || pcempres
            || ' tip='
            || pctiprec;
      -- fin BUG 0026035 - 12/02/2013 - JMF
      v_signo              NUMBER;             -- Bug 26022 - APD - 18/02/2013
      v_cestrec            movrecibo.cestrec%TYPE;
      -- Bug 26022 - APD - 18/02/2013
      v_fmovdia            movrecibo.fmovdia%TYPE;
      -- Bug 26022 - APD - 18/02/2013
      v_sperson            recibos.sperson%TYPE;
      v_grabasperson       NUMBER (1)                  := 0;
      v_cuantos            NUMBER                      := 0;
      --0031322/0175728:NSS;11/06/2014
      v_c                  NUMBER                      := 0;
      --0031322/0175728:NSS;11/06/2014
      vclave               VARCHAR2 (200);    --0031322/0175728:NSS;11/06/2014
      v_cagente            recibos.cagente%TYPE;
      --0031322/0175728:NSS;11/06/2014
      v_cbancar            recibos.cbancar%TYPE;
      --0031322/0175728:NSS;11/06/2014
      v_ctipcob            recibos.ctipcob%TYPE;
      --0031322/0175728:NSS;11/06/2014
      v_fefecto            recibos.fefecto%TYPE;
      --0031322/0175728:NSS;11/06/2014
      v_ncertif            seguros.ncertif%TYPE;
      vncertif             seguros.ncertif%TYPE;
      v_criterio           NUMBER
         := NVL (pac_parametros.f_parempresa_n (pcempres, 'CRITERIO_UNIFREC'),
                 0
                );

      --0031322/0175728:NSS;11/06/2014

      -- BUG22839:DRA:05/11/2012:Fi
      TYPE t_cursor IS REF CURSOR;

      c_rebuts             t_cursor;
      /*TYPE registre IS RECORD(
         npoliza        seguros.npoliza%TYPE,
         nrecibo        recibos.nrecibo%TYPE,
         iprinet        vdetrecibos.iprinet%TYPE,
         itotalr        vdetrecibos.itotalr%TYPE,
         icomcia        vdetrecibos.icomcia%TYPE,
         itotimp        vdetrecibos.icomcia%TYPE,
         itotcon        vdetrecibos.itotcon%TYPE,
         sperson        recibos.sperson%TYPE,
         nrecunif       adm_recunif.nrecunif%TYPE
      );

      rec            registre;*/
      v_polpol             seguros.npoliza%TYPE;
      v_perper             recibos.sperson%TYPE;
      v_uniuni             adm_recunif.nrecunif%TYPE;
      v_recrec             recibos.nrecibo%TYPE;
      v_nrec_dif_unifrec   NUMBER;
      v_agr_max_fechas     NUMBER;
      w_sproduc            NUMBER;
      v_pneta              NUMBER;           -- BUG 0038217 - FAL - 09/12/2015

------------------------------------------
      CURSOR c_recunif (csproduc NUMBER, ppfecha DATE)
      IS
         SELECT s.npoliza, r.*, v.iprinet, v.itotalr, v.icomcia, v.itotimp,
                v.itotcon, NVL (r.sperson, t.sperson),

                --0031322/0175728: NSS: 11/06/2014
                s.ncertif                   --0031322/0175728: NSS: 11/06/2014
           FROM recibos r, seguros s, vdetrecibos v, tomadores t
          WHERE r.ctiprec = pctiprec
            AND r.cestaux = 2    -- Los de cartera de productos colectivos con
            -- certificados se deber¿n crear en este estado
            AND r.fefecto <= ppfecha
            AND r.sseguro = s.sseguro
            AND r.ctipapor = NVL (pctipapor, r.ctipapor)
            AND s.sproduc = csproduc
            AND r.esccero = 1                             -- del certificado 0
            AND r.nrecibo = v.nrecibo
            AND NVL (f_cestrec (r.nrecibo, NULL), 0) = 0
            -- que no esten cobrados
            AND r.nrecibo NOT IN (SELECT nrecibo
                                    FROM adm_recunif)
            AND t.sseguro = r.sseguro       --0031322/0175728: NSS: 11/06/2014
            AND t.nordtom = 1;              --0031322/0175728: NSS: 11/06/2014

      --BUG 14438 - JTS - 12/05/2010
      CURSOR c_detrecibo (ppnrecibo NUMBER)
      IS
         SELECT   d.nrecibo, d.cconcep, d.cgarant, d.nriesgo,
                  SUM (DECODE (pctiprec,
                               9, d.iconcep,
                               13, d.iconcep,
                               DECODE (r.ctiprec,
                                       9, (-1) * d.iconcep,
                                       d.iconcep
                                      )
                              )
                      ) iconcep
             FROM detrecibos d, recibos r
            WHERE d.nrecibo = ppnrecibo AND r.nrecibo = d.nrecibo
         GROUP BY d.nrecibo, d.cconcep, d.cgarant, d.nriesgo;

      CURSOR c_detrecibo_neg (ppnrecibo NUMBER)
      IS
         SELECT   d.nrecibo, d.cconcep, d.cgarant, d.nriesgo,
                  SUM (DECODE (r.ctiprec, 9, (-1) * d.iconcep, d.iconcep)
                      ) iconcep
             FROM detrecibos d, recibos r
            WHERE d.nrecibo = ppnrecibo AND r.nrecibo = d.nrecibo
         GROUP BY d.nrecibo, d.cconcep, d.cgarant, d.nriesgo;
   BEGIN
      vpfecha := NVL (pfecha, f_sysdate);
      vfemisio := NVL (pfemisio, f_sysdate);
      v_nrec_dif_unifrec :=
         NVL (pac_parametros.f_parempresa_n (pcempres, 'NREC_DIF_UNIFREC'),
              0);
      v_agr_max_fechas :=
                       NVL (f_parproductos_v (psproduc, 'AGR_MAX_FECHAS'), 0);

      IF plistarec IS NULL
      THEN
         vtraza := 1;

         FOR regs IN c_recunif (psproduc, vpfecha)
         LOOP
            --INI 0031322/0175728: NSS: 11/06/2014
            --La clave de la tabla asociativa pasa a ser NPOLIZA,NCERTIF,FEFECTO, TOMADOR, AGENTE, CBANCAR
            IF NVL (pac_parametros.f_parempresa_n (pcempres,
                                                   'CRITERIO_UNIFREC'
                                                  ),
                    0
                   ) = 1
            THEN
               vclave :=
                     regs.npoliza
                  || ','
                  || regs.ncertif
                  || ','
                  || regs.sperson
                  || ','
                  || regs.cagente
                  || ','
                  || NVL (regs.cbancar, '');
            ELSE
               vclave :=
                     regs.npoliza
                  || ','
                  || regs.fefecto
                  || ','
                  || regs.sperson
                  || ','
                  || regs.cagente
                  || ','
                  || NVL (regs.cbancar, '');
            END IF;

            --Bug 31135  se elimina criterio ncertificado

            --FIN 0031322/0175728: NSS: 11/06/2014
            IF vrecunif.EXISTS (vclave)       --0031322/0175728:NSS;11/06/2014
            THEN
               vtraza := 2;

               -- Insertamos en tabla de detalle de agrupaci¿n
               INSERT INTO adm_recunif
                           (nrecibo, nrecunif
                           )
                    VALUES (regs.nrecibo, vrecunif (vclave)
                           );                 --0031322/0175728:NSS;11/06/2014
            ELSE
               vtraza := 3;

               -- Obtenemos numero de recibo que agrupa los recibos
               -- peque¿itos
               -- BUG18054:DRA:23/03/2011:Inici
               IF v_nrec_dif_unifrec = 0
               THEN
                  pnrecibo := pac_adm.f_get_seq_cont (pcempres);
               ELSE
                  pnrecibo := pac_adm.f_get_seq_cont (NULL);
               END IF;

               -- BUG18054:DRA:23/03/2011:Fi
               vrecunif (regs.npoliza) := pnrecibo;
               --0031322/0175728:NSS;11/06/2014
               vrecunif (vclave) := pnrecibo; --0031322/0175728:NSS;11/06/2014

               -- Insertamos en tabla de detalle de agrupaci¿n
               INSERT INTO adm_recunif
                           (nrecibo, nrecunif
                           )
                    VALUES (regs.nrecibo, vrecunif (vclave)
                           );
            END IF;
         END LOOP;
      ELSE
         vtraza := 4;

         FOR reg IN plistarec.FIRST .. plistarec.LAST
         LOOP
            SELECT s.npoliza, NVL (r.sperson, t.sperson), a.nrecunif,
                   r.nrecibo, r.cagente, r.cbancar, r.ctipcob, r.fefecto,
                   s.ncertif                --0031322/0175728: NSS: 11/06/2014
              INTO v_polpol, v_perper, v_uniuni,
                   v_recrec, v_cagente, v_cbancar, v_ctipcob, v_fefecto,
                   v_ncertif                --0031322/0175728: NSS: 11/06/2014
              FROM recibos r,
                   seguros s,
                   vdetrecibos v,
                   adm_recunif a,
                   tomadores t              --0031322/0175728: NSS: 11/06/2014
             WHERE r.nrecibo = plistarec (reg).idd
               AND r.sseguro = s.sseguro
               AND r.nrecibo = v.nrecibo
               AND r.nrecibo = a.nrecibo(+)
               AND t.sseguro = r.sseguro    --0031322/0175728: NSS: 11/06/2014
               AND t.nordtom = 1;           --0031322/0175728: NSS: 11/06/2014

            --INI 0031322/0175728:NSS;11/06/2014
            --Debe de haber más de un recibo con mismo npoliza, tomador, agente, fefecto y cuenta bancaria si es recibo domiciliado
            --para poder unificar
            v_cuantos := 0;

            -- bug 35803 - MDS - 04/06/2015
            -- Este bucle no tiene sentido, quitarlo porque relantece el proceso
            --            FOR reg2 IN plistarec.FIRST .. plistarec.LAST LOOP
            IF NVL (pac_parametros.f_parempresa_n (pcempres,
                                                   'CRITERIO_UNIFREC'
                                                  ),
                    0
                   ) = 1
            THEN
               SELECT COUNT (*)
                 INTO v_cuantos
                 FROM recibos r, seguros s, tomadores t
                WHERE s.npoliza = v_polpol
                  --Bug 31135  en total cuántos ha de reunificar r.nrecibo = plistarec(reg2).idd AND
                  AND r.sseguro = s.sseguro
                  AND t.sseguro = r.sseguro
                  AND t.nordtom = 1
                  AND NVL (r.sperson, t.sperson) = v_perper
                  AND r.cagente = v_cagente
                  AND NVL (DECODE (r.ctipcob, 2, r.cbancar, NULL), -1) =
                                                            NVL (v_cbancar,
                                                                 -1)
                  AND s.ncertif = v_ncertif;
            ELSE
               SELECT COUNT (*)
                 INTO v_cuantos
                 FROM recibos r, seguros s, tomadores t
                WHERE s.npoliza = v_polpol
                  --Bug 31135  en total cuántos ha de reunificar r.nrecibo = plistarec(reg2).idd AND
                  AND r.sseguro = s.sseguro
                  AND t.sseguro = r.sseguro
                  AND t.nordtom = 1
                  AND NVL (r.sperson, t.sperson) = v_perper
                  AND r.cagente = v_cagente
                  AND NVL (DECODE (r.ctipcob, 2, r.cbancar, NULL), -1) =
                                                            NVL (v_cbancar,
                                                                 -1)
                  AND r.fefecto = v_fefecto;
            END IF;

            /*IF v_c = 1 THEN   Bug 31135
               v_cuantos := v_cuantos + 1;
            END IF;*/
            --          END LOOP;

            --FIN 0031322/0175728:NSS;11/06/2014

            --INI 0031322/0175728: NSS: 11/06/2014
            --La clave de la tabla asociativa pasa a ser NPOLIZA,NCERTIF,FEFECTO, TOMADOR, AGENTE, CBANCAR
            IF NVL (pac_parametros.f_parempresa_n (pcempres,
                                                   'CRITERIO_UNIFREC'
                                                  ),
                    0
                   ) = 1
            THEN
               vclave :=
                     v_polpol
                  || ','
                  || v_ncertif
                  || ','
                  || v_perper
                  || ','
                  || v_cagente
                  || ','
                  || NVL (v_cbancar, '');
            ELSE
               vclave :=
                     v_polpol
                  || ','
                  || v_fefecto
                  || ','
                  || v_perper
                  || ','
                  || v_cagente
                  || ','
                  || NVL (v_cbancar, '');
            END IF;

            --Bug 31135  se elimina criterio certificado || v_ncertif || ','

            --FIN 0031322/0175728: NSS: 11/06/2014
            IF     v_uniuni IS NULL
               AND v_cuantos > 1            --0031322/0175728: NSS: 11/06/2014
            THEN
               --miramos si los recibos son de la misma persona, caso retornos
               IF v_sperson IS NOT NULL
               THEN
                  IF v_perper IS NULL OR v_sperson <> v_perper
                  THEN
                     v_grabasperson := 1;
                  END IF;
               ELSIF v_grabasperson = 0
               THEN
                  v_sperson := v_perper;
               END IF;

               IF vrecunif.EXISTS (vclave)  --0031322/0175728: NSS: 11/06/2014
               THEN
                  vtraza := 9;

                  -- Insertamos en tabla de detalle de agrupaci¿n
                  INSERT INTO adm_recunif
                              (nrecibo, nrecunif
                              )
                       VALUES (v_recrec, vrecunif (vclave)
                              );            --0031322/0175728: NSS: 11/06/2014
               ELSE
                  vtraza := 10;

                  -- Obtenemos numero de recibo que agrupa los recibos
                  -- peque¿itos
                  -- BUG18054:DRA:23/03/2011:Inici
                  IF v_nrec_dif_unifrec = 0
                  THEN
                     pnrecibo := pac_adm.f_get_seq_cont (pcempres);
                  ELSE
                     pnrecibo := pac_adm.f_get_seq_cont (NULL);
                  END IF;

                  vtraza := 11;
                  -- BUG18054:DRA:23/03/2011:Fi
                  --vrecunif(v_polpol) := pnrecibo;--0031322/0175728: NSS: 11/06/2014
                  vrecunif (vclave) := pnrecibo;

                  --0031322/0175728: NSS: 11/06/2014

                  -- Insertamos en tabla de detalle de agrupaci¿n
                  INSERT INTO adm_recunif
                              (nrecibo, nrecunif
                              )
                       VALUES (v_recrec, vrecunif (vclave)
                              );            --0031322/0175728: NSS: 11/06/2014
               END IF;

               --INI 0031322/0175728: NSS: 11/06/2014
               UPDATE recibos
                  SET cestaux = 2
                WHERE nrecibo = v_recrec;
            --FIN 0031322/0175728: NSS: 11/06/2014
            END IF;
         END LOOP;
      END IF;

      vtraza := 12;
      -- Aqui debemos insertar el recibo 'grande' con el total de los recibos peque¿itos.
      --INI 0031322/0175728: NSS: 11/06/2014
      --vnpoliza := vrecunif.FIRST;
      --La clave de la tabla asociativa pasa a ser NPOLIZA,FEFECTO, TOMADOR, AGENTE, CBANCAR
      vnpoliza :=
         TO_NUMBER (SUBSTR (vrecunif.FIRST, 1, INSTR (vrecunif.FIRST, ',') - 1));

      IF NVL (pac_parametros.f_parempresa_n (pcempres, 'CRITERIO_UNIFREC'), 0) =
                                                                             1
      THEN
         vncertif :=
            TO_NUMBER (SUBSTR (vrecunif.FIRST,
                               INSTR (vrecunif.FIRST, ',') + 1,
                                 (  INSTR (vrecunif.FIRST, ',', 1, 2)
                                  - INSTR (vrecunif.FIRST, ',', 1, 1)
                                 )
                               - 1
                              )
                      );
      END IF;

      vclave := vrecunif.FIRST;

      --FIN 0031322/0175728: NSS: 11/06/2014
      LOOP
         EXIT WHEN vclave IS NULL;         --0031322/0175728: NSS: 11/06/2014
         vtraza := 13;
         vctiprec := pctiprec;

         IF NVL (pac_parametros.f_parempresa_n (pcempres, 'CRITERIO_UNIFREC'),
                 0
                ) = 1
         THEN
            SELECT sseguro, cagente, ccobban, cbancar
              INTO vsseguro, vcagente, vccobban, vcbancar
              FROM seguros
             WHERE npoliza = vnpoliza AND ncertif = vncertif;
         ELSE
            SELECT sseguro, cagente, ccobban, cbancar
              INTO vsseguro, vcagente, vccobban, vcbancar
              FROM seguros
             WHERE npoliza = vnpoliza AND ncertif = 0;
         END IF;

         vtraza := 14;

         -- No se genera movimiento de seguro. Se busca
         -- el ¿ltimo movimiento vigente
         --num_err := f_buscanmovimi(vsseguro, 1, 2, vnmovimi);
         -- Bug 10613 - 06/07/2009 - RSC - Ajustes en productos de Salud
         -- ¿ltimo movimiento del certificado
         SELECT MAX (nmovimi)
           INTO vnmovimi
           FROM movseguro
          WHERE sseguro = vsseguro;

         -- Fin Bug 10613
         vtraza := 15;

         IF plistarec IS NULL
         THEN
            vtraza := 16;

            IF v_agr_max_fechas = 1
            THEN
               SELECT MAX (r2.fefecto), MAX (r2.femisio), MAX (r2.fvencim)
                 INTO vfefecto, vfemisio, vfvencim
                 FROM recibos r2
                WHERE r2.nrecibo IN (
                         SELECT r.nrecibo
                           FROM recibos r, seguros s, vdetrecibos v
                          WHERE r.cestaux = 2
                            AND r.fefecto <= vpfecha
                            AND r.sseguro = s.sseguro
                            -- AND s.sproduc = psproduc
                            AND r.esccero = 1
                            AND r.nrecibo = v.nrecibo
                            AND s.npoliza = vnpoliza
                            AND (   (s.ncertif = vncertif AND v_criterio = 1
                                    )
                                 OR (NVL (v_criterio, 0) = 0)
                                )
                            AND r.nrecibo IN (
                                            SELECT nrecibo
                                              FROM adm_recunif
                                             WHERE nrecunif =
                                                             vrecunif (vclave)));
            --0031322/0175728: NSS: 11/06/2014
            ELSE
               SELECT MAX (r2.fefecto),
                      MAX (r2.fvencim)      --0031322/0175728: NSS: 11/06/2014
                 INTO vfefecto,
                      vfvencim
                 FROM recibos r2
                WHERE r2.nrecibo IN (
                         SELECT r.nrecibo
                           FROM recibos r, seguros s, vdetrecibos v
                          WHERE r.cestaux = 2
                            AND r.fefecto <= vpfecha
                            AND r.sseguro = s.sseguro
                            -- AND s.sproduc = psproduc
                            AND r.esccero = 1
                            AND r.nrecibo = v.nrecibo
                            AND s.npoliza = vnpoliza
                            AND (   (s.ncertif = vncertif AND v_criterio = 1
                                    )
                                 OR (NVL (v_criterio, 0) = 0)
                                )
                            AND r.nrecibo IN (
                                            SELECT nrecibo
                                              FROM adm_recunif
                                             WHERE nrecunif =
                                                             vrecunif (vclave)));
            --0031322/0175728: NSS: 11/06/2014
            END IF;
         ELSE
            vtraza := 18;

            -- Bug 19096 - RSC - 03/08/2011 - LCOL - Parametrizaci¿n b¿sica producto Vida Individual Pagos Permanentes
            -- Borramos: AND r.esccero = 1 (no lo creemos necesarios en esta modalidad de ejecuci¿n)
            IF v_agr_max_fechas = 1
            THEN
               SELECT MAX (r2.fefecto), MAX (r2.femisio), MAX (r2.fvencim)
                 INTO vfefecto, vfemisio, vfvencim
                 FROM recibos r2
                WHERE r2.nrecibo IN (
                         SELECT r.nrecibo
                           FROM recibos r, seguros s, vdetrecibos v
                          WHERE r.sseguro = s.sseguro
                            --AND r.cestaux = 2 -- 22. 0022763 Unificacion / Desunificacion de recibos - 0119028
                            --AND r.esccero = 1 -- Bug 19096 - RSC - 03/08/2011
                            AND r.nrecibo = v.nrecibo
                            AND s.npoliza = vnpoliza
                            AND (   (s.ncertif = vncertif AND v_criterio = 1
                                    )
                                 OR (NVL (v_criterio, 0) = 0)
                                )
                            AND r.nrecibo IN (
                                            SELECT nrecibo
                                              FROM adm_recunif
                                             WHERE nrecunif =
                                                             vrecunif (vclave)));
            --0031322/0175728: NSS: 11/06/2014
            ELSE
               SELECT MAX (r2.fefecto),
                      MAX (r2.fvencim)      --0031322/0175728: NSS: 11/06/2014
                 INTO vfefecto,
                      vfvencim
                 FROM recibos r2
                WHERE r2.nrecibo IN (
                         SELECT r.nrecibo
                           FROM recibos r, seguros s, vdetrecibos v
                          WHERE r.sseguro = s.sseguro
                            --AND r.cestaux = 2 -- 22. 0022763 Unificacion / Desunificacion de recibos - 0119028
                            --AND r.esccero = 1 -- Bug 19096 - RSC - 03/08/2011
                            AND r.nrecibo = v.nrecibo
                            AND s.npoliza = vnpoliza
                            AND (   (s.ncertif = vncertif AND v_criterio = 1
                                    )
                                 OR (NVL (v_criterio, 0) = 0)
                                )
                            AND r.nrecibo IN (
                                            SELECT nrecibo
                                              FROM adm_recunif
                                             WHERE nrecunif =
                                                             vrecunif (vclave)));
            --0031322/0175728: NSS: 11/06/2014
            END IF;

            vtraza := 19;
         END IF;

         vtraza := 20;

         IF vcbancar IS NOT NULL AND vccobban IS NOT NULL
         THEN
            -- BUG22839:DRA:05/11/2012
            vcestimp := 4;
         ELSE
            vcestimp := 1;
         END IF;

         vtraza := 21;

         -- Insertamos el nuevo recibo 'grande'

         -- Bug 19096 - RSC - 03/08/2011 - LCOL - Parametrizaci¿n b¿sica producto Vida Individual Pagos Permanentes
         -- IF plistarec IS NULL THEN -- 22. 0022763 / 0119028 - (segun DRA)
         -- Fin 19096
         IF NVL (pac_parametros.f_parempresa_n (pcempres, 'CRITERIO_UNIFREC'),
                 0
                ) = 1
         THEN
            num_err :=
               f_insrecibo (vsseguro,
                            vcagente,
                            vfemisio,
                            vfefecto,
                            vfvencim,
                            vctiprec,
                            NULL,
                            NULL,
                            vccobban,
                            vcestimp,
                            1,
                            vrecunif (vclave),

                            --0031322/0175728: NSS: 11/06/2014
                            'R',
                            NULL,
                            NULL,
                            vnmovimi,
                            TRUNC (f_sysdate),
                            NULL
                           );
         ELSE
            num_err :=
               f_insrecibo (vsseguro,
                            vcagente,
                            vfemisio,
                            vfefecto,
                            vfvencim,
                            vctiprec,
                            NULL,
                            NULL,
                            vccobban,
                            vcestimp,
                            1,
                            vrecunif (vclave),

                            --0031322/0175728: NSS: 11/06/2014
                            'R',
                            NULL,
                            NULL,
                            vnmovimi,
                            TRUNC (f_sysdate),
                            'CERTIF0'
                           );
         END IF;

         vtraza := 22;

         IF num_err <> 0
         THEN
            RETURN num_err;
         ELSE
            IF v_grabasperson = 0
            THEN
               UPDATE recibos
                  SET sperson = v_sperson
                WHERE nrecibo = vrecunif (vclave);
            --0031322/0175728: NSS: 11/06/2014
            END IF;
         END IF;

         -- Fin 19096
         IF num_err <> 0
         THEN
            RETURN num_err;
         ELSE
            vtraza := 23;

            BEGIN
               -- Pomes CESTAUX = 0 ya que el recibo grande si queremos procesarlo
               UPDATE recibos
                  SET cestaux = 0,
                      cestimp = vcestimp,
                      cmanual = 1,
                      cbancar = vcbancar,
                      ccobban = vccobban,
                      ctipapor = NVL (pctipapor, ctipapor),
                      ctipaportante = NVL (pctipaportante, ctipaportante)
                WHERE nrecibo = vrecunif (vclave);
            --0031322/0175728: NSS: 11/06/2014
            EXCEPTION
               WHEN OTHERS
               THEN
                  RETURN 102358;
            END;

            vtraza := 24;

            -- Obtenemos los recibos peque¿itos de una p¿liza
            -- (por si tenemos que hacer algo con ellos)
            IF plistarec IS NULL
            THEN
               vtraza := 25;

               IF pextornn = 0
               THEN
                  FOR regs IN
                     (SELECT   d.cconcep, d.nriesgo, d.cgarant,
                               SUM (DECODE (pctiprec,
                                            9, d.iconcep,
                                            13, d.iconcep,
                                            DECODE (r.ctiprec,
                                                    9, (-1) * d.iconcep,
                                                    d.iconcep
                                                   )
                                           )
                                   ) iconcep
                          FROM adm_recunif a, recibos r, detrecibos d
                         WHERE a.nrecunif = vrecunif (vclave)
                           --0031322/0175728: NSS: 11/06/2014
                           AND a.nrecibo = r.nrecibo
                           AND a.nrecibo = d.nrecibo
                           AND r.esccero = 1
                           AND r.fefecto <= vpfecha
                      GROUP BY d.cconcep, d.nriesgo, d.cgarant)
                  LOOP
                     INSERT INTO detrecibos
                                 (nrecibo, cconcep,
                                  cgarant, nriesgo, iconcep
                                 )
                          VALUES (vrecunif (vclave),
                                                    --0031322/0175728: NSS: 11/06/2014
                                                    regs.cconcep,
                                  regs.cgarant, regs.nriesgo, regs.iconcep
                                 );
                  END LOOP;
               ELSE
                  FOR regs IN (SELECT   d.cconcep, d.nriesgo, d.cgarant,
                                        SUM (DECODE (r.ctiprec,
                                                     9, (-1) * d.iconcep,
                                                     d.iconcep
                                                    )
                                            ) iconcep
                                   FROM adm_recunif a,
                                        recibos r,
                                        detrecibos d
                                  WHERE a.nrecunif = vrecunif (vclave)
                                    --0031322/0175728: NSS: 11/06/2014
                                    AND a.nrecibo = r.nrecibo
                                    AND a.nrecibo = d.nrecibo
                                    AND r.esccero = 1
                                    AND r.fefecto <= vpfecha
                               GROUP BY d.cconcep, d.nriesgo, d.cgarant)
                  LOOP
                     INSERT INTO detrecibos
                                 (nrecibo, cconcep,
                                  cgarant, nriesgo, iconcep
                                 )
                          VALUES (vrecunif (vclave),
                                                    --0031322/0175728: NSS: 11/06/2014
                                                    regs.cconcep,
                                  regs.cgarant, regs.nriesgo, regs.iconcep
                                 );
                  END LOOP;
               END IF;

               -- BUG 26488_0143335 - JLTS - 25/04/2013 - ini
               UPDATE detrecibos
                  SET iconcep = ABS (iconcep)
                WHERE nrecibo = vrecunif (vclave);
            --0031322/0175728: NSS: 11/06/2014
            -- BUG 26488_0143335 - JLTS - 25/04/2013 - fin
            ELSE
               vtraza := 26;

               IF pextornn = 0
               THEN
                  FOR regs IN
                     (SELECT   d.cconcep, d.nriesgo, d.cgarant,
                               SUM (DECODE (pctiprec,
                                            9, d.iconcep,
                                            13, d.iconcep,
                                            DECODE (r.ctiprec,
                                                    9, (-1) * d.iconcep,
                                                    d.iconcep
                                                   )
                                           )
                                   ) iconcep
                          FROM adm_recunif a, recibos r, detrecibos d
                         WHERE a.nrecunif = vrecunif (vclave)
                           --0031322/0175728: NSS: 11/06/2014
                           AND a.nrecibo = r.nrecibo
                           AND a.nrecibo = d.nrecibo
                      GROUP BY d.cconcep, d.nriesgo, d.cgarant)
                  LOOP
                     INSERT INTO detrecibos
                                 (nrecibo, cconcep,
                                  cgarant, nriesgo, iconcep
                                 )
                          VALUES (vrecunif (vclave),
                                                    --0031322/0175728: NSS: 11/06/2014
                                                    regs.cconcep,
                                  regs.cgarant, regs.nriesgo, regs.iconcep
                                 );
                  END LOOP;
               ELSE
                  FOR regs IN (SELECT   d.cconcep, d.nriesgo, d.cgarant,
                                        SUM (DECODE (r.ctiprec,
                                                     9, (-1) * d.iconcep,
                                                     d.iconcep
                                                    )
                                            ) iconcep
                                   FROM adm_recunif a,
                                        recibos r,
                                        detrecibos d
                                  WHERE a.nrecunif = vrecunif (vclave)
                                    --0031322/0175728: NSS: 11/06/2014
                                    AND a.nrecibo = r.nrecibo
                                    AND a.nrecibo = d.nrecibo
                               GROUP BY d.cconcep, d.nriesgo, d.cgarant)
                  LOOP
                     INSERT INTO detrecibos
                                 (nrecibo, cconcep,
                                  cgarant, nriesgo, iconcep
                                 )
                          VALUES (vrecunif (vclave),
                                                    --0031322/0175728: NSS: 11/06/2014
                                                    regs.cconcep,
                                  regs.cgarant, regs.nriesgo, regs.iconcep
                                 );
                  END LOOP;
               END IF;

               -- BUG 26488_0143335 - JLTS - 25/04/2013 - ini
               /* -- BUG 0038217/0220684 - FAL - 09/12/2015 -- Pemite conceptos negativos (igual que en pac_gestion_rec.f_agruparecibo)
               UPDATE detrecibos
                  SET iconcep = ABS(iconcep)
                WHERE nrecibo = vrecunif(vclave);
               */

               -- BUG 0038217 - FAL - 09/12/2015 - Si el recibo agrupador es negativo (sea porque agrupa extornos, ...) invertir signo de los importes del detalle del recibo y ponerlo como de tipo extorno
               BEGIN
                  SELECT SUM (iconcep)
                    INTO v_pneta
                    FROM detrecibos
                   WHERE nrecibo = vrecunif (vclave) AND cconcep = 0;
               EXCEPTION
                  WHEN OTHERS
                  THEN
                     v_pneta := 0;
               END;

               IF v_pneta < 0
               THEN
                  UPDATE detrecibos
                     SET iconcep = iconcep * (-1)
                   WHERE nrecibo = vrecunif (vclave);

                  UPDATE recibos
                     SET ctiprec = 9
                   WHERE nrecibo = vrecunif (vclave);
               END IF;
            -- FI BUG 0038217

            --0031322/0175728: NSS: 11/06/2014
            -- BUG 26488_0143335 - JLTS - 25/04/2013 - fin
            END IF;

            vtraza := 27;
            num_err := f_vdetrecibos ('R', vrecunif (vclave));

            --0031322/0175728: NSS: 11/06/2014
            IF num_err <> 0
            THEN
               RETURN num_err;
            END IF;

            --Bug 31135   Inserción de la CTACLIENTE, movimiento de 'Anulación por agrupación' para los n-recibos unificados
            SELECT sproduc
              INTO w_sproduc
              FROM recibos r, seguros s
             WHERE r.sseguro = s.sseguro AND r.nrecibo = vrecunif (vclave);

            IF NVL (f_parproductos_v (w_sproduc, 'HAYCTACLIENTE'), 0) = 1
            THEN
               num_err :=
                  pac_ctacliente.f_movctacliente_recunif (vrecunif (vclave),
                                                          7
                                                         );

               IF num_err <> 0
               THEN
                  RETURN num_err;
               END IF;
            END IF;

            --Fin Bug 31135

            -- 37.0 - 27/03/2014 - MMM - 0030713: LCOL_F002-0011957-11958-11959: Se realizo anulacion... Inicio
            -- Cambiamos la manera de hacer el reparto de corretaje. Llamamos directamente a PAC_CORRETAJE.F_REPARTO_CORRETAJE
            -- 38.0 - 03/04/2014 - MMM - 0030713: LCOL_F002-0011957-11958-11959: Se realizo anulacion en polizas... Inicio
            IF pac_corretaje.f_tiene_corretaje (vsseguro, NULL) = 1
            THEN
               num_err :=
                  pac_corretaje.f_reparto_corretaje (vsseguro,
                                                     vnmovimi,
                                                     vrecunif (vclave)
                                                    );
            --0031322/0175728: NSS: 11/06/2014
            END IF;

            -- 38.0 - 03/04/2014 - MMM - 0030713: LCOL_F002-0011957-11958-11959: Se realizo anulacion en polizas... Fin
            IF num_err <> 0
            THEN
               RETURN num_err;
            END IF;

            -- Siguiente p¿liza
            --INI 0031322/0175728: NSS: 11/06/2014
            --vnpoliza := vrecunif.NEXT(vnpoliza);
            --La clave de la tabla asociativa pasa a ser NPOLIZA,NCERTIF,FEFECTO, TOMADOR, AGENTE, CBANCAR
            vnpoliza :=
               TO_NUMBER (SUBSTR (vrecunif.NEXT (vclave),
                                  1,
                                  INSTR (vrecunif.NEXT (vclave), ',') - 1
                                 )
                         );

            IF NVL (pac_parametros.f_parempresa_n (pcempres,
                                                   'CRITERIO_UNIFREC'
                                                  ),
                    0
                   ) = 1
            THEN
               vncertif :=
                  TO_NUMBER (SUBSTR (vrecunif.NEXT (vclave),
                                     INSTR (vrecunif.NEXT (vclave), ',') + 1,
                                       (  INSTR (vrecunif.NEXT (vclave),
                                                 ',',
                                                 1,
                                                 2
                                                )
                                        - INSTR (vrecunif.NEXT (vclave),
                                                 ',',
                                                 1,
                                                 1
                                                )
                                       )
                                     - 1
                                    )
                            );
            END IF;

            vclave := vrecunif.NEXT (vclave);
         --FIN 0031322/0175728: NSS: 11/06/2014
         END IF;
      END LOOP;

      vtraza := 28;

      --Bug.: 15708 - ICV - 09/06/2011
      IF NVL (pac_parametros.f_parempresa_n (pcempres, 'GESTIONA_COBPAG'), 0) =
                                                                             1
      THEN
         --INI 0031322/0175728: NSS: 11/06/2014
         --vnpoliza := vrecunif.FIRST;
         --La clave de la tabla asociativa pasa a ser NPOLIZA,NCERTIF,FEFECTO, TOMADOR, AGENTE, CBANCAR
         vnpoliza :=
            TO_NUMBER (SUBSTR (vrecunif.FIRST,
                               1,
                               INSTR (vrecunif.FIRST, ',') - 1
                              )
                      );
         vclave := vrecunif.FIRST;

         --FIN 0031322/0175728: NSS: 11/06/2014
         LOOP
            EXIT WHEN vnpoliza IS NULL;
            vnrecibo := vrecunif (vclave); --0031322/0175728: NSS: 11/06/2014
            vtraza := 29;

            BEGIN
               SELECT r.cempres, r.sseguro, r.nmovimi, r.femisio, r.fefecto
                 INTO vcempres, vsseguro, vnmovimi, d_emirec, d_eferec
                 FROM recibos r
                WHERE r.nrecibo = vnrecibo;
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  num_err := 101902;
            -- Recibo no encontrado en la tabla RECIBOS
            END;

            vtraza := 30;

            BEGIN
               SELECT m.cestrec, m.cestant, m.smovrec
                 INTO pcestrec, xcestrec, n_movrec
                 FROM movrecibo m
                WHERE m.nrecibo = vnrecibo AND m.fmovfin IS NULL;
            EXCEPTION
               WHEN OTHERS
               THEN
                  pcestrec := NULL;
                  xcestrec := NULL;
            END;

            IF NOT (pcestrec = 0 AND NVL (xcestrec, 0) = 0) --SI NO ES EMISION
            THEN
               RETURN 0;
            END IF;

            vtraza := 31;

            -- ini BUG 0026035 - 12/02/2013 - JMF
            IF num_err = 0
            THEN
               --BUG 23183-XVM-08/11/2012.Inicio
               IF d_emirec < d_eferec
               THEN
                  d_fmovim := d_eferec;
               ELSE
                  d_fmovim := d_emirec;
               END IF;

               num_err :=
                  f_insctacoas (vnrecibo,
                                1,
                                vcempres,
                                n_movrec,
                                TRUNC (d_fmovim)
                               );

               IF num_err != 0
               THEN
                  p_tab_error (f_sysdate,
                               f_user,
                               v_obj,
                               vtraza,
                                  'r='
                               || vnrecibo
                               || ' m='
                               || n_movrec
                               || ' f='
                               || d_fmovim
                               || ' '
                               || v_par,
                               num_err || ' - ' || SQLCODE
                              );
                  RETURN num_err;
               END IF;
            END IF;

            --BUG 23183-XVM-08/11/2012.Fin
            -- fin BUG 0026035 - 12/02/2013 - JMF
            vtraza := 40;

            IF pcommitpag = 1
            THEN
               -- BUG22839:DRA:05/11/2012:Inici
               IF num_err = 0
               THEN
                  num_err :=
                     pac_ctrl_env_recibos.f_proc_recpag_mov (vcempres,
                                                             vsseguro,
                                                             vnmovimi,
                                                             4,
                                                             NULL
                                                            );
               END IF;

               -- BUG22839:DRA:05/11/2012:Fi
               IF num_err <> 0
               THEN
                  p_tab_error (f_sysdate,
                               f_user,
                               'pac_gestion_rec.f_agruparecibo',
                               vtraza,
                                  'psproduc = '
                               || psproduc
                               || ' pfecha = '
                               || pfecha
                               || ' pfemisio = '
                               || pfemisio
                               || ' vcempres = '
                               || vcempres
                               || ' vcempres = '
                               || vcempres
                               || ' vsseguro = '
                               || vsseguro
                               || ' vnmovimi = '
                               || vnmovimi
                               || ' pcestrec = '
                               || pcestrec
                               || ' xcestrec = '
                               || xcestrec,
                                  num_err
                               || ' - '
                               || f_axis_literales (num_err, f_usu_idioma)
                              );
                  --Mira si borraar sin_tramita_movpago porque se tiene que hacer un commit para que loo vea el sap
                  RETURN num_err;
               END IF;
            END IF;

            --INI 0031322/0175728: NSS: 11/06/2014
            --vnpoliza := vrecunif.NEXT(vnpoliza);
            --La clave de la tabla asociativa pasa a ser NPOLIZA,NCERTIF,FEFECTO, TOMADOR, AGENTE, CBANCAR
            vnpoliza :=
               TO_NUMBER (SUBSTR (vrecunif.NEXT (vclave),
                                  1,
                                  INSTR (vrecunif.NEXT (vclave), ',') - 1
                                 )
                         );
            vclave := vrecunif.NEXT (vclave);
            --FIN 0031322/0175728: NSS: 11/06/2014
            vnpoliza := vrecunif.NEXT (vnpoliza);
         END LOOP;
      END IF;

      --Fi Bug.: 15708
      RETURN 0;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      'f_agruparecibo ',
                      vtraza,
                         'psproduc = '
                      || psproduc
                      || ' pfecha = '
                      || pfecha
                      || ' pfemisio = '
                      || pfemisio
                      || ' pcempres = '
                      || pcempres,
                      SQLERRM
                     );
         RETURN 9901207;
   END f_agruparecibo_manual;

   --IGIL_INI-CONF_603
   FUNCTION f_get_detrecibos_det_fcambio (
      pcempres   IN   NUMBER,
      pnrecibo   IN   NUMBER,
      pconcep    IN   NUMBER
   )
      RETURN VARCHAR2
   IS
      --vnumerr        NUMBER(8) := 0;
      squery     VARCHAR2 (2000);
      vpasexec   NUMBER (8)      := 1;
      vparam     VARCHAR2 (500)
         := 'parámetros - pnrecibo: ' || pnrecibo || ', pconcep: ' || pconcep;
      vobject    VARCHAR2 (200)  := 'PAC_ADM.F_Get_Detrecibos_det_fcambio';
   --numrecs        NUMBER;
   --v_error        NUMBER;
   BEGIN
      --Mirem si agafem la moneda del producte o la moneda de cobrament. XPL#03012011#20592
      squery :=
            'SELECT cgarant, nriesgo, iconcep, iconcep_monpol, cageven , nmovima
FROM detrecibos_fcambio
WHERE nrecibo = '
         || pnrecibo
         || ' AND cconcep =  '
         || pconcep;
      vpasexec := 3;
      RETURN squery;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      vobject,
                      vpasexec,
                      vparam,
                      SQLCODE || ' - ' || SQLERRM
                     );
         RETURN NULL;
   END f_get_detrecibos_det_fcambio;

   FUNCTION f_get_detrecibos_fcambio (pcempres IN NUMBER, pnrecibo IN NUMBER)
      RETURN VARCHAR2
   IS
      --vnumerr        NUMBER(8) := 0;
      squery     VARCHAR2 (2000);
      vpasexec   NUMBER (8)      := 1;
      vparam     VARCHAR2 (500)  := 'parámetros - pnrecibo: ' || pnrecibo;
      vobject    VARCHAR2 (200)  := 'PAC_ADM.f_get_detrecibos_fcambio';
   --numrecs        NUMBER;
   BEGIN
      -- falta la búsqueda del tconcep --
      --Mirem si agafem la moneda del producte o la moneda de cobrament. XPL#03012011#20592
      squery :=
            'SELECT cconcep, sum (nvl( iconcep, 0)) iconcep, sum (nvl( iconcep_monpol, 0)) iconcep_monpol
FROM detrecibos_fcambio
WHERE nrecibo = '
         || pnrecibo
         || ' GROUP BY cconcep';
      RETURN squery;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_tab_error (f_sysdate,
                      f_user,
                      vobject,
                      vpasexec,
                      vparam,
                      SQLCODE || ' - ' || SQLERRM
                     );
         RETURN NULL;
   END f_get_detrecibos_fcambio;

--IGIL_FI-CONF_603
   FUNCTION f_get_posicion_retaplica_sap (pccodigo IN VARCHAR2)
      RETURN NUMBER
   IS
      vsinterf    NUMBER         := NULL;
      vposicion   NUMBER         := NULL;
      vcodigo     VARCHAR2 (20);
      vpasexec    NUMBER (8)     := 1;
      vparam      VARCHAR2 (500) := 'parámetros - pccodigo: ' || pccodigo;
      vobject     VARCHAR2 (200) := 'PAC_ADM.f_get_posicion_retaplica_sap';

      CURSOR c_contab (vsinterf IN NUMBER)
      IS
         SELECT ROWNUM posicion, SUBSTR (otros, 323, 17) subotros
           FROM contab_asient_interf
          WHERE sinterf = vsinterf;
   BEGIN
      IF pccodigo != '00000000000000000' AND SUBSTR (pccodigo, 1, 1) = 'H'
      THEN
         BEGIN
            SELECT sinterf
              INTO vsinterf
              FROM contab_asient_interf
             WHERE SUBSTR (otros, 323, 17) = 'P' || SUBSTR (pccodigo, 2, 16);
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               RETURN NULL;
         END;

         FOR rcontab IN c_contab (vsinterf)
         LOOP
            IF rcontab.subotros = 'P' || SUBSTR (pccodigo, 2, 16)
            THEN
               vposicion := rcontab.posicion;
            END IF;
         END LOOP;
      END IF;

    RETURN vposicion;
  EXCEPTION
  WHEN OTHERS THEN
    p_tab_error(f_sysdate, f_user, vobject, vpasexec, vparam, SQLCODE || ' - ' || SQLERRM);
    RETURN NULL;
  END f_get_posicion_retaplica_sap;
-- INI SGM. IAXIS-4134 Reporte de acuerdo de pago
   FUNCTION f_get_recibos_saldos(
          pnpoliza IN NUMBER,
          psquery OUT VARCHAR2)
     RETURN NUMBER
IS
     PARAM_LIKE VARCHAR2 (30000);
     PARAM_NOT_LIKE VARCHAR2 (30000);
     nombaux      VARCHAR2(1000);
     nerr           NUMBER(10);
     condicion      VARCHAR2(1000);
     vobject VARCHAR2 (500) := 'PAC_GESTION_REC.f_get_recibos_saldos';
     vparam  VARCHAR2 (500) := 'parámetros - pnpoliza: ' || pnpoliza;
     vsquery VARCHAR2 (9000);
     vcantidad NUMBER(3);
BEGIN

--se agrega al resultado la cantidad de registros para recorrer el cursor en el jsp
      SELECT COUNT(*)
        INTO vcantidad
        FROM seguros se, recibos re, titulopro tp
       WHERE se.sseguro = re.sseguro
        AND tp.cramo = se.cramo
        AND tp.cmodali = se.cmodali
        AND tp.ccolect = se.ccolect
        AND tp.ctipseg = se.ctipseg
        AND tp.cidioma = se.cidioma
        AND se.sseguro = pnpoliza
        AND re.ctiprec <>9;

     vsquery :=
     'SELECT se.npoliza AS npoliza,
       tp.ttitulo AS producto,
       re.nrecibo AS nrecibo,
       NVL(CASE (SELECT MAX(mv.cestrec) FROM movrecibo mv WHERE mv.nrecibo = re.nrecibo)
            WHEN 0 THEN (SELECT itotalr FROM vdetrecibos_monpol vd WHERE vd.nrecibo = re.nrecibo)-
            (nvl((SELECT SUM(dm.iimporte_moncon) FROM detmovrecibo dm WHERE dm.nrecibo = re.nrecibo),0))
            WHEN 1 THEN 0
            WHEN 2 THEN 0
            ELSE 0
        END,0)
       saldo_recibo, ';
        vsquery := vsquery || vcantidad || ' AS cantidad ';
        vsquery := vsquery ||
        'FROM seguros se, recibos re, titulopro tp
        WHERE se.sseguro = re.sseguro
        and tp.cramo = se.cramo
        and tp.cmodali = se.cmodali
        and tp.ccolect = se.ccolect
        and tp.ctipseg = se.ctipseg
        and tp.cidioma = se.cidioma
        and re.ctiprec <>9 ';

     /*aclarar que funcion tiene este valor quemado*/
     IF pnpoliza IS NOT NULL THEN
          vsquery := vsquery || ' and se.sseguro = ' || pnpoliza;
     END IF;

     psquery := vsquery;

     --DBMS_OUTPUT.PUT_LINE('Query:'||psquery);
     p_control_error('SGM','Query:',psquery);
     RETURN 0;
EXCEPTION
WHEN OTHERS THEN
     p_tab_error(f_sysdate, f_user, 'PAC_GESTION_REC.f_get_recibos_saldos', 1, vparam,
     'SQLERROR: ' || SQLCODE || ' - ' || SQLERRM);
     RETURN 9908775;
     /*Error creado la consulta*/
END f_get_recibos_saldos;
-- FIN SGM. IAXIS-4134 Reporte de acuerdo de pago
--
-- Inicio IAXIS-3651 09/07/2019
--
/*************************************************************************
 FUNCION f_calcula_comisiones
 Funcion para calcular las comisiones del outsourcing por recibo gestionado
 param in pnrecibo :  Número de recibo
 return            :  0 indica comisión calculada correctamente.
                   <> 0 Proceso incorrecto.
 *************************************************************************/
FUNCTION f_calcula_comisiones (pnrecibo IN NUMBER)
  RETURN NUMBER IS
    vpasexec          NUMBER;
    vrecibo_nocomis   NUMBER := 0;
    vnrecibo          NUMBER;
    vpagos            NUMBER := 0;
    vfprimeragestion  DATE;
    vfechapago        DATE;
    vmotivonocomis    NUMBER := 0;
    vdiasmora         NUMBER;
    vnorden           NUMBER;
    vnit              VARCHAR2(20);
    vanio             NUMBER;
    vrangoini         NUMBER;
    vrangofin         NUMBER;
    vporcentajetarifa NUMBER(5,4);
    vmontomin         NUMBER; 
    vmontomax         NUMBER;
    vcomis            NUMBER:=0;-- JRVG 11/03/2020 IAXIS BUG-6149 Cálculo errado de tarifa para pólizas con madurez 0-49
    viva              NUMBER(6,5); 
    vretefuente       NUMBER(6,5); 
    vreteiva          NUMBER(6,5);
    vreteica          NUMBER(6,5);
    vtotal_neto       NUMBER;
    vivafinal         NUMBER;
    vretefuentefinal  NUMBER;
    vreteivafinal     NUMBER;
    vreteicafinal     NUMBER;
    vtotal_bruto      NUMBER;
    vsmovrec          NUMBER; 
    vnordrec          NUMBER; 
    vniabono          NUMBER;
    vnreccaj          VARCHAR2(20);
    vsumatoria        NUMBER;
    
     
 CURSOR c_abonos_pend(pcfprimeragestion IN DATE) IS
  --INI SGM 8/11/2019 IAXIS BUG-6149 recibos que tienen reversiones
  /* SELECT d.smovrec, d.norden, d.iimporte_moncon 
     FROM detmovrecibo d
    WHERE d.nrecibo = pnrecibo 
      AND TRUNC(fmovimi) >= pcfprimeragestion
      AND NOT EXISTS(SELECT 1 FROM adm_det_comisiones a 
                      WHERE a.smovrec = d.smovrec 
                        AND a.nnumordabo = d.norden 
                        AND a.nrecibo = d.nrecibo)
    ORDER BY d.norden ASC;                        */
SELECT d.smovrec, d.norden, d.iimporte_moncon,d.nreccaj  
     FROM detmovrecibo d
    WHERE d.nrecibo = pnrecibo 
      AND TRUNC(fmovimi) >= pcfprimeragestion
      AND NOT EXISTS(SELECT 1 FROM adm_det_comisiones a 
                      WHERE a.nreccaj=d.nreccaj
                        AND a.nrecibo = d.nrecibo)
      --INI JRVG 11/03/2020 IAXIS BUG-6149 Cálculo errado de tarifa para pólizas con madurez 0-49
      --AND d.nreccaj NOT IN (SELECT nreccaj FROM
      AND d.nreccaj IN (SELECT nreccaj FROM 
      --FIN JRVG 11/03/2020 IAXIS BUG-6149 Cálculo errado de tarifa para pólizas con madurez 0-49 
                                      (SELECT d2.nreccaj, SUM(d2.iimporte_moncon)
                                        FROM detmovrecibo d2
                                       WHERE d2.nrecibo = d.nrecibo
                                         AND d2.nreccaj IS NOT NULL
                                       GROUP BY nreccaj
                                      HAVING SUM(d2.iimporte_moncon)>0));                         
    --INI SGM 8/11/2019 IAXIS BUG-6149 recibos que tienen reversiones
  CURSOR c_abonos_pag(pcfprimeragestion IN DATE) IS 
    SELECT NVL(d.smovrec, m.smovrec),
           NVL(d.norden, 0),
           NVL(d.iimporte_moncon, v.itotalr),
           d.nreccaj --SGM 8/11/2019 IAXIS BUG-6149 recibos que tienen reversiones
      FROM detmovrecibo d, movrecibo m, vdetrecibos_monpol v
     WHERE v.nrecibo = pnrecibo
       AND v.nrecibo = m.nrecibo
       AND d.nrecibo(+) = m.nrecibo
       AND NVL(TRUNC(fmovimi), TRUNC(m.fmovini)) >= pcfprimeragestion
       AND m.cestrec = 1 --SGM 8/11/2019 IAXIS BUG-6149 recibos que tienen reversiones
       AND NOT EXISTS (SELECT 1
                         FROM adm_det_comisiones a
                        WHERE a.smovrec = NVL(d.smovrec, m.smovrec)
                          AND a.nnumordabo = NVL(d.norden, 0)
                          AND a.nrecibo = NVL(d.nrecibo, m.nrecibo))
     ORDER BY d.norden ASC;
     
 BEGIN
   
   vpasexec := 0;
   
   IF pnrecibo IS NULL THEN
     RAISE NO_DATA_FOUND;
   ELSE
     vnrecibo := pnrecibo;
   END IF;
   
     -- Se obtiene el NIT del Outsourcing
     SELECT aoo.nit
       INTO vnit
       FROM adm_observa_outsourcing aoo
      WHERE aoo.idobs = (SELECT MAX(idobs)
                           FROM agd_observaciones a
                          WHERE REPLACE(UPPER(TTITOBS),' ','') = 'GESTIONOUTSOURCING'
                            AND a.nrecibo = vnrecibo); 
      vpasexec := 1;    
      -- Se obtienen los porcentajes de Impuestos para el Outsourcing
      SELECT iva, retefuente, reteiva, reteica 
        INTO viva, vretefuente, vreteiva, vreteica
        FROM adm_out_porcentajes
       WHERE nit = vnit;
      vpasexec := 2;    
      -- Se obtienen los dias de mora(madurez) para saber en que rango aplica la comision                   
     -- SELECT round(f_sysdate - fefecto)
     SELECT nvl(TRUNC(fmarcagest),TRUNC(f_sysdate)) - TRUNC(fefecto)--SGM IAXIS 5241 Marcacion con fecha gestion outsourcing
        INTO vdiasmora
        FROM recibos
       WHERE nrecibo = vnrecibo;
       vpasexec := 3;          
       -- Se obtienen los diferentes porcentajes de comision según la madurez del recibo   
      SELECT anio, rangoini, rangofin, porcentajetarifa, montomin, montomax
        INTO vanio, vrangoini, vrangofin, vporcentajetarifa, vmontomin, vmontomax 
        FROM adm_out_tarifas 
       WHERE vdiasmora BETWEEN rangoini AND RANGOFIN;
       vpasexec := 4;          
       -- Se obtiene el número de orden de pago en la que se adicionará el pago
       BEGIN
         SELECT norden
           INTO vnorden
           FROM adm_informacion_pagos
          WHERE forden = TRUNC(f_sysdate)
            AND estadopago = 1
            AND nit = vnit;
       EXCEPTION
         WHEN NO_DATA_FOUND THEN
           SELECT NVL(MAX(norden)+1,1)
             INTO vnorden
             FROM adm_informacion_pagos;                         
        END;
        vpasexec := 5;
        -- Se revisa si tiene anulación por no pago
        IF vmotivonocomis = 0 THEN             
            SELECT COUNT(*)
              INTO vrecibo_nocomis
              FROM recibos re, seguros se, movseguro ms
             WHERE re.sseguro = se.sseguro
               AND se.sseguro = ms.sseguro
               AND ms.cmotmov = 321 --anulación por no pago
               AND re.nrecibo = vnrecibo;
                      
               IF vrecibo_nocomis > 0 THEN
                    vmotivonocomis:=1;
               END IF;
                   
         END IF;
         --
         vpasexec := 6;    
         --
         --Se valida que el recibo no tenga acuerdos de pago             
          IF vmotivonocomis = 0 THEN             
                 SELECT COUNT(*)
                   INTO vrecibo_nocomis
                   FROM agd_observaciones
                  WHERE cconobs = 38
                    AND nrecibo = vnrecibo;
                        
                 IF vrecibo_nocomis > 0 THEN
                      vmotivonocomis:=2;
                 END IF;
                     
           END IF;
           
           vpasexec := 7;

          -- Se valida que el tomador de la poliza no tenga reporte en central de riesgo cifin            
          /* se comenta esta parte pues el sistema no permite actualmente saber el score crediticio
          se esta haciendo una implementacion de este tema y sus validaciones iran en esta parte
          cuando se termine
                  IF vmotivonocomis = 0 THEN
                      SELECT COUNT(*)
                        INTO vrecibo_nocomis
                        FROM cifin_intermedio ci, per_personas pp, tomadores tom, recibos re
                       WHERE ci.no_id = pp.nnumide
                         AND pp.sperson = tom.sperson
                         AND tom.sseguro =re.sseguro
                         AND re.nrecibo = vnrecibo;
           
                         IF vrecibo_nocomis > 0 THEN
                              vmotivonocomis:=3;   
                         END IF;
                             
                   END IF;
                   vpasexec := 8;*/
  
          --Se valida que el recibo no sea de producto COASEGURO ACEPTADO          
           IF vmotivonocomis = 0 THEN
              SELECT COUNT(*)
                INTO vrecibo_nocomis                
                FROM recibos re, seguros se
               WHERE re.sseguro = se.sseguro
                 AND se.sproduc in (8005,8006,8007,8030,8031,8032,8013,8014,8015,8016)
                 AND re.nrecibo = vnrecibo;
                     
                 IF vrecibo_nocomis > 0 THEN
                      vmotivonocomis:=4;   
                 END IF;                   
           END IF;    
           vpasexec := 9;

           --Se valida que el modo de pago no sea por cruces         
           IF vmotivonocomis = 0 THEN
              SELECT COUNT(*)
                INTO vrecibo_nocomis                
                FROM movrecibo
               WHERE cmreca = 21
                 AND nrecibo = vnrecibo;
                     
                 IF vrecibo_nocomis > 0 THEN
                      vmotivonocomis:=5;   
                 END IF;                   
           END IF; 
           --    
           vpasexec := 10;
           --Se valida que el modo de pago no sea por financiacion     
           IF vmotivonocomis = 0 THEN
              SELECT COUNT(*)
                INTO vrecibo_nocomis                
                FROM movrecibo
               WHERE cmreca IN(1,19)
                 AND nrecibo = vnrecibo;
                     
                 IF vrecibo_nocomis > 0 THEN
                      vmotivonocomis:=6;   
                 END IF;                   
           END IF;  
           --
           vpasexec := 11;
           --se valida la fecha de la primera gestión y que los abonos o pagos se hagan posterior a dicha fecha
            BEGIN
                SELECT MIN(FOBS)
                  INTO vfprimeragestion
                  FROM agd_observaciones 
                 WHERE replace(UPPER(TTITOBS),' ','') = 'GESTIONOUTSOURCING'
                   AND nrecibo = vnrecibo;
                   /*AND fobs >= nvl((SELECT MAX(ffin) --SGM 8/11/2019 IAXIS BUG-6149 recibos que tienen reversiones  
                                 FROM adm_det_comisiones 
                                WHERE nrecibo = vnrecibo),fobs); */                  
             EXCEPTION
                WHEN NO_DATA_FOUND THEN
                     p_tab_error(pferror => f_sysdate, pcusuari => f_user,
                                 ptobjeto => 'f_calcula_comisiones',
                                 pntraza => vpasexec, ptdescrip => 'El recibo'||vnrecibo||'no tenia gestión',
                                 pterror => SQLERRM);
                     vfprimeragestion := null;              
            END;
            --
            vpasexec := 12;
            --
             BEGIN
                SELECT TRUNC(m.fmovini)
                  INTO vfechapago
                  FROM movrecibo m
                 WHERE nrecibo = vnrecibo
                   AND cestrec = 1
                   AND m.smovrec = (SELECT MAX(smovrec) FROM movrecibo mv WHERE mv.nrecibo = m.nrecibo);--SGM 8/11/2019 IAXIS BUG-6149 recibos que tienen reversiones
             EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    vfechapago := null;
             END;
             --
             vpasexec := 13;
             --
             --si vfprimeragestion is not null and vfechapago is not null and vfprimeragestion <= vfechapago
              IF (vfprimeragestion is not null) AND (vfechapago is not null) AND (vfprimeragestion <= vfechapago) THEN
              -- fue pagada en su totalidad vpagos = total
              vpasexec := 14;
              OPEN c_abonos_pag(vfprimeragestion); 
                LOOP
                  FETCH c_abonos_pag INTO vsmovrec, vnordrec, vniabono,vnreccaj; 
                  EXIT WHEN c_abonos_pag%notfound;
                  
                  IF vniabono > 0 AND vmotivonocomis = 0 THEN
                  --INI SGM 8/11/2019 IAXIS BUG-6149 recibos que tienen reversiones
                  --no se calculara comision sobre cada registro, sino sobre el total
                  --y ya no estara en la tabla adm_det_comisiones sino en la tabla adm_totales_comis
                       vcomis := vcomis + vniabono;
                      --calcula la comision inicial antes de ajustarla a los rangos de pagos
                     /* vcomis := vniabono * vporcentajetarifa;
                      -- Se ajusta la comisión si esta por debajo del minimo
                      IF vcomis < vmontomin THEN
                        vcomis := vmontomin;
                      END IF;
                      -- Se ajusta la comisión si esta sobre el maximo
                      IF vcomis > vmontomax THEN
                        vcomis := vmontomax;
                      END IF;*/
                   --FIN SGM 8/11/2019 IAXIS BUG-6149 recibos que tienen reversiones   
                      INSERT INTO adm_det_comisiones 
                        (smovrec, nnumordabo, norden, nit, nrecibo, vlr_gestionado, fini, ffin,nreccaj)
                      VALUES 
                        (vsmovrec, vnordrec, vnorden, vnit, vnrecibo, vniabono, vfprimeragestion, f_sysdate,vnreccaj);
                       
                  END IF;  
              
                  vpagos := vpagos + vniabono;
                      
                END LOOP;
                
                vsumatoria:=vcomis;
                vcomis := vcomis * vporcentajetarifa;
              -- Se ajusta la comisión si esta por debajo del minimo
                IF vcomis < vmontomin THEN
                    vcomis := vmontomin;
                END IF;
              -- Se ajusta la comisión si esta sobre el maximo
                IF vcomis > vmontomax THEN
                vcomis := vmontomax;
                END IF;
                
                INSERT INTO ADM_TOTALES_COMIS
                    (smovrec,norden,    nit, nrecibo, vlr_gestionado, comision)
                VALUES
                    (vsmovrec,vnorden, vnit, vnrecibo,vsumatoria,vcomis);

                
              CLOSE c_abonos_pag;       
         ELSIF (vfprimeragestion is not null) and (vfechapago is null) THEN
         -- Se suma el total de los abonos hechos después de la fecha de primera gestión
         -- y que aún no han sido procesados
                vpasexec := 15;
                OPEN c_abonos_pend(vfprimeragestion); 
                LOOP
                  FETCH c_abonos_pend INTO vsmovrec, vnordrec, vniabono,vnreccaj; 
                  EXIT WHEN c_abonos_pend%notfound;
                      
                  IF vniabono > 0 AND vmotivonocomis = 0 THEN
                  --INI SGM 8/11/2019 IAXIS BUG-6149 recibos que tienen reversiones
                  --no se calculara comision sobre cada registro, sino sobre el total
                  --y ya no estara en la tabla adm_det_comisiones sino en la tabla adm_totales_comis
                       vcomis := vcomis + vniabono;
                      --calcula la comision inicial antes de ajustarla a los rangos de pagos
                     /* vcomis := vniabono * vporcentajetarifa;
                      -- Se ajusta la comisión si esta por debajo del minimo
                      IF vcomis < vmontomin THEN
                        vcomis := vmontomin;
                      END IF;
                      -- Se ajusta la comisión si esta sobre el maximo
                      IF vcomis > vmontomax THEN
                        vcomis := vmontomax;
                      END IF;*/
                   --FIN SGM 8/11/2019 IAXIS BUG-6149 recibos que tienen reversiones   
                      INSERT INTO adm_det_comisiones 
                        (smovrec, nnumordabo, norden, nit, nrecibo, vlr_gestionado, fini, ffin,nreccaj)
                      VALUES 
                        (vsmovrec, vnordrec, vnorden, vnit, vnrecibo, vniabono, vfprimeragestion, f_sysdate,vnreccaj);
                        
                       
                  END IF;   
                      
                  vpagos := vpagos + vniabono;
                      
                END LOOP;
                vsumatoria:=vcomis;
                vcomis := vcomis * vporcentajetarifa;
              -- Se ajusta la comisión si esta por debajo del minimo
                IF vcomis < vmontomin THEN
                    vcomis := vmontomin;
                END IF;
              -- Se ajusta la comisión si esta sobre el maximo
                IF vcomis > vmontomax THEN
                vcomis := vmontomax;
                END IF;
                
                INSERT INTO ADM_TOTALES_COMIS
                    (smovrec,norden,    nit, nrecibo, vlr_gestionado, comision)
                VALUES
                    (vsmovrec,vnorden, vnit, vnrecibo,vsumatoria,vcomis);                
                CLOSE c_abonos_pend;       
         ELSIF (vfprimeragestion is not null) AND (vfechapago is not null) AND (vfprimeragestion > vfechapago) THEN
              --
              vpasexec := 16;
              --
              vmotivonocomis:=7;
         END IF;
         vpasexec := 17;    
         IF vpagos > 0 AND vmotivonocomis = 0 THEN  
           --1 PARA ESTE PUNTO SE INSERTA EN LA TABLA DETALLE,  MUY IMPORTANTE NUMERO DE ORDEN Y ESTADO (CANCELADO PENDIENTE)
           --2 INSERTAR EN LA TABLA NO COMISIONA Y EL MOTIVO (ASI ES MAS FACIL HACERLE LATRAZA DE PORQUE NO COMISIONÓ)
           --3 LUEGO INSERTAMOS LOS CONSOLIDADOS EN LA MAESTRO MUY IMPORTANTE NUMERO DE ORDEN Y ESTADO (CANCELADO PENDIENTE)
            -- INSERTAMOS EN TABLA DETALLE
           BEGIN
             --     
             vpasexec := 18; 
             --
             SELECT SUM(adc.COMISION),
                         SUM(adc.COMISION) * viva,
                         SUM(adc.COMISION) * vretefuente,
                         SUM(adc.COMISION) * vreteiva,
                         SUM(adc.COMISION) * vreteica,
                         (SUM(adc.COMISION) + 
                         ( SUM(adc.COMISION) * viva))-
                         ((SUM(adc.COMISION) * vretefuente)+
                         (SUM(adc.COMISION) * vreteiva)+
                         (SUM(adc.COMISION) * vreteica))
               INTO vtotal_neto,vivafinal,vretefuentefinal,vreteivafinal,vreteicafinal,vtotal_bruto
               FROM adm_totales_comis adc
              WHERE adc.nit = vnit
                AND norden = vnorden
              GROUP BY adc.norden;  
             --INSERTAMOS EN TABLA MAESTRO (DE AQUI SE OBTIENE EL REPORTE EN JASPER)
             BEGIN
               vpasexec := 19;
               INSERT INTO adm_informacion_pagos
                 (norden, forden, totalbruto, nit, estadopago, nprocesoerp, fpago, vlrpagadoerp, totalneto, iva,
                  retefuente, reteiva, reteica)
               VALUES (vnorden,TRUNC(f_sysdate),vtotal_bruto,vnit,1,null,null,null,vtotal_neto,vivafinal,vretefuentefinal,vreteivafinal,vreteicafinal);    

              EXCEPTION
                WHEN DUP_VAL_ON_INDEX THEN
                  UPDATE adm_informacion_pagos
                     SET forden     = TRUNC(f_sysdate),
                         totalbruto = vtotal_bruto,
                         nit        = vnit,
                         totalneto  = vtotal_neto,
                         iva        = vivafinal,
                         retefuente = vretefuentefinal,
                         reteiva    = vreteivafinal, 
                         reteica    = vreteicafinal
                   WHERE norden     = vnorden;     
              END;                     
            END;
          ELSE
            vpasexec := 20;
            -- Por alguno de los motivos, el recibo no comisiono, deja el registro aqui
            INSERT INTO adm_det_nocomisiona(nrecibo,cmotivo,usuario,fecha) 
            VALUES (vnrecibo,vmotivonocomis,f_user,f_sysdate);
          END IF;
    vpasexec := 21;
    RETURN 0;
 EXCEPTION
    WHEN OTHERS THEN
       p_tab_error(pferror => f_sysdate, pcusuari => f_user,
                   ptobjeto => 'f_calcula_comisiones',
                   pntraza => vpasexec, ptdescrip => 'Excepcion en f_calcula_comisiones',
                   pterror => SQLERRM);
       COMMIT;
       RETURN 108190;
END f_calcula_comisiones;   
/*************************************************************************
 FUNCION f_get_info_pagos_out
 Funcion para obtener la información por orden de pago para cada outsourcing
 param in pnnumide :  Outsourcing
 param in pnnumord :  Número de orden de pago
 return            :  0 indica comisión calculada correctamente. 
                   <> 0 Proceso incorrecto.
 *************************************************************************/
FUNCTION f_get_info_pagos_out(pnnumide IN VARCHAR2, pnnumord IN NUMBER)
  RETURN VARCHAR2 IS
  vpasexec NUMBER(8)     := 0;
  vsquery  VARCHAR2(2000);
  vparam   VARCHAR2(500) := 'parámetros - pnnumide: ' || pnnumide|| ' - pnnumord '||pnnumord ;
  vobject  VARCHAR2(200) := 'pac_adm.f_get_info_pagos_out';

BEGIN
  vpasexec := 1;
  vsquery := 'SELECT a.norden AS nnumord,'
                  ||'a.forden AS ffecord,'
                  ||'a.totalbruto AS itotpag,'
                  ||'a.nit AS nnumide,'
                  ||'ff_desvalorfijo(8002024, 8, a.estadopago) AS testerp,'
                  ||'a.estadopago AS cesterp,'
                  ||'(SELECT LTRIM(RTRIM(pd.tapelli1)) || '' '' || LTRIM(RTRIM(pd.tapelli2)) || '' '' ||'
                  ||        'LTRIM(RTRIM(pd.tnombre)) '
                  ||   'FROM per_personas pp, per_detper pd '
                  ||  'WHERE pp.sperson = pd.sperson '
                  ||    'AND pp.sperson = p.sperson) AS tnomout,'
                  || 'a.nprocesoerp AS nprcerp,'
                  || 'a.fpago AS ffecpagerp,'
                  || 'a.vlrpagadoerp AS ivalpagerp,' 
                  || 'a.totalneto AS itotnet,' 
                  || 'a.iva AS iiva,'
                  || 'a.retefuente AS iretfue,'
                  || 'a.reteiva AS iretiva,'
                  || 'a.reteica AS iretica '
            || 'FROM adm_informacion_pagos a, per_personas p '
            ||'WHERE p.nnumide = a.nit ';

  vpasexec := 2;
  IF pnnumide IS NOT NULL THEN
    vsquery :=  vsquery || 'AND a.nit ='|| CHR(39) || pnnumide|| CHR(39); 
  END IF; 
  vpasexec := 3;
  IF pnnumord IS NOT NULL THEN
    vsquery :=  vsquery || 'AND a.norden ='|| pnnumord; 
  END IF;
  vpasexec := 4;
  vsquery :=  vsquery || 'ORDER BY a.norden DESC'; 
  vpasexec := 5;
  RETURN vsquery;
  
EXCEPTION
WHEN OTHERS THEN
  p_tab_error(f_sysdate, f_user, vobject, vpasexec, vparam, SQLCODE || ' - ' || SQLERRM);
  RETURN 1;
END f_get_info_pagos_out;
/*************************************************************************
 FUNCION f_set_info_pago_out
 Funcion para actualizar la información por orden de pago para cada outsourcing
 param in pnnumord :  Número de orden de pago
 param in pcesterp :  Estado pago ERP
 param in pnprcerp :  Número de proceso ERP
 param in pffecpagerp :  Fecha de pago ERP
 param in pivalpagerp :  Valor pago ERP
 return            :  0 indica comisión calculada correctamente. 
                   <> 0 Proceso incorrecto.
 *************************************************************************/
FUNCTION f_set_info_pago_out(pnnumord    IN NUMBER, 
                             pcesterp    IN NUMBER, 
                             pnprcerp    IN NUMBER, 
                             pffecpagerp IN DATE, 
                             pivalpagerp IN NUMBER )
RETURN NUMBER IS
  vpasexec NUMBER(8)     := 0;
  vparam   VARCHAR2(500) := 'parámetros - pnnumord: ' || pnnumord || ' - pcesterp '||pcesterp
                            || ' - pnprcerp '||pnprcerp|| ' - pffecpagerp '||pffecpagerp|| ' - pivalpagerp '||pivalpagerp ;
  vobject  VARCHAR2(200) := 'pac_adm.f_set_info_pago_out';

BEGIN
  
  vpasexec := 1;
  
  UPDATE adm_informacion_pagos a
     SET a.estadopago   = pcesterp,
         a.nprocesoerp  = pnprcerp, 
         a.fpago        = pffecpagerp, 
         a.vlrpagadoerp = pivalpagerp
   WHERE a.norden = pnnumord; 
   
   vpasexec := 2; 

  RETURN 0;
EXCEPTION
WHEN OTHERS THEN
  p_tab_error(f_sysdate, f_user, vobject, vpasexec, vparam, SQLCODE || ' - ' || SQLERRM);
  RETURN 1;
END f_set_info_pago_out;
--
-- Fin IAXIS-3651 09/07/2019
--
--
-- Inicio IAXIS-3591 17/07/2019
--
/*************************************************************************
 FUNCION f_get_info_coa
 Funcion para obtener los importes distribuidos en las compañías aceptantes 
 param in pnrecibo :  Número de recibo
 return             :  Cursor con compañías aceptantes y sus respectivos importes.
 *************************************************************************/
--
FUNCTION f_get_info_coa(pnrecibo IN NUMBER)
  RETURN VARCHAR2 IS
  vpasexec NUMBER(8)     := 0;
  vsquery  VARCHAR2(2000);
  vparam   VARCHAR2(500) := 'parámetros - pnrecibo: ' || pnrecibo ;
  vobject  VARCHAR2(200) := 'pac_adm.f_get_info_coa';

BEGIN
  vpasexec := 1;
  vsquery := 'SELECT ff_descompania(c.ccompan) AS tdescomp,'
            || '     pac_coa.f_impcoa_ccomp(c.sseguro, c.ccompan, f_sysdate, v.icednet) AS iimpcom'
            ||' FROM coacedido c, recibos r, vdetrecibos_monpol v '
            ||'WHERE r.sseguro = c.sseguro '
            ||'  AND r.nrecibo = v.nrecibo '
            ||'  AND v.nrecibo ='||pnrecibo 
            ||'  AND c.ncuacoa = r.nmovimi';
  
  RETURN vsquery;

EXCEPTION
WHEN OTHERS THEN
  p_tab_error(f_sysdate, f_user, vobject, vpasexec, vparam, SQLCODE || ' - ' || SQLERRM);
  RETURN 1;
END f_get_info_coa;
--
-- Fin IAXIS-3591 17/07/2019
--
  -- INI --IAXIS-3264
  FUNCTION f_cmotmov_baja(psseguro IN movseguro.sseguro%TYPE,
                          pnmovimi IN movseguro.nmovimi%TYPE,
                          pnrecibo IN recibos.nrecibo%TYPE) RETURN NUMBER IS
    v_result NUMBER := 0;
  BEGIN
    SELECT COUNT(1)
      INTO v_result
      FROM recibos r
     WHERE r.nrecibo = pnrecibo
       AND r.nmovimi = pnmovimi
       AND r.sseguro = psseguro
       AND EXISTS (SELECT 1
              FROM movseguro s
             WHERE s.sseguro = r.sseguro
               AND s.nmovimi = r.nmovimi
               AND s.cmotmov = 239)
       AND r.ctiprec = 9;
    IF v_result = 1 THEN
      RETURN 1;
    ELSE
      RETURN 0;
    END IF;
  END f_cmotmov_baja;
  -- FIN --IAXIS-3264
  
   /************************************************************************************************
   La función Se encarga de generar el porcentaje de comision por poliza y mov. del recibo
   *************************************************************************************************/
 
  FUNCTION f_porc_comisi(pi_sseguro IN NUMBER, pi_nmovimi IN NUMBER) RETURN NUMBER IS
    pporcent NUMBER := 0;
  BEGIN
  
   SELECT regexp_substr(ff_buscadatosindsap(3,pi_sseguro||'|'||pi_nmovimi), '[^|]+', 1, LEVEL) valor
     INTO pporcent
     FROM dual
  CONNECT BY regexp_substr(ff_buscadatosindsap(3,pi_sseguro||'|'||pi_nmovimi), '[^|]+', 1, LEVEL) IS NOT NULL
      AND rownum = 1;
  
    RETURN pporcent;
  
  END f_porc_comisi;
  
 /*************************************************************************
 FUNCION f_get_import_vdetrecibos
 Funcion para devolver el importe de vdetrecibos
 param in pcempres :  Empresa
 param in pnrecibo :  Numero de recibo
 param in pctipo   :  Campo requerido
 return            :  Valor del importe
 Author            :  IAXIS-4136 JRVG - 05/05/2020
 *************************************************************************/
  
  function f_get_import_vdetrecibos(
           pcempres   in   number,
           pnrecibo   in   number,
           pctipo   in   number)
   return varchar2
   is
      squery           varchar2 (2000);
      vpasexec         number (8)      := 1;
      vparam           varchar2 (500):= 'parametros - pnrecibo: ' || pnrecibo ;
      vobject          varchar2 (200)  := 'PAC_ADM.f_get_import_vdetrecibos';
      v_sum_importe    number;
      v_sum_gastos     number;
      v_sum_impuesto   number;
      v_sum_importe_ch    varchar2(50);
      v_sum_gastos_ch     varchar2(50);
      v_sum_impuesto_ch   varchar2(50);
	    importe varchar2(50);
      v_prima number;
      v_iva number;
      v_gasto number;
      v_cmoneda varchar2(10);

   begin
     
      Begin
        select ec.cmoneda
          into v_cmoneda
          from monedas m, eco_codmonedas ec
         where m.cidioma = pac_md_common.f_get_cxtidioma
           and m.cmonint = ec.cmoneda
           and m.cmoneda =
               (select cmoneda
                  from codidivisa
                 where cdivisa =
                       (select cdivisa
                          from productos
                         where sproduc =
                               (select sproduc
                                  from seguros
                                 where sseguro =
                                       (select sseguro
                                          from recibos
                                         WHERE NRECIBO = pnrecibo))));
      exception
        when no_data_found then
          v_cmoneda := '';
      end;

      begin
         select nvl (sum (b.iconcep), 0)
           into v_sum_importe
           from detmovrecibo a, detmovrecibo_parcial b
          where a.nrecibo = pnrecibo
            and a.nrecibo = b.nrecibo
            and a.smovrec = (select max (b.smovrec)
                               from detmovrecibo b
                              where b.nrecibo = a.nrecibo)
            and a.norden = b.norden
            and a.smovrec = b.smovrec
            and b.cconcep in (0,50); 
      exception
         when no_data_found
         then
            v_sum_importe := 0;
      end;

      begin
         select nvl (sum (b.iconcep), 0)
           into v_sum_gastos
           from detmovrecibo a, detmovrecibo_parcial b
          where a.nrecibo = pnrecibo
            and a.nrecibo = b.nrecibo
            and a.smovrec = (select max (b.smovrec)
                               from detmovrecibo b
                              where b.nrecibo = a.nrecibo)
            and a.norden = b.norden
            and a.smovrec = b.smovrec 
            and b.cconcep in (14);
      exception
         when no_data_found
         then
            v_sum_gastos := 0;
      end;
     
      begin
         select nvl(sum(b.iconcep), 0)
           into v_sum_impuesto
           from detmovrecibo a, detmovrecibo_parcial b
          where a.nrecibo = pnrecibo
            and a.nrecibo = b.nrecibo
            and a.smovrec = (select max (b.smovrec)
                               from detmovrecibo b
                              where b.nrecibo = a.nrecibo)
            and a.norden = b.norden
            and a.smovrec = b.smovrec 
            and b.cconcep in (4, 86);
      exception
         when no_data_found
         then
            v_sum_impuesto  := 0;
      end;
     
      if v_sum_importe    < 1 then v_sum_importe_ch := replace(to_char(v_sum_importe,'0D0000000000'),',','.'); else v_sum_importe_ch := replace(v_sum_importe,',','.'); end if;
      if v_sum_gastos     < 1 then v_sum_gastos_ch := replace(to_char(v_sum_gastos,'0D0000000000'),',','.'); else v_sum_gastos_ch := replace(v_sum_gastos,',','.'); end if;
      if v_sum_impuesto   < 1 then v_sum_impuesto_ch := replace(to_char(v_sum_impuesto,'0D0000000000'),',','.'); else v_sum_impuesto_ch := replace(v_sum_impuesto,',','.'); end if;
      
       select
              case when itotpri - v_sum_importe_ch <= 0 
                then
                   0 
                  else decode(itotalr - v_sum_gastos_ch - v_sum_importe_ch - v_sum_impuesto_ch,0,itotalr - v_sum_gastos_ch -v_sum_importe_ch - v_sum_impuesto_ch,itotpri - v_sum_importe_ch ) 
              end  iprinet, 
              case when itotimp - v_sum_impuesto_ch <= 0
                then 0 
                  else decode(itotalr - v_sum_gastos_ch - v_sum_importe_ch - v_sum_impuesto_ch,0,itotalr - v_sum_gastos_ch - v_sum_importe_ch -v_sum_impuesto_ch,
                       decode(itotimp - v_sum_impuesto_ch,1,0,itotimp - v_sum_impuesto_ch)) 
               end iips,
              case when abs(itotrec - v_sum_gastos_ch) <= 0 then 0 
                else (itotrec - v_sum_gastos_ch) 
               end iderreg
         into v_prima,v_iva,v_gasto
         from vdetrecibos
        where nrecibo =  pnrecibo;
        
        if pctipo = 1 then
          
          if v_cmoneda= 'COP' then
              importe := '';
          else
              importe := v_prima;
          end if;
            
        elsif pctipo = 2 then
           importe := v_iva;
           
        elsif pctipo = 3 then
           importe := v_gasto; 
           
         end if; 
        
      return  importe;
   exception
      when others
      then
         p_tab_error (f_sysdate,
                      f_user,
                      vobject,
                      vpasexec,
                      vparam,
                      sqlcode || ' - ' || sqlerrm
                     );
         return null;
   end f_get_import_vdetrecibos;
   
 /*************************************************************************
 FUNCION f_get_import_vdetrecibos_mon
 Funcion para devolver el importe de vdetrecibos_monpol
 param in pcempres :  Empresa
 param in pnrecibo :  Numero de recibo
 param in pctipo   :  Campo requerido
 return            :  Valor del importe
 Author            :  IAXIS-4136 JRVG - 05/05/2020
 *************************************************************************/
   function f_get_import_vdetrecibos_mon(
           pcempres   in   number,
           pnrecibo   in   number,
           pctipo   in   number)
   return varchar2
   is
      squery           varchar2 (2000);
      vpasexec         number (8)      := 1;
      vparam           varchar2 (500):= 'parametros - pnrecibo: ' || pnrecibo ;
      vobject          varchar2 (200)  := 'PAC_ADM.f_get_importes_mon';
      v_sum_importe    number;
      v_sum_gastos     number;
      v_sum_impuesto   number;
      v_sum_importe_ch    varchar2(50);
      v_sum_gastos_ch     varchar2(50);
      v_sum_impuesto_ch   varchar2(50);
      v_tolerancia     NUMBER;
	    importe varchar2(50);
      v_prima number;
      v_iva number;
      v_gasto number;

   begin

      begin
        
        v_tolerancia := NVL(pac_parametros.f_parempresa_n(pac_md_common.f_get_cxtempresa, 'TOLERANCIA_COP'),0);  
      
         select nvl (sum (b.iconcep_monpol), 0)
           into v_sum_importe
           from detmovrecibo a, detmovrecibo_parcial b
          where a.nrecibo = pnrecibo
            and a.nrecibo = b.nrecibo
            and a.smovrec = (select max (b.smovrec)
                               from detmovrecibo b
                              where b.nrecibo = a.nrecibo)
            and a.norden = b.norden
            and a.smovrec = b.smovrec
            and b.cconcep in (0,50); 
      exception
         when no_data_found
         then
            v_sum_importe := 0;
      end;

      begin
         select nvl (sum (b.iconcep_monpol), 0)
           into v_sum_gastos
           from detmovrecibo a, detmovrecibo_parcial b
          where a.nrecibo = pnrecibo
            and a.nrecibo = b.nrecibo
            and a.smovrec = (select max (b.smovrec)
                               from detmovrecibo b
                              where b.nrecibo = a.nrecibo)
            and a.norden = b.norden
            and a.smovrec = b.smovrec 
            and b.cconcep in (14);
      exception
         when no_data_found
         then
            v_sum_gastos := 0;
      end;
     
      begin
         select nvl(sum(b.iconcep_monpol), 0)
           into v_sum_impuesto
           from detmovrecibo a, detmovrecibo_parcial b
          where a.nrecibo = pnrecibo
            and a.nrecibo = b.nrecibo
            and a.smovrec = (select max (b.smovrec)
                               from detmovrecibo b
                              where b.nrecibo = a.nrecibo)
            and a.norden = b.norden
            and a.smovrec = b.smovrec 
            and b.cconcep in (4, 86);
      exception
         when no_data_found
         then
            v_sum_impuesto  := 0;
      end;
     
       select
              case when ABS(itotpri - v_sum_importe) <= v_tolerancia  then 0 else (itotpri - v_sum_importe) end   iprinet, 
              case when ABS(itotimp - v_sum_impuesto) <= v_tolerancia then 0 else (itotimp - v_sum_impuesto) end  iips,
              case when ABS(itotrec - v_sum_gastos) <= v_tolerancia then 0 else (itotrec - v_sum_gastos) end iderreg
         into v_prima,v_iva,v_gasto
         from vdetrecibos_monpol
        where nrecibo =  pnrecibo;
        
        if pctipo = 1 then
           importe := v_prima;
           
        elsif pctipo = 2 then
           importe := v_iva;
           
        elsif pctipo = 3 then
           importe := v_gasto; 
           
        elsif pctipo = 4 then
           importe := v_prima + v_iva + v_gasto;
           
         end if; 
        
      return  importe;
   exception
      when others
      then
         p_tab_error (f_sysdate,
                      f_user,
                      vobject,
                      vpasexec,
                      vparam,
                      sqlcode || ' - ' || sqlerrm
                     );
         return null;
   end f_get_import_vdetrecibos_mon;

END pac_adm;
/
